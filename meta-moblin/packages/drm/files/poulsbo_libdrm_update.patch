From eea94c0cd2198bd46ae4417b7eb7ab5f45df0c3c Mon Sep 17 00:00:00 2001
From: Inuka Gunawardana <inuka.gunawardana@intel.com>
Date: Sun, 20 Jan 2008 00:46:32 -0800
Subject: [PATCH] added changes

---
 configure.ac                   |    2 +-
 libdrm/Makefile.am             |    4 +-
 libdrm/xf86drm.c               | 1194 ++---
 libdrm/xf86drm.h               |    4 +-
 libdrm/xf86drmHash.c           |   20 +-
 libdrm/xf86drmMode.c           |  465 ++
 libdrm/xf86drmMode.h           |  226 +
 libdrm/xf86drmRandom.c         |   20 +-
 libdrm/xf86drmSL.c             |   23 +-
 libdrm/xf86mm.h                |  120 +-
 shared-core/Makefile.am        |    7 +-
 shared-core/Makefile.in        |    5 +-
 shared-core/drm.h              |  908 ++--
 shared-core/drm_pciids.txt     |  744 +++
 shared-core/drm_sarea.h        |   30 +-
 shared-core/i915_dma.c         |  968 ++++
 shared-core/i915_drm.h         |  131 +-
 shared-core/i915_drv.h         |  676 +++
 shared-core/i915_irq.c         |  752 +++
 shared-core/i915_mem.c         |  386 ++
 shared-core/imagine_drv.h      |   43 +
 shared-core/mach64_dma.c       | 1532 ++++++
 shared-core/mach64_drm.h       |    4 +-
 shared-core/mach64_drv.h       | 1058 ++++
 shared-core/mach64_irq.c       |  136 +
 shared-core/mach64_state.c     |  897 ++++
 shared-core/mga_dma.c          | 1164 ++++
 shared-core/mga_drm.h          |   22 +-
 shared-core/mga_drv.h          |  688 +++
 shared-core/mga_irq.c          |  150 +
 shared-core/mga_state.c        | 1143 ++++
 shared-core/mga_ucode.h        |11645 ++++++++++++++++++++++++++++++++++++++++
 shared-core/mga_warp.c         |  198 +
 shared-core/nouveau_drm.h      |  164 +
 shared-core/nouveau_drv.h      |  584 ++
 shared-core/nouveau_fifo.c     |  554 ++
 shared-core/nouveau_irq.c      |  430 ++
 shared-core/nouveau_mem.c      |  608 +++
 shared-core/nouveau_notifier.c |  173 +
 shared-core/nouveau_object.c   | 1148 ++++
 shared-core/nouveau_reg.h      |  550 ++
 shared-core/nouveau_state.c    |  566 ++
 shared-core/nv04_fb.c          |   24 +
 shared-core/nv04_fifo.c        |  129 +
 shared-core/nv04_graph.c       |  474 ++
 shared-core/nv04_mc.c          |   23 +
 shared-core/nv04_timer.c       |   45 +
 shared-core/nv10_fb.c          |   26 +
 shared-core/nv10_fifo.c        |  160 +
 shared-core/nv10_graph.c       |  872 +++
 shared-core/nv20_graph.c       |  249 +
 shared-core/nv30_graph.c       | 2912 ++++++++++
 shared-core/nv40_fb.c          |   56 +
 shared-core/nv40_fifo.c        |  208 +
 shared-core/nv40_graph.c       | 2055 +++++++
 shared-core/nv40_mc.c          |   39 +
 shared-core/nv50_fifo.c        |  327 ++
 shared-core/nv50_graph.c       |  316 ++
 shared-core/nv50_mc.c          |   43 +
 shared-core/nv_drv.h           |   52 +
 shared-core/psb_drm.h          |  359 ++
 shared-core/psb_drv.h          |  786 +++
 shared-core/psb_reg.h          |  555 ++
 shared-core/r128_cce.c         |  932 ++++
 shared-core/r128_drm.h         |   22 +-
 shared-core/r128_drv.h         |  523 ++
 shared-core/r128_irq.c         |  101 +
 shared-core/r128_state.c       | 1682 ++++++
 shared-core/r300_cmdbuf.c      |  954 ++++
 shared-core/r300_reg.h         | 1078 +++--
 shared-core/radeon_cp.c        | 2316 ++++++++
 shared-core/radeon_drm.h       |   29 +-
 shared-core/radeon_drv.h       | 1269 +++++
 shared-core/radeon_irq.c       |  321 ++
 shared-core/radeon_mem.c       |  302 ++
 shared-core/radeon_state.c     | 3240 +++++++++++
 shared-core/savage_bci.c       | 1095 ++++
 shared-core/savage_drm.h       |    4 +-
 shared-core/savage_drv.h       |  575 ++
 shared-core/savage_state.c     | 1165 ++++
 shared-core/sis_drv.h          |   92 +
 shared-core/sis_ds.c           |  299 +
 shared-core/sis_ds.h           |  146 +
 shared-core/sis_mm.c           |  386 ++
 shared-core/tdfx_drv.h         |   47 +
 shared-core/via_dma.c          |  719 +++
 shared-core/via_drm.h          |   40 +-
 shared-core/via_drv.c          |  161 +
 shared-core/via_drv.h          |  219 +
 shared-core/via_ds.c           |  274 +
 shared-core/via_ds.h           |  104 +
 shared-core/via_irq.c          |  393 ++
 shared-core/via_map.c          |  143 +
 shared-core/via_mm.c           |  347 ++
 shared-core/via_mm.h           |   40 +
 shared-core/via_verifier.c     | 1121 ++++
 shared-core/via_verifier.h     |   64 +
 shared-core/via_video.c        |   93 +
 98 files changed, 58391 insertions(+), 1757 deletions(-)
 create mode 100644 libdrm/xf86drmMode.c
 create mode 100644 libdrm/xf86drmMode.h
 create mode 100644 shared-core/drm_pciids.txt
 create mode 100644 shared-core/i915_dma.c
 create mode 100644 shared-core/i915_drv.h
 create mode 100644 shared-core/i915_irq.c
 create mode 100644 shared-core/i915_mem.c
 create mode 100644 shared-core/imagine_drv.h
 create mode 100644 shared-core/mach64_dma.c
 create mode 100644 shared-core/mach64_drv.h
 create mode 100644 shared-core/mach64_irq.c
 create mode 100644 shared-core/mach64_state.c
 create mode 100644 shared-core/mga_dma.c
 create mode 100644 shared-core/mga_drv.h
 create mode 100644 shared-core/mga_irq.c
 create mode 100644 shared-core/mga_state.c
 create mode 100644 shared-core/mga_ucode.h
 create mode 100644 shared-core/mga_warp.c
 create mode 100644 shared-core/nouveau_drm.h
 create mode 100644 shared-core/nouveau_drv.h
 create mode 100644 shared-core/nouveau_fifo.c
 create mode 100644 shared-core/nouveau_irq.c
 create mode 100644 shared-core/nouveau_mem.c
 create mode 100644 shared-core/nouveau_notifier.c
 create mode 100644 shared-core/nouveau_object.c
 create mode 100644 shared-core/nouveau_reg.h
 create mode 100644 shared-core/nouveau_state.c
 create mode 100644 shared-core/nv04_fb.c
 create mode 100644 shared-core/nv04_fifo.c
 create mode 100644 shared-core/nv04_graph.c
 create mode 100644 shared-core/nv04_mc.c
 create mode 100644 shared-core/nv04_timer.c
 create mode 100644 shared-core/nv10_fb.c
 create mode 100644 shared-core/nv10_fifo.c
 create mode 100644 shared-core/nv10_graph.c
 create mode 100644 shared-core/nv20_graph.c
 create mode 100644 shared-core/nv30_graph.c
 create mode 100644 shared-core/nv40_fb.c
 create mode 100644 shared-core/nv40_fifo.c
 create mode 100644 shared-core/nv40_graph.c
 create mode 100644 shared-core/nv40_mc.c
 create mode 100644 shared-core/nv50_fifo.c
 create mode 100644 shared-core/nv50_graph.c
 create mode 100644 shared-core/nv50_mc.c
 create mode 100644 shared-core/nv_drv.h
 create mode 100644 shared-core/psb_drm.h
 create mode 100644 shared-core/psb_drv.h
 create mode 100644 shared-core/psb_reg.h
 create mode 100644 shared-core/r128_cce.c
 create mode 100644 shared-core/r128_drv.h
 create mode 100644 shared-core/r128_irq.c
 create mode 100644 shared-core/r128_state.c
 create mode 100644 shared-core/r300_cmdbuf.c
 create mode 100644 shared-core/radeon_cp.c
 create mode 100644 shared-core/radeon_drv.h
 create mode 100644 shared-core/radeon_irq.c
 create mode 100644 shared-core/radeon_mem.c
 create mode 100644 shared-core/radeon_state.c
 create mode 100644 shared-core/savage_bci.c
 create mode 100644 shared-core/savage_drv.h
 create mode 100644 shared-core/savage_state.c
 create mode 100644 shared-core/sis_drv.h
 create mode 100644 shared-core/sis_ds.c
 create mode 100644 shared-core/sis_ds.h
 create mode 100644 shared-core/sis_mm.c
 create mode 100644 shared-core/tdfx_drv.h
 create mode 100644 shared-core/via_dma.c
 create mode 100644 shared-core/via_drv.c
 create mode 100644 shared-core/via_drv.h
 create mode 100644 shared-core/via_ds.c
 create mode 100644 shared-core/via_ds.h
 create mode 100644 shared-core/via_irq.c
 create mode 100644 shared-core/via_map.c
 create mode 100644 shared-core/via_mm.c
 create mode 100644 shared-core/via_mm.h
 create mode 100644 shared-core/via_verifier.c
 create mode 100644 shared-core/via_verifier.h
 create mode 100644 shared-core/via_video.c

Index: git/configure.ac
===================================================================
--- git.orig/configure.ac	2008-12-12 17:20:14.000000000 +0000
+++ git/configure.ac	2008-12-12 17:35:22.000000000 +0000
@@ -19,7 +19,7 @@
 #  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 AC_PREREQ(2.57)
-AC_INIT([libdrm], 2.3.0, [dri-devel@lists.sourceforge.net], libdrm)
+AC_INIT([libdrm], 2.3.1, [dri-devel@lists.sourceforge.net], libdrm)
 AC_CONFIG_SRCDIR([Makefile.am])
 AM_INIT_AUTOMAKE([dist-bzip2])
 
Index: git/libdrm/Makefile.am
===================================================================
--- git.orig/libdrm/Makefile.am	2008-12-12 17:20:14.000000000 +0000
+++ git/libdrm/Makefile.am	2008-12-12 17:35:22.000000000 +0000
@@ -23,9 +23,9 @@
 libdrm_la_LDFLAGS = -version-number 2:3:0 -no-undefined
 
 AM_CFLAGS = -I$(top_srcdir)/shared-core
-libdrm_la_SOURCES = xf86drm.c xf86drmHash.c xf86drmRandom.c xf86drmSL.c
+libdrm_la_SOURCES = xf86drm.c xf86drmHash.c xf86drmRandom.c xf86drmSL.c xf86drmMode.c
 
 libdrmincludedir = ${includedir}
-libdrminclude_HEADERS = xf86drm.h xf86mm.h
+libdrminclude_HEADERS = xf86drm.h xf86mm.h xf86drmMode.h
 
 EXTRA_DIST = ChangeLog TODO
Index: git/libdrm/xf86drm.c
===================================================================
--- git.orig/libdrm/xf86drm.c	2008-12-12 17:20:14.000000000 +0000
+++ git/libdrm/xf86drm.c	2008-12-12 17:35:22.000000000 +0000
@@ -31,10 +31,6 @@
  * DEALINGS IN THE SOFTWARE.
  */
 
-#ifdef HAVE_XORG_CONFIG_H
-#include <xorg-config.h>
-#endif
-
 #ifdef HAVE_CONFIG_H
 # include <config.h>
 #endif
@@ -53,7 +49,6 @@
 #include <sys/mman.h>
 #include <sys/time.h>
 #include <stdarg.h>
-#include "drm.h"
 
 /* Not all systems have MAP_FAILED defined */
 #ifndef MAP_FAILED
@@ -96,7 +91,7 @@
 
 void drmSetServerInfo(drmServerInfoPtr info)
 {
-  drm_server_info = info;
+    drm_server_info = info;
 }
 
 /**
@@ -110,7 +105,7 @@
 
 static int drmDebugPrint(const char *format, va_list ap)
 {
-  return vfprintf(stderr, format, ap);
+    return vfprintf(stderr, format, ap);
 }
 
 static int (*drm_debug_print)(const char *format, va_list ap) = drmDebugPrint;
@@ -135,26 +130,28 @@
 void
 drmSetDebugMsgFunction(int (*debug_msg_ptr)(const char *format, va_list ap))
 {
-  drm_debug_print = debug_msg_ptr;
+    drm_debug_print = debug_msg_ptr;
 }
 
 static void *drmHashTable = NULL; /* Context switch callbacks */
 
 void *drmGetHashTable(void)
 {
-  return drmHashTable;
+    return drmHashTable;
 }
 
 void *drmMalloc(int size)
 {
     void *pt;
-    if ((pt = malloc(size))) memset(pt, 0, size);
+    if ((pt = malloc(size)))
+	memset(pt, 0, size);
     return pt;
 }
 
 void drmFree(void *pt)
 {
-    if (pt) free(pt);
+    if (pt)
+	free(pt);
 }
 
 /* drmStrdup can't use strdup(3), since it doesn't call _DRM_MALLOC... */
@@ -190,7 +187,8 @@
     void          *value;
     drmHashEntry  *entry;
 
-    if (!drmHashTable) drmHashTable = drmHashCreate();
+    if (!drmHashTable)
+	drmHashTable = drmHashCreate();
 
     if (drmHashLookup(drmHashTable, key, &value)) {
 	entry           = drmMalloc(sizeof(*entry));
@@ -280,14 +278,15 @@
     drmMsg("drmOpenDevice: node name is %s\n", buf);
 
     if (drm_server_info) {
-      drm_server_info->get_perms(&serv_group, &serv_mode);
-      devmode  = serv_mode ? serv_mode : DRM_DEV_MODE;
-      devmode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);
-      group = (serv_group >= 0) ? serv_group : DRM_DEV_GID;
+	drm_server_info->get_perms(&serv_group, &serv_mode);
+	devmode  = serv_mode ? serv_mode : DRM_DEV_MODE;
+	devmode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);
+	group = (serv_group >= 0) ? serv_group : DRM_DEV_GID;
     }
 
     if (stat(DRM_DIR_NAME, &st)) {
-	if (!isroot) return DRM_ERR_NOT_ROOT;
+	if (!isroot)
+	    return DRM_ERR_NOT_ROOT;
 	mkdir(DRM_DIR_NAME, DRM_DEV_DIRMODE);
 	chown(DRM_DIR_NAME, 0, 0); /* root:root */
 	chmod(DRM_DIR_NAME, DRM_DEV_DIRMODE);
@@ -295,37 +294,41 @@
 
     /* Check if the device node exists and create it if necessary. */
     if (stat(buf, &st)) {
-	if (!isroot) return DRM_ERR_NOT_ROOT;
+	if (!isroot)
+	    return DRM_ERR_NOT_ROOT;
 	remove(buf);
 	mknod(buf, S_IFCHR | devmode, dev);
     }
 
     if (drm_server_info) {
-      chown(buf, user, group);
-      chmod(buf, devmode);
+	chown(buf, user, group);
+	chmod(buf, devmode);
     }
 
     fd = open(buf, O_RDWR, 0);
     drmMsg("drmOpenDevice: open result is %d, (%s)\n",
 		fd, fd < 0 ? strerror(errno) : "OK");
-    if (fd >= 0) return fd;
+    if (fd >= 0)
+	return fd;
 
     /* Check if the device node is not what we expect it to be, and recreate it
      * and try again if so.
      */
     if (st.st_rdev != dev) {
-	if (!isroot) return DRM_ERR_NOT_ROOT;
+	if (!isroot)
+	    return DRM_ERR_NOT_ROOT;
 	remove(buf);
 	mknod(buf, S_IFCHR | devmode, dev);
 	if (drm_server_info) {
-	  chown(buf, user, group);
-	  chmod(buf, devmode);
+	    chown(buf, user, group);
+	    chmod(buf, devmode);
 	}
     }
     fd = open(buf, O_RDWR, 0);
     drmMsg("drmOpenDevice: open result is %d, (%s)\n",
 		fd, fd < 0 ? strerror(errno) : "OK");
-    if (fd >= 0) return fd;
+    if (fd >= 0)
+	return fd;
 
     drmMsg("drmOpenDevice: Open failed\n");
     remove(buf);
@@ -350,10 +353,12 @@
     int  fd;
     char buf[64];
     
-    if (create) return drmOpenDevice(makedev(DRM_MAJOR, minor), minor);
+    if (create)
+	return drmOpenDevice(makedev(DRM_MAJOR, minor), minor);
     
     sprintf(buf, DRM_DEV_NAME, DRM_DIR_NAME, minor);
-    if ((fd = open(buf, O_RDWR, 0)) >= 0) return fd;
+    if ((fd = open(buf, O_RDWR, 0)) >= 0)
+	return fd;
     return -errno;
 }
 
@@ -377,7 +382,8 @@
     if ((fd = drmOpenMinor(0, 1)) < 0) {
 #ifdef __linux__
 	/* Try proc for backward Linux compatibility */
-	if (!access("/proc/dri/0", R_OK)) return 1;
+	if (!access("/proc/dri/0", R_OK))
+	    return 1;
 #endif
 	return 0;
     }
@@ -428,7 +434,8 @@
 		drmFreeBusid(buf);
 		return fd;
 	    }
-	    if (buf) drmFreeBusid(buf);
+	    if (buf)
+		drmFreeBusid(buf);
 	    close(fd);
 	}
     }
@@ -458,16 +465,16 @@
     char *        id;
     
     if (!drmAvailable()) {
-      if (!drm_server_info)
-	return -1;
-      else {
-        /* try to load the kernel module now */
-        if (!drm_server_info->load_module(name)) {
-	  drmMsg("[drm] failed to load kernel module \"%s\"\n",
-		 name);
-	  return -1;
-        }
-      }
+	if (!drm_server_info) {
+	    return -1;
+	}
+	else {
+	    /* try to load the kernel module now */
+	    if (!drm_server_info->load_module(name)) {
+		drmMsg("[drm] failed to load kernel module \"%s\"\n", name);
+		return -1;
+	    }
+	}
     }
 
     /*
@@ -552,16 +559,13 @@
     if (!drmAvailable() && name != NULL && drm_server_info) {
 	/* try to load the kernel */
 	if (!drm_server_info->load_module(name)) {
-	  drmMsg("[drm] failed to load kernel module \"%s\"\n",
-	           name);
+	    drmMsg("[drm] failed to load kernel module \"%s\"\n", name);
 	    return -1;
 	}
     }
 
     if (busid) {
-	int fd;
-
-	fd = drmOpenByBusid(busid);
+	int fd = drmOpenByBusid(busid);
 	if (fd >= 0)
 	    return fd;
     }
@@ -584,10 +588,11 @@
  */
 void drmFreeVersion(drmVersionPtr v)
 {
-    if (!v) return;
-    if (v->name) drmFree(v->name);
-    if (v->date) drmFree(v->date);
-    if (v->desc) drmFree(v->desc);
+    if (!v)
+	return;
+    drmFree(v->name);
+    drmFree(v->date);
+    drmFree(v->desc);
     drmFree(v);
 }
 
@@ -603,10 +608,11 @@
  */
 static void drmFreeKernelVersion(drm_version_t *v)
 {
-    if (!v) return;
-    if (v->name) drmFree(v->name);
-    if (v->date) drmFree(v->date);
-    if (v->desc) drmFree(v->desc);
+    if (!v)
+	return;
+    drmFree(v->name);
+    drmFree(v->date);
+    drmFree(v->desc);
     drmFree(v);
 }
 
@@ -760,9 +766,11 @@
     u.unique_len = 0;
     u.unique     = NULL;
 
-    if (ioctl(fd, DRM_IOCTL_GET_UNIQUE, &u)) return NULL;
+    if (ioctl(fd, DRM_IOCTL_GET_UNIQUE, &u))
+	return NULL;
     u.unique = drmMalloc(u.unique_len + 1);
-    if (ioctl(fd, DRM_IOCTL_GET_UNIQUE, &u)) return NULL;
+    if (ioctl(fd, DRM_IOCTL_GET_UNIQUE, &u))
+	return NULL;
     u.unique[u.unique_len] = '\0';
 
     return u.unique;
@@ -799,7 +807,8 @@
     drm_auth_t auth;
 
     *magic = 0;
-    if (ioctl(fd, DRM_IOCTL_GET_MAGIC, &auth)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_GET_MAGIC, &auth))
+	return -errno;
     *magic = auth.magic;
     return 0;
 }
@@ -809,7 +818,8 @@
     drm_auth_t auth;
 
     auth.magic = magic;
-    if (ioctl(fd, DRM_IOCTL_AUTH_MAGIC, &auth)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_AUTH_MAGIC, &auth))
+	return -errno;
     return 0;
 }
 
@@ -873,8 +883,10 @@
     map.handle  = 0;
     map.type    = type;
     map.flags   = flags;
-    if (ioctl(fd, DRM_IOCTL_ADD_MAP, &map)) return -errno;
-    if (handle) *handle = (drm_handle_t)map.handle;
+    if (ioctl(fd, DRM_IOCTL_ADD_MAP, &map))
+	return -errno;
+    if (handle)
+	*handle = (drm_handle_t)map.handle;
     return 0;
 }
 
@@ -884,7 +896,8 @@
 
     map.handle = (void *)handle;
 
-    if(ioctl(fd, DRM_IOCTL_RM_MAP, &map)) return -errno;
+    if(ioctl(fd, DRM_IOCTL_RM_MAP, &map))
+	return -errno;
     return 0;
 }
 
@@ -916,7 +929,8 @@
     request.flags     = flags;
     request.agp_start = agp_offset;
 
-    if (ioctl(fd, DRM_IOCTL_ADD_BUFS, &request)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_ADD_BUFS, &request))
+	return -errno;
     return request.count;
 }
 
@@ -928,9 +942,11 @@
     info.count = 0;
     info.list  = NULL;
 
-    if (ioctl(fd, DRM_IOCTL_INFO_BUFS, &info)) return -EINVAL;
+    if (ioctl(fd, DRM_IOCTL_INFO_BUFS, &info))
+	return -EINVAL;
 
-    if (!info.count) return -EINVAL;
+    if (!info.count)
+	return -EINVAL;
 
     if (!(info.list = drmMalloc(info.count * sizeof(*info.list))))
 	return -ENOMEM;
@@ -976,7 +992,8 @@
 
     request.count = count;
     request.list  = list;
-    if (ioctl(fd, DRM_IOCTL_FREE_BUFS, &request)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_FREE_BUFS, &request))
+	return -errno;
     return 0;
 }
 
@@ -1024,7 +1041,8 @@
 {
     static unsigned long pagesize_mask = 0;
 
-    if (fd < 0) return -EINVAL;
+    if (fd < 0)
+	return -EINVAL;
 
     if (!pagesize_mask)
 	pagesize_mask = getpagesize() - 1;
@@ -1032,7 +1050,8 @@
     size = (size + pagesize_mask) & ~pagesize_mask;
 
     *address = mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, handle);
-    if (*address == MAP_FAILED) return -errno;
+    if (*address == MAP_FAILED)
+	return -errno;
     return 0;
 }
 
@@ -1062,7 +1081,8 @@
     info.count = 0;
     info.list  = NULL;
 
-    if (ioctl(fd, DRM_IOCTL_INFO_BUFS, &info)) return NULL;
+    if (ioctl(fd, DRM_IOCTL_INFO_BUFS, &info))
+	return NULL;
 
     if (info.count) {
 	if (!(info.list = drmMalloc(info.count * sizeof(*info.list))))
@@ -1112,9 +1132,11 @@
     bufs.count = 0;
     bufs.list  = NULL;
     bufs.virtual = NULL;
-    if (ioctl(fd, DRM_IOCTL_MAP_BUFS, &bufs)) return NULL;
+    if (ioctl(fd, DRM_IOCTL_MAP_BUFS, &bufs))
+	return NULL;
 
-    if (!bufs.count) return NULL;
+    if (!bufs.count)
+	return NULL;
 
 	if (!(bufs.list = drmMalloc(bufs.count * sizeof(*bufs.list))))
 	    return NULL;
@@ -1269,20 +1291,25 @@
 
     res.count    = 0;
     res.contexts = NULL;
-    if (ioctl(fd, DRM_IOCTL_RES_CTX, &res)) return NULL;
+    if (ioctl(fd, DRM_IOCTL_RES_CTX, &res))
+	return NULL;
 
-    if (!res.count) return NULL;
+    if (!res.count)
+	return NULL;
 
-    if (!(list   = drmMalloc(res.count * sizeof(*list)))) return NULL;
+    if (!(list   = drmMalloc(res.count * sizeof(*list))))
+	return NULL;
     if (!(retval = drmMalloc(res.count * sizeof(*retval)))) {
 	drmFree(list);
 	return NULL;
     }
 
     res.contexts = list;
-    if (ioctl(fd, DRM_IOCTL_RES_CTX, &res)) return NULL;
+    if (ioctl(fd, DRM_IOCTL_RES_CTX, &res))
+	return NULL;
 
-    for (i = 0; i < res.count; i++) retval[i] = list[i].handle;
+    for (i = 0; i < res.count; i++)
+	retval[i] = list[i].handle;
     drmFree(list);
 
     *count = res.count;
@@ -1317,7 +1344,8 @@
     drm_ctx_t ctx;
 
     ctx.flags = 0;	/* Modified with functions below */
-    if (ioctl(fd, DRM_IOCTL_ADD_CTX, &ctx)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_ADD_CTX, &ctx))
+	return -errno;
     *handle = ctx.handle;
     return 0;
 }
@@ -1327,7 +1355,8 @@
     drm_ctx_t ctx;
 
     ctx.handle = context;
-    if (ioctl(fd, DRM_IOCTL_SWITCH_CTX, &ctx)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_SWITCH_CTX, &ctx))
+	return -errno;
     return 0;
 }
 
@@ -1343,9 +1372,12 @@
      */
     ctx.handle = context;
     ctx.flags  = 0;
-    if (flags & DRM_CONTEXT_PRESERVED) ctx.flags |= _DRM_CONTEXT_PRESERVED;
-    if (flags & DRM_CONTEXT_2DONLY)    ctx.flags |= _DRM_CONTEXT_2DONLY;
-    if (ioctl(fd, DRM_IOCTL_MOD_CTX, &ctx)) return -errno;
+    if (flags & DRM_CONTEXT_PRESERVED)
+	ctx.flags |= _DRM_CONTEXT_PRESERVED;
+    if (flags & DRM_CONTEXT_2DONLY)
+	ctx.flags |= _DRM_CONTEXT_2DONLY;
+    if (ioctl(fd, DRM_IOCTL_MOD_CTX, &ctx))
+	return -errno;
     return 0;
 }
 
@@ -1355,10 +1387,13 @@
     drm_ctx_t ctx;
 
     ctx.handle = context;
-    if (ioctl(fd, DRM_IOCTL_GET_CTX, &ctx)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_GET_CTX, &ctx))
+	return -errno;
     *flags = 0;
-    if (ctx.flags & _DRM_CONTEXT_PRESERVED) *flags |= DRM_CONTEXT_PRESERVED;
-    if (ctx.flags & _DRM_CONTEXT_2DONLY)    *flags |= DRM_CONTEXT_2DONLY;
+    if (ctx.flags & _DRM_CONTEXT_PRESERVED)
+	*flags |= DRM_CONTEXT_PRESERVED;
+    if (ctx.flags & _DRM_CONTEXT_2DONLY)
+	*flags |= DRM_CONTEXT_2DONLY;
     return 0;
 }
 
@@ -1383,14 +1418,16 @@
 {
     drm_ctx_t ctx;
     ctx.handle = handle;
-    if (ioctl(fd, DRM_IOCTL_RM_CTX, &ctx)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_RM_CTX, &ctx))
+	return -errno;
     return 0;
 }
 
 int drmCreateDrawable(int fd, drm_drawable_t *handle)
 {
     drm_draw_t draw;
-    if (ioctl(fd, DRM_IOCTL_ADD_DRAW, &draw)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_ADD_DRAW, &draw))
+	return -errno;
     *handle = draw.handle;
     return 0;
 }
@@ -1399,7 +1436,8 @@
 {
     drm_draw_t draw;
     draw.handle = handle;
-    if (ioctl(fd, DRM_IOCTL_RM_DRAW, &draw)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_RM_DRAW, &draw))
+	return -errno;
     return 0;
 }
 
@@ -1414,7 +1452,8 @@
     update.num = num;
     update.data = (unsigned long long)(unsigned long)data;
 
-    if (ioctl(fd, DRM_IOCTL_UPDATE_DRAW, &update)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_UPDATE_DRAW, &update))
+	return -errno;
 
     return 0;
 }
@@ -1433,7 +1472,8 @@
  */
 int drmAgpAcquire(int fd)
 {
-    if (ioctl(fd, DRM_IOCTL_AGP_ACQUIRE, NULL)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_AGP_ACQUIRE, NULL))
+	return -errno;
     return 0;
 }
 
@@ -1450,7 +1490,8 @@
  */
 int drmAgpRelease(int fd)
 {
-    if (ioctl(fd, DRM_IOCTL_AGP_RELEASE, NULL)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_AGP_RELEASE, NULL))
+	return -errno;
     return 0;
 }
 
@@ -1472,7 +1513,8 @@
     drm_agp_mode_t m;
 
     m.mode = mode;
-    if (ioctl(fd, DRM_IOCTL_AGP_ENABLE, &m)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_AGP_ENABLE, &m))
+	return -errno;
     return 0;
 }
 
@@ -1502,8 +1544,10 @@
     b.size   = size;
     b.handle = 0;
     b.type   = type;
-    if (ioctl(fd, DRM_IOCTL_AGP_ALLOC, &b)) return -errno;
-    if (address != 0UL) *address = b.physical;
+    if (ioctl(fd, DRM_IOCTL_AGP_ALLOC, &b))
+	return -errno;
+    if (address != 0UL)
+	*address = b.physical;
     *handle = b.handle;
     return 0;
 }
@@ -1527,7 +1571,8 @@
 
     b.size   = 0;
     b.handle = handle;
-    if (ioctl(fd, DRM_IOCTL_AGP_FREE, &b)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_AGP_FREE, &b))
+	return -errno;
     return 0;
 }
 
@@ -1551,7 +1596,8 @@
 
     b.handle = handle;
     b.offset = offset;
-    if (ioctl(fd, DRM_IOCTL_AGP_BIND, &b)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_AGP_BIND, &b))
+	return -errno;
     return 0;
 }
 
@@ -1574,7 +1620,8 @@
 
     b.handle = handle;
     b.offset = 0;
-    if (ioctl(fd, DRM_IOCTL_AGP_UNBIND, &b)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_AGP_UNBIND, &b))
+	return -errno;
     return 0;
 }
 
@@ -1594,7 +1641,8 @@
 {
     drm_agp_info_t i;
 
-    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
+	return -errno;
     return i.agp_version_major;
 }
 
@@ -1614,7 +1662,8 @@
 {
     drm_agp_info_t i;
 
-    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
+	return -errno;
     return i.agp_version_minor;
 }
 
@@ -1634,7 +1683,8 @@
 {
     drm_agp_info_t i;
 
-    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i)) return 0;
+    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
+	return 0;
     return i.mode;
 }
 
@@ -1654,7 +1704,8 @@
 {
     drm_agp_info_t i;
 
-    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i)) return 0;
+    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
+	return 0;
     return i.aperture_base;
 }
 
@@ -1674,7 +1725,8 @@
 {
     drm_agp_info_t i;
 
-    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i)) return 0;
+    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
+	return 0;
     return i.aperture_size;
 }
 
@@ -1694,7 +1746,8 @@
 {
     drm_agp_info_t i;
 
-    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i)) return 0;
+    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
+	return 0;
     return i.memory_used;
 }
 
@@ -1714,7 +1767,8 @@
 {
     drm_agp_info_t i;
 
-    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i)) return 0;
+    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
+	return 0;
     return i.memory_allowed;
 }
 
@@ -1734,7 +1788,8 @@
 {
     drm_agp_info_t i;
 
-    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i)) return 0;
+    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
+	return 0;
     return i.id_vendor;
 }
 
@@ -1754,7 +1809,8 @@
 {
     drm_agp_info_t i;
 
-    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i)) return 0;
+    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
+	return 0;
     return i.id_device;
 }
 
@@ -1765,7 +1821,8 @@
     *handle = 0;
     sg.size   = size;
     sg.handle = 0;
-    if (ioctl(fd, DRM_IOCTL_SG_ALLOC, &sg)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_SG_ALLOC, &sg))
+	return -errno;
     *handle = sg.handle;
     return 0;
 }
@@ -1776,7 +1833,8 @@
 
     sg.size   = 0;
     sg.handle = handle;
-    if (ioctl(fd, DRM_IOCTL_SG_FREE, &sg)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_SG_FREE, &sg))
+	return -errno;
     return 0;
 }
 
@@ -1806,12 +1864,21 @@
 int drmError(int err, const char *label)
 {
     switch (err) {
-    case DRM_ERR_NO_DEVICE: fprintf(stderr, "%s: no device\n", label);   break;
-    case DRM_ERR_NO_ACCESS: fprintf(stderr, "%s: no access\n", label);   break;
-    case DRM_ERR_NOT_ROOT:  fprintf(stderr, "%s: not root\n", label);    break;
-    case DRM_ERR_INVALID:   fprintf(stderr, "%s: invalid args\n", label);break;
+    case DRM_ERR_NO_DEVICE:
+	fprintf(stderr, "%s: no device\n", label);
+	break;
+    case DRM_ERR_NO_ACCESS:
+	fprintf(stderr, "%s: no access\n", label);
+	break;
+    case DRM_ERR_NOT_ROOT:
+	fprintf(stderr, "%s: not root\n", label);
+	break;
+    case DRM_ERR_INVALID:
+	fprintf(stderr, "%s: invalid args\n", label);
+	break;
     default:
-	if (err < 0) err = -err;
+	if (err < 0)
+	    err = -err;
 	fprintf( stderr, "%s: error %d (%s)\n", label, err, strerror(err) );
 	break;
     }
@@ -1837,7 +1904,8 @@
 
     ctl.func  = DRM_INST_HANDLER;
     ctl.irq   = irq;
-    if (ioctl(fd, DRM_IOCTL_CONTROL, &ctl)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_CONTROL, &ctl))
+	return -errno;
     return 0;
 }
 
@@ -1859,7 +1927,8 @@
 
     ctl.func  = DRM_UNINST_HANDLER;
     ctl.irq   = 0;
-    if (ioctl(fd, DRM_IOCTL_CONTROL, &ctl)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_CONTROL, &ctl))
+	return -errno;
     return 0;
 }
 
@@ -1875,7 +1944,8 @@
     if (flags & DRM_LOCK_FLUSH_ALL)  lock.flags |= _DRM_LOCK_FLUSH_ALL;
     if (flags & DRM_HALT_ALL_QUEUES) lock.flags |= _DRM_HALT_ALL_QUEUES;
     if (flags & DRM_HALT_CUR_QUEUES) lock.flags |= _DRM_HALT_CUR_QUEUES;
-    if (ioctl(fd, DRM_IOCTL_FINISH, &lock)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_FINISH, &lock))
+	return -errno;
     return 0;
 }
 
@@ -1900,7 +1970,8 @@
     p.busnum  = busnum;
     p.devnum  = devnum;
     p.funcnum = funcnum;
-    if (ioctl(fd, DRM_IOCTL_IRQ_BUSID, &p)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_IRQ_BUSID, &p))
+	return -errno;
     return p.irq;
 }
 
@@ -1927,7 +1998,8 @@
     drmHashEntry  *entry = drmGetEntry(fd);
     void          *value;
 
-    if (drmHashLookup(entry->tagTable, context, &value)) return NULL;
+    if (drmHashLookup(entry->tagTable, context, &value))
+	return NULL;
 
     return value;
 }
@@ -1940,7 +2012,8 @@
     map.ctx_id = ctx_id;
     map.handle = (void *)handle;
 
-    if (ioctl(fd, DRM_IOCTL_SET_SAREA_CTX, &map)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_SET_SAREA_CTX, &map))
+	return -errno;
     return 0;
 }
 
@@ -1951,8 +2024,10 @@
 
     map.ctx_id = ctx_id;
 
-    if (ioctl(fd, DRM_IOCTL_GET_SAREA_CTX, &map)) return -errno;
-    if (handle) *handle = (drm_handle_t)map.handle;
+    if (ioctl(fd, DRM_IOCTL_GET_SAREA_CTX, &map))
+	return -errno;
+    if (handle)
+	*handle = (drm_handle_t)map.handle;
 
     return 0;
 }
@@ -1964,7 +2039,8 @@
     drm_map_t map;
 
     map.offset = idx;
-    if (ioctl(fd, DRM_IOCTL_GET_MAP, &map)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_GET_MAP, &map))
+	return -errno;
     *offset = map.offset;
     *size   = map.size;
     *type   = map.type;
@@ -1980,7 +2056,8 @@
     drm_client_t client;
 
     client.idx = idx;
-    if (ioctl(fd, DRM_IOCTL_GET_CLIENT, &client)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_GET_CLIENT, &client))
+	return -errno;
     *auth      = client.auth;
     *pid       = client.pid;
     *uid       = client.uid;
@@ -1994,7 +2071,8 @@
     drm_stats_t s;
     int         i;
 
-    if (ioctl(fd, DRM_IOCTL_GET_STATS, &s)) return -errno;
+    if (ioctl(fd, DRM_IOCTL_GET_STATS, &s))
+	return -errno;
 
     stats->count = 0;
     memset(stats, 0, sizeof(*stats));
@@ -2267,19 +2345,20 @@
  * DRM_FENCE_MASK_DRIVER
  */
 
-int drmFenceCreate(int fd, unsigned flags, int class,unsigned type, 
+int drmFenceCreate(int fd, unsigned flags, int fence_class, unsigned type,
 		   drmFence *fence)
 {
     drm_fence_arg_t arg;
-    
+
     memset(&arg, 0, sizeof(arg));
+    arg.flags = flags;
     arg.type = type;
-    arg.class = class;
-    arg.op = drm_fence_create;
-    if (ioctl(fd, DRM_IOCTL_FENCE, &arg))
+    arg.fence_class = fence_class;
+
+    if (ioctl(fd, DRM_IOCTL_FENCE_CREATE, &arg))
 	return -errno;
     fence->handle = arg.handle;
-    fence->class = arg.class;
+    fence->fence_class = arg.fence_class;
     fence->type = arg.type;
     fence->flags = arg.flags;
     fence->signaled = 0;
@@ -2292,46 +2371,36 @@
  * DRM_FENCE_MASK_DRIVER
  */
 
-int drmFenceBuffers(int fd, unsigned flags, drmFence *fence)
+int drmFenceBuffers(int fd, unsigned flags, uint32_t fence_class, drmFence *fence)
 {
     drm_fence_arg_t arg;
-    
+
     memset(&arg, 0, sizeof(arg));
     arg.flags = flags;
-    arg.op = drm_fence_buffers;
-    if (ioctl(fd, DRM_IOCTL_FENCE, &arg))
+    arg.fence_class = fence_class;
+
+    if (ioctl(fd, DRM_IOCTL_FENCE_BUFFERS, &arg))
 	return -errno;
     fence->handle = arg.handle;
-    fence->class = arg.class;
+    fence->fence_class = arg.fence_class;
     fence->type = arg.type;
     fence->flags = arg.flags;
+    fence->sequence = arg.sequence;
     fence->signaled = 0;
     return 0;
 }
-    
-int drmFenceDestroy(int fd, const drmFence *fence)
-{
-    drm_fence_arg_t arg;
-   
-    memset(&arg, 0, sizeof(arg));
-    arg.handle = fence->handle;
-    arg.op = drm_fence_destroy;
-    if (ioctl(fd, DRM_IOCTL_FENCE, &arg))
-	return -errno;
-    return 0;
-}
 
 int drmFenceReference(int fd, unsigned handle, drmFence *fence)
 {
     drm_fence_arg_t arg;
-   
+
     memset(&arg, 0, sizeof(arg));
     arg.handle = handle;
-    arg.op = drm_fence_reference;
-    if (ioctl(fd, DRM_IOCTL_FENCE, &arg))
+
+    if (ioctl(fd, DRM_IOCTL_FENCE_REFERENCE, &arg))
 	return -errno;
     fence->handle = arg.handle;
-    fence->class = arg.class;
+    fence->fence_class = arg.fence_class;
     fence->type = arg.type;
     fence->flags = arg.flags;
     fence->signaled = arg.signaled;
@@ -2341,11 +2410,11 @@
 int drmFenceUnreference(int fd, const drmFence *fence)
 {
     drm_fence_arg_t arg;
-   
+
     memset(&arg, 0, sizeof(arg));
     arg.handle = fence->handle;
-    arg.op = drm_fence_unreference;
-    if (ioctl(fd, DRM_IOCTL_FENCE, &arg))
+
+    if (ioctl(fd, DRM_IOCTL_FENCE_UNREFERENCE, &arg))
 	return -errno;
     return 0;
 }
@@ -2353,29 +2422,29 @@
 int drmFenceFlush(int fd, drmFence *fence, unsigned flush_type)
 {
     drm_fence_arg_t arg;
-   
+
     memset(&arg, 0, sizeof(arg));
     arg.handle = fence->handle;
     arg.type = flush_type;
-    arg.op = drm_fence_flush;
-    if (ioctl(fd, DRM_IOCTL_FENCE, &arg))
+
+    if (ioctl(fd, DRM_IOCTL_FENCE_FLUSH, &arg))
 	return -errno;
-    fence->class = arg.class;
+    fence->fence_class = arg.fence_class;
     fence->type = arg.type;
     fence->signaled = arg.signaled;
-    return 0;
+    return arg.error;
 }
 
 int drmFenceUpdate(int fd, drmFence *fence)
 {
-	drm_fence_arg_t arg;
-	
+    drm_fence_arg_t arg;
+
     memset(&arg, 0, sizeof(arg));
     arg.handle = fence->handle;
-    arg.op = drm_fence_signaled;
-    if (ioctl(fd, DRM_IOCTL_FENCE, &arg))
+
+    if (ioctl(fd, DRM_IOCTL_FENCE_SIGNALED, &arg))
 	return -errno;
-    fence->class = arg.class;
+    fence->fence_class = arg.fence_class;
     fence->type = arg.type;
     fence->signaled = arg.signaled;
     return 0;
@@ -2384,13 +2453,9 @@
 int drmFenceSignaled(int fd, drmFence *fence, unsigned fenceType, 
 		     int *signaled)
 {
-    int 
-	ret;
-
     if ((fence->flags & DRM_FENCE_FLAG_SHAREABLE) ||
 	((fenceType & fence->signaled) != fenceType)) {
-
-	ret = drmFenceFlush(fd, fence, fenceType);
+	int ret = drmFenceFlush(fd, fence, fenceType);
 	if (ret)
 	    return ret;
     }
@@ -2410,17 +2475,19 @@
 int drmFenceEmit(int fd, unsigned flags, drmFence *fence, unsigned emit_type)
 {
     drm_fence_arg_t arg;
-   
+
     memset(&arg, 0, sizeof(arg));
+    arg.fence_class = fence->fence_class;
     arg.flags = flags;
     arg.handle = fence->handle;
     arg.type = emit_type;
-    arg.op = drm_fence_emit;
-    if (ioctl(fd, DRM_IOCTL_FENCE, &arg))
+
+    if (ioctl(fd, DRM_IOCTL_FENCE_EMIT, &arg))
 	return -errno;
-    fence->class = arg.class;
+    fence->fence_class = arg.fence_class;
     fence->type = arg.type;
     fence->signaled = arg.signaled;
+    fence->sequence = arg.sequence;
     return 0;
 }
 
@@ -2429,7 +2496,50 @@
  * DRM_FENCE_FLAG_WAIT_LAZY
  * DRM_FENCE_FLAG_WAIT_IGNORE_SIGNALS
  */
+
+#define DRM_IOCTL_TIMEOUT_USEC 3000000UL
+
+static unsigned long
+drmTimeDiff(struct timeval *now, struct timeval *then)
+{
+    uint64_t val;
+
+    val = now->tv_sec - then->tv_sec;
+    val *= 1000000LL;
+    val += now->tv_usec;
+    val -= then->tv_usec;
+
+    return (unsigned long) val;
+}
+
+static int
+drmIoctlTimeout(int fd, unsigned long request, void *argp)
+{
+    int haveThen = 0;
+    struct timeval then, now;
+    int ret;
+
+    do {
+	ret = ioctl(fd, request, argp);
+	if (ret != 0 && errno == EAGAIN) {
+	    if (!haveThen) {
+		gettimeofday(&then, NULL);
+		haveThen = 1;
+	    }
+	    gettimeofday(&now, NULL);
+	}
+    } while (ret != 0 && errno == EAGAIN && 
+	     drmTimeDiff(&now, &then) < DRM_IOCTL_TIMEOUT_USEC);
+    
+    if (ret != 0)
+	return ((errno == EAGAIN) ? -EBUSY : -errno);
+
+    return 0;
+}
     
+	
+
+
 int drmFenceWait(int fd, unsigned flags, drmFence *fence, unsigned flush_type)
 {
     drm_fence_arg_t arg;
@@ -2449,160 +2559,19 @@
     arg.handle = fence->handle;
     arg.type = flush_type;
     arg.flags = flags;
-    arg.op = drm_fence_wait;
-    do {
-	ret = ioctl(fd, DRM_IOCTL_FENCE, &arg);
-    } while (ret != 0 && errno == EAGAIN);
 
+
+    ret = drmIoctlTimeout(fd, DRM_IOCTL_FENCE_WAIT, &arg);
     if (ret)
-	return -errno;
+	return ret;
 
-    fence->class = arg.class;
+    fence->fence_class = arg.fence_class;
     fence->type = arg.type;
     fence->signaled = arg.signaled;
-    return 0;
+    return arg.error;
 }    
 
-static int drmAdjustListNodes(drmBOList *list)
-{
-    drmBONode *node;
-    drmMMListHead *l;
-    int ret = 0;
-
-    while(list->numCurrent < list->numTarget) {
-	node = (drmBONode *) malloc(sizeof(*node));
-	if (!node) {
-	    ret = -ENOMEM;
-	    break;
-	}
-	list->numCurrent++;
-	DRMLISTADD(&node->head, &list->free);
-    }
-
-    while(list->numCurrent > list->numTarget) {
-	l = list->free.next;
-	if (l == &list->free)
-	    break;
-	DRMLISTDEL(l);
-	node = DRMLISTENTRY(drmBONode, l, head);
-	free(node);
-	list->numCurrent--;
-    }
-    return ret;
-}
-
-void drmBOFreeList(drmBOList *list)
-{
-    drmBONode *node;
-    drmMMListHead *l;
-
-    l = list->list.next;
-    while(l != &list->list) {
-	DRMLISTDEL(l);
-	node = DRMLISTENTRY(drmBONode, l, head);
-	free(node);
-	l = list->free.next;
-	list->numCurrent--;
-	list->numOnList--;
-    }
-
-    l = list->free.next;
-    while(l != &list->free) {
-	DRMLISTDEL(l);
-	node = DRMLISTENTRY(drmBONode, l, head);
-	free(node);
-	l = list->free.next;
-	list->numCurrent--;
-    }
-}
-	
-int drmBOResetList(drmBOList *list) {
-
-    drmMMListHead *l;
-    int ret;
-
-    ret = drmAdjustListNodes(list);
-    if (ret)
-	return ret;
-
-    l = list->list.next;
-    while(l != &list->list) {
-	DRMLISTDEL(l);
-	DRMLISTADD(l, &list->free);
-	list->numOnList--;
-	l = list->list.next;
-    }
-    return drmAdjustListNodes(list);
-}
-	
-static drmBONode *drmAddListItem(drmBOList *list, drmBO *item, 
-				 unsigned long arg0,
-				 unsigned long arg1)
-{
-    drmBONode *node;
-    drmMMListHead *l;
-
-    l = list->free.next;
-    if (l == &list->free) {
-	node = (drmBONode *) malloc(sizeof(*node));
-	if (!node) {
-	    return NULL;
-	}
-	list->numCurrent++;
-    } else {
-	DRMLISTDEL(l);
-	node = DRMLISTENTRY(drmBONode, l, head);
-    }
-    node->buf = item;
-    node->arg0 = arg0;
-    node->arg1 = arg1;
-    DRMLISTADD(&node->head, &list->list);
-    list->numOnList++;
-    return node;
-}
-     	
-void *drmBOListIterator(drmBOList *list)
-{
-    void *ret = list->list.next;
-
-    if (ret == &list->list)
-	return NULL;
-    return ret;
-}
-
-void *drmBOListNext(drmBOList *list, void *iterator)
-{
-    void *ret;
-
-    drmMMListHead *l = (drmMMListHead *) iterator;
-    ret = l->next;
-    if (ret == &list->list)
-	return NULL;
-    return ret;
-}
-
-drmBO *drmBOListBuf(void *iterator)
-{
-    drmBONode *node;
-    drmMMListHead *l = (drmMMListHead *) iterator;
-    node = DRMLISTENTRY(drmBONode, l, head);
-    
-    return node->buf;
-}
-
-
-int drmBOCreateList(int numTarget, drmBOList *list)
-{
-    DRMINITLISTHEAD(&list->list);
-    DRMINITLISTHEAD(&list->free);
-    list->numTarget = numTarget;
-    list->numCurrent = 0;
-    list->numOnList = 0;
-    return drmAdjustListNodes(list);
-}
-
-static void drmBOCopyReply(const drm_bo_arg_reply_t *rep, 
-			   drmBO *buf)
+static void drmBOCopyReply(const struct drm_bo_info_rep *rep, drmBO *buf)
 {
     buf->handle = rep->handle;
     buf->flags = rep->flags;
@@ -2614,18 +2583,21 @@
     buf->fenceFlags = rep->fence_flags;
     buf->replyFlags = rep->rep_flags;
     buf->pageAlignment = rep->page_alignment;
+    buf->tileInfo = rep->tile_info;
+    buf->hwTileStride = rep->hw_tile_stride;
+    buf->desiredTileStride = rep->desired_tile_stride;
 }
-    
-    
 
-int drmBOCreate(int fd, unsigned long start, unsigned long size, 
-		unsigned pageAlignment, void *user_buffer, drm_bo_type_t type, 
-		unsigned mask,
+
+
+int drmBOCreate(int fd, unsigned long size,
+		unsigned pageAlignment, void *user_buffer,
+		uint64_t mask,
 		unsigned hint, drmBO *buf)
 {
-    drm_bo_arg_t arg;
-    drm_bo_arg_request_t *req = &arg.d.req;
-    drm_bo_arg_reply_t *rep = &arg.d.rep;
+    struct drm_bo_create_arg arg;
+    struct drm_bo_create_req *req = &arg.d.req;
+    struct drm_bo_info_rep *rep = &arg.d.rep;
     int ret;
 
     memset(buf, 0, sizeof(*buf));
@@ -2633,99 +2605,35 @@
     req->mask = mask;
     req->hint = hint;
     req->size = size;
-    req->type = type;
     req->page_alignment = pageAlignment;
+    req->buffer_start = (unsigned long) user_buffer;
 
     buf->virtual = NULL;
 
-    switch(type) {
-    case drm_bo_type_dc:
-        req->buffer_start = start;
-	break;
-    case drm_bo_type_user:
-	req->buffer_start = (unsigned long) user_buffer;
-	buf->virtual = user_buffer;
-	break;
-    case drm_bo_type_fake:
-        req->buffer_start = start;
-	break;
-    default:
-	return -EINVAL;
-    }
-    req->op = drm_bo_create;
-
-    do {
-	ret = ioctl(fd, DRM_IOCTL_BUFOBJ, &arg);
-    } while (ret != 0 && errno == EAGAIN);
-
+    ret = drmIoctlTimeout(fd, DRM_IOCTL_BO_CREATE, &arg);
     if (ret)
-	return -errno;
-    if (!arg.handled) {
-	return -EFAULT;
-    }
-    if (rep->ret) {
-        fprintf(stderr, "Error %d\n", rep->ret);
-	return rep->ret;
-    }
-    
+	return ret;
+
     drmBOCopyReply(rep, buf);
-    buf->mapVirtual = NULL;
+    buf->virtual = user_buffer;
     buf->mapCount = 0;
 
     return 0;
 }
 
-int drmBODestroy(int fd, drmBO *buf)
-{
-    drm_bo_arg_t arg;
-    drm_bo_arg_request_t *req = &arg.d.req;
-    drm_bo_arg_reply_t *rep = &arg.d.rep;
-    
-    if (buf->mapVirtual && (buf->type != drm_bo_type_fake)) {
-	(void) drmUnmap(buf->mapVirtual, buf->start + buf->size);
-	buf->mapVirtual = NULL;
-	buf->virtual = NULL;
-    }
-
-    memset(&arg, 0, sizeof(arg));
-    req->handle = buf->handle;
-    req->op = drm_bo_destroy;
-
-    if (ioctl(fd, DRM_IOCTL_BUFOBJ, &arg))
-	return -errno;
-    if (!arg.handled) {
-	return -EFAULT;
-    }
-    if (rep->ret) {
-	return rep->ret;
-    }
-
-    buf->handle = 0;
-    return 0;
-}
- 
 int drmBOReference(int fd, unsigned handle, drmBO *buf)
 {
-
-    drm_bo_arg_t arg;
-    drm_bo_arg_request_t *req = &arg.d.req;
-    drm_bo_arg_reply_t *rep = &arg.d.rep;
+    struct drm_bo_reference_info_arg arg;
+    struct drm_bo_handle_arg *req = &arg.d.req;
+    struct drm_bo_info_rep *rep = &arg.d.rep;
     
     memset(&arg, 0, sizeof(arg));
     req->handle = handle;
-    req->op = drm_bo_reference;
     
-    if (ioctl(fd, DRM_IOCTL_BUFOBJ, &arg))
+    if (ioctl(fd, DRM_IOCTL_BO_REFERENCE, &arg))
 	return -errno;
-    if (!arg.handled) {
-	return -EFAULT;
-    }
-    if (rep->ret) {
-	return rep->ret;
-    }
 
     drmBOCopyReply(rep, buf);
-    buf->type = drm_bo_type_dc;
     buf->mapVirtual = NULL;
     buf->mapCount = 0;
     buf->virtual = NULL;
@@ -2733,36 +2641,27 @@
     return 0;
 }
 
-int drmBOUnReference(int fd, drmBO *buf)
+int drmBOUnreference(int fd, drmBO *buf)
 {
-    drm_bo_arg_t arg;
-    drm_bo_arg_request_t *req = &arg.d.req;
-    drm_bo_arg_reply_t *rep = &arg.d.rep;
-    
+    struct drm_bo_handle_arg arg;
 
-    if (buf->mapVirtual && (buf->type != drm_bo_type_fake)) {
+    if (buf->mapVirtual && buf->mapHandle) {
 	(void) munmap(buf->mapVirtual, buf->start + buf->size);
 	buf->mapVirtual = NULL;
 	buf->virtual = NULL;
     }
 
     memset(&arg, 0, sizeof(arg));
-    req->handle = buf->handle;
-    req->op = drm_bo_unreference;
+    arg.handle = buf->handle;
 
-    if (ioctl(fd, DRM_IOCTL_BUFOBJ, &arg))
+    if (ioctl(fd, DRM_IOCTL_BO_UNREFERENCE, &arg))
 	return -errno;
-    if (!arg.handled) {
-	return -EFAULT;
-    }
-    if (rep->ret) {
-	return rep->ret;
-    }
 
     buf->handle = 0;
     return 0;
 }   
 
+
 /*
  * Flags can be  DRM_BO_FLAG_READ, DRM_BO_FLAG_WRITE or'ed together
  * Hint currently be DRM_BO_HINT_DONT_BLOCK, which makes the
@@ -2772,17 +2671,16 @@
 int drmBOMap(int fd, drmBO *buf, unsigned mapFlags, unsigned mapHint,
 	     void **address)
 {
-
-    drm_bo_arg_t arg;
-    drm_bo_arg_request_t *req = &arg.d.req;
-    drm_bo_arg_reply_t *rep = &arg.d.rep;
+    struct drm_bo_map_wait_idle_arg arg;
+    struct drm_bo_info_req *req = &arg.d.req;
+    struct drm_bo_info_rep *rep = &arg.d.rep;
     int ret = 0;
 
     /*
      * Make sure we have a virtual address of the buffer.
      */
 
-    if (!buf->virtual && buf->type != drm_bo_type_fake) {
+    if (!buf->virtual) {
 	drmAddress virtual;
 	virtual = mmap(0, buf->size + buf->start, 
 		       PROT_READ | PROT_WRITE, MAP_SHARED,
@@ -2800,23 +2698,15 @@
     req->handle = buf->handle;
     req->mask = mapFlags;
     req->hint = mapHint;
-    req->op = drm_bo_map;
 
     /*
      * May hang if the buffer object is busy.
      * This IOCTL synchronizes the buffer.
      */
     
-    do {
-	ret = ioctl(fd, DRM_IOCTL_BUFOBJ, &arg);
-    } while (ret != 0 && errno == EAGAIN);
-
-    if (ret) 
+    ret = drmIoctlTimeout(fd, DRM_IOCTL_BO_MAP, &arg);
+    if (ret)
 	return ret;
-    if (!arg.handled) 
-	return -EFAULT;
-    if (rep->ret)
-	return rep->ret;
 
     drmBOCopyReply(rep, buf);	
     buf->mapFlags = mapFlags;
@@ -2826,130 +2716,85 @@
     return 0;
 }
 
+
 int drmBOUnmap(int fd, drmBO *buf)
 {
-    drm_bo_arg_t arg;
-    drm_bo_arg_request_t *req = &arg.d.req;
-    drm_bo_arg_reply_t *rep = &arg.d.rep;
+    struct drm_bo_handle_arg arg;
 
-	
     memset(&arg, 0, sizeof(arg));
-    req->handle = buf->handle;
-    req->op = drm_bo_unmap;
+    arg.handle = buf->handle;
 
-    if (ioctl(fd, DRM_IOCTL_BUFOBJ, &arg)) {
+    if (ioctl(fd, DRM_IOCTL_BO_UNMAP, &arg)) {
 	return -errno;
     }
-    if (!arg.handled) 
-        return -EFAULT;
-    if (rep->ret)
-	return rep->ret;
-
+    buf->mapCount--;
     return 0;
 }
-    
-int drmBOValidate(int fd, drmBO *buf, unsigned flags, unsigned mask, 
-		  unsigned hint)
+
+int drmBOSetStatus(int fd, drmBO *buf, 
+		   uint64_t flags, uint64_t mask,
+		   unsigned int hint, 
+		   unsigned int desired_tile_stride,
+		   unsigned int tile_info)
 {
-    drm_bo_arg_t arg;
-    drm_bo_arg_request_t *req = &arg.d.req;
-    drm_bo_arg_reply_t *rep = &arg.d.rep;
+
+    struct drm_bo_map_wait_idle_arg arg;
+    struct drm_bo_info_req *req = &arg.d.req;
+    struct drm_bo_info_rep *rep = &arg.d.rep;
     int ret = 0;
 
     memset(&arg, 0, sizeof(arg));
+    req->mask = mask;
+    req->flags = flags;
     req->handle = buf->handle;
-    req->mask = flags;
     req->hint = hint;
-    req->arg_handle = mask; /* Encode mask in the arg_handle field :/ */
-    req->op = drm_bo_validate;
-
-    do{
-	ret = ioctl(fd, DRM_IOCTL_BUFOBJ, &arg);
-    } while (ret && errno == EAGAIN);
+    req->desired_tile_stride = desired_tile_stride;
+    req->tile_info = tile_info;
     
+    ret = drmIoctlTimeout(fd, DRM_IOCTL_BO_SETSTATUS, &arg);
     if (ret) 
-	return ret;
-    if (!arg.handled)
-	return -EFAULT;
-    if (rep->ret)
-	return rep->ret;
+	    return ret;
 
     drmBOCopyReply(rep, buf);
     return 0;
 }
 	    
 
-int drmBOFence(int fd, drmBO *buf, unsigned flags, unsigned fenceHandle)
-{
-    drm_bo_arg_t arg;
-    drm_bo_arg_request_t *req = &arg.d.req;
-    drm_bo_arg_reply_t *rep = &arg.d.rep;
-    int ret = 0;
-
-    memset(&arg, 0, sizeof(arg));
-    req->handle = buf->handle;
-    req->mask = flags;
-    req->arg_handle = fenceHandle;
-    req->op = drm_bo_validate;
-
-    ret = ioctl(fd, DRM_IOCTL_BUFOBJ, &arg);
-    
-    if (ret) 
-	return ret;
-    if (!arg.handled)
-	return -EFAULT;
-    if (rep->ret)
-	return rep->ret;
-    return 0;
-}
-
 int drmBOInfo(int fd, drmBO *buf)
 {
-    drm_bo_arg_t arg;
-    drm_bo_arg_request_t *req = &arg.d.req;
-    drm_bo_arg_reply_t *rep = &arg.d.rep;
+    struct drm_bo_reference_info_arg arg;
+    struct drm_bo_handle_arg *req = &arg.d.req;
+    struct drm_bo_info_rep *rep = &arg.d.rep;
     int ret = 0;
 
     memset(&arg, 0, sizeof(arg));
     req->handle = buf->handle;
-    req->op = drm_bo_info;
 
-    ret = ioctl(fd, DRM_IOCTL_BUFOBJ, &arg);
-    
+    ret = ioctl(fd, DRM_IOCTL_BO_INFO, &arg);
     if (ret) 
-	return ret;
-    if (!arg.handled)
-	return -EFAULT;
-    if (rep->ret)
-	return rep->ret;
+	return -errno;
+
     drmBOCopyReply(rep, buf);
     return 0;
 }
 
 int drmBOWaitIdle(int fd, drmBO *buf, unsigned hint)
 {
-    drm_bo_arg_t arg;
-    drm_bo_arg_request_t *req = &arg.d.req;
-    drm_bo_arg_reply_t *rep = &arg.d.rep;
+    struct drm_bo_map_wait_idle_arg arg;
+    struct drm_bo_info_req *req = &arg.d.req;
+    struct drm_bo_info_rep *rep = &arg.d.rep;
     int ret = 0;
 
     if ((buf->flags & DRM_BO_FLAG_SHAREABLE) ||
 	(buf->replyFlags & DRM_BO_REP_BUSY)) {
         memset(&arg, 0, sizeof(arg));
 	req->handle = buf->handle;
-	req->op = drm_bo_wait_idle;
 	req->hint = hint;
 
-	do {
-	    ret = ioctl(fd, DRM_IOCTL_BUFOBJ, &arg);
-	} while (ret && errno == EAGAIN);
-
+	ret = drmIoctlTimeout(fd, DRM_IOCTL_BO_WAIT_IDLE, &arg);
 	if (ret) 
 	    return ret;
-	if (!arg.handled)
-	    return -EFAULT;
-	if (rep->ret)
-	    return rep->ret;
+
 	drmBOCopyReply(rep, buf);
     }
     return 0;
@@ -2961,7 +2806,8 @@
 	!(buf->replyFlags & DRM_BO_REP_BUSY)) {
 	*busy = 0;
 	return 0;
-    } else {
+    }
+    else {
 	int ret = drmBOInfo(fd, buf);
 	if (ret)
 	    return ret;
@@ -2970,257 +2816,95 @@
     }
 }
     
-    
-int drmAddValidateItem(drmBOList *list, drmBO *buf, unsigned flags, 
-		       unsigned mask,
-		       int *newItem)
-{
-    drmBONode *node, *cur;
-    drmMMListHead *l;
-
-    *newItem = 0;
-    cur = NULL;
-
-    for (l = list->list.next; l != &list->list; l = l->next) {
-	node = DRMLISTENTRY(drmBONode, l, head);
-	if (node->buf == buf) {
-	    cur = node;
-	    break;
-	}
-    }
-    if (!cur) {
-	cur = drmAddListItem(list, buf, flags, mask);
-	if (!cur) {
-	    drmMsg("Out of memory creating validate list node.\n");
-	    return -ENOMEM;
-	}
-	*newItem = 1;
-	cur->arg0 = flags;
-	cur->arg1 = mask;
-    } else {
-	unsigned memMask = (cur->arg1 | mask) & DRM_BO_MASK_MEM;
-	unsigned memFlags = cur->arg0 & flags & memMask;
-	
-	if (!memFlags) {
-	    drmMsg("Incompatible memory location requests "
-		   "on validate list.\n");
-	    drmMsg("Previous flag: 0x%08lx, mask: 0x%08lx\n",
-		   cur->arg0, cur->arg1);
-	    drmMsg("Current flag: 0x%08lx, mask: 0x%08lx\n",
-		   flags, mask);
-	    return -EINVAL;
-	}
-	if (mask & cur->arg1 & ~DRM_BO_MASK_MEM  & (cur->arg0 ^ flags)) {
-	    drmMsg("Incompatible buffer flag requests "
-		   "on validate list.\n");
-	    drmMsg("Previous flag: 0x%08lx, mask: 0x%08lx\n",
-		   cur->arg0, cur->arg1);
-	    drmMsg("Current flag: 0x%08lx, mask: 0x%08lx\n",
-		   flags, mask);
-	    return -EINVAL;
-	}
-	cur->arg1 |= mask;
-	cur->arg0 = memFlags | ((cur->arg0 | flags) & 
-				cur->arg1 & ~DRM_BO_MASK_MEM);	
-    }
-    return 0;
-}
-
-
-int drmBOValidateList(int fd, drmBOList *list)
-{
-   
-  drmBONode *node;
-  drmMMListHead *l;
-  drm_bo_arg_t *arg, *first;
-  drm_bo_arg_request_t *req;
-  drm_bo_arg_reply_t *rep;
-  drm_u64_t *prevNext = NULL;
-  drmBO *buf;
-  int ret;
-
-  first = NULL;
-
-  for (l = list->list.next; l != &list->list; l = l->next) {
-      node = DRMLISTENTRY(drmBONode, l, head);
-
-      arg = &node->bo_arg;
-      req = &arg->d.req;
-
-      if (!first)
-	  first = arg;
-
-      if (prevNext)
-	  *prevNext = (unsigned long) arg;
-
-      memset(arg, 0, sizeof(*arg));
-      prevNext = &arg->next;
-      req->handle = node->buf->handle;
-      req->op = drm_bo_validate;
-      req->mask = node->arg0;
-      req->hint = 0;
-      req->arg_handle = node->arg1;
-  }
-  
-  if (!first) 
-      return 0;
-
-  do{
-      ret = ioctl(fd, DRM_IOCTL_BUFOBJ, first);
-  } while (ret && errno == EAGAIN);
-
-
-  if (ret)
-      return -errno;
-  
-  for (l = list->list.next; l != &list->list; l = l->next) {
-      node = DRMLISTENTRY(drmBONode, l, head);
-      arg = &node->bo_arg;
-      rep = &arg->d.rep;
-      
-      if (!arg->handled) {
-	  drmMsg("Unhandled request\n");
-	  return -EFAULT;
-      }
-      if (rep->ret)
-	  return rep->ret;
-
-      buf = node->buf;
-      drmBOCopyReply(rep, buf);
-  }
-
-  return 0;
-}
-	  
-
-int drmBOFenceList(int fd, drmBOList *list, unsigned fenceHandle)
-{
-   
-  drmBONode *node;
-  drmMMListHead *l;
-  drm_bo_arg_t *arg, *first;
-  drm_bo_arg_request_t *req;
-  drm_bo_arg_reply_t *rep;
-  drm_u64_t *prevNext = NULL;
-  drmBO *buf;
-  unsigned fence_flags;
-  int ret;
-
-  first = NULL;
-
-  for (l = list->list.next; l != &list->list; l = l->next) {
-      node = DRMLISTENTRY(drmBONode, l, head);
-
-      arg = &node->bo_arg;
-      req = &arg->d.req;
-
-      if (!first)
-	  first = arg;
-
-      if (prevNext)
-	  *prevNext = (unsigned long) arg;
-
-      memset(arg, 0, sizeof(*arg));
-      prevNext = &arg->next;
-      req->handle = node->buf->handle;
-      req->op = drm_bo_fence;
-      req->mask = node->arg0;
-      req->arg_handle = fenceHandle;
-  }
-  
-  if (!first) 
-      return 0;
-
-  ret = ioctl(fd, DRM_IOCTL_BUFOBJ, first);
-
-  if (ret)
-      return -errno;
-  
-  for (l = list->list.next; l != &list->list; l = l->next) {
-      node = DRMLISTENTRY(drmBONode, l, head);
-
-      arg = &node->bo_arg;
-      rep = &arg->d.rep;
-      
-      if (!arg->handled)
-	  return -EFAULT;
-      if (rep->ret)
-	  return rep->ret;
-      drmBOCopyReply(rep, node->buf);
-  }
-
-  return 0;
-}
-
 int drmMMInit(int fd, unsigned long pOffset, unsigned long pSize,
 	      unsigned memType)
 {
-    drm_mm_init_arg_t arg;
-    
+    struct drm_mm_init_arg arg;
+
     memset(&arg, 0, sizeof(arg));
-    arg.req.op = mm_init;
-    arg.req.p_offset = pOffset;
-    arg.req.p_size = pSize;
-    arg.req.mem_type = memType;
+
+    arg.magic = DRM_BO_INIT_MAGIC;
+    arg.major = DRM_BO_INIT_MAJOR;
+    arg.minor = DRM_BO_INIT_MINOR;
+    arg.p_offset = pOffset;
+    arg.p_size = pSize;
+    arg.mem_type = memType;
 
     if (ioctl(fd, DRM_IOCTL_MM_INIT, &arg))
 	return -errno;
-    
     return 0;	
 }
 
 int drmMMTakedown(int fd, unsigned memType)
 {
-    drm_mm_init_arg_t arg;
-
+    struct drm_mm_type_arg arg;
 
     memset(&arg, 0, sizeof(arg));
-    arg.req.op = mm_takedown;
-    arg.req.mem_type = memType;
+    arg.mem_type = memType;
 
-    if (ioctl(fd, DRM_IOCTL_MM_INIT, &arg))
+    if (ioctl(fd, DRM_IOCTL_MM_TAKEDOWN, &arg))
 	return -errno;
-    
     return 0;	
 }
 
-int drmMMLock(int fd, unsigned memType)
+/*
+ * If this function returns an error, and lockBM was set to 1,
+ * the buffer manager is NOT locked.
+ */
+
+int drmMMLock(int fd, unsigned memType, int lockBM, int ignoreNoEvict)
 {
-    drm_mm_init_arg_t arg;
-    int ret;
+    struct drm_mm_type_arg arg;
 
     memset(&arg, 0, sizeof(arg));
-    arg.req.op = mm_lock;
-    arg.req.mem_type = memType;
+    arg.mem_type = memType;
+    arg.lock_flags |= (lockBM) ? DRM_BO_LOCK_UNLOCK_BM : 0;
+    arg.lock_flags |= (ignoreNoEvict) ? DRM_BO_LOCK_IGNORE_NO_EVICT : 0;
 
-    do{
-	ret = ioctl(fd, DRM_IOCTL_MM_INIT, &arg);
-    } while (ret && errno == EAGAIN);
+    return drmIoctlTimeout(fd, DRM_IOCTL_MM_LOCK, &arg);
+}
+
+int drmMMUnlock(int fd, unsigned memType, int unlockBM)
+{
+    struct drm_mm_type_arg arg;
+
+    memset(&arg, 0, sizeof(arg));
     
-    return ret;	
+    arg.mem_type = memType;
+    arg.lock_flags |= (unlockBM) ? DRM_BO_LOCK_UNLOCK_BM : 0;
+
+    return drmIoctlTimeout(fd, DRM_IOCTL_MM_UNLOCK, &arg);
 }
 
-int drmMMUnlock(int fd, unsigned memType)
+int drmBOVersion(int fd, unsigned int *major,
+		 unsigned int *minor,
+		 unsigned int *patchlevel)
 {
-    drm_mm_init_arg_t arg;
+    struct drm_bo_version_arg arg;
     int ret;
 
     memset(&arg, 0, sizeof(arg));
-    arg.req.op = mm_unlock;
-    arg.req.mem_type = memType;
+    ret = ioctl(fd, DRM_IOCTL_BO_VERSION, &arg);
+    if (ret)
+	return -errno;
 
-    do{
-	ret = ioctl(fd, DRM_IOCTL_MM_INIT, &arg);
-    } while (ret && errno == EAGAIN);
-    
-    return ret;	
+    if (major)
+	*major = arg.major;
+    if (minor)
+	*minor = arg.minor;
+    if (patchlevel)
+	*patchlevel = arg.patchlevel;
+
+    return 0;
 }
 
+
+
 #define DRM_MAX_FDS 16
 static struct {
-   char *BusID;
-   int fd;
-   int refcount;
+    char *BusID;
+    int fd;
+    int refcount;
 } connection[DRM_MAX_FDS];
 
 static int nr_fds = 0;
@@ -3229,50 +2913,50 @@
 		const char *BusID,
 		int *newlyopened)
 {
-   int i;
-   int fd;
+    int i;
+    int fd;
    
-   for (i = 0; i < nr_fds; i++)
-      if (strcmp(BusID, connection[i].BusID) == 0) {
-	 connection[i].refcount++;
-	 *newlyopened = 0;
-	 return connection[i].fd;
-      }
-
-   fd = drmOpen(unused, BusID);
-   if (fd <= 0 || nr_fds == DRM_MAX_FDS)
-      return fd;
+    for (i = 0; i < nr_fds; i++)
+	if (strcmp(BusID, connection[i].BusID) == 0) {
+	    connection[i].refcount++;
+	    *newlyopened = 0;
+	    return connection[i].fd;
+	}
+
+    fd = drmOpen(unused, BusID);
+    if (fd <= 0 || nr_fds == DRM_MAX_FDS)
+	return fd;
    
-   connection[nr_fds].BusID = strdup(BusID);
-   connection[nr_fds].fd = fd;
-   connection[nr_fds].refcount = 1;
-   *newlyopened = 1;
-
-   if (0)
-      fprintf(stderr, "saved connection %d for %s %d\n", 
-              nr_fds, connection[nr_fds].BusID, 
-              strcmp(BusID, connection[nr_fds].BusID));
+    connection[nr_fds].BusID = strdup(BusID);
+    connection[nr_fds].fd = fd;
+    connection[nr_fds].refcount = 1;
+    *newlyopened = 1;
+
+    if (0)
+	fprintf(stderr, "saved connection %d for %s %d\n", 
+		nr_fds, connection[nr_fds].BusID, 
+		strcmp(BusID, connection[nr_fds].BusID));
 
-   nr_fds++;
+    nr_fds++;
 
-   return fd;   
+    return fd;
 }
 
 void drmCloseOnce(int fd)
 {
-   int i;
+    int i;
 
-   for (i = 0; i < nr_fds; i++) {
-      if (fd == connection[i].fd) {
-	 if (--connection[i].refcount == 0) {
-	    drmClose(connection[i].fd);
-	    free(connection[i].BusID);
+    for (i = 0; i < nr_fds; i++) {
+	if (fd == connection[i].fd) {
+	    if (--connection[i].refcount == 0) {
+		drmClose(connection[i].fd);
+		free(connection[i].BusID);
 	    
-	    if (i < --nr_fds) 
-	       connection[i] = connection[nr_fds];
+		if (i < --nr_fds) 
+		    connection[i] = connection[nr_fds];
 
-	    return;
-	 }
-      }
-   }
+		return;
+	    }
+	}
+    }
 }
Index: git/libdrm/xf86drm.h
===================================================================
--- git.orig/libdrm/xf86drm.h	2008-12-12 17:20:14.000000000 +0000
+++ git/libdrm/xf86drm.h	2008-12-12 17:35:22.000000000 +0000
@@ -31,13 +31,12 @@
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/xf86drm.h,v 1.26 2003/08/16 19:26:37 dawes Exp $ */
-
 #ifndef _XF86DRM_H_
 #define _XF86DRM_H_
 
 #include <stdarg.h>
 #include <sys/types.h>
+#include <stdint.h>
 #include <drm.h>
 
 				/* Defaults, if nothing set in xf86config */
@@ -270,6 +269,7 @@
 typedef enum {
     DRM_VBLANK_ABSOLUTE = 0x0,	/**< Wait for specific vblank sequence number */
     DRM_VBLANK_RELATIVE = 0x1,	/**< Wait for given number of vblanks */
+    DRM_VBLANK_FLIP = 0x8000000,	/**< Scheduled buffer swap should flip */
     DRM_VBLANK_NEXTONMISS = 0x10000000,	/**< If missed, wait for next vblank */
     DRM_VBLANK_SECONDARY = 0x20000000,	/**< Secondary display controller */
     DRM_VBLANK_SIGNAL   = 0x40000000	/* Send signal instead of blocking */
Index: git/libdrm/xf86drmHash.c
===================================================================
--- git.orig/libdrm/xf86drmHash.c	2008-12-12 17:20:14.000000000 +0000
+++ git/libdrm/xf86drmHash.c	2008-12-12 17:35:22.000000000 +0000
@@ -25,8 +25,6 @@
  *
  * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
  *
- * $XFree86: xc/programs/Xserver/hw/xfree86/os-support/linux/drm/xf86drmHash.c,v 1.4 2001/03/21 18:08:54 dawes Exp $
- *
  * DESCRIPTION
  *
  * This file contains a straightforward implementation of a fixed-sized
@@ -70,25 +68,13 @@
  *
  */
 
-#ifdef HAVE_XORG_CONFIG_H
-#include <xorg-config.h>
-#endif
+#include <stdio.h>
+#include <stdlib.h>
 
 #define HASH_MAIN 0
 
-#if HASH_MAIN
-# include <stdio.h>
-# include <stdlib.h>
-#else
-# include "drm.h"
+#if !HASH_MAIN
 # include "xf86drm.h"
-# ifdef XFree86LOADER
-#  include "xf86.h"
-#  include "xf86_ansic.h"
-# else
-#  include <stdio.h>
-#  include <stdlib.h>
-# endif
 #endif
 
 #define HASH_MAGIC 0xdeadbeef
Index: git/libdrm/xf86drmMode.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/libdrm/xf86drmMode.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,465 @@
+/*
+ * \file xf86drmMode.c
+ * Header for DRM modesetting interface.
+ *
+ * \author Jakob Bornecrantz <wallbraker@gmail.com>
+ *
+ * \par Acknowledgements:
+ * Feb 2007, Dave Airlie <airlied@linux.ie>
+ */
+
+/*
+ * Copyright (c) <year> <copyright holders>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+/*
+ * TODO the types we are after are defined in diffrent headers on diffrent
+ * platforms find which headers to include to get uint32_t
+ */
+#include <stdint.h>
+
+#include "xf86drmMode.h"
+#include "xf86drm.h"
+#include <drm.h>
+#include <string.h>
+
+/*
+ * Util functions
+ */
+
+void* drmAllocCpy(void *array, int count, int entry_size)
+{
+	char *r;
+	int i;
+
+	if (!count || !array || !entry_size)
+		return 0;
+
+	if (!(r = drmMalloc(count*entry_size)))
+		return 0;
+
+	for (i = 0; i < count; i++)
+		memcpy(r+(entry_size*i), array+(entry_size*i), entry_size);
+
+	return r;
+}
+
+/**
+ * Generate crtc and output ids.
+ *
+ * Will generate ids starting from 1 up to count if count is greater then 0.
+ */
+static uint32_t* drmAllocGenerate(int count)
+{
+	uint32_t *r;
+	int i;
+
+	if(0 <= count)
+		return 0;
+
+	if (!(r = drmMalloc(count*sizeof(*r))))
+		return 0;
+
+	for (i = 0; i < count; r[i] = ++i);
+
+	return 0;
+}
+
+/*
+ * A couple of free functions.
+ */
+
+void drmModeFreeModeInfo(struct drm_mode_modeinfo *ptr)
+{
+	if (!ptr)
+		return;
+
+	drmFree(ptr);
+}
+
+void drmModeFreeResources(drmModeResPtr ptr)
+{
+	if (!ptr)
+		return;
+
+	drmFree(ptr->modes);
+	drmFree(ptr);
+
+}
+
+void drmModeFreeFB(drmModeFBPtr ptr)
+{
+	if (!ptr)
+		return;
+
+	/* we might add more frees later. */
+	drmFree(ptr);
+}
+
+void drmModeFreeCrtc(drmModeCrtcPtr ptr)
+{
+	if (!ptr)
+		return;
+
+	drmFree(ptr);
+
+}
+
+void drmModeFreeOutput(drmModeOutputPtr ptr)
+{
+	if (!ptr)
+		return;
+
+	drmFree(ptr->modes);
+	drmFree(ptr);
+
+}
+
+/*
+ * ModeSetting functions.
+ */
+
+drmModeResPtr drmModeGetResources(int fd)
+{
+	struct drm_mode_card_res res;
+	int i;
+	drmModeResPtr r = 0;
+
+	memset(&res, 0, sizeof(struct drm_mode_card_res));
+
+	if (ioctl(fd, DRM_IOCTL_MODE_GETRESOURCES, &res))
+		return 0;
+
+	if (res.count_fbs)
+		res.fb_id = drmMalloc(res.count_fbs*sizeof(uint32_t));
+	if (res.count_crtcs)
+		res.crtc_id = drmMalloc(res.count_crtcs*sizeof(uint32_t));
+	if (res.count_outputs)
+		res.output_id = drmMalloc(res.count_outputs*sizeof(uint32_t));
+	if (res.count_modes)
+		res.modes = drmMalloc(res.count_modes*sizeof(*res.modes));
+
+	if (ioctl(fd, DRM_IOCTL_MODE_GETRESOURCES, &res)) {
+		r = NULL;
+		goto err_allocs;
+	}
+
+	/*
+	 * return
+	 */
+
+
+	if (!(r = drmMalloc(sizeof(*r))))
+		return 0;
+
+	r->count_fbs     = res.count_fbs;
+	r->count_crtcs   = res.count_crtcs;
+	r->count_outputs = res.count_outputs;
+	r->count_modes   = res.count_modes;
+	/* TODO we realy should test if these allocs fails. */
+	r->fbs           = drmAllocCpy(res.fb_id, res.count_fbs, sizeof(uint32_t));
+	r->crtcs         = drmAllocCpy(res.crtc_id, res.count_crtcs, sizeof(uint32_t));
+	r->outputs       = drmAllocCpy(res.output_id, res.count_outputs, sizeof(uint32_t));
+	r->modes         = drmAllocCpy(res.modes, res.count_modes, sizeof(struct drm_mode_modeinfo));
+
+err_allocs:
+	drmFree(res.fb_id);
+	drmFree(res.crtc_id);
+	drmFree(res.output_id);
+	drmFree(res.modes);
+
+	return r;
+}
+
+int drmModeAddFB(int fd, uint32_t width, uint32_t height, uint8_t depth,
+                 uint8_t bpp, uint32_t pitch, drmBO *bo, uint32_t *buf_id)
+{
+	struct drm_mode_fb_cmd f;
+	int ret;
+
+	f.width  = width;
+	f.height = height;
+	f.pitch  = pitch;
+	f.bpp    = bpp;
+	f.depth  = depth;
+	f.handle = bo->handle;
+
+	if (ret = ioctl(fd, DRM_IOCTL_MODE_ADDFB, &f))
+		return ret;
+
+	*buf_id = f.buffer_id;
+	return 0;
+}
+
+int drmModeRmFB(int fd, uint32_t bufferId)
+{
+	return ioctl(fd, DRM_IOCTL_MODE_RMFB, &bufferId);
+}
+
+drmModeFBPtr drmModeGetFB(int fd, uint32_t buf)
+{
+	struct drm_mode_fb_cmd info;
+	drmModeFBPtr r;
+
+	info.buffer_id = buf;
+
+	if (ioctl(fd, DRM_IOCTL_MODE_GETFB, &info))
+		return NULL;
+
+	if (!(r = drmMalloc(sizeof(*r))))
+		return NULL;
+
+	r->buffer_id = info.buffer_id;
+	r->width = info.width;
+	r->height = info.height;
+	r->pitch = info.pitch;
+	r->bpp = info.bpp;
+	r->handle = info.handle;
+	r->depth = info.depth;
+
+	return r;
+}
+
+
+/*
+ * Crtc functions
+ */
+
+drmModeCrtcPtr drmModeGetCrtc(int fd, uint32_t crtcId)
+{
+	struct drm_mode_crtc crtc;
+	drmModeCrtcPtr r;
+	int i = 0;
+
+	crtc.count_outputs   = 0;
+	crtc.outputs         = 0;
+	crtc.count_possibles = 0;
+	crtc.possibles       = 0;
+	crtc.crtc_id = crtcId;
+
+	if (ioctl(fd, DRM_IOCTL_MODE_GETCRTC, &crtc))
+		return 0;
+
+	/*
+	 * return
+	 */
+
+	if (!(r = drmMalloc(sizeof(*r))))
+		return 0;
+	
+	r->crtc_id         = crtc.crtc_id;
+	r->x               = crtc.x;
+	r->y               = crtc.y;
+	r->mode            = crtc.mode;
+	r->buffer_id       = crtc.fb_id;
+	r->gamma_size      = crtc.gamma_size;
+	r->count_outputs   = crtc.count_outputs;
+	r->count_possibles = crtc.count_possibles;
+	/* TODO we realy should test if these alloc & cpy fails. */
+	r->outputs         = crtc.outputs;
+	r->possibles       = crtc.possibles;
+
+	return r;
+
+err_allocs:
+
+	return 0;
+}
+
+
+int drmModeSetCrtc(int fd, uint32_t crtcId, uint32_t bufferId,
+                   uint32_t x, uint32_t y, uint32_t modeId,
+                   uint32_t *outputs, int count)
+{
+	struct drm_mode_crtc crtc;
+
+	crtc.count_outputs   = 0;
+	crtc.outputs         = 0;
+	crtc.count_possibles = 0;
+	crtc.possibles       = 0;
+
+	crtc.x             = x;
+	crtc.y             = y;
+	crtc.crtc_id       = crtcId;
+	crtc.fb_id         = bufferId;
+	crtc.set_outputs   = outputs;
+	crtc.count_outputs = count;
+	crtc.mode          = modeId;
+
+	return ioctl(fd, DRM_IOCTL_MODE_SETCRTC, &crtc);
+}
+
+
+/*
+ * Output manipulation
+ */
+
+drmModeOutputPtr drmModeGetOutput(int fd, uint32_t output_id)
+{
+	struct drm_mode_get_output out;
+	drmModeOutputPtr r = NULL;
+
+	out.output = output_id;
+	out.count_crtcs  = 0;
+	out.crtcs        = 0;
+	out.count_clones = 0;
+	out.clones       = 0;
+	out.count_modes  = 0;
+	out.modes        = 0;
+	out.count_props  = 0;
+	out.props = NULL;
+	out.prop_values = NULL;
+
+	if (ioctl(fd, DRM_IOCTL_MODE_GETOUTPUT, &out))
+		return 0;
+
+	if (out.count_props) {
+		out.props = drmMalloc(out.count_props*sizeof(uint32_t));
+		out.prop_values = drmMalloc(out.count_props*sizeof(uint32_t));
+	}
+
+	if (out.count_modes)
+		out.modes = drmMalloc(out.count_modes*sizeof(uint32_t));
+
+	if (ioctl(fd, DRM_IOCTL_MODE_GETOUTPUT, &out))
+		goto err_allocs;
+
+	if(!(r = drmMalloc(sizeof(*r)))) {
+		goto err_allocs;
+	}
+
+	r->output_id = out.output;
+	r->crtc = out.crtc;
+	r->connection   = out.connection;
+	r->mmWidth      = out.mm_width;
+	r->mmHeight     = out.mm_height;
+	r->subpixel     = out.subpixel;
+	r->count_crtcs  = out.count_crtcs;
+	r->count_clones = out.count_clones;
+	r->count_modes  = out.count_modes;
+	/* TODO we should test if these alloc & cpy fails. */
+	r->crtcs        = out.crtcs;
+	r->clones       = out.clones;
+	r->count_props  = out.count_props;
+	r->props        = drmAllocCpy(out.props, out.count_props, sizeof(uint32_t));
+	r->prop_values  = drmAllocCpy(out.prop_values, out.count_props, sizeof(uint32_t));
+	r->modes        = drmAllocCpy(out.modes, out.count_modes, sizeof(uint32_t));
+	strncpy(r->name, out.name, DRM_OUTPUT_NAME_LEN);
+	r->name[DRM_OUTPUT_NAME_LEN-1] = 0;
+
+err_allocs:
+	drmFree(out.prop_values);
+	drmFree(out.props);
+	drmFree(out.modes);
+
+	return r;
+}
+
+uint32_t drmModeAddMode(int fd, struct drm_mode_modeinfo *mode_info)
+{
+	if (ioctl(fd, DRM_IOCTL_MODE_ADDMODE, mode_info))
+		return 0;
+	
+	return mode_info->id;
+}
+
+int drmModeRmMode(int fd, uint32_t mode_id)
+{
+  	return ioctl(fd, DRM_IOCTL_MODE_RMMODE, &mode_id);
+}
+
+int drmModeAttachMode(int fd, uint32_t output_id, uint32_t mode_id)
+{
+
+	struct drm_mode_mode_cmd res;
+
+	res.output_id = output_id;
+	res.mode_id = mode_id;
+
+	return ioctl(fd, DRM_IOCTL_MODE_ATTACHMODE, &res);
+}
+
+int drmModeDetachMode(int fd, uint32_t output_id, uint32_t mode_id)
+{
+	struct drm_mode_mode_cmd res;
+
+	res.output_id = output_id;
+	res.mode_id = mode_id;
+
+	return ioctl(fd, DRM_IOCTL_MODE_DETACHMODE, &res);
+}
+
+
+drmModePropertyPtr drmModeGetProperty(int fd, uint32_t property_id)
+{
+	struct drm_mode_get_property prop;
+	drmModePropertyPtr r;
+
+	prop.prop_id = property_id;
+	prop.count_enums = 0;
+	prop.count_values = 0;
+	prop.flags = 0;
+	prop.enums = NULL;
+	prop.values = NULL;
+
+	if (ioctl(fd, DRM_IOCTL_MODE_GETPROPERTY, &prop))
+		return 0;
+
+	if (prop.count_values)
+		prop.values = drmMalloc(prop.count_values * sizeof(uint32_t));
+
+	if (prop.count_enums)
+		prop.enums = drmMalloc(prop.count_enums * sizeof(struct drm_mode_property_enum));
+
+	if (ioctl(fd, DRM_IOCTL_MODE_GETPROPERTY, &prop)) {
+		r = NULL;
+		goto err_allocs;
+	}
+
+	if (!(r = drmMalloc(sizeof(*r))))
+		return NULL;
+	
+	r->prop_id = prop.prop_id;
+	r->count_values = prop.count_values;
+	r->count_enums = prop.count_enums;
+
+	r->values = drmAllocCpy(prop.values, prop.count_values, sizeof(uint32_t));
+	r->enums = drmAllocCpy(prop.enums, prop.count_enums, sizeof(struct drm_mode_property_enum));
+	strncpy(r->name, prop.name, DRM_PROP_NAME_LEN);
+	r->name[DRM_PROP_NAME_LEN-1] = 0;
+
+err_allocs:
+	drmFree(prop.values);
+	drmFree(prop.enums);
+
+	return r;
+}
+
+void drmModeFreeProperty(drmModePropertyPtr ptr)
+{
+	if (!ptr)
+		return;
+
+	drmFree(ptr->values);
+	drmFree(ptr->enums);
+	drmFree(ptr);
+}
Index: git/libdrm/xf86drmMode.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/libdrm/xf86drmMode.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,226 @@
+/*
+ * \file xf86drmMode.h
+ * Header for DRM modesetting interface.
+ *
+ * \author Jakob Bornecrantz <wallbraker@gmail.com>
+ *
+ * \par Acknowledgements:
+ * Feb 2007, Dave Airlie <airlied@linux.ie>
+ */
+
+/*
+ * Copyright (c) <year> <copyright holders>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#include <drm.h>
+#include "xf86mm.h"
+
+/*
+ * This is the interface for modesetting for drm.
+ *
+ * In order to use this interface you must include either <stdint.h> or another
+ * header defining uint32_t, int32_t and uint16_t.
+ *
+ * It aims to provide a randr1.2 compatible interface for modesettings in the
+ * kernel, the interface is also ment to be used by libraries like EGL.
+ *
+ * More information can be found in randrproto.txt which can be found here:
+ * http://gitweb.freedesktop.org/?p=xorg/proto/randrproto.git
+ *
+ * There are some major diffrences to be noted. Unlike the randr1.2 proto you
+ * need to create the memory object of the framebuffer yourself with the ttm
+ * buffer object interface. This object needs to be pinned.
+ */
+
+
+typedef struct _drmModeRes {
+
+	int count_fbs;
+	uint32_t *fbs;
+
+	int count_crtcs;
+	uint32_t *crtcs;
+
+	int count_outputs;
+	uint32_t *outputs;
+
+	int count_modes;
+	struct drm_mode_modeinfo *modes;
+
+} drmModeRes, *drmModeResPtr;
+
+typedef struct drm_mode_fb_cmd drmModeFB, *drmModeFBPtr;
+
+typedef struct _drmModeProperty {
+	unsigned int prop_id;
+	unsigned int flags;
+	unsigned char name[DRM_PROP_NAME_LEN];
+	int count_values;
+	uint32_t *values;
+	int count_enums;
+	struct drm_mode_property_enum *enums;
+
+} drmModePropertyRes, *drmModePropertyPtr;
+
+typedef struct _drmModeCrtc {
+	unsigned int crtc_id;
+	unsigned int buffer_id; /**< FB id to connect to 0 = disconnect*/
+
+	uint32_t x, y; /**< Position on the frameuffer */
+	uint32_t width, height;
+	uint32_t mode; /**< Current mode used */
+
+	int count_outputs;
+	uint32_t outputs; /**< Outputs that are connected */
+
+	int count_possibles;
+	uint32_t possibles; /**< Outputs that can be connected */
+
+	int gamma_size; /**< Number of gamma stops */
+
+} drmModeCrtc, *drmModeCrtcPtr;
+
+typedef enum {
+	DRM_MODE_CONNECTED         = 1,
+	DRM_MODE_DISCONNECTED      = 2,
+	DRM_MODE_UNKNOWNCONNECTION = 3
+} drmModeConnection;
+
+typedef enum {
+	DRM_MODE_SUBPIXEL_UNKNOWN        = 1,
+	DRM_MODE_SUBPIXEL_HORIZONTAL_RGB = 2,
+	DRM_MODE_SUBPIXEL_HORIZONTAL_BGR = 3,
+	DRM_MODE_SUBPIXEL_VERTICAL_RGB   = 4,
+	DRM_MODE_SUBPIXEL_VERTICAL_BGR   = 5,
+	DRM_MODE_SUBPIXEL_NONE           = 6
+} drmModeSubPixel;
+
+typedef struct _drmModeOutput {
+	unsigned int output_id;
+
+	unsigned int crtc; /**< Crtc currently connected to */
+	unsigned char name[DRM_OUTPUT_NAME_LEN];
+	drmModeConnection connection;
+	uint32_t mmWidth, mmHeight; /**< HxW in millimeters */
+	drmModeSubPixel subpixel;
+
+	int count_crtcs;
+	uint32_t crtcs; /**< Possible crtc to connect to */
+
+	int count_clones;
+	uint32_t clones; /**< Mask of clones */
+
+	int count_modes;
+	uint32_t *modes; /**< List of modes ids */
+
+	int count_props;
+	uint32_t *props; /**< List of property ids */
+	uint32_t *prop_values; /**< List of property values */
+
+} drmModeOutput, *drmModeOutputPtr;
+
+
+
+extern void drmModeFreeModeInfo( struct drm_mode_modeinfo *ptr );
+extern void drmModeFreeResources( drmModeResPtr ptr );
+extern void drmModeFreeFB( drmModeFBPtr ptr );
+extern void drmModeFreeCrtc( drmModeCrtcPtr ptr );
+extern void drmModeFreeOutput( drmModeOutputPtr ptr );
+
+/**
+ * Retrives all of the resources associated with a card.
+ */
+extern drmModeResPtr drmModeGetResources(int fd);
+
+
+/*
+ * FrameBuffer manipulation.
+ */
+
+/**
+ * Retrive information about framebuffer bufferId
+ */
+extern drmModeFBPtr drmModeGetFB(int fd, uint32_t bufferId);
+
+/**
+ * Creates a new framebuffer with an buffer object as its scanout buffer.
+ */
+extern int drmModeAddFB(int fd, uint32_t width, uint32_t height, uint8_t depth,
+			uint8_t bpp, uint32_t pitch, drmBO *bo,
+			uint32_t *buf_id);
+/**
+ * Destroies the given framebuffer.
+ */
+extern int drmModeRmFB(int fd, uint32_t bufferId);
+
+
+/*
+ * Crtc functions
+ */
+
+/**
+ * Retrive information about the ctrt crtcId
+ */
+extern drmModeCrtcPtr drmModeGetCrtc(int fd, uint32_t crtcId);
+
+/**
+ * Set the mode on a crtc crtcId with the given mode modeId.
+ */
+extern int drmModeSetCrtc(int fd, uint32_t crtcId, uint32_t bufferId,
+		uint32_t x, uint32_t y, uint32_t modeId,
+		uint32_t *outputs, int count);
+
+
+/*
+ * Output manipulation
+ */
+
+/**
+ * Retrive information about the output outputId.
+ */
+extern drmModeOutputPtr drmModeGetOutput(int fd,
+		uint32_t outputId);
+
+/**
+ * Adds a new mode from the given mode info.
+ * Name must be unique.
+ */
+extern uint32_t drmModeAddMode(int fd, struct drm_mode_modeinfo *modeInfo);
+
+/**
+ * Removes a mode created with AddMode, must be unused.
+ */
+extern int drmModeRmMode(int fd, uint32_t modeId);
+
+/**
+ * Attaches the given mode to an output.
+ */
+extern int drmModeAttachMode(int fd, uint32_t outputId, uint32_t modeId);
+
+/**
+ * Detaches a mode from the output
+ * must be unused, by the given mode.
+ */
+extern int drmModeDetachMode(int fd, uint32_t outputId, uint32_t modeId);
+
+extern drmModePropertyPtr drmModeGetProperty(int fd, uint32_t propertyId);
+extern void drmModeFreeProperty(drmModePropertyPtr ptr);
Index: git/libdrm/xf86drmRandom.c
===================================================================
--- git.orig/libdrm/xf86drmRandom.c	2008-12-12 17:20:14.000000000 +0000
+++ git/libdrm/xf86drmRandom.c	2008-12-12 17:35:22.000000000 +0000
@@ -25,8 +25,6 @@
  * 
  * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
  *
- * $XFree86: xc/programs/Xserver/hw/xfree86/os-support/linux/drm/xf86drmRandom.c,v 1.4 2000/06/17 00:03:34 martin Exp $
- *
  * DESCRIPTION
  *
  * This file contains a simple, straightforward implementation of the Park
@@ -73,25 +71,13 @@
  *
  */
 
-#ifdef HAVE_XORG_CONFIG_H
-#include <xorg-config.h>
-#endif
+#include <stdio.h>
+#include <stdlib.h>
 
 #define RANDOM_MAIN 0
 
-#if RANDOM_MAIN
-# include <stdio.h>
-# include <stdlib.h>
-#else
-# include "drm.h"
+#if !RANDOM_MAIN
 # include "xf86drm.h"
-# ifdef XFree86LOADER
-#  include "xf86.h"
-#  include "xf86_ansic.h"
-# else
-#  include <stdio.h>
-#  include <stdlib.h>
-# endif
 #endif
 
 #define RANDOM_MAGIC 0xfeedbeef
Index: git/libdrm/xf86drmSL.c
===================================================================
--- git.orig/libdrm/xf86drmSL.c	2008-12-12 17:20:14.000000000 +0000
+++ git/libdrm/xf86drmSL.c	2008-12-12 17:35:22.000000000 +0000
@@ -25,8 +25,6 @@
  * 
  * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
  *
- * $XFree86: xc/programs/Xserver/hw/xfree86/os-support/linux/drm/xf86drmSL.c,v 1.3 2000/06/17 00:03:34 martin Exp $
- *
  * DESCRIPTION
  *
  * This file contains a straightforward skip list implementation.n
@@ -40,26 +38,15 @@
  *
  */
 
-#ifdef HAVE_XORG_CONFIG_H
-#include <xorg-config.h>
-#endif
+#include <stdio.h>
+#include <stdlib.h>
 
 #define SL_MAIN 0
 
-#if SL_MAIN
-# include <stdio.h>
-# include <stdlib.h>
-#  include <sys/time.h>
-#else
-# include "drm.h"
+#if !SL_MAIN
 # include "xf86drm.h"
-# ifdef XFree86LOADER
-#  include "xf86.h"
-#  include "xf86_ansic.h"
-# else
-#  include <stdio.h>
-#  include <stdlib.h>
-# endif
+#else
+# include <sys/time.h>
 #endif
 
 #define SL_LIST_MAGIC  0xfacade00LU
Index: git/libdrm/xf86mm.h
===================================================================
--- git.orig/libdrm/xf86mm.h	2008-12-12 17:20:14.000000000 +0000
+++ git/libdrm/xf86mm.h	2008-12-12 17:35:22.000000000 +0000
@@ -29,6 +29,7 @@
 #ifndef _XF86MM_H_
 #define _XF86MM_H_
 #include <stddef.h>
+#include <stdint.h>
 #include "drm.h"
 
 /*
@@ -37,7 +38,7 @@
  * be protected using an external mutex.
  *
  * Note: Don't protect the following functions, as it may lead to deadlocks:
- * drmBOUnmap(), drmFenceBuffers().
+ * drmBOUnmap().
  * The kernel is synchronizing and refcounting buffer maps. 
  * User space only needs to refcount object usage within the same application.
  */
@@ -60,7 +61,7 @@
     (__item)->next = (__item);		       \
   } while (0)
 
-#define DRMLISTADD(__item, __list)			\
+#define DRMLISTADD(__item, __list)		\
   do {						\
     (__item)->prev = (__list);			\
     (__item)->next = (__list)->next;		\
@@ -93,21 +94,23 @@
 #define DRMLISTENTRY(__type, __item, __field)   \
     ((__type *)(((char *) (__item)) - offsetof(__type, __field)))
 
-typedef struct _drmFence{
-        unsigned handle;
-        int class;
-        unsigned type; 
-        unsigned flags;
-        unsigned signaled;
-        unsigned pad[4]; /* for future expansion */
+typedef struct _drmFence
+{
+    unsigned handle;
+    int fence_class;
+    unsigned type; 
+    unsigned flags;
+    unsigned signaled;
+    uint32_t sequence;
+    unsigned pad[4]; /* for future expansion */
 } drmFence;
 
-typedef struct _drmBO{
-    drm_bo_type_t type;
+typedef struct _drmBO
+{
     unsigned handle;
-    drm_u64_t mapHandle;
-    unsigned flags;
-    unsigned mask;
+    uint64_t mapHandle;
+    uint64_t flags;
+    uint64_t mask;
     unsigned mapFlags;
     unsigned long size;
     unsigned long offset;
@@ -115,84 +118,49 @@
     unsigned replyFlags;
     unsigned fenceFlags;
     unsigned pageAlignment;
+    unsigned tileInfo;
+    unsigned hwTileStride;
+    unsigned desiredTileStride;
     void *virtual;
     void *mapVirtual;
     int mapCount;
     unsigned pad[8];     /* for future expansion */
 } drmBO;
 
-
-typedef struct _drmBONode {
-    drmMMListHead head;
-    drmBO *buf;
-    drm_bo_arg_t bo_arg;
-    unsigned long arg0;
-    unsigned long arg1;
-} drmBONode;
-
-typedef struct _drmBOList {
-    unsigned numTarget;
-    unsigned numCurrent;
-    unsigned numOnList;
-    drmMMListHead list;
-    drmMMListHead free;
-} drmBOList;
-
-/* Fencing */
-
-extern int           drmFenceCreate(int fd, unsigned flags, int class,
-				    unsigned type, 
-				    drmFence *fence);
-extern int           drmFenceDestroy(int fd, const drmFence *fence);
-extern int           drmFenceReference(int fd, unsigned handle, drmFence *fence);
-extern int           drmFenceUnreference(int fd, const drmFence *fence);
-extern int           drmFenceFlush(int fd, drmFence *fence, unsigned flush_type);
-extern int           drmFenceSignaled(int fd, drmFence *fence, 
-				      unsigned fenceType, int *signaled);
-extern int           drmFenceWait(int fd, unsigned flags, drmFence *fence, 
-				  unsigned flush_type);
-extern int           drmFenceEmit(int fd, unsigned flags, drmFence *fence, 
-				  unsigned emit_type);
-extern int           drmFenceBuffers(int fd, unsigned flags, drmFence *fence);
-
-
 /*
- * Buffer object list functions.
+ * Fence functions.
  */
 
-extern void drmBOFreeList(drmBOList *list);
-extern int drmBOResetList(drmBOList *list);
-extern void *drmBOListIterator(drmBOList *list);
-extern void *drmBOListNext(drmBOList *list, void *iterator);
-extern drmBO *drmBOListBuf(void *iterator);
-extern int drmBOCreateList(int numTarget, drmBOList *list);
+extern int drmFenceCreate(int fd, unsigned flags, int fence_class,
+                          unsigned type, drmFence *fence);
+extern int drmFenceReference(int fd, unsigned handle, drmFence *fence);
+extern int drmFenceUnreference(int fd, const drmFence *fence);
+extern int drmFenceFlush(int fd, drmFence *fence, unsigned flush_type);
+extern int drmFenceSignaled(int fd, drmFence *fence, 
+                            unsigned fenceType, int *signaled);
+extern int drmFenceWait(int fd, unsigned flags, drmFence *fence, 
+                        unsigned flush_type);
+extern int drmFenceEmit(int fd, unsigned flags, drmFence *fence, 
+                        unsigned emit_type);
+extern int drmFenceBuffers(int fd, unsigned flags, uint32_t fence_class, drmFence *fence);
+
 
 /*
  * Buffer object functions.
  */
 
-extern int drmBOCreate(int fd, unsigned long start, unsigned long size,
-		       unsigned pageAlignment,void *user_buffer, 
-		       drm_bo_type_t type, unsigned mask,
-		       unsigned hint, drmBO *buf);
-extern int drmBODestroy(int fd, drmBO *buf);
+extern int drmBOCreate(int fd, unsigned long size,
+		       unsigned pageAlignment, void *user_buffer,
+		       uint64_t mask, unsigned hint, drmBO *buf);
 extern int drmBOReference(int fd, unsigned handle, drmBO *buf);
-extern int drmBOUnReference(int fd, drmBO *buf);
+extern int drmBOUnreference(int fd, drmBO *buf);
 extern int drmBOMap(int fd, drmBO *buf, unsigned mapFlags, unsigned mapHint,
 		    void **address);
 extern int drmBOUnmap(int fd, drmBO *buf);
-extern int drmBOValidate(int fd, drmBO *buf, unsigned flags, unsigned mask, 
-			 unsigned hint);
 extern int drmBOFence(int fd, drmBO *buf, unsigned flags, unsigned fenceHandle);
 extern int drmBOInfo(int fd, drmBO *buf);
 extern int drmBOBusy(int fd, drmBO *buf, int *busy);
 
-
-extern int drmAddValidateItem(drmBOList *list, drmBO *buf, unsigned flags, 
-		       unsigned mask,
-		       int *newItem);
-extern int drmBOValidateList(int fd, drmBOList *list);
-extern int drmBOFenceList(int fd, drmBOList *list, unsigned fenceHandle);
 extern int drmBOWaitIdle(int fd, drmBO *buf, unsigned hint);
 
 /*
@@ -202,8 +170,16 @@
 extern int drmMMInit(int fd, unsigned long pOffset, unsigned long pSize,
 		     unsigned memType);
 extern int drmMMTakedown(int fd, unsigned memType);
-extern int drmMMLock(int fd, unsigned memType);
-extern int drmMMUnlock(int fd, unsigned memType);
+extern int drmMMLock(int fd, unsigned memType, int lockBM, int ignoreNoEvict);
+extern int drmMMUnlock(int fd, unsigned memType, int unlockBM);
+extern int drmBOSetStatus(int fd, drmBO *buf, 
+			  uint64_t flags, uint64_t mask,
+			  unsigned int hint, 
+			  unsigned int desired_tile_stride,
+			  unsigned int tile_info);
+extern int drmBOVersion(int fd, unsigned int *major,
+			unsigned int *minor,
+			unsigned int *patchlevel);
 
 
 #endif
Index: git/shared-core/Makefile.am
===================================================================
--- git.orig/shared-core/Makefile.am	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/Makefile.am	2008-12-12 17:36:30.000000000 +0000
@@ -29,10 +29,14 @@
                          i915_drm.h \
                          mach64_drm.h \
                          mga_drm.h \
+                         nouveau_drm.h \
+                         psb_drm.h \
+                         psb_reg.h \
                          r128_drm.h \
                          radeon_drm.h \
                          savage_drm.h \
                          sis_drm.h \
                          via_drm.h \
+			 psb_reg.h \
                          r300_reg.h \
                          via_3d_reg.h
Index: git/shared-core/Makefile.in
===================================================================
--- git.orig/shared-core/Makefile.in	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/Makefile.in	2008-12-12 17:35:31.000000000 +0000
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005  Free Software Foundation, Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -38,15 +38,11 @@
 # however, r300 and via need their reg headers installed in order to build.
 # better solutions are welcome.
 
-srcdir = @srcdir@
-top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
-top_builddir = ..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -85,8 +81,6 @@
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
-AMDEP_FALSE = @AMDEP_FALSE@
-AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AR = @AR@
 AUTOCONF = @AUTOCONF@
@@ -98,33 +92,39 @@
 CFLAGS = @CFLAGS@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
 DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-ECHO = @ECHO@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-F77 = @F77@
-FFLAGS = @FFLAGS@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
 LDFLAGS = @LDFLAGS@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
@@ -133,20 +133,17 @@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
-ac_ct_AR = @ac_ct_AR@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_F77 = @ac_ct_F77@
-ac_ct_RANLIB = @ac_ct_RANLIB@
-ac_ct_STRIP = @ac_ct_STRIP@
-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
-am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
-am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -158,29 +155,41 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
+builddir = @builddir@
 datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
+htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+localedir = @localedir@
 localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
 pkgconfigdir = @pkgconfigdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
+psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
 klibdrmincludedir = ${includedir}/drm
 klibdrminclude_HEADERS = \
                          drm.h \
@@ -188,13 +197,18 @@
                          i915_drm.h \
                          mach64_drm.h \
                          mga_drm.h \
+                         nouveau_drm.h \
+                         psb_drm.h \
+                         psb_reg.h \
                          r128_drm.h \
                          radeon_drm.h \
                          savage_drm.h \
                          sis_drm.h \
                          via_drm.h \
+			 psb_reg.h \
                          r300_reg.h \
-                         via_3d_reg.h
+                         via_3d_reg.h \
+			 xgi_drm.h
 
 all: all-am
 
@@ -234,13 +248,9 @@
 
 clean-libtool:
 	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool
-uninstall-info-am:
 install-klibdrmincludeHEADERS: $(klibdrminclude_HEADERS)
 	@$(NORMAL_INSTALL)
-	test -z "$(klibdrmincludedir)" || $(mkdir_p) "$(DESTDIR)$(klibdrmincludedir)"
+	test -z "$(klibdrmincludedir)" || $(MKDIR_P) "$(DESTDIR)$(klibdrmincludedir)"
 	@list='$(klibdrminclude_HEADERS)'; for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  f=$(am__strip_dir) \
@@ -261,8 +271,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -274,8 +284,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -285,13 +295,12 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
-	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -305,22 +314,21 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
-	list='$(DISTFILES)'; for file in $$list; do \
-	  case $$file in \
-	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
-	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
-	  esac; \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
-	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
-	    dir="/$$dir"; \
-	    $(mkdir_p) "$(distdir)$$dir"; \
-	  else \
-	    dir=''; \
-	  fi; \
 	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -336,7 +344,7 @@
 all-am: Makefile $(HEADERS)
 installdirs:
 	for dir in "$(DESTDIR)$(klibdrmincludedir)"; do \
-	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
 	done
 install: install-am
 install-exec: install-exec-am
@@ -368,8 +376,7 @@
 
 distclean: distclean-am
 	-rm -f Makefile
-distclean-am: clean-am distclean-generic distclean-libtool \
-	distclean-tags
+distclean-am: clean-am distclean-generic distclean-tags
 
 dvi: dvi-am
 
@@ -383,12 +390,20 @@
 
 install-data-am: install-klibdrmincludeHEADERS
 
+install-dvi: install-dvi-am
+
 install-exec-am:
 
+install-html: install-html-am
+
 install-info: install-info-am
 
 install-man:
 
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -407,19 +422,22 @@
 
 ps-am:
 
-uninstall-am: uninstall-info-am uninstall-klibdrmincludeHEADERS
+uninstall-am: uninstall-klibdrmincludeHEADERS
+
+.MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-libtool ctags distclean distclean-generic \
 	distclean-libtool distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
 	install-info-am install-klibdrmincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
 	install-strip installcheck installcheck-am installdirs \
 	maintainer-clean maintainer-clean-generic mostlyclean \
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-klibdrmincludeHEADERS
+	tags uninstall uninstall-am uninstall-klibdrmincludeHEADERS
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
Index: git/shared-core/drm.h
===================================================================
--- git.orig/shared-core/drm.h	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/drm.h	2008-12-12 17:35:22.000000000 +0000
@@ -61,6 +61,9 @@
 #ifndef __user
 #define __user
 #endif
+#ifndef __iomem
+#define __iomem
+#endif
 
 #ifdef __GNUC__
 # define DEPRECATED  __attribute__ ((deprecated))
@@ -77,14 +80,7 @@
 #define DRM_IOC_READWRITE	_IOC_READ|_IOC_WRITE
 #define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
 #elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
-#if (defined(__FreeBSD__) || defined(__FreeBSD_kernel__)) && defined(IN_MODULE)
-/* Prevent name collision when including sys/ioccom.h */
-#undef ioctl
-#include <sys/ioccom.h>
-#define ioctl(a,b,c)		xf86ioctl(a,b,c)
-#else
 #include <sys/ioccom.h>
-#endif				/* __FreeBSD__ && xf86ioctl */
 #define DRM_IOCTL_NR(n)		((n) & 0xff)
 #define DRM_IOC_VOID		IOC_VOID
 #define DRM_IOC_READ		IOC_OUT
@@ -93,24 +89,6 @@
 #define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
 #endif
 
-#define XFREE86_VERSION(major,minor,patch,snap) \
-		((major << 16) | (minor << 8) | patch)
-
-#ifndef CONFIG_XFREE86_VERSION
-#define CONFIG_XFREE86_VERSION XFREE86_VERSION(4,1,0,0)
-#endif
-
-#if CONFIG_XFREE86_VERSION < XFREE86_VERSION(4,1,0,0)
-#define DRM_PROC_DEVICES "/proc/devices"
-#define DRM_PROC_MISC	 "/proc/misc"
-#define DRM_PROC_DRM	 "/proc/drm"
-#define DRM_DEV_DRM	 "/dev/drm"
-#define DRM_DEV_MODE	 (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP)
-#define DRM_DEV_UID	 0
-#define DRM_DEV_GID	 0
-#endif
-
-#if CONFIG_XFREE86_VERSION >= XFREE86_VERSION(4,1,0,0)
 #ifdef __OpenBSD__
 #define DRM_MAJOR       81
 #endif
@@ -118,7 +96,7 @@
 #define DRM_MAJOR       226
 #endif
 #define DRM_MAX_MINOR   15
-#endif
+
 #define DRM_NAME	"drm"	  /**< Name in kernel, /dev, and /proc */
 #define DRM_MIN_ORDER	5	  /**< At least 2^5 bytes = 32 bytes */
 #define DRM_MAX_ORDER	22	  /**< Up to 2^22 bytes = 4MB */
@@ -131,16 +109,9 @@
 #define _DRM_LOCKING_CONTEXT(lock) ((lock) & ~(_DRM_LOCK_HELD|_DRM_LOCK_CONT))
 
 #if defined(__linux__)
-#if defined(__KERNEL__)
-typedef __u64 drm_u64_t;
-#else
-typedef unsigned long long drm_u64_t;
-#endif
-
 typedef unsigned int drm_handle_t;
 #else
 #include <sys/types.h>
-typedef u_int64_t drm_u64_t;
 typedef unsigned long drm_handle_t;	/**< To mapped regions */
 #endif
 typedef unsigned int drm_context_t;	/**< GLXContext handle */
@@ -156,31 +127,23 @@
  * \note KW: Actually it's illegal to change either for
  * backwards-compatibility reasons.
  */
-typedef struct drm_clip_rect {
+struct drm_clip_rect {
 	unsigned short x1;
 	unsigned short y1;
 	unsigned short x2;
 	unsigned short y2;
-} drm_clip_rect_t;
-
-/**
- * Drawable information.
- */
-typedef struct drm_drawable_info {
-	unsigned int num_rects;
-	drm_clip_rect_t *rects;
-} drm_drawable_info_t;
+};
 
 /**
  * Texture region,
  */
-typedef struct drm_tex_region {
+struct drm_tex_region {
 	unsigned char next;
 	unsigned char prev;
 	unsigned char in_use;
 	unsigned char padding;
 	unsigned int age;
-} drm_tex_region_t;
+};
 
 /**
  * Hardware lock.
@@ -189,10 +152,10 @@
  * processor bus contention on a multiprocessor system, there should not be any
  * other data stored in the same cache line.
  */
-typedef struct drm_hw_lock {
+struct drm_hw_lock {
 	__volatile__ unsigned int lock;		/**< lock variable */
 	char padding[60];			/**< Pad to cache line */
-} drm_hw_lock_t;
+};
 
 /* This is beyond ugly, and only works on GCC.  However, it allows me to use
  * drm.h in places (i.e., in the X-server) where I can't use size_t.  The real
@@ -215,7 +178,7 @@
  *
  * \sa drmGetVersion().
  */
-typedef struct drm_version {
+struct drm_version {
 	int version_major;	  /**< Major version */
 	int version_minor;	  /**< Minor version */
 	int version_patchlevel;	  /**< Patch level */
@@ -225,35 +188,35 @@
 	char __user *date;		  /**< User-space buffer to hold date */
 	DRM_SIZE_T desc_len;	  /**< Length of desc buffer */
 	char __user *desc;		  /**< User-space buffer to hold desc */
-} drm_version_t;
+};
 
 /**
  * DRM_IOCTL_GET_UNIQUE ioctl argument type.
  *
  * \sa drmGetBusid() and drmSetBusId().
  */
-typedef struct drm_unique {
+struct drm_unique {
 	DRM_SIZE_T unique_len;	  /**< Length of unique */
 	char __user *unique;		  /**< Unique name for driver instantiation */
-} drm_unique_t;
+};
 
 #undef DRM_SIZE_T
 
-typedef struct drm_list {
+struct drm_list {
 	int count;		  /**< Length of user-space structures */
-	drm_version_t __user *version;
-} drm_list_t;
+	struct drm_version __user *version;
+};
 
-typedef struct drm_block {
+struct drm_block {
 	int unused;
-} drm_block_t;
+};
 
 /**
  * DRM_IOCTL_CONTROL ioctl argument type.
  *
  * \sa drmCtlInstHandler() and drmCtlUninstHandler().
  */
-typedef struct drm_control {
+struct drm_control {
 	enum {
 		DRM_ADD_COMMAND,
 		DRM_RM_COMMAND,
@@ -261,12 +224,12 @@
 		DRM_UNINST_HANDLER
 	} func;
 	int irq;
-} drm_control_t;
+};
 
 /**
  * Type of memory to map.
  */
-typedef enum drm_map_type {
+enum drm_map_type {
 	_DRM_FRAME_BUFFER = 0,	  /**< WC (no caching), no core dump */
 	_DRM_REGISTERS = 1,	  /**< no caching, no core dump */
 	_DRM_SHM = 2,		  /**< shared, cached */
@@ -274,25 +237,26 @@
 	_DRM_SCATTER_GATHER = 4,  /**< Scatter/gather memory for PCI DMA */
 	_DRM_CONSISTENT = 5,	  /**< Consistent memory for PCI DMA */
 	_DRM_TTM = 6
-} drm_map_type_t;
+};
 
 /**
  * Memory mapping flags.
  */
-typedef enum drm_map_flags {
+enum drm_map_flags {
 	_DRM_RESTRICTED = 0x01,	     /**< Cannot be mapped to user-virtual */
 	_DRM_READ_ONLY = 0x02,
 	_DRM_LOCKED = 0x04,	     /**< shared, cached, locked */
 	_DRM_KERNEL = 0x08,	     /**< kernel requires access */
 	_DRM_WRITE_COMBINING = 0x10, /**< use write-combining if available */
 	_DRM_CONTAINS_LOCK = 0x20,   /**< SHM page that contains lock */
-	_DRM_REMOVABLE = 0x40	     /**< Removable mapping */
-} drm_map_flags_t;
+	_DRM_REMOVABLE = 0x40,	     /**< Removable mapping */
+        _DRM_DRIVER = 0x80           /**< Driver will take care of it */
+};
 
-typedef struct drm_ctx_priv_map {
+struct drm_ctx_priv_map {
 	unsigned int ctx_id;	 /**< Context requesting private mapping */
 	void *handle;		 /**< Handle of map */
-} drm_ctx_priv_map_t;
+};
 
 /**
  * DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls
@@ -300,30 +264,30 @@
  *
  * \sa drmAddMap().
  */
-typedef struct drm_map {
+struct drm_map {
 	unsigned long offset;	 /**< Requested physical address (0 for SAREA)*/
 	unsigned long size;	 /**< Requested physical size (bytes) */
-	drm_map_type_t type;	 /**< Type of memory to map */
-	drm_map_flags_t flags;	 /**< Flags */
+	enum drm_map_type type;	 /**< Type of memory to map */
+	enum drm_map_flags flags;	 /**< Flags */
 	void *handle;		 /**< User-space: "Handle" to pass to mmap() */
 				 /**< Kernel-space: kernel-virtual address */
 	int mtrr;		 /**< MTRR slot used */
 	/*   Private data */
-} drm_map_t;
+};
 
 /**
  * DRM_IOCTL_GET_CLIENT ioctl argument type.
  */
-typedef struct drm_client {
+struct drm_client {
 	int idx;		/**< Which client desired? */
 	int auth;		/**< Is client authenticated? */
 	unsigned long pid;	/**< Process ID */
 	unsigned long uid;	/**< User ID */
 	unsigned long magic;	/**< Magic */
 	unsigned long iocs;	/**< Ioctl count */
-} drm_client_t;
+};
 
-typedef enum {
+enum drm_stat_type {
 	_DRM_STAT_LOCK,
 	_DRM_STAT_OPENS,
 	_DRM_STAT_CLOSES,
@@ -341,23 +305,23 @@
 	_DRM_STAT_SPECIAL,	/**< Special DMA (e.g., priority or polled) */
 	_DRM_STAT_MISSED	/**< Missed DMA opportunity */
 	    /* Add to the *END* of the list */
-} drm_stat_type_t;
+};
 
 /**
  * DRM_IOCTL_GET_STATS ioctl argument type.
  */
-typedef struct drm_stats {
+struct drm_stats {
 	unsigned long count;
 	struct {
 		unsigned long value;
-		drm_stat_type_t type;
+		enum drm_stat_type type;
 	} data[15];
-} drm_stats_t;
+};
 
 /**
  * Hardware locking flags.
  */
-typedef enum drm_lock_flags {
+enum drm_lock_flags {
 	_DRM_LOCK_READY = 0x01,	     /**< Wait until hardware is ready for DMA */
 	_DRM_LOCK_QUIESCENT = 0x02,  /**< Wait until hardware quiescent */
 	_DRM_LOCK_FLUSH = 0x04,	     /**< Flush this context's DMA queue first */
@@ -367,17 +331,17 @@
 	   full-screen DGA-like mode. */
 	_DRM_HALT_ALL_QUEUES = 0x10, /**< Halt all current and future queues */
 	_DRM_HALT_CUR_QUEUES = 0x20  /**< Halt all current queues */
-} drm_lock_flags_t;
+};
 
 /**
  * DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type.
  *
  * \sa drmGetLock() and drmUnlock().
  */
-typedef struct drm_lock {
+struct drm_lock {
 	int context;
-	drm_lock_flags_t flags;
-} drm_lock_t;
+	enum drm_lock_flags flags;
+};
 
 /**
  * DMA flags
@@ -387,7 +351,7 @@
  *
  * \sa drm_dma.
  */
-typedef enum drm_dma_flags {
+enum drm_dma_flags {
 	/* Flags for DMA buffer dispatch */
 	_DRM_DMA_BLOCK = 0x01,	      /**<
 				       * Block until buffer dispatched.
@@ -406,14 +370,14 @@
 	_DRM_DMA_WAIT = 0x10,	      /**< Wait for free buffers */
 	_DRM_DMA_SMALLER_OK = 0x20,   /**< Smaller-than-requested buffers OK */
 	_DRM_DMA_LARGER_OK = 0x40     /**< Larger-than-requested buffers OK */
-} drm_dma_flags_t;
+};
 
 /**
  * DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type.
  *
  * \sa drmAddBufs().
  */
-typedef struct drm_buf_desc {
+struct drm_buf_desc {
 	int count;		 /**< Number of buffers of this size */
 	int size;		 /**< Size in bytes */
 	int low_mark;		 /**< Low water mark */
@@ -429,48 +393,48 @@
 				  * Start address of where the AGP buffers are
 				  * in the AGP aperture
 				  */
-} drm_buf_desc_t;
+};
 
 /**
  * DRM_IOCTL_INFO_BUFS ioctl argument type.
  */
-typedef struct drm_buf_info {
+struct drm_buf_info {
 	int count;		  /**< Number of buffers described in list */
-	drm_buf_desc_t __user *list;	  /**< List of buffer descriptions */
-} drm_buf_info_t;
+	struct drm_buf_desc __user *list; /**< List of buffer descriptions */
+};
 
 /**
  * DRM_IOCTL_FREE_BUFS ioctl argument type.
  */
-typedef struct drm_buf_free {
+struct drm_buf_free {
 	int count;
 	int __user *list;
-} drm_buf_free_t;
+};
 
 /**
  * Buffer information
  *
  * \sa drm_buf_map.
  */
-typedef struct drm_buf_pub {
+struct drm_buf_pub {
 	int idx;		       /**< Index into the master buffer list */
 	int total;		       /**< Buffer size */
 	int used;		       /**< Amount of buffer in use (for DMA) */
 	void __user *address;	       /**< Address of buffer */
-} drm_buf_pub_t;
+};
 
 /**
  * DRM_IOCTL_MAP_BUFS ioctl argument type.
  */
-typedef struct drm_buf_map {
+struct drm_buf_map {
 	int count;		/**< Length of the buffer list */
 #if defined(__cplusplus)
 	void __user *c_virtual;
 #else
 	void __user *virtual;		/**< Mmap'd area in user-virtual */
 #endif
-	drm_buf_pub_t __user *list;	/**< Buffer information */
-} drm_buf_map_t;
+	struct drm_buf_pub __user *list;	/**< Buffer information */
+};
 
 /**
  * DRM_IOCTL_DMA ioctl argument type.
@@ -479,48 +443,48 @@
  *
  * \sa drmDMA().
  */
-typedef struct drm_dma {
+struct drm_dma {
 	int context;			  /**< Context handle */
 	int send_count;			  /**< Number of buffers to send */
 	int __user *send_indices;	  /**< List of handles to buffers */
 	int __user *send_sizes;		  /**< Lengths of data to send */
-	drm_dma_flags_t flags;		  /**< Flags */
+	enum drm_dma_flags flags;	  /**< Flags */
 	int request_count;		  /**< Number of buffers requested */
 	int request_size;		  /**< Desired size for buffers */
 	int __user *request_indices;	 /**< Buffer information */
 	int __user *request_sizes;
 	int granted_count;		  /**< Number of buffers granted */
-} drm_dma_t;
+};
 
-typedef enum {
+enum drm_ctx_flags {
 	_DRM_CONTEXT_PRESERVED = 0x01,
 	_DRM_CONTEXT_2DONLY = 0x02
-} drm_ctx_flags_t;
+};
 
 /**
  * DRM_IOCTL_ADD_CTX ioctl argument type.
  *
  * \sa drmCreateContext() and drmDestroyContext().
  */
-typedef struct drm_ctx {
+struct drm_ctx {
 	drm_context_t handle;
-	drm_ctx_flags_t flags;
-} drm_ctx_t;
+	enum drm_ctx_flags flags;
+};
 
 /**
  * DRM_IOCTL_RES_CTX ioctl argument type.
  */
-typedef struct drm_ctx_res {
+struct drm_ctx_res {
 	int count;
-	drm_ctx_t __user *contexts;
-} drm_ctx_res_t;
+	struct drm_ctx __user *contexts;
+};
 
 /**
  * DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type.
  */
-typedef struct drm_draw {
+struct drm_draw {
 	drm_drawable_t handle;
-} drm_draw_t;
+};
 
 /**
  * DRM_IOCTL_UPDATE_DRAW ioctl argument type.
@@ -529,52 +493,53 @@
 	DRM_DRAWABLE_CLIPRECTS,
 } drm_drawable_info_type_t;
 
-typedef struct drm_update_draw {
+struct drm_update_draw {
 	drm_drawable_t handle;
 	unsigned int type;
 	unsigned int num;
 	unsigned long long data;
-} drm_update_draw_t;
+};
 
 /**
  * DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type.
  */
-typedef struct drm_auth {
+struct drm_auth {
 	drm_magic_t magic;
-} drm_auth_t;
+};
 
 /**
  * DRM_IOCTL_IRQ_BUSID ioctl argument type.
  *
  * \sa drmGetInterruptFromBusID().
  */
-typedef struct drm_irq_busid {
+struct drm_irq_busid {
 	int irq;	/**< IRQ number */
 	int busnum;	/**< bus number */
 	int devnum;	/**< device number */
 	int funcnum;	/**< function number */
-} drm_irq_busid_t;
+};
 
-typedef enum {
+enum drm_vblank_seq_type {
 	_DRM_VBLANK_ABSOLUTE = 0x0,	/**< Wait for specific vblank sequence number */
 	_DRM_VBLANK_RELATIVE = 0x1,	/**< Wait for given number of vblanks */
+	_DRM_VBLANK_FLIP = 0x8000000,	/**< Scheduled buffer swap should flip */
 	_DRM_VBLANK_NEXTONMISS = 0x10000000,	/**< If missed, wait for next vblank */
 	_DRM_VBLANK_SECONDARY = 0x20000000,	/**< Secondary display controller */
 	_DRM_VBLANK_SIGNAL = 0x40000000	/**< Send signal instead of blocking */
-} drm_vblank_seq_type_t;
+};
 
 #define _DRM_VBLANK_TYPES_MASK (_DRM_VBLANK_ABSOLUTE | _DRM_VBLANK_RELATIVE)
 #define _DRM_VBLANK_FLAGS_MASK (_DRM_VBLANK_SIGNAL | _DRM_VBLANK_SECONDARY | \
 				_DRM_VBLANK_NEXTONMISS)
 
 struct drm_wait_vblank_request {
-	drm_vblank_seq_type_t type;
+	enum drm_vblank_seq_type type;
 	unsigned int sequence;
 	unsigned long signal;
 };
 
 struct drm_wait_vblank_reply {
-	drm_vblank_seq_type_t type;
+	enum drm_vblank_seq_type type;
 	unsigned int sequence;
 	long tval_sec;
 	long tval_usec;
@@ -585,41 +550,41 @@
  *
  * \sa drmWaitVBlank().
  */
-typedef union drm_wait_vblank {
+union drm_wait_vblank {
 	struct drm_wait_vblank_request request;
 	struct drm_wait_vblank_reply reply;
-} drm_wait_vblank_t;
+};
 
 /**
  * DRM_IOCTL_AGP_ENABLE ioctl argument type.
  *
  * \sa drmAgpEnable().
  */
-typedef struct drm_agp_mode {
+struct drm_agp_mode {
 	unsigned long mode;	/**< AGP mode */
-} drm_agp_mode_t;
+};
 
 /**
  * DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type.
  *
  * \sa drmAgpAlloc() and drmAgpFree().
  */
-typedef struct drm_agp_buffer {
+struct drm_agp_buffer {
 	unsigned long size;	/**< In bytes -- will round to page boundary */
 	unsigned long handle;	/**< Used for binding / unbinding */
 	unsigned long type;	/**< Type of memory to allocate */
 	unsigned long physical;	/**< Physical used by i810 */
-} drm_agp_buffer_t;
+};
 
 /**
  * DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type.
  *
  * \sa drmAgpBind() and drmAgpUnbind().
  */
-typedef struct drm_agp_binding {
+struct drm_agp_binding {
 	unsigned long handle;	/**< From drm_agp_buffer */
 	unsigned long offset;	/**< In bytes -- will round to page boundary */
-} drm_agp_binding_t;
+};
 
 /**
  * DRM_IOCTL_AGP_INFO ioctl argument type.
@@ -628,7 +593,7 @@
  * drmAgpBase(), drmAgpSize(), drmAgpMemoryUsed(), drmAgpMemoryAvail(),
  * drmAgpVendorId() and drmAgpDeviceId().
  */
-typedef struct drm_agp_info {
+struct drm_agp_info {
 	int agp_version_major;
 	int agp_version_minor;
 	unsigned long mode;
@@ -642,151 +607,177 @@
 	unsigned short id_vendor;
 	unsigned short id_device;
 	/*@} */
-} drm_agp_info_t;
+};
 
 /**
  * DRM_IOCTL_SG_ALLOC ioctl argument type.
  */
-typedef struct drm_scatter_gather {
+struct drm_scatter_gather {
 	unsigned long size;	/**< In bytes -- will round to page boundary */
 	unsigned long handle;	/**< Used for mapping / unmapping */
-} drm_scatter_gather_t;
+};
 
 /**
  * DRM_IOCTL_SET_VERSION ioctl argument type.
  */
-typedef struct drm_set_version {
+struct drm_set_version {
 	int drm_di_major;
 	int drm_di_minor;
 	int drm_dd_major;
 	int drm_dd_minor;
-} drm_set_version_t;
+};
 
 
 #define DRM_FENCE_FLAG_EMIT                0x00000001
 #define DRM_FENCE_FLAG_SHAREABLE           0x00000002
 #define DRM_FENCE_FLAG_WAIT_LAZY           0x00000004
 #define DRM_FENCE_FLAG_WAIT_IGNORE_SIGNALS 0x00000008
+#define DRM_FENCE_FLAG_NO_USER             0x00000010
 
 /* Reserved for driver use */
 #define DRM_FENCE_MASK_DRIVER              0xFF000000
 
 #define DRM_FENCE_TYPE_EXE                 0x00000001
 
-typedef struct drm_fence_arg {
-	unsigned handle;
-        int class;
-	unsigned type;
-	unsigned flags;
-	unsigned signaled;
-	unsigned expand_pad[4]; /*Future expansion */
-	enum {
-		drm_fence_create,
-		drm_fence_destroy,
-		drm_fence_reference,
-		drm_fence_unreference,
-		drm_fence_signaled,
-		drm_fence_flush,
-		drm_fence_wait,
-		drm_fence_emit,
-		drm_fence_buffers
-	} op;
-} drm_fence_arg_t;
+struct drm_fence_arg {
+	unsigned int handle;
+	unsigned int fence_class;
+	unsigned int type;
+	unsigned int flags;
+	unsigned int signaled;
+	unsigned int error;
+	unsigned int sequence;
+	unsigned int pad64;
+	uint64_t expand_pad[2]; /*Future expansion */
+};
 
 /* Buffer permissions, referring to how the GPU uses the buffers.
-   these translate to fence types used for the buffers. 
-   Typically a texture buffer is read, A destination buffer is write and
-   a command (batch-) buffer is exe. Can be or-ed together. */
-
-#define DRM_BO_FLAG_READ        0x00000001
-#define DRM_BO_FLAG_WRITE       0x00000002
-#define DRM_BO_FLAG_EXE         0x00000004
+ * these translate to fence types used for the buffers.
+ * Typically a texture buffer is read, A destination buffer is write and
+ *  a command (batch-) buffer is exe. Can be or-ed together.
+ */
+
+#define DRM_BO_FLAG_READ        (1ULL << 0)
+#define DRM_BO_FLAG_WRITE       (1ULL << 1)
+#define DRM_BO_FLAG_EXE         (1ULL << 2)
 
 /*
  * Status flags. Can be read to determine the actual state of a buffer.
+ * Can also be set in the buffer mask before validation.
+ */
+
+/*
+ * Mask: Never evict this buffer. Not even with force. This type of buffer is only
+ * available to root and must be manually removed before buffer manager shutdown
+ * or lock.
+ * Flags: Acknowledge
+ */
+#define DRM_BO_FLAG_NO_EVICT    (1ULL << 4)
+
+/*
+ * Mask: Require that the buffer is placed in mappable memory when validated.
+ *       If not set the buffer may or may not be in mappable memory when validated.
+ * Flags: If set, the buffer is in mappable memory.
+ */
+#define DRM_BO_FLAG_MAPPABLE    (1ULL << 5)
+
+/* Mask: The buffer should be shareable with other processes.
+ * Flags: The buffer is shareable with other processes.
+ */
+#define DRM_BO_FLAG_SHAREABLE   (1ULL << 6)
+
+/* Mask: If set, place the buffer in cache-coherent memory if available.
+ *       If clear, never place the buffer in cache coherent memory if validated.
+ * Flags: The buffer is currently in cache-coherent memory.
+ */
+#define DRM_BO_FLAG_CACHED      (1ULL << 7)
+
+/* Mask: Make sure that every time this buffer is validated,
+ *       it ends up on the same location provided that the memory mask is the same.
+ *       The buffer will also not be evicted when claiming space for
+ *       other buffers. Basically a pinned buffer but it may be thrown out as
+ *       part of buffer manager shutdown or locking.
+ * Flags: Acknowledge.
+ */
+#define DRM_BO_FLAG_NO_MOVE     (1ULL << 8)
+
+/* Mask: Make sure the buffer is in cached memory when mapped
+ * Flags: Acknowledge.
+ * Buffers allocated with this flag should not be used for suballocators
+ * This type may have issues on CPUs with over-aggressive caching
+ * http://marc.info/?l=linux-kernel&m=102376926732464&w=2
+ */
+#define DRM_BO_FLAG_CACHED_MAPPED    (1ULL << 19)
+
+
+/* Mask: Force DRM_BO_FLAG_CACHED flag strictly also if it is set.
+ * Flags: Acknowledge.
  */
+#define DRM_BO_FLAG_FORCE_CACHING  (1ULL << 13)
 
-/* 
- * Cannot evict this buffer. Not even with force. This type of buffer should
- * only be available for root, and must be manually removed before buffer
- * manager shutdown or swapout.
- */
-#define DRM_BO_FLAG_NO_EVICT    0x00000010
-/* Always keep a system memory shadow to a vram buffer */
-#define DRM_BO_FLAG_SHADOW_VRAM 0x00000020
-/* The buffer is shareable with other processes */
-#define DRM_BO_FLAG_SHAREABLE   0x00000040
-/* The buffer is currently cached */
-#define DRM_BO_FLAG_CACHED      0x00000080
-/* Make sure that every time this buffer is validated, it ends up on the same
- * location. The buffer will also not be evicted when claiming space for
- * other buffers. Basically a pinned buffer but it may be thrown out as
- * part of buffer manager shutdown or swapout. Not supported yet.*/
-#define DRM_BO_FLAG_NO_MOVE     0x00000100
-
-/* Make sure the buffer is in cached memory when mapped for reading */
-#define DRM_BO_FLAG_READ_CACHED 0x00080000
-/* When there is a choice between VRAM and TT, prefer VRAM. 
-   The default behaviour is to prefer TT. */
-#define DRM_BO_FLAG_PREFER_VRAM 0x00040000
-/* Bind this buffer cached if the hardware supports it. */
-#define DRM_BO_FLAG_BIND_CACHED 0x0002000
+/*
+ * Mask: Force DRM_BO_FLAG_MAPPABLE flag strictly also if it is clear.
+ * Flags: Acknowledge.
+ */
+#define DRM_BO_FLAG_FORCE_MAPPABLE (1ULL << 14)
+#define DRM_BO_FLAG_TILE           (1ULL << 15)
 
-/* System Memory */
-#define DRM_BO_FLAG_MEM_LOCAL  0x01000000
+/*
+ * Memory type flags that can be or'ed together in the mask, but only
+ * one appears in flags.
+ */
+
+/* System memory */
+#define DRM_BO_FLAG_MEM_LOCAL  (1ULL << 24)
 /* Translation table memory */
-#define DRM_BO_FLAG_MEM_TT     0x02000000
+#define DRM_BO_FLAG_MEM_TT     (1ULL << 25)
 /* Vram memory */
-#define DRM_BO_FLAG_MEM_VRAM   0x04000000
-/* Unmappable Vram memory */
-#define DRM_BO_FLAG_MEM_VRAM_NM   0x08000000
+#define DRM_BO_FLAG_MEM_VRAM   (1ULL << 26)
+/* Up to the driver to define. */
+#define DRM_BO_FLAG_MEM_PRIV0  (1ULL << 27)
+#define DRM_BO_FLAG_MEM_PRIV1  (1ULL << 28)
+#define DRM_BO_FLAG_MEM_PRIV2  (1ULL << 29)
+#define DRM_BO_FLAG_MEM_PRIV3  (1ULL << 30)
+#define DRM_BO_FLAG_MEM_PRIV4  (1ULL << 31)
+/* We can add more of these now with a 64-bit flag type */
+
 /* Memory flag mask */
-#define DRM_BO_MASK_MEM         0xFF000000
+#define DRM_BO_MASK_MEM         0x00000000FF000000ULL
+#define DRM_BO_MASK_MEMTYPE     0x00000000FF0800A0ULL
+
+/* Driver-private flags */
+#define DRM_BO_MASK_DRIVER      0xFFFF000000000000ULL
 
-/* When creating a buffer, Avoid system storage even if allowed */
-#define DRM_BO_HINT_AVOID_LOCAL 0x00000001
 /* Don't block on validate and map */
 #define DRM_BO_HINT_DONT_BLOCK  0x00000002
 /* Don't place this buffer on the unfenced list.*/
 #define DRM_BO_HINT_DONT_FENCE  0x00000004
 #define DRM_BO_HINT_WAIT_LAZY   0x00000008
-#define DRM_BO_HINT_ALLOW_UNFENCED_MAP 0x00000010
 
+#define DRM_BO_INIT_MAGIC 0xfe769812
+#define DRM_BO_INIT_MAJOR 1
+#define DRM_BO_INIT_MINOR 0
+#define DRM_BO_INIT_PATCH 0
 
-/* Driver specific flags. Could be for example rendering engine */  
-#define DRM_BO_MASK_DRIVER      0x00F00000
 
-typedef enum {
-	drm_bo_type_dc,
-	drm_bo_type_user,
-	drm_bo_type_fake
-}drm_bo_type_t;
-	
-
-typedef struct drm_bo_arg_request {
-	unsigned handle; /* User space handle */
-	unsigned mask;
-	unsigned hint;
-	drm_u64_t size;
-	drm_bo_type_t type;
-	unsigned arg_handle;
-	drm_u64_t buffer_start;
-        unsigned page_alignment;
-	unsigned expand_pad[4]; /*Future expansion */
-	enum {
-		drm_bo_create,
-		drm_bo_validate,
-		drm_bo_map,
-		drm_bo_unmap,
-		drm_bo_fence,
-		drm_bo_destroy,
-		drm_bo_reference,
-		drm_bo_unreference,
-		drm_bo_info,
-		drm_bo_wait_idle,
-		drm_bo_ref_fence
-	} op;
-} drm_bo_arg_request_t;
+struct drm_bo_info_req {
+	uint64_t mask;
+	uint64_t flags;
+	unsigned int handle;
+	unsigned int hint;
+	unsigned int fence_class;
+	unsigned int desired_tile_stride;
+	unsigned int tile_info;
+	unsigned int pad64;
+};
+
+struct drm_bo_create_req {
+	uint64_t mask;
+	uint64_t size;
+	uint64_t buffer_start;
+	unsigned int hint;
+	unsigned int page_alignment;
+};
 
 
 /*
@@ -795,56 +786,238 @@
 
 #define DRM_BO_REP_BUSY 0x00000001
 
-typedef struct drm_bo_arg_reply {
+struct drm_bo_info_rep {
+	uint64_t flags;
+	uint64_t mask;
+	uint64_t size;
+	uint64_t offset;
+	uint64_t arg_handle;
+	uint64_t buffer_start;
+	unsigned int handle;
+	unsigned int fence_flags;
+	unsigned int rep_flags;
+	unsigned int page_alignment;
+	unsigned int desired_tile_stride;
+	unsigned int hw_tile_stride;
+	unsigned int tile_info;
+	unsigned int pad64;
+	uint64_t expand_pad[4]; /*Future expansion */
+};
+
+struct drm_bo_arg_rep {
+	struct drm_bo_info_rep bo_info;
 	int ret;
-	unsigned handle;
-	unsigned flags;
-	drm_u64_t size;
-	drm_u64_t offset;
-	drm_u64_t arg_handle;
-        unsigned mask;
-        drm_u64_t buffer_start;
-        unsigned fence_flags;
-        unsigned rep_flags;
-        unsigned page_alignment;
-	unsigned expand_pad[4]; /*Future expansion */
-}drm_bo_arg_reply_t;
-	
-
-typedef struct drm_bo_arg{
-        int handled;
-	drm_u64_t next;
+	unsigned int pad64;
+};
+
+struct drm_bo_create_arg {
 	union {
-		drm_bo_arg_request_t req;
-		drm_bo_arg_reply_t rep;
+		struct drm_bo_create_req req;
+		struct drm_bo_info_rep rep;
 	} d;
-} drm_bo_arg_t;
+};
+
+struct drm_bo_handle_arg {
+	unsigned int handle;
+};
+
+struct drm_bo_reference_info_arg {
+	union {
+		struct drm_bo_handle_arg req;
+		struct drm_bo_info_rep rep;
+	} d;
+};
+
+struct drm_bo_map_wait_idle_arg {
+	union {
+		struct drm_bo_info_req req;
+		struct drm_bo_info_rep rep;
+	} d;
+};
+
+struct drm_bo_op_req {
+	enum {
+		drm_bo_validate,
+		drm_bo_fence,
+		drm_bo_ref_fence,
+	} op;
+	unsigned int arg_handle;
+	struct drm_bo_info_req bo_req;
+};
+
+
+struct drm_bo_op_arg {
+	uint64_t next;
+	union {
+		struct drm_bo_op_req req;
+		struct drm_bo_arg_rep rep;
+	} d;
+	int handled;
+	unsigned int pad64;
+};
+
 
 #define DRM_BO_MEM_LOCAL 0
 #define DRM_BO_MEM_TT 1
 #define DRM_BO_MEM_VRAM 2
-#define DRM_BO_MEM_VRAM_NM 3
-#define DRM_BO_MEM_TYPES 2 /* For now. */
+#define DRM_BO_MEM_PRIV0 3
+#define DRM_BO_MEM_PRIV1 4
+#define DRM_BO_MEM_PRIV2 5
+#define DRM_BO_MEM_PRIV3 6
+#define DRM_BO_MEM_PRIV4 7
+
+#define DRM_BO_MEM_TYPES 8 /* For now. */
+
+#define DRM_BO_LOCK_UNLOCK_BM       (1 << 0)
+#define DRM_BO_LOCK_IGNORE_NO_EVICT (1 << 1)
+
+struct drm_bo_version_arg {
+	uint32_t major;
+	uint32_t minor;
+	uint32_t patchlevel;
+};
 
-typedef union drm_mm_init_arg{
-	struct {
-		enum {
-			mm_init,
-			mm_takedown,
-			mm_query,
-			mm_lock,
-			mm_unlock
-		} op;
-		drm_u64_t p_offset;
-		drm_u64_t p_size;
-		unsigned mem_type;
-		unsigned expand_pad[8]; /*Future expansion */
-	} req;
-	struct {
-		drm_handle_t mm_sarea;
-		unsigned expand_pad[8]; /*Future expansion */
-	} rep;
-} drm_mm_init_arg_t;
+struct drm_mm_type_arg {
+	unsigned int mem_type;
+	unsigned int lock_flags;
+};
+
+struct drm_mm_init_arg {
+	unsigned int magic;
+	unsigned int major;
+	unsigned int minor;
+	unsigned int mem_type;
+	uint64_t p_offset;
+	uint64_t p_size;
+};
+
+/*
+ * Drm mode setting
+ */
+#define DRM_DISPLAY_INFO_LEN 32
+#define DRM_OUTPUT_NAME_LEN 32
+#define DRM_DISPLAY_MODE_LEN 32
+#define DRM_PROP_NAME_LEN 32
+
+#define DRM_MODE_TYPE_BUILTIN	(1<<0)
+#define DRM_MODE_TYPE_CLOCK_C	((1<<1) | DRM_MODE_TYPE_BUILTIN)
+#define DRM_MODE_TYPE_CRTC_C	((1<<2) | DRM_MODE_TYPE_BUILTIN)
+#define DRM_MODE_TYPE_PREFERRED	(1<<3)
+#define DRM_MODE_TYPE_DEFAULT	(1<<4)
+#define DRM_MODE_TYPE_USERDEF	(1<<5)
+#define DRM_MODE_TYPE_DRIVER	(1<<6)
+
+struct drm_mode_modeinfo {
+
+	unsigned int id;
+
+	unsigned int clock;
+	unsigned short hdisplay, hsync_start, hsync_end, htotal, hskew;
+	unsigned short vdisplay, vsync_start, vsync_end, vtotal, vscan;
+
+	unsigned int vrefresh; /* vertical refresh * 1000 */
+
+	unsigned int flags;
+	unsigned int type;
+	char name[DRM_DISPLAY_MODE_LEN];
+};
+
+struct drm_mode_card_res {
+
+	int count_fbs;
+	unsigned int __user *fb_id;
+
+	int count_crtcs;
+	unsigned int __user *crtc_id;
+
+	int count_outputs;
+	unsigned int __user *output_id;
+
+	int count_modes;
+        struct drm_mode_modeinfo __user *modes;
+
+};
+
+struct drm_mode_crtc {
+	unsigned int crtc_id; /**< Id */
+	unsigned int fb_id; /**< Id of framebuffer */
+
+	int x, y; /**< Position on the frameuffer */
+
+	unsigned int mode; /**< Current mode used */
+
+	int count_outputs;
+	unsigned int outputs; /**< Outputs that are connected */
+
+	int count_possibles;
+	unsigned int possibles; /**< Outputs that can be connected */
+
+	unsigned int __user *set_outputs; /**< Outputs to be connected */
+
+	int gamma_size;
+
+};
+
+struct drm_mode_get_output {
+
+	unsigned int output; /**< Id */
+	unsigned int crtc; /**< Id of crtc */
+	unsigned char name[DRM_OUTPUT_NAME_LEN];
+
+	unsigned int connection;
+	unsigned int mm_width, mm_height; /**< HxW in millimeters */
+	unsigned int subpixel;
+
+	int count_crtcs;
+	unsigned int crtcs; /**< possible crtc to connect to */
+
+	int count_clones;
+	unsigned int clones; /**< list of clones */
+
+	int count_modes;
+	unsigned int __user *modes; /**< list of modes it supports */
+
+	int count_props;
+	unsigned int __user *props;
+	unsigned int __user *prop_values;
+};
+
+#define DRM_MODE_PROP_PENDING (1<<0)
+#define DRM_MODE_PROP_RANGE (1<<1)
+#define DRM_MODE_PROP_IMMUTABLE (1<<2)
+#define DRM_MODE_PROP_ENUM (1<<3) // enumerated type with text strings
+
+struct drm_mode_property_enum {
+	uint32_t value;
+	unsigned char name[DRM_PROP_NAME_LEN];
+};
+		
+struct drm_mode_get_property {
+
+	unsigned int prop_id;
+	unsigned int flags;
+	unsigned char name[DRM_PROP_NAME_LEN];
+
+	int count_values;
+	uint32_t __user *values;
+
+	int count_enums;
+	struct drm_mode_property_enum *enums;
+};
+
+struct drm_mode_fb_cmd {
+        unsigned int buffer_id;
+        unsigned int width, height;
+        unsigned int pitch;
+        unsigned int bpp;
+        unsigned int handle;
+	unsigned int depth;
+};
+
+struct drm_mode_mode_cmd {
+	unsigned int output_id;
+	unsigned int mode_id;
+};
 
 /**
  * \name Ioctls Definitions
@@ -857,66 +1030,101 @@
 #define DRM_IOW(nr,type)		_IOW(DRM_IOCTL_BASE,nr,type)
 #define DRM_IOWR(nr,type)		_IOWR(DRM_IOCTL_BASE,nr,type)
 
-#define DRM_IOCTL_VERSION		DRM_IOWR(0x00, drm_version_t)
-#define DRM_IOCTL_GET_UNIQUE		DRM_IOWR(0x01, drm_unique_t)
-#define DRM_IOCTL_GET_MAGIC		DRM_IOR( 0x02, drm_auth_t)
-#define DRM_IOCTL_IRQ_BUSID		DRM_IOWR(0x03, drm_irq_busid_t)
-#define DRM_IOCTL_GET_MAP               DRM_IOWR(0x04, drm_map_t)
-#define DRM_IOCTL_GET_CLIENT            DRM_IOWR(0x05, drm_client_t)
-#define DRM_IOCTL_GET_STATS             DRM_IOR( 0x06, drm_stats_t)
-#define DRM_IOCTL_SET_VERSION		DRM_IOWR(0x07, drm_set_version_t)
-
-#define DRM_IOCTL_SET_UNIQUE		DRM_IOW( 0x10, drm_unique_t)
-#define DRM_IOCTL_AUTH_MAGIC		DRM_IOW( 0x11, drm_auth_t)
-#define DRM_IOCTL_BLOCK			DRM_IOWR(0x12, drm_block_t)
-#define DRM_IOCTL_UNBLOCK		DRM_IOWR(0x13, drm_block_t)
-#define DRM_IOCTL_CONTROL		DRM_IOW( 0x14, drm_control_t)
-#define DRM_IOCTL_ADD_MAP		DRM_IOWR(0x15, drm_map_t)
-#define DRM_IOCTL_ADD_BUFS		DRM_IOWR(0x16, drm_buf_desc_t)
-#define DRM_IOCTL_MARK_BUFS		DRM_IOW( 0x17, drm_buf_desc_t)
-#define DRM_IOCTL_INFO_BUFS		DRM_IOWR(0x18, drm_buf_info_t)
-#define DRM_IOCTL_MAP_BUFS		DRM_IOWR(0x19, drm_buf_map_t)
-#define DRM_IOCTL_FREE_BUFS		DRM_IOW( 0x1a, drm_buf_free_t)
-
-#define DRM_IOCTL_RM_MAP		DRM_IOW( 0x1b, drm_map_t)
-
-#define DRM_IOCTL_SET_SAREA_CTX		DRM_IOW( 0x1c, drm_ctx_priv_map_t)
-#define DRM_IOCTL_GET_SAREA_CTX 	DRM_IOWR(0x1d, drm_ctx_priv_map_t)
-
-#define DRM_IOCTL_ADD_CTX		DRM_IOWR(0x20, drm_ctx_t)
-#define DRM_IOCTL_RM_CTX		DRM_IOWR(0x21, drm_ctx_t)
-#define DRM_IOCTL_MOD_CTX		DRM_IOW( 0x22, drm_ctx_t)
-#define DRM_IOCTL_GET_CTX		DRM_IOWR(0x23, drm_ctx_t)
-#define DRM_IOCTL_SWITCH_CTX		DRM_IOW( 0x24, drm_ctx_t)
-#define DRM_IOCTL_NEW_CTX		DRM_IOW( 0x25, drm_ctx_t)
-#define DRM_IOCTL_RES_CTX		DRM_IOWR(0x26, drm_ctx_res_t)
-#define DRM_IOCTL_ADD_DRAW		DRM_IOWR(0x27, drm_draw_t)
-#define DRM_IOCTL_RM_DRAW		DRM_IOWR(0x28, drm_draw_t)
-#define DRM_IOCTL_DMA			DRM_IOWR(0x29, drm_dma_t)
-#define DRM_IOCTL_LOCK			DRM_IOW( 0x2a, drm_lock_t)
-#define DRM_IOCTL_UNLOCK		DRM_IOW( 0x2b, drm_lock_t)
-#define DRM_IOCTL_FINISH		DRM_IOW( 0x2c, drm_lock_t)
+#define DRM_IOCTL_VERSION		DRM_IOWR(0x00, struct drm_version)
+#define DRM_IOCTL_GET_UNIQUE		DRM_IOWR(0x01, struct drm_unique)
+#define DRM_IOCTL_GET_MAGIC		DRM_IOR( 0x02, struct drm_auth)
+#define DRM_IOCTL_IRQ_BUSID		DRM_IOWR(0x03, struct drm_irq_busid)
+#define DRM_IOCTL_GET_MAP               DRM_IOWR(0x04, struct drm_map)
+#define DRM_IOCTL_GET_CLIENT            DRM_IOWR(0x05, struct drm_client)
+#define DRM_IOCTL_GET_STATS             DRM_IOR( 0x06, struct drm_stats)
+#define DRM_IOCTL_SET_VERSION		DRM_IOWR(0x07, struct drm_set_version)
+
+#define DRM_IOCTL_SET_UNIQUE		DRM_IOW( 0x10, struct drm_unique)
+#define DRM_IOCTL_AUTH_MAGIC		DRM_IOW( 0x11, struct drm_auth)
+#define DRM_IOCTL_BLOCK			DRM_IOWR(0x12, struct drm_block)
+#define DRM_IOCTL_UNBLOCK		DRM_IOWR(0x13, struct drm_block)
+#define DRM_IOCTL_CONTROL		DRM_IOW( 0x14, struct drm_control)
+#define DRM_IOCTL_ADD_MAP		DRM_IOWR(0x15, struct drm_map)
+#define DRM_IOCTL_ADD_BUFS		DRM_IOWR(0x16, struct drm_buf_desc)
+#define DRM_IOCTL_MARK_BUFS		DRM_IOW( 0x17, struct drm_buf_desc)
+#define DRM_IOCTL_INFO_BUFS		DRM_IOWR(0x18, struct drm_buf_info)
+#define DRM_IOCTL_MAP_BUFS		DRM_IOWR(0x19, struct drm_buf_map)
+#define DRM_IOCTL_FREE_BUFS		DRM_IOW( 0x1a, struct drm_buf_free)
+
+#define DRM_IOCTL_RM_MAP		DRM_IOW( 0x1b, struct drm_map)
+
+#define DRM_IOCTL_SET_SAREA_CTX		DRM_IOW( 0x1c, struct drm_ctx_priv_map)
+#define DRM_IOCTL_GET_SAREA_CTX		DRM_IOWR(0x1d, struct drm_ctx_priv_map)
+
+#define DRM_IOCTL_ADD_CTX		DRM_IOWR(0x20, struct drm_ctx)
+#define DRM_IOCTL_RM_CTX		DRM_IOWR(0x21, struct drm_ctx)
+#define DRM_IOCTL_MOD_CTX		DRM_IOW( 0x22, struct drm_ctx)
+#define DRM_IOCTL_GET_CTX		DRM_IOWR(0x23, struct drm_ctx)
+#define DRM_IOCTL_SWITCH_CTX		DRM_IOW( 0x24, struct drm_ctx)
+#define DRM_IOCTL_NEW_CTX		DRM_IOW( 0x25, struct drm_ctx)
+#define DRM_IOCTL_RES_CTX		DRM_IOWR(0x26, struct drm_ctx_res)
+#define DRM_IOCTL_ADD_DRAW		DRM_IOWR(0x27, struct drm_draw)
+#define DRM_IOCTL_RM_DRAW		DRM_IOWR(0x28, struct drm_draw)
+#define DRM_IOCTL_DMA			DRM_IOWR(0x29, struct drm_dma)
+#define DRM_IOCTL_LOCK			DRM_IOW( 0x2a, struct drm_lock)
+#define DRM_IOCTL_UNLOCK		DRM_IOW( 0x2b, struct drm_lock)
+#define DRM_IOCTL_FINISH		DRM_IOW( 0x2c, struct drm_lock)
 
 #define DRM_IOCTL_AGP_ACQUIRE		DRM_IO(  0x30)
 #define DRM_IOCTL_AGP_RELEASE		DRM_IO(  0x31)
-#define DRM_IOCTL_AGP_ENABLE		DRM_IOW( 0x32, drm_agp_mode_t)
-#define DRM_IOCTL_AGP_INFO		DRM_IOR( 0x33, drm_agp_info_t)
-#define DRM_IOCTL_AGP_ALLOC		DRM_IOWR(0x34, drm_agp_buffer_t)
-#define DRM_IOCTL_AGP_FREE		DRM_IOW( 0x35, drm_agp_buffer_t)
-#define DRM_IOCTL_AGP_BIND		DRM_IOW( 0x36, drm_agp_binding_t)
-#define DRM_IOCTL_AGP_UNBIND		DRM_IOW( 0x37, drm_agp_binding_t)
-
-#define DRM_IOCTL_SG_ALLOC		DRM_IOW( 0x38, drm_scatter_gather_t)
-#define DRM_IOCTL_SG_FREE		DRM_IOW( 0x39, drm_scatter_gather_t)
-
-#define DRM_IOCTL_WAIT_VBLANK		DRM_IOWR(0x3a, drm_wait_vblank_t)
-
-#define DRM_IOCTL_FENCE                 DRM_IOWR(0x3b, drm_fence_arg_t)
-#define DRM_IOCTL_BUFOBJ                DRM_IOWR(0x3d, drm_bo_arg_t)
-#define DRM_IOCTL_MM_INIT               DRM_IOWR(0x3e, drm_mm_init_arg_t)
-
-#define DRM_IOCTL_UPDATE_DRAW           DRM_IOW(0x3f, drm_update_draw_t)
+#define DRM_IOCTL_AGP_ENABLE		DRM_IOW( 0x32, struct drm_agp_mode)
+#define DRM_IOCTL_AGP_INFO		DRM_IOR( 0x33, struct drm_agp_info)
+#define DRM_IOCTL_AGP_ALLOC		DRM_IOWR(0x34, struct drm_agp_buffer)
+#define DRM_IOCTL_AGP_FREE		DRM_IOW( 0x35, struct drm_agp_buffer)
+#define DRM_IOCTL_AGP_BIND		DRM_IOW( 0x36, struct drm_agp_binding)
+#define DRM_IOCTL_AGP_UNBIND		DRM_IOW( 0x37, struct drm_agp_binding)
+
+#define DRM_IOCTL_SG_ALLOC		DRM_IOW( 0x38, struct drm_scatter_gather)
+#define DRM_IOCTL_SG_FREE		DRM_IOW( 0x39, struct drm_scatter_gather)
+
+#define DRM_IOCTL_WAIT_VBLANK		DRM_IOWR(0x3a, union drm_wait_vblank)
+
+#define DRM_IOCTL_UPDATE_DRAW           DRM_IOW(0x3f, struct drm_update_draw)
+
+#define DRM_IOCTL_MM_INIT               DRM_IOWR(0xc0, struct drm_mm_init_arg)
+#define DRM_IOCTL_MM_TAKEDOWN           DRM_IOWR(0xc1, struct drm_mm_type_arg)
+#define DRM_IOCTL_MM_LOCK               DRM_IOWR(0xc2, struct drm_mm_type_arg)
+#define DRM_IOCTL_MM_UNLOCK             DRM_IOWR(0xc3, struct drm_mm_type_arg)
+
+#define DRM_IOCTL_FENCE_CREATE          DRM_IOWR(0xc4, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_REFERENCE       DRM_IOWR(0xc6, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_UNREFERENCE     DRM_IOWR(0xc7, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_SIGNALED        DRM_IOWR(0xc8, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_FLUSH           DRM_IOWR(0xc9, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_WAIT            DRM_IOWR(0xca, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_EMIT            DRM_IOWR(0xcb, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_BUFFERS         DRM_IOWR(0xcc, struct drm_fence_arg)
+
+#define DRM_IOCTL_BO_CREATE             DRM_IOWR(0xcd, struct drm_bo_create_arg)
+#define DRM_IOCTL_BO_MAP                DRM_IOWR(0xcf, struct drm_bo_map_wait_idle_arg)
+#define DRM_IOCTL_BO_UNMAP              DRM_IOWR(0xd0, struct drm_bo_handle_arg)
+#define DRM_IOCTL_BO_REFERENCE          DRM_IOWR(0xd1, struct drm_bo_reference_info_arg)
+#define DRM_IOCTL_BO_UNREFERENCE        DRM_IOWR(0xd2, struct drm_bo_handle_arg)
+#define DRM_IOCTL_BO_SETSTATUS          DRM_IOWR(0xd3, struct drm_bo_map_wait_idle_arg)
+#define DRM_IOCTL_BO_INFO               DRM_IOWR(0xd4, struct drm_bo_reference_info_arg)
+#define DRM_IOCTL_BO_WAIT_IDLE          DRM_IOWR(0xd5, struct drm_bo_map_wait_idle_arg)
+#define DRM_IOCTL_BO_VERSION          DRM_IOR(0xd6, struct drm_bo_version_arg)
+
+
+#define DRM_IOCTL_MODE_GETRESOURCES     DRM_IOWR(0xA0, struct drm_mode_card_res)
+#define DRM_IOCTL_MODE_GETCRTC          DRM_IOWR(0xA1, struct drm_mode_crtc)
+#define DRM_IOCTL_MODE_GETOUTPUT        DRM_IOWR(0xA2, struct drm_mode_get_output)
+#define DRM_IOCTL_MODE_SETCRTC          DRM_IOWR(0xA3, struct drm_mode_crtc)
+#define DRM_IOCTL_MODE_ADDFB            DRM_IOWR(0xA4, struct drm_mode_fb_cmd)
+#define DRM_IOCTL_MODE_RMFB             DRM_IOWR(0xA5, unsigned int)
+#define DRM_IOCTL_MODE_GETFB            DRM_IOWR(0xA6, struct drm_mode_fb_cmd)
+
+#define DRM_IOCTL_MODE_ADDMODE         DRM_IOWR(0xA7, struct drm_mode_modeinfo)
+#define DRM_IOCTL_MODE_RMMODE          DRM_IOWR(0xA8, unsigned int)
+#define DRM_IOCTL_MODE_ATTACHMODE      DRM_IOWR(0xA9, struct drm_mode_mode_cmd)
+#define DRM_IOCTL_MODE_DETACHMODE      DRM_IOWR(0xAA, struct drm_mode_mode_cmd)
 
+#define DRM_IOCTL_MODE_GETPROPERTY     DRM_IOWR(0xAB, struct drm_mode_get_property)
 /*@}*/
 
 /**
@@ -930,4 +1138,52 @@
 #define DRM_COMMAND_BASE                0x40
 #define DRM_COMMAND_END                 0xA0
 
+/* typedef area */
+#if !defined(__KERNEL__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
+typedef struct drm_clip_rect drm_clip_rect_t;
+typedef struct drm_tex_region drm_tex_region_t;
+typedef struct drm_hw_lock drm_hw_lock_t;
+typedef struct drm_version drm_version_t;
+typedef struct drm_unique drm_unique_t;
+typedef struct drm_list drm_list_t;
+typedef struct drm_block drm_block_t;
+typedef struct drm_control drm_control_t;
+typedef enum drm_map_type drm_map_type_t;
+typedef enum drm_map_flags drm_map_flags_t;
+typedef struct drm_ctx_priv_map drm_ctx_priv_map_t;
+typedef struct drm_map drm_map_t;
+typedef struct drm_client drm_client_t;
+typedef enum drm_stat_type drm_stat_type_t;
+typedef struct drm_stats drm_stats_t;
+typedef enum drm_lock_flags drm_lock_flags_t;
+typedef struct drm_lock drm_lock_t;
+typedef enum drm_dma_flags drm_dma_flags_t;
+typedef struct drm_buf_desc drm_buf_desc_t;
+typedef struct drm_buf_info drm_buf_info_t;
+typedef struct drm_buf_free drm_buf_free_t;
+typedef struct drm_buf_pub drm_buf_pub_t;
+typedef struct drm_buf_map drm_buf_map_t;
+typedef struct drm_dma drm_dma_t;
+typedef union drm_wait_vblank drm_wait_vblank_t;
+typedef struct drm_agp_mode drm_agp_mode_t;
+typedef enum drm_ctx_flags drm_ctx_flags_t;
+typedef struct drm_ctx drm_ctx_t;
+typedef struct drm_ctx_res drm_ctx_res_t;
+typedef struct drm_draw drm_draw_t;
+typedef struct drm_update_draw drm_update_draw_t;
+typedef struct drm_auth drm_auth_t;
+typedef struct drm_irq_busid drm_irq_busid_t;
+typedef enum drm_vblank_seq_type drm_vblank_seq_type_t;
+typedef struct drm_agp_buffer drm_agp_buffer_t;
+typedef struct drm_agp_binding drm_agp_binding_t;
+typedef struct drm_agp_info drm_agp_info_t;
+typedef struct drm_scatter_gather drm_scatter_gather_t;
+typedef struct drm_set_version drm_set_version_t;
+
+typedef struct drm_fence_arg drm_fence_arg_t;
+typedef struct drm_mm_type_arg drm_mm_type_arg_t;
+typedef struct drm_mm_init_arg drm_mm_init_arg_t;
+typedef enum drm_bo_type drm_bo_type_t;
+#endif
+
 #endif
Index: git/shared-core/drm_pciids.txt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/drm_pciids.txt	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,744 @@
+[radeon]
+0x1002 0x3150 CHIP_RV380|RADEON_IS_MOBILITY "ATI Radeon Mobility X600 M24"
+0x1002 0x3152 CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI Radeon Mobility X300 M24"
+0x1002 0x3154 CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI FireGL M24 GL"
+0x1002 0x3E50 CHIP_RV380|RADEON_NEW_MEMMAP "ATI Radeon RV380 X600"
+0x1002 0x3E54 CHIP_RV380|RADEON_NEW_MEMMAP "ATI FireGL V3200 RV380"
+0x1002 0x4136 CHIP_RS100|RADEON_IS_IGP "ATI Radeon RS100 IGP 320"
+0x1002 0x4137 CHIP_RS200|RADEON_IS_IGP "ATI Radeon RS200 IGP 340"
+0x1002 0x4144 CHIP_R300 "ATI Radeon AD 9500"
+0x1002 0x4145 CHIP_R300 "ATI Radeon AE 9700 Pro"
+0x1002 0x4146 CHIP_R300 "ATI Radeon AF R300 9600TX"
+0x1002 0x4147 CHIP_R300 "ATI FireGL AG Z1"
+0x1002 0x4148 CHIP_R350 "ATI Radeon AH 9800 SE"
+0x1002 0x4149 CHIP_R350 "ATI Radeon AI 9800"
+0x1002 0x414A CHIP_R350 "ATI Radeon AJ 9800"
+0x1002 0x414B CHIP_R350 "ATI FireGL AK X2"
+0x1002 0x4150 CHIP_RV350 "ATI Radeon AP 9600"
+0x1002 0x4151 CHIP_RV350 "ATI Radeon AQ 9600 SE"
+0x1002 0x4152 CHIP_RV350 "ATI Radeon AR 9600 XT"
+0x1002 0x4153 CHIP_RV350 "ATI Radeon AS 9550"
+0x1002 0x4154 CHIP_RV350 "ATI FireGL AT T2"
+0x1002 0x4155 CHIP_RV350 "ATI Radeon 9650"
+0x1002 0x4156 CHIP_RV350 "ATI FireGL AV RV360 T2"
+0x1002 0x4237 CHIP_RS200|RADEON_IS_IGP "ATI Radeon RS250 IGP"
+0x1002 0x4242 CHIP_R200 "ATI Radeon BB R200 AIW 8500DV"
+0x1002 0x4243 CHIP_R200 "ATI Radeon BC R200"
+0x1002 0x4336 CHIP_RS100|RADEON_IS_IGP|RADEON_IS_MOBILITY "ATI Radeon RS100 Mobility U1"
+0x1002 0x4337 CHIP_RS200|RADEON_IS_IGP|RADEON_IS_MOBILITY "ATI Radeon RS200 Mobility IGP 340M"
+0x1002 0x4437 CHIP_RS200|RADEON_IS_IGP|RADEON_IS_MOBILITY "ATI Radeon RS250 Mobility IGP"
+0x1002 0x4966 CHIP_RV250 "ATI Radeon If RV250 9000"
+0x1002 0x4967 CHIP_RV250 "ATI Radeon Ig RV250 9000"
+0x1002 0x4A48 CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon JH R420 X800"
+0x1002 0x4A49 CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon JI R420 X800 Pro"
+0x1002 0x4A4A CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon JJ R420 X800 SE"
+0x1002 0x4A4B CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon JK R420 X800 XT"
+0x1002 0x4A4C CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon JL R420 X800"
+0x1002 0x4A4D CHIP_R420|RADEON_NEW_MEMMAP "ATI FireGL JM X3-256"
+0x1002 0x4A4E CHIP_R420|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI Radeon JN R420 Mobility M18"
+0x1002 0x4A4F CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon JO R420 X800 SE"
+0x1002 0x4A50 CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon JP R420 X800 XT PE"
+0x1002 0x4A54 CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon JT R420 AIW X800 VE"
+0x1002 0x4B49 CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R481 X850 XT"
+0x1002 0x4B4A CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R481 X850 SE"
+0x1002 0x4B4B CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R481 X850 Pro"
+0x1002 0x4B4C CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R481 X850 XT PE"
+0x1002 0x4C57 CHIP_RV200|RADEON_IS_MOBILITY "ATI Radeon LW RV200 Mobility 7500 M7"
+0x1002 0x4C58 CHIP_RV200|RADEON_IS_MOBILITY "ATI Radeon LX RV200 Mobility FireGL 7800 M7"
+0x1002 0x4C59 CHIP_RV100|RADEON_IS_MOBILITY "ATI Radeon LY RV100 Mobility M6"
+0x1002 0x4C5A CHIP_RV100|RADEON_IS_MOBILITY "ATI Radeon LZ RV100 Mobility M6"
+0x1002 0x4C64 CHIP_RV250|RADEON_IS_MOBILITY "ATI Radeon Ld RV250 Mobility 9000 M9"
+0x1002 0x4C66 CHIP_RV250 "ATI Radeon Lf RV250 Mobility 9000 M9 / FireMV 2400 PCI"
+0x1002 0x4C67 CHIP_RV250|RADEON_IS_MOBILITY "ATI Radeon Lg RV250 Mobility 9000 M9"
+0x1002 0x4E44 CHIP_R300 "ATI Radeon ND R300 9700 Pro"
+0x1002 0x4E45 CHIP_R300 "ATI Radeon NE R300 9500 Pro / 9700"
+0x1002 0x4E46 CHIP_R300 "ATI Radeon NF R300 9600TX"
+0x1002 0x4E47 CHIP_R300 "ATI Radeon NG R300 FireGL X1"
+0x1002 0x4E48 CHIP_R350 "ATI Radeon NH R350 9800 Pro"
+0x1002 0x4E49 CHIP_R350 "ATI Radeon NI R350 9800"
+0x1002 0x4E4A CHIP_R350 "ATI Radeon NJ R360 9800 XT"
+0x1002 0x4E4B CHIP_R350 "ATI FireGL NK X2"
+0x1002 0x4E50 CHIP_RV350|RADEON_IS_MOBILITY "ATI Radeon RV350 Mobility 9600 M10 NP"
+0x1002 0x4E51 CHIP_RV350|RADEON_IS_MOBILITY "ATI Radeon RV350 Mobility 9600 M10 NQ"
+0x1002 0x4E52 CHIP_RV350|RADEON_IS_MOBILITY "ATI Radeon RV350 Mobility 9600 M11 NR"
+0x1002 0x4E53 CHIP_RV350|RADEON_IS_MOBILITY "ATI Radeon RV350 Mobility 9600 M10 NS"
+0x1002 0x4E54 CHIP_RV350|RADEON_IS_MOBILITY "ATI FireGL T2/T2e"
+0x1002 0x4E56 CHIP_RV350|RADEON_IS_MOBILITY "ATI Radeon Mobility 9550"
+0x1002 0x5144 CHIP_R100|RADEON_SINGLE_CRTC "ATI Radeon QD R100"
+0x1002 0x5145 CHIP_R100|RADEON_SINGLE_CRTC "ATI Radeon QE R100"
+0x1002 0x5146 CHIP_R100|RADEON_SINGLE_CRTC "ATI Radeon QF R100"
+0x1002 0x5147 CHIP_R100|RADEON_SINGLE_CRTC "ATI Radeon QG R100"
+0x1002 0x5148 CHIP_R200 "ATI Radeon QH R200 8500"
+0x1002 0x514C CHIP_R200 "ATI Radeon QL R200 8500 LE"
+0x1002 0x514D CHIP_R200 "ATI Radeon QM R200 9100"
+0x1002 0x5157 CHIP_RV200 "ATI Radeon QW RV200 7500"
+0x1002 0x5158 CHIP_RV200 "ATI Radeon QX RV200 7500"
+0x1002 0x5159 CHIP_RV100 "ATI Radeon QY RV100 7000/VE"
+0x1002 0x515A CHIP_RV100 "ATI Radeon QZ RV100 7000/VE"
+0x1002 0x515E CHIP_RV100 "ATI ES1000 RN50"
+0x1002 0x5460 CHIP_RV380|RADEON_IS_MOBILITY "ATI Radeon Mobility X300 M22"
+0x1002 0x5462 CHIP_RV380|RADEON_IS_MOBILITY "ATI Radeon Mobility X600 SE M24C"
+0x1002 0x5464 CHIP_RV380|RADEON_IS_MOBILITY "ATI FireGL M22 GL 5464"
+0x1002 0x5548 CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R423 X800"
+0x1002 0x5549 CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R423 X800 Pro"
+0x1002 0x554A CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R423 X800 XT PE"
+0x1002 0x554B CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R423 X800 SE"
+0x1002 0x554C CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R430 X800 XTP"
+0x1002 0x554D CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R430 X800 XL"
+0x1002 0x554E CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R430 X800 SE"
+0x1002 0x554F CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R430 X800"
+0x1002 0x5550 CHIP_R420|RADEON_NEW_MEMMAP "ATI FireGL V7100 R423"
+0x1002 0x5551 CHIP_R420|RADEON_NEW_MEMMAP "ATI FireGL V5100 R423 UQ"
+0x1002 0x5552 CHIP_R420|RADEON_NEW_MEMMAP "ATI FireGL unknown R423 UR"
+0x1002 0x5554 CHIP_R420|RADEON_NEW_MEMMAP "ATI FireGL unknown R423 UT"
+0x1002 0x564A CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI Mobility FireGL V5000 M26"
+0x1002 0x564B CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI Mobility FireGL V5000 M26"
+0x1002 0x564F CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI Radeon Mobility X700 XL M26"
+0x1002 0x5652 CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI Radeon Mobility X700 M26"
+0x1002 0x5653 CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI Radeon Mobility X700 M26"
+0x1002 0x5834 CHIP_RS300|RADEON_IS_IGP "ATI Radeon RS300 9100 IGP"
+0x1002 0x5835 CHIP_RS300|RADEON_IS_IGP|RADEON_IS_MOBILITY "ATI Radeon RS300 Mobility IGP"
+0x1002 0x5954 CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART "ATI RS480 XPRESS 200G"
+0x1002 0x5955 CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART "ATI Radeon XPRESS 200M 5955"
+0x1002 0x5974 CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART "ATI Radeon RS482 XPRESS 200"
+0x1002 0x5975 CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART "ATI Radeon RS485 XPRESS 1100 IGP"
+0x1002 0x5960 CHIP_RV280 "ATI Radeon RV280 9250"
+0x1002 0x5961 CHIP_RV280 "ATI Radeon RV280 9200"
+0x1002 0x5962 CHIP_RV280 "ATI Radeon RV280 9200"
+0x1002 0x5964 CHIP_RV280 "ATI Radeon RV280 9200 SE"
+0x1002 0x5965 CHIP_RV280 "ATI FireMV 2200 PCI"
+0x1002 0x5969 CHIP_RV100 "ATI ES1000 RN50"
+0x1002 0x5a41 CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART "ATI Radeon RS400 XPRESS 200"
+0x1002 0x5a42 CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART "ATI Radeon RS400 XPRESS 200M"
+0x1002 0x5a61 CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART "ATI Radeon RC410 XPRESS 200"
+0x1002 0x5a62 CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART "ATI Radeon RC410 XPRESS 200M"
+0x1002 0x5b60 CHIP_RV380|RADEON_NEW_MEMMAP "ATI Radeon RV370 X300 SE"
+0x1002 0x5b62 CHIP_RV380|RADEON_NEW_MEMMAP "ATI Radeon RV370 X600 Pro"
+0x1002 0x5b63 CHIP_RV380|RADEON_NEW_MEMMAP "ATI Radeon RV370 X550"
+0x1002 0x5b64 CHIP_RV380|RADEON_NEW_MEMMAP "ATI FireGL V3100 (RV370) 5B64"
+0x1002 0x5b65 CHIP_RV380|RADEON_NEW_MEMMAP "ATI FireMV 2200 PCIE (RV370) 5B65"
+0x1002 0x5c61 CHIP_RV280|RADEON_IS_MOBILITY "ATI Radeon RV280 Mobility"
+0x1002 0x5c63 CHIP_RV280|RADEON_IS_MOBILITY "ATI Radeon RV280 Mobility"
+0x1002 0x5d48 CHIP_R420|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI Mobility Radeon X800 XT M28"
+0x1002 0x5d49 CHIP_R420|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI Mobility FireGL V5100 M28"
+0x1002 0x5d4a CHIP_R420|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI Mobility Radeon X800 M28"
+0x1002 0x5d4c CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R480 X850"
+0x1002 0x5d4d CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R480 X850 XT PE"
+0x1002 0x5d4e CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R480 X850 SE"
+0x1002 0x5d4f CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R480 X850 Pro"
+0x1002 0x5d50 CHIP_R420|RADEON_NEW_MEMMAP "ATI unknown Radeon / FireGL R480"
+0x1002 0x5d52 CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R480 X850 XT"
+0x1002 0x5d57 CHIP_R420|RADEON_NEW_MEMMAP "ATI Radeon R423 X800 XT"
+0x1002 0x5e48 CHIP_RV410|RADEON_NEW_MEMMAP "ATI FireGL V5000 RV410"
+0x1002 0x5e4a CHIP_RV410|RADEON_NEW_MEMMAP "ATI Radeon RV410 X700 XT"
+0x1002 0x5e4b CHIP_RV410|RADEON_NEW_MEMMAP "ATI Radeon RV410 X700 Pro"
+0x1002 0x5e4c CHIP_RV410|RADEON_NEW_MEMMAP "ATI Radeon RV410 X700 SE"
+0x1002 0x5e4d CHIP_RV410|RADEON_NEW_MEMMAP "ATI Radeon RV410 X700"
+0x1002 0x5e4f CHIP_RV410|RADEON_NEW_MEMMAP "ATI Radeon RV410 X700 SE"
+0x1002 0x7834 CHIP_RS300|RADEON_IS_IGP|RADEON_NEW_MEMMAP "ATI Radeon RS350 9000/9100 IGP"
+0x1002 0x7835 CHIP_RS300|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP "ATI Radeon RS350 Mobility IGP"
+
+[r128]
+0x1002 0x4c45 0 "ATI Rage 128 Mobility LE (PCI)"
+0x1002 0x4c46 0 "ATI Rage 128 Mobility LF (AGP)"
+0x1002 0x4d46 0 "ATI Rage 128 Mobility MF (AGP)"
+0x1002 0x4d4c 0 "ATI Rage 128 Mobility ML (AGP)"
+0x1002 0x5041 0 "ATI Rage 128 Pro PA (PCI)"
+0x1002 0x5042 0 "ATI Rage 128 Pro PB (AGP)"
+0x1002 0x5043 0 "ATI Rage 128 Pro PC (AGP)"
+0x1002 0x5044 0 "ATI Rage 128 Pro PD (PCI)"
+0x1002 0x5045 0 "ATI Rage 128 Pro PE (AGP)"
+0x1002 0x5046 0 "ATI Rage 128 Pro PF (AGP)"
+0x1002 0x5047 0 "ATI Rage 128 Pro PG (PCI)"
+0x1002 0x5048 0 "ATI Rage 128 Pro PH (AGP)"
+0x1002 0x5049 0 "ATI Rage 128 Pro PI (AGP)"
+0x1002 0x504A 0 "ATI Rage 128 Pro PJ (PCI)"
+0x1002 0x504B 0 "ATI Rage 128 Pro PK (AGP)"
+0x1002 0x504C 0 "ATI Rage 128 Pro PL (AGP)"
+0x1002 0x504D 0 "ATI Rage 128 Pro PM (PCI)"
+0x1002 0x504E 0 "ATI Rage 128 Pro PN (AGP)"
+0x1002 0x504F 0 "ATI Rage 128 Pro PO (AGP)"
+0x1002 0x5050 0 "ATI Rage 128 Pro PP (PCI)"
+0x1002 0x5051 0 "ATI Rage 128 Pro PQ (AGP)"
+0x1002 0x5052 0 "ATI Rage 128 Pro PR (PCI)"
+0x1002 0x5053 0 "ATI Rage 128 Pro PS (PCI)"
+0x1002 0x5054 0 "ATI Rage 128 Pro PT (AGP)"
+0x1002 0x5055 0 "ATI Rage 128 Pro PU (AGP)"
+0x1002 0x5056 0 "ATI Rage 128 Pro PV (PCI)"
+0x1002 0x5057 0 "ATI Rage 128 Pro PW (AGP)"
+0x1002 0x5058 0 "ATI Rage 128 Pro PX (AGP)"
+0x1002 0x5245 0 "ATI Rage 128 RE (PCI)"
+0x1002 0x5246 0 "ATI Rage 128 RF (AGP)"
+0x1002 0x5247 0 "ATI Rage 128 RG (AGP)"
+0x1002 0x524b 0 "ATI Rage 128 RK (PCI)"
+0x1002 0x524c 0 "ATI Rage 128 RL (AGP)"
+0x1002 0x534d 0 "ATI Rage 128 SM (AGP)"
+0x1002 0x5446 0 "ATI Rage 128 Pro Ultra TF (AGP)"
+0x1002 0x544C 0 "ATI Rage 128 Pro Ultra TL (AGP)"
+0x1002 0x5452 0 "ATI Rage 128 Pro Ultra TR (AGP)"
+
+[mga]
+0x102b 0x0520 MGA_CARD_TYPE_G200 "Matrox G200 (PCI)"
+0x102b 0x0521 MGA_CARD_TYPE_G200 "Matrox G200 (AGP)"
+0x102b 0x0525 MGA_CARD_TYPE_G400 "Matrox G400/G450 (AGP)"
+0x102b 0x2527 MGA_CARD_TYPE_G550 "Matrox G550 (AGP)"
+
+[mach64]
+0x1002 0x4749 0 "3D Rage Pro"
+0x1002 0x4750 0 "3D Rage Pro 215GP"
+0x1002 0x4751 0 "3D Rage Pro 215GQ"
+0x1002 0x4742 0 "3D Rage Pro AGP 1X/2X"
+0x1002 0x4744 0 "3D Rage Pro AGP 1X"
+0x1002 0x4c49 0 "3D Rage LT Pro"
+0x1002 0x4c50 0 "3D Rage LT Pro"
+0x1002 0x4c51 0 "3D Rage LT Pro"
+0x1002 0x4c42 0 "3D Rage LT Pro AGP-133"
+0x1002 0x4c44 0 "3D Rage LT Pro AGP-66"
+0x1002 0x474c 0 "Rage XC"
+0x1002 0x474f 0 "Rage XL"
+0x1002 0x4752 0 "Rage XL"
+0x1002 0x4753 0 "Rage XC"
+0x1002 0x474d 0 "Rage XL AGP 2X"
+0x1002 0x474e 0 "Rage XC AGP"
+0x1002 0x4c52 0 "Rage Mobility P/M"
+0x1002 0x4c53 0 "Rage Mobility L"
+0x1002 0x4c4d 0 "Rage Mobility P/M AGP 2X"
+0x1002 0x4c4e 0 "Rage Mobility L AGP 2X"
+
+[sis]
+0x1039 0x0300 0 "SiS 300/305"
+0x1039 0x5300 0 "SiS 540"
+0x1039 0x6300 0 "SiS 630"
+0x1039 0x6330 SIS_CHIP_315 "SiS 661"
+0x1039 0x7300 0 "SiS 730"
+0x18CA 0x0040 SIS_CHIP_315 "Volari V3XT/V5/V8"
+0x18CA 0x0042 SIS_CHIP_315 "Volari Unknown"
+
+[tdfx]
+0x121a 0x0003 0 "3dfx Voodoo Banshee"
+0x121a 0x0004 0 "3dfx Voodoo3 2000"
+0x121a 0x0005 0 "3dfx Voodoo3 3000"
+0x121a 0x0007 0 "3dfx Voodoo4 4500"
+0x121a 0x0009 0 "3dfx Voodoo5 5500"
+0x121a 0x000b 0 "3dfx Voodoo4 4200"
+
+[viadrv]
+0x1106 0x3022 0 "VIA CLE266 3022"
+0x1106 0x3118 VIA_PRO_GROUP_A "VIA CN400 / PM8X0"
+0x1106 0x3122 0 "VIA CLE266"
+0x1106 0x7205 0 "VIA KM400"
+0x1106 0x3108 0 "VIA K8M800"
+0x1106 0x3344 0 "VIA CN700 / VM800 / P4M800Pro"
+0x1106 0x3343 0 "VIA P4M890"
+0x1106 0x3230 VIA_DX9_0 "VIA K8M890"
+0x1106 0x3157 VIA_PRO_GROUP_A "VIA CX700"
+
+[i810]
+0x8086 0x7121 0 "Intel i810 GMCH"
+0x8086 0x7123 0 "Intel i810-DC100 GMCH"
+0x8086 0x7125 0 "Intel i810E GMCH"
+0x8086 0x1132 0 "Intel i815 GMCH"
+
+[i830]
+0x8086 0x3577 0 "Intel i830M GMCH"
+0x8086 0x2562 0 "Intel i845G GMCH"
+0x8086 0x3582 0 "Intel i852GM/i855GM GMCH"
+0x8086 0x2572 0 "Intel i865G GMCH"
+
+[gamma]
+0x3d3d 0x0008 0 "3DLabs GLINT Gamma G1"
+
+[savage]
+0x5333 0x8a20 S3_SAVAGE3D "Savage 3D"
+0x5333 0x8a21 S3_SAVAGE3D "Savage 3D/MV"
+0x5333 0x8a22 S3_SAVAGE4 "Savage4"
+0x5333 0x8a23 S3_SAVAGE4 "Savage4"
+0x5333 0x8c10 S3_SAVAGE_MX "Savage/MX-MV"
+0x5333 0x8c11 S3_SAVAGE_MX "Savage/MX"
+0x5333 0x8c12 S3_SAVAGE_MX "Savage/IX-MV"
+0x5333 0x8c13 S3_SAVAGE_MX "Savage/IX"
+0x5333 0x8c22 S3_SUPERSAVAGE "SuperSavage MX/128"
+0x5333 0x8c24 S3_SUPERSAVAGE "SuperSavage MX/64"
+0x5333 0x8c26 S3_SUPERSAVAGE "SuperSavage MX/64C"
+0x5333 0x8c2a S3_SUPERSAVAGE "SuperSavage IX/128 SDR"
+0x5333 0x8c2b S3_SUPERSAVAGE "SuperSavage IX/128 DDR"
+0x5333 0x8c2c S3_SUPERSAVAGE "SuperSavage IX/64 SDR"
+0x5333 0x8c2d S3_SUPERSAVAGE "SuperSavage IX/64 DDR"
+0x5333 0x8c2e S3_SUPERSAVAGE "SuperSavage IX/C SDR"
+0x5333 0x8c2f S3_SUPERSAVAGE "SuperSavage IX/C DDR"
+0x5333 0x8a25 S3_PROSAVAGE "ProSavage PM133"
+0x5333 0x8a26 S3_PROSAVAGE "ProSavage KM133"
+0x5333 0x8d01 S3_TWISTER "ProSavage Twister PN133"
+0x5333 0x8d02 S3_TWISTER "ProSavage Twister KN133"
+0x5333 0x8d03 S3_PROSAVAGEDDR "ProSavage DDR"
+0x5333 0x8d04 S3_PROSAVAGEDDR "ProSavage DDR-K"
+
+[ffb]
+
+[i915]
+0x8086 0x3577 CHIP_I8XX "Intel i830M GMCH"
+0x8086 0x2562 CHIP_I8XX "Intel i845G GMCH"
+0x8086 0x3582 CHIP_I8XX "Intel i852GM/i855GM GMCH"
+0x8086 0x2572 CHIP_I8XX "Intel i865G GMCH"
+0x8086 0x2582 CHIP_I9XX|CHIP_I915 "Intel i915G"
+0x8086 0x2592 CHIP_I9XX|CHIP_I915 "Intel i915GM"
+0x8086 0x2772 CHIP_I9XX|CHIP_I915 "Intel i945G"
+0x8086 0x27A2 CHIP_I9XX|CHIP_I915 "Intel i945GM"
+0x8086 0x27AE CHIP_I9XX|CHIP_I915 "Intel i945GME"
+0x8086 0x2972 CHIP_I9XX|CHIP_I965 "Intel i946GZ"
+0x8086 0x2982 CHIP_I9XX|CHIP_I965 "Intel i965G"
+0x8086 0x2992 CHIP_I9XX|CHIP_I965 "Intel i965Q"
+0x8086 0x29A2 CHIP_I9XX|CHIP_I965 "Intel i965G"
+0x8086 0x2A02 CHIP_I9XX|CHIP_I965 "Intel i965GM"
+0x8086 0x2A12 CHIP_I9XX|CHIP_I965 "Intel i965GME/GLE"
+0x8086 0x29C2 CHIP_I9XX|CHIP_I915 "Intel G33"
+0x8086 0x29B2 CHIP_I9XX|CHIP_I915 "Intel Q35"
+0x8086 0x29D2 CHIP_I9XX|CHIP_I915 "Intel Q33"
+
+[psb]
+0x8086 0x8108 CHIP_PSB_8108 "Intel Poulsbo"
+
+[imagine]
+0x105d 0x2309 IMAGINE_128 "Imagine 128"
+0x105d 0x2339 IMAGINE_128_2 "Imagine 128-II"
+0x105d 0x493d IMAGINE_T2R "Ticket to Ride"
+0x105d 0x5348 IMAGINE_REV4 "Revolution IV"
+
+[nv]
+0x10DE 0x0020 NV04 "NVidia RIVA TNT"
+0x10DE 0x0028 NV04 "NVidia RIVA TNT2"
+0x10DE 0x002A NV04 "NVidia Unknown TNT2"
+0x10DE 0x002C NV04 "NVidia Vanta"
+0x10DE 0x0029 NV04 "NVidia RIVA TNT2 Ultra"
+0x10DE 0x002D NV04 "NVidia RIVA TNT2 Model 64"
+0x10DE 0x00A0 NV04 "NVidia Aladdin TNT2"
+0x10DE 0x0100 NV10 "NVidia GeForce 256"
+0x10DE 0x0101 NV10 "NVidia GeForce DDR"
+0x10DE 0x0103 NV10 "NVidia Quadro"
+0x10DE 0x0110 NV10 "NVidia GeForce2 MX/MX 400"
+0x10DE 0x0111 NV10 "NVidia GeForce2 MX 100/200"
+0x10DE 0x0112 NV10 "NVidia GeForce2 Go"
+0x10DE 0x0113 NV10 "NVidia Quadro2 MXR/EX/Go"
+0x10DE 0x0150 NV10 "NVidia GeForce2 GTS"
+0x10DE 0x0151 NV10 "NVidia GeForce2 Ti"
+0x10DE 0x0152 NV10 "NVidia GeForce2 Ultra"
+0x10DE 0x0153 NV10 "NVidia Quadro2 Pro"
+0x10DE 0x0170 NV10 "NVidia GeForce4 MX 460"
+0x10DE 0x0171 NV10 "NVidia GeForce4 MX 440"
+0x10DE 0x0172 NV10 "NVidia GeForce4 MX 420"
+0x10DE 0x0173 NV10 "NVidia GeForce4 MX 440-SE"
+0x10DE 0x0174 NV10 "NVidia GeForce4 440 Go"
+0x10DE 0x0175 NV10 "NVidia GeForce4 420 Go"
+0x10DE 0x0176 NV10 "NVidia GeForce4 420 Go 32M"
+0x10DE 0x0177 NV10 "NVidia GeForce4 460 Go"
+0x10DE 0x0178 NV10 "NVidia Quadro4 550 XGL"
+0x10DE 0x0179 NV10 "NVidia GeForce4"
+0x10DE 0x017A NV10 "NVidia Quadro4 NVS"
+0x10DE 0x017C NV10 "NVidia Quadro4 500 GoGL"
+0x10DE 0x017D NV10 "NVidia GeForce4 410 Go 16M"
+0x10DE 0x0181 NV10 "NVidia GeForce4 MX 440 with AGP8X"
+0x10DE 0x0182 NV10 "NVidia GeForce4 MX 440SE with AGP8X"
+0x10DE 0x0183 NV10 "NVidia GeForce4 MX 420 with AGP8X"
+0x10DE 0x0185 NV10 "NVidia GeForce4 MX 4000"
+0x10DE 0x0186 NV10 "NVidia GeForce4 448 Go"
+0x10DE 0x0187 NV10 "NVidia GeForce4 488 Go"
+0x10DE 0x0188 NV10 "NVidia Quadro4 580 XGL"
+0x10DE 0x0189 NV10 "NVidia GeForce4 MX with AGP8X (Mac)"
+0x10DE 0x018A NV10 "NVidia Quadro4 280 NVS"
+0x10DE 0x018B NV10 "NVidia Quadro4 380 XGL"
+0x10DE 0x018C NV10 "NVidia Quadro NVS 50 PCI"
+0x10DE 0x018D NV10 "NVidia GeForce4 448 Go"
+0x10DE 0x01A0 NV10 "NVidia GeForce2 Integrated GPU"
+0x10DE 0x01F0 NV10 "NVidia GeForce4 MX Integrated GPU"
+0x10DE 0x0200 NV20 "NVidia GeForce3"
+0x10DE 0x0201 NV20 "NVidia GeForce3 Ti 200"
+0x10DE 0x0202 NV20 "NVidia GeForce3 Ti 500"
+0x10DE 0x0203 NV20 "NVidia Quadro DCC"
+0x10DE 0x0250 NV20 "NVidia GeForce4 Ti 4600"
+0x10DE 0x0251 NV20 "NVidia GeForce4 Ti 4400"
+0x10DE 0x0252 NV20 "NVidia 0x0252"
+0x10DE 0x0253 NV20 "NVidia GeForce4 Ti 4200"
+0x10DE 0x0258 NV20 "NVidia Quadro4 900 XGL"
+0x10DE 0x0259 NV20 "NVidia Quadro4 750 XGL"
+0x10DE 0x025B NV20 "NVidia Quadro4 700 XGL"
+0x10DE 0x0280 NV20 "NVidia GeForce4 Ti 4800"
+0x10DE 0x0281 NV20 "NVidia GeForce4 Ti 4200 with AGP8X"
+0x10DE 0x0282 NV20 "NVidia GeForce4 Ti 4800 SE"
+0x10DE 0x0286 NV20 "NVidia GeForce4 4200 Go"
+0x10DE 0x028C NV20 "NVidia Quadro4 700 GoGL"
+0x10DE 0x0288 NV20 "NVidia Quadro4 980 XGL"
+0x10DE 0x0289 NV20 "NVidia Quadro4 780 XGL"
+0x10DE 0x0301 NV30 "NVidia GeForce FX 5800 Ultra"
+0x10DE 0x0302 NV30 "NVidia GeForce FX 5800"
+0x10DE 0x0308 NV30 "NVidia Quadro FX 2000"
+0x10DE 0x0309 NV30 "NVidia Quadro FX 1000"
+0x10DE 0x0311 NV30 "NVidia GeForce FX 5600 Ultra"
+0x10DE 0x0312 NV30 "NVidia GeForce FX 5600"
+0x10DE 0x0313 NV30 "NVidia 0x0313"
+0x10DE 0x0314 NV30 "NVidia GeForce FX 5600SE"
+0x10DE 0x0316 NV30 "NVidia 0x0316"
+0x10DE 0x0317 NV30 "NVidia 0x0317"
+0x10DE 0x031A NV30 "NVidia GeForce FX Go5600"
+0x10DE 0x031B NV30 "NVidia GeForce FX Go5650"
+0x10DE 0x031C NV30 "NVidia Quadro FX Go700"
+0x10DE 0x031D NV30 "NVidia 0x031D"
+0x10DE 0x031E NV30 "NVidia 0x031E"
+0x10DE 0x031F NV30 "NVidia 0x031F"
+0x10DE 0x0320 NV30 "NVidia GeForce FX 5200"
+0x10DE 0x0321 NV30 "NVidia GeForce FX 5200 Ultra"
+0x10DE 0x0322 NV30 "NVidia GeForce FX 5200"
+0x10DE 0x0323 NV30 "NVidia GeForce FX 5200SE"
+0x10DE 0x0324 NV30 "NVidia GeForce FX Go5200"
+0x10DE 0x0325 NV30 "NVidia GeForce FX Go5250"
+0x10DE 0x0326 NV30 "NVidia GeForce FX 5500"
+0x10DE 0x0327 NV30 "NVidia GeForce FX 5100"
+0x10DE 0x0328 NV30 "NVidia GeForce FX Go5200 32M/64M"
+0x10DE 0x0329 NV30 "NVidia GeForce FX 5200 (Mac)"
+0x10DE 0x032A NV30 "NVidia Quadro NVS 280 PCI"
+0x10DE 0x032B NV30 "NVidia Quadro FX 500/600 PCI"
+0x10DE 0x032C NV30 "NVidia GeForce FX Go53xx Series"
+0x10DE 0x032D NV30 "NVidia GeForce FX Go5100"
+0x10DE 0x032F NV30 "NVidia 0x032F"
+0x10DE 0x0330 NV30 "NVidia GeForce FX 5900 Ultra"
+0x10DE 0x0331 NV30 "NVidia GeForce FX 5900"
+0x10DE 0x0332 NV30 "NVidia GeForce FX 5900XT"
+0x10DE 0x0333 NV30 "NVidia GeForce FX 5950 Ultra"
+0x10DE 0x033F NV30 "NVidia Quadro FX 700"
+0x10DE 0x0334 NV30 "NVidia GeForce FX 5900ZT"
+0x10DE 0x0338 NV30 "NVidia Quadro FX 3000"
+0x10DE 0x0341 NV30 "NVidia GeForce FX 5700 Ultra"
+0x10DE 0x0342 NV30 "NVidia GeForce FX 5700"
+0x10DE 0x0343 NV30 "NVidia GeForce FX 5700LE"
+0x10DE 0x0344 NV30 "NVidia GeForce FX 5700VE"
+0x10DE 0x0345 NV30 "NVidia 0x0345"
+0x10DE 0x0347 NV30 "NVidia GeForce FX Go5700"
+0x10DE 0x0348 NV30 "NVidia GeForce FX Go5700"
+0x10DE 0x0349 NV30 "NVidia 0x0349"
+0x10DE 0x034B NV30 "NVidia 0x034B"
+0x10DE 0x034C NV30 "NVidia Quadro FX Go1000"
+0x10DE 0x034E NV30 "NVidia Quadro FX 1100"
+0x10DE 0x034F NV30 "NVidia 0x034F"
+0x10DE 0x0040 NV40 "NVidia GeForce 6800 Ultra"
+0x10DE 0x0041 NV40 "NVidia GeForce 6800"
+0x10DE 0x0042 NV40 "NVidia GeForce 6800 LE"
+0x10DE 0x0043 NV40 "NVidia 0x0043"
+0x10DE 0x0045 NV40 "NVidia GeForce 6800 GT"
+0x10DE 0x0046 NV40 "NVidia GeForce 6800 GT"
+0x10DE 0x0049 NV40 "NVidia 0x0049"
+0x10DE 0x004E NV40 "NVidia Quadro FX 4000"
+0x10DE 0x00C0 NV40 "NVidia 0x00C0"
+0x10DE 0x00C1 NV40 "NVidia GeForce 6800"
+0x10DE 0x00C2 NV40 "NVidia GeForce 6800 LE"
+0x10DE 0x00C8 NV40 "NVidia GeForce Go 6800"
+0x10DE 0x00C9 NV40 "NVidia GeForce Go 6800 Ultra"
+0x10DE 0x00CC NV40 "NVidia Quadro FX Go1400"
+0x10DE 0x00CD NV40 "NVidia Quadro FX 3450/4000 SDI"
+0x10DE 0x00CE NV40 "NVidia Quadro FX 1400"
+0x10de 0x00f0 NV40 "Nvidia GeForce 6600 GT"
+0x10de 0x00f1 NV40 "Nvidia GeForce 6600 GT"
+0x10DE 0x0140 NV40 "NVidia GeForce 6600 GT"
+0x10DE 0x0141 NV40 "NVidia GeForce 6600"
+0x10DE 0x0142 NV40 "NVidia GeForce 6600 LE"
+0x10DE 0x0143 NV40 "NVidia 0x0143"
+0x10DE 0x0144 NV40 "NVidia GeForce Go 6600"
+0x10DE 0x0145 NV40 "NVidia GeForce 6610 XL"
+0x10DE 0x0146 NV40 "NVidia GeForce Go 6600 TE/6200 TE"
+0x10DE 0x0147 NV40 "NVidia GeForce 6700 XL"
+0x10DE 0x0148 NV40 "NVidia GeForce Go 6600"
+0x10DE 0x0149 NV40 "NVidia GeForce Go 6600 GT"
+0x10DE 0x014B NV40 "NVidia 0x014B"
+0x10DE 0x014C NV40 "NVidia 0x014C"
+0x10DE 0x014D NV40 "NVidia 0x014D"
+0x10DE 0x014E NV40 "NVidia Quadro FX 540"
+0x10DE 0x014F NV40 "NVidia GeForce 6200"
+0x10DE 0x0160 NV40 "NVidia 0x0160"
+0x10DE 0x0161 NV40 "NVidia GeForce 6200 TurboCache(TM)"
+0x10DE 0x0162 NV40 "NVidia GeForce 6200SE TurboCache(TM)"
+0x10DE 0x0163 NV40 "NVidia 0x0163"
+0x10DE 0x0164 NV40 "NVidia GeForce Go 6200"
+0x10DE 0x0165 NV40 "NVidia Quadro NVS 285"
+0x10DE 0x0166 NV40 "NVidia GeForce Go 6400"
+0x10DE 0x0167 NV40 "NVidia GeForce Go 6200"
+0x10DE 0x0168 NV40 "NVidia GeForce Go 6400"
+0x10DE 0x0169 NV40 "NVidia 0x0169"
+0x10DE 0x016B NV40 "NVidia 0x016B"
+0x10DE 0x016C NV40 "NVidia 0x016C"
+0x10DE 0x016D NV40 "NVidia 0x016D"
+0x10DE 0x016E NV40 "NVidia 0x016E"
+0x10DE 0x0210 NV40 "NVidia 0x0210"
+0x10DE 0x0211 NV40 "NVidia GeForce 6800"
+0x10DE 0x0212 NV40 "NVidia GeForce 6800 LE"
+0x10DE 0x0215 NV40 "NVidia GeForce 6800 GT"
+0x10DE 0x0220 NV40 "NVidia 0x0220"
+0x10DE 0x0221 NV40 "NVidia GeForce 6200"
+0x10DE 0x0222 NV40 "NVidia 0x0222"
+0x10DE 0x0228 NV40 "NVidia 0x0228"
+0x10DE 0x0090 NV40 "NVidia 0x0090"
+0x10DE 0x0091 NV40 "NVidia GeForce 7800 GTX"
+0x10DE 0x0092 NV40 "NVidia 0x0092"
+0x10DE 0x0093 NV40 "NVidia 0x0093"
+0x10DE 0x0094 NV40 "NVidia 0x0094"
+0x10DE 0x0098 NV40 "NVidia 0x0098"
+0x10DE 0x0099 NV40 "NVidia GeForce Go 7800 GTX"
+0x10DE 0x009C NV40 "NVidia 0x009C"
+0x10DE 0x009D NV40 "NVidia Quadro FX 4500"
+0x10DE 0x009E NV40 "NVidia 0x009E"
+
+[nouveau]
+0x10de 0x0020 NV_04 "RIVA TNT"
+0x10de 0x0028 NV_04 "RIVA TNT2/TNT2 Pro"
+0x10de 0x0029 NV_04 "RIVA TNT2 Ultra"
+0x10de 0x002a NV_04 "Riva TnT2"
+0x10de 0x002b NV_04 "Riva TnT2"
+0x10de 0x002c NV_04 "Vanta/Vanta LT"
+0x10de 0x002d NV_04 "RIVA TNT2 Model 64/Model 64 Pro"
+0x10de 0x002e NV_04 "Vanta"
+0x10de 0x002f NV_04 "Vanta"
+0x10de 0x0040 NV_40 "GeForce 6800 Ultra"
+0x10de 0x0041 NV_40 "GeForce 6800"
+0x10de 0x0042 NV_40 "GeForce 6800 LE"
+0x10de 0x0043 NV_40 "NV40.3"
+0x10de 0x0044 NV_40 "GeForce 6800 XT"
+0x10de 0x0045 NV_40 "GeForce 6800 GT"
+0x10de 0x0046 NV_40 "GeForce 6800 GT"
+0x10de 0x0047 NV_40 "GeForce 6800 GS"
+0x10de 0x0048 NV_40 "GeForce 6800 XT"
+0x10de 0x0049 NV_40 "NV40GL"
+0x10de 0x004d NV_40 "Quadro FX 4000"
+0x10de 0x004e NV_40 "Quadro FX 4000"
+0x10de 0x0090 NV_40 "GeForce 7800 GTX"
+0x10de 0x0091 NV_40 "GeForce 7800 GTX"
+0x10de 0x0092 NV_40 "GeForce 7800 GT"
+0x10de 0x0093 NV_40 "GeForce 7800 GS"
+0x10de 0x0095 NV_40 "GeForce 7800 SLI"
+0x10de 0x0098 NV_40 "GeForce Go 7800"
+0x10de 0x0099 NV_40 "GeForce Go 7800 GTX"
+0x10de 0x009d NV_40 "Quadro FX4500"
+0x10de 0x00a0 NV_04 "Aladdin TNT2"
+0x10de 0x00c0 NV_40 "GeForce 6800 GS"
+0x10de 0x00c1 NV_40 "GeForce 6800"
+0x10de 0x00c2 NV_40 "GeForce 6800 LE"
+0x10de 0x00c3 NV_40 "Geforce 6800 XT"
+0x10de 0x00c8 NV_40 "GeForce Go 6800"
+0x10de 0x00c9 NV_40 "GeForce Go 6800 Ultra"
+0x10de 0x00cc NV_40 "Quadro FX Go1400"
+0x10de 0x00cd NV_40 "Quadro FX 3450/4000 SDI"
+0x10de 0x00ce NV_40 "Quadro FX 1400"
+0x10de 0x00f0 NV_40 "GeForce 6800/GeForce 6800 Ultra"
+0x10de 0x00f1 NV_40 "GeForce 6600/GeForce 6600 GT"
+0x10de 0x00f2 NV_40 "GeForce 6600/GeForce 6600 GT"
+0x10de 0x00f3 NV_40 "GeForce 6200"
+0x10de 0x00f4 NV_40 "GeForce 6600 LE"
+0x10de 0x00f5 NV_40 "GeForce 7800 GS"
+0x10de 0x00f6 NV_40 "GeForce 6600 GS"
+0x10de 0x00f8 NV_40 "Quadro FX 3400/4400"
+0x10de 0x00f9 NV_40 "GeForce 6800 Ultra/GeForce 6800 GT"
+0x10de 0x00fa NV_30 "GeForce PCX 5750"
+0x10de 0x00fb NV_30 "GeForce PCX 5900"
+0x10de 0x00fc NV_30 "Quadro FX 330/GeForce PCX 5300"
+0x10de 0x00fd NV_30 "Quadro FX 330/Quadro NVS280"
+0x10de 0x00fe NV_30 "Quadro FX 1300"
+0x10de 0x00ff NV_17 "GeForce PCX 4300"
+0x10de 0x0100 NV_10 "GeForce 256 SDR"
+0x10de 0x0101 NV_10 "GeForce 256 DDR"
+0x10de 0x0103 NV_10 "Quadro"
+0x10de 0x0110 NV_11 "GeForce2 MX/MX 400"
+0x10de 0x0111 NV_11 "GeForce2 MX 100 DDR/200 DDR"
+0x10de 0x0112 NV_11 "GeForce2 Go"
+0x10de 0x0113 NV_11 "Quadro2 MXR/EX/Go"
+0x10de 0x0140 NV_40 "GeForce 6600 GT"
+0x10de 0x0141 NV_40 "GeForce 6600"
+0x10de 0x0142 NV_40 "GeForce 6600 LE"
+0x10de 0x0143 NV_40 "GeForce 6600 VE"
+0x10de 0x0144 NV_40 "GeForce Go 6600"
+0x10de 0x0145 NV_40 "GeForce 6610 XL"
+0x10de 0x0146 NV_40 "Geforce Go 6600TE/6200TE"
+0x10de 0x0147 NV_40 "GeForce 6700 XL"
+0x10de 0x0148 NV_40 "GeForce Go 6600"
+0x10de 0x0149 NV_40 "GeForce Go 6600 GT"
+0x10de 0x014a NV_40 "Quadro NVS 440"
+0x10de 0x014c NV_40 "Quadro FX 550"
+0x10de 0x014d NV_17 "Quadro FX 550"
+0x10de 0x014e NV_40 "Quadro FX 540"
+0x10de 0x014f NV_40 "GeForce 6200"
+0x10de 0x0150 NV_15 "GeForce2 GTS/Pro"
+0x10de 0x0151 NV_15 "GeForce2 Ti"
+0x10de 0x0152 NV_15 "GeForce2 Ultra, Bladerunner"
+0x10de 0x0153 NV_15 "Quadro2 Pro"
+0x10de 0x0160 NV_44 "GeForce 6500"
+0x10de 0x0161 NV_44 "GeForce 6200 TurboCache(TM)"
+0x10de 0x0162 NV_44 "GeForce 6200 SE TurboCache (TM)"
+0x10de 0x0163 NV_44 "GeForce 6200 LE"
+0x10de 0x0164 NV_44 "GeForce Go 6200"
+0x10de 0x0165 NV_44 "Quadro NVS 285"
+0x10de 0x0166 NV_44 "GeForce Go 6400"
+0x10de 0x0167 NV_44 "GeForce Go 6200 TurboCache"
+0x10de 0x0168 NV_44 "GeForce Go 6200 TurboCache"
+0x10de 0x0169 NV_44 "GeForce 6250"
+0x10de 0x0170 NV_17 "GeForce4 MX 460"
+0x10de 0x0171 NV_17 "GeForce4 MX 440"
+0x10de 0x0172 NV_17 "GeForce4 MX 420"
+0x10de 0x0173 NV_17 "GeForce4 MX 440-SE"
+0x10de 0x0174 NV_17 "GeForce4 440 Go"
+0x10de 0x0175 NV_17 "GeForce4 420 Go"
+0x10de 0x0176 NV_17 "GeForce4 420 Go 32M"
+0x10de 0x0177 NV_17 "GeForce4 460 Go"
+0x10de 0x0178 NV_17 "Quadro4 550 XGL"
+0x10de 0x0179 NV_17 "GeForce4 420 Go 32M"
+0x10de 0x017a NV_17 "Quadro4 200/400 NVS"
+0x10de 0x017b NV_17 "Quadro4 550 XGL"
+0x10de 0x017c NV_17 "Quadro4 500 GoGL"
+0x10de 0x017d NV_17 "GeForce4 410 Go 16M"
+0x10de 0x0181 NV_17 "GeForce4 MX 440 AGP 8x"
+0x10de 0x0182 NV_17 "GeForce4 MX 440SE AGP 8x"
+0x10de 0x0183 NV_17 "GeForce4 MX 420 AGP 8x"
+0x10de 0x0185 NV_17 "GeForce4 MX 4000 AGP 8x"
+0x10de 0x0186 NV_17 "GeForce4 448 Go"
+0x10de 0x0187 NV_17 "GeForce4 488 Go"
+0x10de 0x0188 NV_17 "Quadro4 580 XGL"
+0x10de 0x018a NV_17 "Quadro4 NVS AGP 8x"
+0x10de 0x018b NV_17 "Quadro4 380 XGL"
+0x10de 0x018c NV_17 "Quadro NVS 50 PCI"
+0x10de 0x018d NV_17 "GeForce4 448 Go"
+0x10de 0x0191 NV_50 "GeForce 8800 GTX"
+0x10de 0x0193 NV_50 "GeForce 8800 GTS"
+0x10de 0x0194 NV_50 "GeForce 8800 Ultra"
+0x10de 0x019d NV_50 "Quadro FX 5600"
+0x10de 0x019e NV_50 "Quadro FX 4600"
+0x10de 0x01a0 NV_11|NV_NFORCE "GeForce2 MX Integrated Graphics"
+0x10de 0x01d1 NV_44 "GeForce 7300 LE"
+0x10de 0x01d3 NV_44 "Geforce 7300 SE"
+0x10de 0x01d6 NV_44 "GeForce Go 7200"
+0x10de 0x01d7 NV_44 "Quadro NVS 110M / GeForce Go 7300"
+0x10de 0x01d8 NV_44 "GeForce Go 7400"
+0x10de 0x01d9 NV_44 "GeForce Go 7400 GS"
+0x10de 0x01da NV_44 "Quadro NVS 110M"
+0x10de 0x01db NV_44 "Quadro NVS 120M"
+0x10de 0x01dc NV_44 "Quadro FX 350M"
+0x10de 0x01dd NV_44 "GeForce 7500 LE"
+0x10de 0x01de NV_44 "Quadro FX 350"
+0x10de 0x01df NV_44 "GeForce 7300 GS"
+0x10de 0x01f0 NV_17|NV_NFORCE2 "GeForce4 MX - nForce GPU"
+0x10de 0x0200 NV_20 "GeForce3"
+0x10de 0x0201 NV_20 "GeForce3 Ti 200"
+0x10de 0x0202 NV_20 "GeForce3 Ti 500"
+0x10de 0x0203 NV_20 "Quadro DCC"
+0x10de 0x0211 NV_40 "GeForce 6800"
+0x10de 0x0212 NV_40 "GeForce 6800 LE"
+0x10de 0x0215 NV_40 "GeForce 6800 GT"
+0x10de 0x0218 NV_40 "GeForce 6800 XT"
+0x10de 0x0221 NV_44 "GeForce 6200"
+0x10de 0x0222 NV_44 "GeForce 6200 A-LE"
+0x10de 0x0240 NV_44 "GeForce 6150"
+0x10de 0x0241 NV_44 "GeForce 6150 LE"
+0x10de 0x0242 NV_44 "GeForce 6100"
+0x10de 0x0244 NV_44 "GeForce Go 6150"
+0x10de 0x0247 NV_44 "GeForce Go 6100"
+0x10de 0x0250 NV_25 "GeForce4 Ti 4600"
+0x10de 0x0251 NV_25 "GeForce4 Ti 4400"
+0x10de 0x0252 NV_25 "GeForce4 Ti"
+0x10de 0x0253 NV_25 "GeForce4 Ti 4200"
+0x10de 0x0258 NV_25 "Quadro4 900 XGL"
+0x10de 0x0259 NV_25 "Quadro4 750 XGL"
+0x10de 0x025b NV_25 "Quadro4 700 XGL"
+0x10de 0x0280 NV_25 "GeForce4 Ti 4800"
+0x10de 0x0281 NV_25 "GeForce4 Ti 4200 AGP 8x"
+0x10de 0x0282 NV_25 "GeForce4 Ti 4800 SE"
+0x10de 0x0286 NV_25 "GeForce4 Ti 4200 Go AGP 8x"
+0x10de 0x0288 NV_25 "Quadro4 980 XGL"
+0x10de 0x0289 NV_25 "Quadro4 780 XGL"
+0x10de 0x028c NV_25 "Quadro4 700 GoGL"
+0x10de 0x0290 NV_40 "GeForce 7900 GTX"
+0x10de 0x0291 NV_40 "GeForce 7900 GT"
+0x10de 0x0292 NV_40 "GeForce 7900 GS"
+0x10de 0x0298 NV_40 "GeForce Go 7900 GS"
+0x10de 0x0299 NV_40 "GeForce Go 7900 GTX"
+0x10de 0x029a NV_40 "Quadro FX 2500M"
+0x10de 0x029b NV_40 "Quadro FX 1500M"
+0x10de 0x029c NV_40 "Quadro FX 5500"
+0x10de 0x029d NV_40 "Quadro FX 3500"
+0x10de 0x029e NV_40 "Quadro FX 1500"
+0x10de 0x029f NV_40 "Quadro FX 4500 X2"
+0x10de 0x02a0 NV_20 "XGPU"
+0x10de 0x02e1 NV_40 "GeForce 7600 GS"
+0x10de 0x0300 NV_30 "GeForce FX"
+0x10de 0x0301 NV_30 "GeForce FX 5800 Ultra"
+0x10de 0x0302 NV_30 "GeForce FX 5800"
+0x10de 0x0308 NV_30 "Quadro FX 2000"
+0x10de 0x0309 NV_30 "Quadro FX 1000"
+0x10de 0x0311 NV_30 "GeForce FX 5600 Ultra"
+0x10de 0x0312 NV_30 "GeForce FX 5600"
+0x10de 0x0313 NV_30 "NV31"
+0x10de 0x0314 NV_30 "GeForce FX 5600XT"
+0x10de 0x0316 NV_30 "NV31M"
+0x10de 0x0317 NV_30 "NV31M Pro"
+0x10de 0x031a NV_30 "GeForce FX Go5600"
+0x10de 0x031b NV_30 "GeForce FX Go5650"
+0x10de 0x031d NV_30 "NV31GLM"
+0x10de 0x031e NV_30 "NV31GLM Pro"
+0x10de 0x031f NV_30 "NV31GLM Pro"
+0x10de 0x0320 NV_34 "GeForce FX 5200"
+0x10de 0x0321 NV_34 "GeForce FX 5200 Ultra"
+0x10de 0x0322 NV_34 "GeForce FX 5200"
+0x10de 0x0323 NV_34 "GeForce FX 5200LE"
+0x10de 0x0324 NV_34 "GeForce FX Go5200"
+0x10de 0x0325 NV_34 "GeForce FX Go5250"
+0x10de 0x0326 NV_34 "GeForce FX 5500"
+0x10de 0x0327 NV_34 "GeForce FX 5100"
+0x10de 0x0328 NV_34 "GeForce FX Go5200 32M/64M"
+0x10de 0x0329 NV_34 "GeForce FX Go5200"
+0x10de 0x032a NV_34 "Quadro NVS 280 PCI"
+0x10de 0x032b NV_34 "Quadro FX 500/600 PCI"
+0x10de 0x032c NV_34 "GeForce FX Go 5300"
+0x10de 0x032d NV_34 "GeForce FX Go5100"
+0x10de 0x032f NV_34 "NV34GL"
+0x10de 0x0330 NV_30 "GeForce FX 5900 Ultra"
+0x10de 0x0331 NV_30 "GeForce FX 5900"
+0x10de 0x0332 NV_30 "GeForce FX 5900XT"
+0x10de 0x0333 NV_30 "GeForce FX 5950 Ultra"
+0x10de 0x0334 NV_30 "GeForce FX 5900ZT"
+0x10de 0x0338 NV_30 "Quadro FX 3000"
+0x10de 0x033f NV_30 "Quadro FX 700"
+0x10de 0x0341 NV_30 "GeForce FX 5700 Ultra"
+0x10de 0x0342 NV_30 "GeForce FX 5700"
+0x10de 0x0343 NV_30 "GeForce FX 5700LE"
+0x10de 0x0344 NV_30 "GeForce FX 5700VE"
+0x10de 0x0345 NV_30 "NV36.5"
+0x10de 0x0347 NV_30 "GeForce FX Go5700"
+0x10de 0x0348 NV_30 "GeForce FX Go5700"
+0x10de 0x0349 NV_30 "NV36M Pro"
+0x10de 0x034b NV_30 "NV36MAP"
+0x10de 0x034c NV_30 "Quadro FX Go1000"
+0x10de 0x034e NV_30 "Quadro FX 1100"
+0x10de 0x034f NV_30 "NV36GL"
+0x10de 0x0391 NV_40 "GeForce 7600 GT"
+0x10de 0x0392 NV_40 "GeForce 7600 GS"
+0x10de 0x0393 NV_40 "GeForce 7300 GT"
+0x10de 0x0394 NV_40 "GeForce 7600 LE"
+0x10de 0x0395 NV_40 "GeForce 7300 GT"
+0x10de 0x0397 NV_40 "GeForce Go 7700"
+0x10de 0x0398 NV_40 "GeForce Go 7600"
+0x10de 0x0399 NV_40 "GeForce Go 7600 GT"
+0x10de 0x039a NV_40 "Quadro NVS 300M"
+0x10de 0x039b NV_40 "GeForce Go 7900 SE"
+0x10de 0x039c NV_40 "Quadro FX 550M"
+0x10de 0x039e NV_40 "Quadro FX 560"
+0x10de 0x03d0 NV_44 "GeForce 6100 nForce 430"
+0x10de 0x03d1 NV_44 "GeForce 6100 nForce 405"
+0x10de 0x03d2 NV_44 "GeForce 6100 nForce 400"
+0x10de 0x03d5 NV_44 "GeForce 6100 nForce 420"
+0x10de 0x0400 NV_50 "GeForce 8600 GTS"
+0x10de 0x0402 NV_50 "GeForce 8600 GT"
+0x10de 0x0421 NV_50 "GeForce 8500 GT"
+0x10de 0x0422 NV_50 "GeForce 8400 GS"
+0x10de 0x0423 NV_50 "GeForce 8300 GS"
+0x10de 0x0429 NV_50 "Quadro NVS 140"
+0x12d2 0x0020 NV_04 "TNT"
+0x12d2 0x0028 NV_04 "TNT2"
+0x12d2 0x0029 NV_04 "UTNT2"
+0x12d2 0x002c NV_04 "VTNT2"
+0x12d2 0x00a0 NV_04 "ITNT2"
+
+[xgi]
+0x18ca 0x2200 0 "XP5"
+0x18ca 0x0047 0 "XP10 / XG47"
Index: git/shared-core/drm_sarea.h
===================================================================
--- git.orig/shared-core/drm_sarea.h	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/drm_sarea.h	2008-12-12 17:35:22.000000000 +0000
@@ -41,38 +41,44 @@
 #define SAREA_MAX                       0x10000	/* 64kB */
 #else
 /* Intel 830M driver needs at least 8k SAREA */
-#define SAREA_MAX                       0x2000
+#define SAREA_MAX                       0x2000UL
 #endif
 
 /** Maximum number of drawables in the SAREA */
-#define SAREA_MAX_DRAWABLES 		256
+#define SAREA_MAX_DRAWABLES		256
 
 #define SAREA_DRAWABLE_CLAIMED_ENTRY    0x80000000
 
 /** SAREA drawable */
-typedef struct drm_sarea_drawable {
+struct drm_sarea_drawable {
 	unsigned int stamp;
 	unsigned int flags;
-} drm_sarea_drawable_t;
+};
 
 /** SAREA frame */
-typedef struct drm_sarea_frame {
+struct drm_sarea_frame {
 	unsigned int x;
 	unsigned int y;
 	unsigned int width;
 	unsigned int height;
 	unsigned int fullscreen;
-} drm_sarea_frame_t;
+};
 
 /** SAREA */
-typedef struct drm_sarea {
+struct drm_sarea {
     /** first thing is always the DRM locking structure */
-	drm_hw_lock_t lock;
+	struct drm_hw_lock lock;
     /** \todo Use readers/writer lock for drm_sarea::drawable_lock */
-	drm_hw_lock_t drawable_lock;
-	drm_sarea_drawable_t drawableTable[SAREA_MAX_DRAWABLES];	/**< drawables */
-	drm_sarea_frame_t frame;	/**< frame */
+	struct drm_hw_lock drawable_lock;
+	struct drm_sarea_drawable drawableTable[SAREA_MAX_DRAWABLES];	/**< drawables */
+	struct drm_sarea_frame frame;	/**< frame */
 	drm_context_t dummy_context;
-} drm_sarea_t;
+};
+
+#ifndef __KERNEL__
+typedef struct drm_sarea_drawable drm_sarea_drawable_t;
+typedef struct drm_sarea_frame drm_sarea_frame_t;
+typedef struct drm_sarea drm_sarea_t;
+#endif
 
 #endif				/* _DRM_SAREA_H_ */
Index: git/shared-core/i915_dma.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/i915_dma.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,968 @@
+/* i915_dma.c -- DMA support for the I915 -*- linux-c -*-
+ */
+/*
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "i915_drm.h"
+#include "i915_drv.h"
+
+#define IS_I965G(dev)  (dev->pci_device == 0x2972 || \
+			dev->pci_device == 0x2982 || \
+			dev->pci_device == 0x2992 || \
+			dev->pci_device == 0x29A2 || \
+			dev->pci_device == 0x2A02 || \
+			dev->pci_device == 0x2A12)
+
+#define IS_G33(dev)    (dev->pci_device == 0x29C2 || \
+		   	dev->pci_device == 0x29B2 || \
+			dev->pci_device == 0x29D2) 
+
+/* Really want an OS-independent resettable timer.  Would like to have
+ * this loop run for (eg) 3 sec, but have the timer reset every time
+ * the head pointer changes, so that EBUSY only happens if the ring
+ * actually stalls for (eg) 3 seconds.
+ */
+int i915_wait_ring(struct drm_device * dev, int n, const char *caller)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_ring_buffer_t *ring = &(dev_priv->ring);
+	u32 last_head = I915_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
+	int i;
+
+	for (i = 0; i < 10000; i++) {
+		ring->head = I915_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
+		ring->space = ring->head - (ring->tail + 8);
+		if (ring->space < 0)
+			ring->space += ring->Size;
+		if (ring->space >= n)
+			return 0;
+
+		dev_priv->sarea_priv->perf_boxes |= I915_BOX_WAIT;
+
+		if (ring->head != last_head)
+			i = 0;
+
+		last_head = ring->head;
+		DRM_UDELAY(1);
+	}
+
+	return -EBUSY;
+}
+
+void i915_kernel_lost_context(struct drm_device * dev)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_ring_buffer_t *ring = &(dev_priv->ring);
+
+	ring->head = I915_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
+	ring->tail = I915_READ(LP_RING + RING_TAIL) & TAIL_ADDR;
+	ring->space = ring->head - (ring->tail + 8);
+	if (ring->space < 0)
+		ring->space += ring->Size;
+
+	if (ring->head == ring->tail)
+		dev_priv->sarea_priv->perf_boxes |= I915_BOX_RING_EMPTY;
+}
+
+static int i915_dma_cleanup(struct drm_device * dev)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+	/* Make sure interrupts are disabled here because the uninstall ioctl
+	 * may not have been called from userspace and after dev_private
+	 * is freed, it's too late.
+	 */
+	I915_WRITE(LP_RING + RING_LEN, 0);
+
+	if (dev->irq)
+		drm_irq_uninstall(dev);
+
+	if (dev->dev_private) {
+		drm_i915_private_t *dev_priv =
+		    (drm_i915_private_t *) dev->dev_private;
+
+		if (dev_priv->ring.virtual_start) {
+			drm_core_ioremapfree(&dev_priv->ring.map, dev);
+		}
+
+		if (dev_priv->status_page_dmah) {
+			drm_pci_free(dev, dev_priv->status_page_dmah);
+			/* Need to rewrite hardware status page */
+			I915_WRITE(0x02080, 0x1ffff000);
+		}
+		if (dev_priv->status_gfx_addr) {
+			dev_priv->status_gfx_addr = 0;
+			drm_core_ioremapfree(&dev_priv->hws_map, dev);
+			I915_WRITE(0x02080, 0x1ffff000);
+		}
+		drm_free(dev->dev_private, sizeof(drm_i915_private_t),
+			 DRM_MEM_DRIVER);
+
+		dev->dev_private = NULL;
+	}
+
+	return 0;
+}
+
+static int i915_initialize(struct drm_device * dev,
+			   drm_i915_private_t * dev_priv,
+			   drm_i915_init_t * init)
+{
+	dev_priv->sarea = drm_getsarea(dev);
+	if (!dev_priv->sarea) {
+		DRM_ERROR("can not find sarea!\n");
+		dev->dev_private = (void *)dev_priv;
+		i915_dma_cleanup(dev);
+		return -EINVAL;
+	}
+
+	memset((void *)(dev_priv->ring.virtual_start), 0, dev_priv->ring.Size);
+
+	I915_WRITE(LP_RING + RING_START, dev_priv->ring.Start);
+	I915_WRITE(LP_RING + RING_LEN, ((dev_priv->ring.Size - 4096) & RING_NR_PAGES) | (RING_NO_REPORT | RING_VALID));
+
+	dev_priv->cpp = init->cpp;
+	dev_priv->sarea_priv->pf_current_page = 0;
+
+	/* We are using separate values as placeholders for mechanisms for
+	 * private backbuffer/depthbuffer usage.
+	 */
+	dev_priv->use_mi_batchbuffer_start = 0;
+
+	/* Allow hardware batchbuffers unless told otherwise.
+	 */
+	dev_priv->allow_batchbuffer = 1;
+
+	/* Enable vblank on pipe A for older X servers
+	 */
+    	dev_priv->vblank_pipe = DRM_I915_VBLANK_PIPE_A;
+
+	/* Program Hardware Status Page */
+	if (!IS_G33(dev)) {
+		dev_priv->status_page_dmah = 
+			drm_pci_alloc(dev, PAGE_SIZE, PAGE_SIZE, 0xffffffff);
+
+		if (!dev_priv->status_page_dmah) {
+			dev->dev_private = (void *)dev_priv;
+			i915_dma_cleanup(dev);
+			DRM_ERROR("Can not allocate hardware status page\n");
+			return -ENOMEM;
+		}
+		dev_priv->hw_status_page = dev_priv->status_page_dmah->vaddr;
+		dev_priv->dma_status_page = dev_priv->status_page_dmah->busaddr;
+
+		memset(dev_priv->hw_status_page, 0, PAGE_SIZE);
+
+		I915_WRITE(0x02080, dev_priv->dma_status_page);
+	}
+	DRM_DEBUG("Enabled hardware status page\n");
+	dev->dev_private = (void *)dev_priv;
+	return 0;
+}
+
+static int i915_dma_resume(struct drm_device * dev)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	if (!dev_priv->sarea) {
+		DRM_ERROR("can not find sarea!\n");
+		return -EINVAL;
+	}
+
+	if (!dev_priv->mmio_map) {
+		DRM_ERROR("can not find mmio map!\n");
+		return -EINVAL;
+	}
+
+	if (dev_priv->ring.map.handle == NULL) {
+		DRM_ERROR("can not ioremap virtual address for"
+			  " ring buffer\n");
+		return -ENOMEM;
+	}
+
+	/* Program Hardware Status Page */
+	if (!dev_priv->hw_status_page) {
+		DRM_ERROR("Can not find hardware status page\n");
+		return -EINVAL;
+	}
+	DRM_DEBUG("hw status page @ %p\n", dev_priv->hw_status_page);
+
+	if (dev_priv->status_gfx_addr != 0)
+		I915_WRITE(0x02080, dev_priv->status_gfx_addr);
+	else
+		I915_WRITE(0x02080, dev_priv->dma_status_page);
+	DRM_DEBUG("Enabled hardware status page\n");
+
+	return 0;
+}
+
+static int i915_dma_init(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv)
+{
+	DRM_DEVICE;
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+	drm_i915_init_t init;
+	int retcode = 0;
+
+	switch (init->func) {
+	case I915_INIT_DMA:
+		retcode = i915_initialize(dev, dev_priv, &init);
+		break;
+	case I915_CLEANUP_DMA:
+		retcode = i915_dma_cleanup(dev);
+		break;
+	case I915_RESUME_DMA:
+		retcode = i915_dma_resume(dev);
+		break;
+	default:
+		retcode = -EINVAL;
+		break;
+	}
+
+	return retcode;
+}
+
+/* Implement basically the same security restrictions as hardware does
+ * for MI_BATCH_NON_SECURE.  These can be made stricter at any time.
+ *
+ * Most of the calculations below involve calculating the size of a
+ * particular instruction.  It's important to get the size right as
+ * that tells us where the next instruction to check is.  Any illegal
+ * instruction detected will be given a size of zero, which is a
+ * signal to abort the rest of the buffer.
+ */
+static int do_validate_cmd(int cmd)
+{
+	switch (((cmd >> 29) & 0x7)) {
+	case 0x0:
+		switch ((cmd >> 23) & 0x3f) {
+		case 0x0:
+			return 1;	/* MI_NOOP */
+		case 0x4:
+			return 1;	/* MI_FLUSH */
+		default:
+			return 0;	/* disallow everything else */
+		}
+		break;
+	case 0x1:
+		return 0;	/* reserved */
+	case 0x2:
+		return (cmd & 0xff) + 2;	/* 2d commands */
+	case 0x3:
+		if (((cmd >> 24) & 0x1f) <= 0x18)
+			return 1;
+
+		switch ((cmd >> 24) & 0x1f) {
+		case 0x1c:
+			return 1;
+		case 0x1d:
+			switch ((cmd >> 16) & 0xff) {
+			case 0x3:
+				return (cmd & 0x1f) + 2;
+			case 0x4:
+				return (cmd & 0xf) + 2;
+			default:
+				return (cmd & 0xffff) + 2;
+			}
+		case 0x1e:
+			if (cmd & (1 << 23))
+				return (cmd & 0xffff) + 1;
+			else
+				return 1;
+		case 0x1f:
+			if ((cmd & (1 << 23)) == 0)	/* inline vertices */
+				return (cmd & 0x1ffff) + 2;
+			else if (cmd & (1 << 17))	/* indirect random */
+				if ((cmd & 0xffff) == 0)
+					return 0;	/* unknown length, too hard */
+				else
+					return (((cmd & 0xffff) + 1) / 2) + 1;
+			else
+				return 2;	/* indirect sequential */
+		default:
+			return 0;
+		}
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int validate_cmd(int cmd)
+{
+	int ret = do_validate_cmd(cmd);
+
+/* 	printk("validate_cmd( %x ): %d\n", cmd, ret); */
+
+	return ret;
+}
+
+static int i915_emit_cmds(struct drm_device * dev, int __user * buffer,
+			  int dwords)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	int i;
+	RING_LOCALS;
+
+	if ((dwords+1) * sizeof(int) >= dev_priv->ring.Size - 8)
+		return -EINVAL;
+
+	BEGIN_LP_RING((dwords+1)&~1);
+
+	for (i = 0; i < dwords;) {
+		int cmd, sz;
+
+		if (DRM_COPY_FROM_USER_UNCHECKED(&cmd, &buffer[i], sizeof(cmd)))
+			return -EINVAL;
+
+		if ((sz = validate_cmd(cmd)) == 0 || i + sz > dwords)
+			return -EINVAL;
+
+		OUT_RING(cmd);
+
+		while (++i, --sz) {
+			if (DRM_COPY_FROM_USER_UNCHECKED(&cmd, &buffer[i],
+							 sizeof(cmd))) {
+				return -EINVAL;
+			}
+			OUT_RING(cmd);
+		}
+	}
+		
+	if (dwords & 1)
+		OUT_RING(0);
+
+	ADVANCE_LP_RING();
+		
+	return 0;
+}
+
+static int i915_emit_box(struct drm_device * dev,
+			 struct drm_clip_rect __user * boxes,
+			 int i, int DR1, int DR4)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	struct drm_clip_rect box;
+	RING_LOCALS;
+
+	if (DRM_COPY_FROM_USER_UNCHECKED(&box, &boxes[i], sizeof(box))) {
+		return -EFAULT;
+	}
+
+	if (box.y2 <= box.y1 || box.x2 <= box.x1 || box.y2 <= 0 || box.x2 <= 0) {
+		DRM_ERROR("Bad box %d,%d..%d,%d\n",
+			  box.x1, box.y1, box.x2, box.y2);
+		return -EINVAL;
+	}
+
+	if (IS_I965G(dev)) {
+		BEGIN_LP_RING(4);
+		OUT_RING(GFX_OP_DRAWRECT_INFO_I965);
+		OUT_RING((box.x1 & 0xffff) | (box.y1 << 16));
+		OUT_RING(((box.x2 - 1) & 0xffff) | ((box.y2 - 1) << 16));
+		OUT_RING(DR4);
+		ADVANCE_LP_RING();
+	} else {
+		BEGIN_LP_RING(6);
+		OUT_RING(GFX_OP_DRAWRECT_INFO);
+		OUT_RING(DR1);
+		OUT_RING((box.x1 & 0xffff) | (box.y1 << 16));
+		OUT_RING(((box.x2 - 1) & 0xffff) | ((box.y2 - 1) << 16));
+		OUT_RING(DR4);
+		OUT_RING(0);
+		ADVANCE_LP_RING();
+	}
+
+	return 0;
+}
+
+/* XXX: Emitting the counter should really be moved to part of the IRQ
+ * emit.  For now, do it in both places:
+ */
+
+void i915_emit_breadcrumb(struct drm_device *dev)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	RING_LOCALS;
+
+	if (++dev_priv->counter > BREADCRUMB_MASK) {
+		 dev_priv->counter = 1;
+		 DRM_DEBUG("Breadcrumb counter wrapped around\n");
+	}
+
+	dev_priv->sarea_priv->last_enqueue = dev_priv->counter;
+
+	BEGIN_LP_RING(4);
+	OUT_RING(CMD_STORE_DWORD_IDX);
+	OUT_RING(20);
+	OUT_RING(dev_priv->counter);
+	OUT_RING(0);
+	ADVANCE_LP_RING();
+}
+
+
+int i915_emit_mi_flush(struct drm_device *dev, uint32_t flush)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	uint32_t flush_cmd = CMD_MI_FLUSH;
+	RING_LOCALS;
+
+	flush_cmd |= flush;
+
+	i915_kernel_lost_context(dev);
+
+	BEGIN_LP_RING(4);
+	OUT_RING(flush_cmd);
+	OUT_RING(0);
+	OUT_RING(0);
+	OUT_RING(0);
+	ADVANCE_LP_RING();
+
+	return 0;
+}
+
+
+static int i915_dispatch_cmdbuffer(struct drm_device * dev,
+				   drm_i915_cmdbuffer_t * cmd)
+{
+#ifdef I915_HAVE_FENCE
+	drm_i915_private_t *dev_priv = dev->dev_private;
+#endif
+	int nbox = cmd->num_cliprects;
+	int i = 0, count, ret;
+
+	if (cmd->sz & 0x3) {
+		DRM_ERROR("alignment");
+		return -EINVAL;
+	}
+
+	i915_kernel_lost_context(dev);
+
+	count = nbox ? nbox : 1;
+
+	for (i = 0; i < count; i++) {
+		if (i < nbox) {
+			ret = i915_emit_box(dev, cmd->cliprects, i,
+					    cmd->DR1, cmd->DR4);
+			if (ret)
+				return ret;
+		}
+
+		ret = i915_emit_cmds(dev, (int __user *)cmd->buf, cmd->sz / 4);
+		if (ret)
+			return ret;
+	}
+
+	i915_emit_breadcrumb( dev );
+#ifdef I915_HAVE_FENCE
+	drm_fence_flush_old(dev, 0, dev_priv->counter);
+#endif
+	return 0;
+}
+
+static int i915_dispatch_batchbuffer(struct drm_device * dev,
+				     drm_i915_batchbuffer_t * batch)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	struct drm_clip_rect __user *boxes = batch->cliprects;
+	int nbox = batch->num_cliprects;
+	int i = 0, count;
+	RING_LOCALS;
+
+	if ((batch->start | batch->used) & 0x7) {
+		DRM_ERROR("alignment");
+		return -EINVAL;
+	}
+
+	i915_kernel_lost_context(dev);
+
+	count = nbox ? nbox : 1;
+
+	for (i = 0; i < count; i++) {
+		if (i < nbox) {
+			int ret = i915_emit_box(dev, boxes, i,
+						batch->DR1, batch->DR4);
+			if (ret)
+				return ret;
+		}
+
+		if (dev_priv->use_mi_batchbuffer_start) {
+			BEGIN_LP_RING(2);
+			if (IS_I965G(dev)) {
+				OUT_RING(MI_BATCH_BUFFER_START | (2 << 6) | MI_BATCH_NON_SECURE_I965);
+				OUT_RING(batch->start);
+			} else {
+				OUT_RING(MI_BATCH_BUFFER_START | (2 << 6));
+				OUT_RING(batch->start | MI_BATCH_NON_SECURE);
+			}
+			ADVANCE_LP_RING();
+
+		} else {
+			BEGIN_LP_RING(4);
+			OUT_RING(MI_BATCH_BUFFER);
+			OUT_RING(batch->start | MI_BATCH_NON_SECURE);
+			OUT_RING(batch->start + batch->used - 4);
+			OUT_RING(0);
+			ADVANCE_LP_RING();
+		}
+	}
+
+	i915_emit_breadcrumb( dev );
+#ifdef I915_HAVE_FENCE
+	drm_fence_flush_old(dev, 0, dev_priv->counter);
+#endif
+	return 0;
+}
+
+static void i915_do_dispatch_flip(struct drm_device * dev, int plane, int sync)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	u32 num_pages, current_page, next_page, dspbase;
+	int shift = 2 * plane, x, y;
+	RING_LOCALS;
+
+	/* Calculate display base offset */
+	num_pages = dev_priv->sarea_priv->third_handle ? 3 : 2;
+	current_page = (dev_priv->sarea_priv->pf_current_page >> shift) & 0x3;
+	next_page = (current_page + 1) % num_pages;
+
+	switch (next_page) {
+	default:
+	case 0:
+		dspbase = dev_priv->sarea_priv->front_offset;
+		break;
+	case 1:
+		dspbase = dev_priv->sarea_priv->back_offset;
+		break;
+	case 2:
+		dspbase = dev_priv->sarea_priv->third_offset;
+		break;
+	}
+
+	if (plane == 0) {
+		x = dev_priv->sarea_priv->planeA_x;
+		y = dev_priv->sarea_priv->planeA_y;
+	} else {
+		x = dev_priv->sarea_priv->planeB_x;
+		y = dev_priv->sarea_priv->planeB_y;
+	}
+
+	dspbase += (y * dev_priv->sarea_priv->pitch + x) * dev_priv->cpp;
+
+	DRM_DEBUG("plane=%d current_page=%d dspbase=0x%x\n", plane, current_page,
+		  dspbase);
+
+	BEGIN_LP_RING(4);
+	OUT_RING(sync ? 0 :
+		 (MI_WAIT_FOR_EVENT | (plane ? MI_WAIT_FOR_PLANE_B_FLIP :
+				       MI_WAIT_FOR_PLANE_A_FLIP)));
+	OUT_RING(CMD_OP_DISPLAYBUFFER_INFO | (sync ? 0 : ASYNC_FLIP) |
+		 (plane ? DISPLAY_PLANE_B : DISPLAY_PLANE_A));
+	OUT_RING(dev_priv->sarea_priv->pitch * dev_priv->cpp);
+	OUT_RING(dspbase);
+	ADVANCE_LP_RING();
+
+	dev_priv->sarea_priv->pf_current_page &= ~(0x3 << shift);
+	dev_priv->sarea_priv->pf_current_page |= next_page << shift;
+}
+
+void i915_dispatch_flip(struct drm_device * dev, int planes, int sync)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	int i;
+
+	DRM_DEBUG("%s: planes=0x%x pfCurrentPage=%d\n",
+		  __FUNCTION__,
+		  planes, dev_priv->sarea_priv->pf_current_page);
+
+	i915_emit_mi_flush(dev, MI_READ_FLUSH | MI_EXE_FLUSH);
+
+	for (i = 0; i < 2; i++)
+		if (planes & (1 << i))
+			i915_do_dispatch_flip(dev, i, sync);
+
+	i915_emit_breadcrumb(dev);
+#ifdef I915_HAVE_FENCE
+	if (!sync)
+		drm_fence_flush_old(dev, 0, dev_priv->counter);
+#endif
+}
+
+static int i915_quiescent(struct drm_device * dev)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+
+	i915_kernel_lost_context(dev);
+	return i915_wait_ring(dev, dev_priv->ring.Size - 8, __FUNCTION__);
+}
+
+static int i915_flush_ioctl(struct drm_device *dev, void *data,
+			    struct drm_file *file_priv)
+{
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	return i915_quiescent(dev);
+}
+
+static int i915_batchbuffer(struct drm_device *dev, void *data,
+			    struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+	drm_i915_sarea_t *sarea_priv = (drm_i915_sarea_t *)
+	    dev_priv->sarea_priv;
+	drm_i915_batchbuffer_t *batch = data;
+	int ret;
+
+	if (!dev_priv->allow_batchbuffer) {
+		DRM_ERROR("Batchbuffer ioctl disabled\n");
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("i915 batchbuffer, start %x used %d cliprects %d\n",
+		  batch->start, batch->used, batch->num_cliprects);
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (batch->num_cliprects && DRM_VERIFYAREA_READ(batch->cliprects,
+							batch->num_cliprects *
+							sizeof(struct drm_clip_rect)))
+		return -EFAULT;
+
+	ret = i915_dispatch_batchbuffer(dev, batch);
+
+	sarea_priv->last_dispatch = READ_BREADCRUMB(dev_priv);
+	return ret;
+}
+
+static int i915_cmdbuffer(struct drm_device *dev, void *data,
+			  struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+	drm_i915_sarea_t *sarea_priv = (drm_i915_sarea_t *)
+	    dev_priv->sarea_priv;
+	drm_i915_cmdbuffer_t *cmdbuf = data;
+	int ret;
+
+	DRM_DEBUG("i915 cmdbuffer, buf %p sz %d cliprects %d\n",
+		  cmdbuf->buf, cmdbuf->sz, cmdbuf->num_cliprects);
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (cmdbuf->num_cliprects &&
+	    DRM_VERIFYAREA_READ(cmdbuf->cliprects,
+				cmdbuf->num_cliprects *
+				sizeof(struct drm_clip_rect))) {
+		DRM_ERROR("Fault accessing cliprects\n");
+		return -EFAULT;
+	}
+
+	ret = i915_dispatch_cmdbuffer(dev, cmdbuf);
+	if (ret) {
+		DRM_ERROR("i915_dispatch_cmdbuffer failed\n");
+		return ret;
+	}
+
+	sarea_priv->last_dispatch = READ_BREADCRUMB(dev_priv);
+	return 0;
+}
+
+static int i915_do_cleanup_pageflip(struct drm_device * dev)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	int i, planes, num_pages = dev_priv->sarea_priv->third_handle ? 3 : 2;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	for (i = 0, planes = 0; i < 2; i++)
+		if (dev_priv->sarea_priv->pf_current_page & (0x3 << (2 * i))) {
+			dev_priv->sarea_priv->pf_current_page =
+				(dev_priv->sarea_priv->pf_current_page &
+				 ~(0x3 << (2 * i))) | (num_pages - 1) << (2 * i);
+
+			planes |= 1 << i;
+		}
+
+	if (planes)
+		i915_dispatch_flip(dev, planes, 0);
+
+	return 0;
+}
+
+static int i915_flip_bufs(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_i915_flip_t *param = data;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (param->planes & ~0x3) {
+		DRM_ERROR("Invalid planes 0x%x, only <= 0x3 is valid\n",
+			  param->planes);
+		return -EINVAL;
+	}
+
+	i915_dispatch_flip(dev, param->planes, 0);
+
+	return 0;
+}
+
+
+static int i915_getparam(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_getparam_t *param = data;
+	int value;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	switch (param->param) {
+	case I915_PARAM_IRQ_ACTIVE:
+		value = dev->irq ? 1 : 0;
+		break;
+	case I915_PARAM_ALLOW_BATCHBUFFER:
+		value = dev_priv->allow_batchbuffer ? 1 : 0;
+		break;
+	case I915_PARAM_LAST_DISPATCH:
+		value = READ_BREADCRUMB(dev_priv);
+		break;
+	default:
+		DRM_ERROR("Unknown parameter %d\n", param->param);
+		return -EINVAL;
+	}
+
+	if (DRM_COPY_TO_USER(param->value, &value, sizeof(int))) {
+		DRM_ERROR("DRM_COPY_TO_USER failed\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int i915_setparam(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_setparam_t *param = data;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	switch (param->param) {
+	case I915_SETPARAM_USE_MI_BATCHBUFFER_START:
+		dev_priv->use_mi_batchbuffer_start = param->value;
+		break;
+	case I915_SETPARAM_TEX_LRU_LOG_GRANULARITY:
+		dev_priv->tex_lru_log_granularity = param->value;
+		break;
+	case I915_SETPARAM_ALLOW_BATCHBUFFER:
+		dev_priv->allow_batchbuffer = param->value;
+		break;
+	default:
+		DRM_ERROR("unknown parameter %d\n", param->param);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+drm_i915_mmio_entry_t mmio_table[] = {
+	[MMIO_REGS_PS_DEPTH_COUNT] = {
+		I915_MMIO_MAY_READ|I915_MMIO_MAY_WRITE,
+		0x2350,
+		8
+	}	
+};
+
+static int mmio_table_size = sizeof(mmio_table)/sizeof(drm_i915_mmio_entry_t);
+
+static int i915_mmio(struct drm_device *dev, void *data,
+		     struct drm_file *file_priv)
+{
+	uint32_t buf[8];
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_mmio_entry_t *e;	 
+	drm_i915_mmio_t *mmio = data;
+	void __iomem *base;
+	int i;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (mmio->reg >= mmio_table_size)
+		return -EINVAL;
+
+	e = &mmio_table[mmio->reg];
+	base = (u8 *) dev_priv->mmio_map->handle + e->offset;
+
+	switch (mmio->read_write) {
+		case I915_MMIO_READ:
+			if (!(e->flag & I915_MMIO_MAY_READ))
+				return -EINVAL;
+			for (i = 0; i < e->size / 4; i++)
+				buf[i] = I915_READ(e->offset + i * 4);
+			if (DRM_COPY_TO_USER(mmio->data, buf, e->size)) {
+				DRM_ERROR("DRM_COPY_TO_USER failed\n");
+				return -EFAULT;
+			}
+			break;
+
+		case I915_MMIO_WRITE:
+			if (!(e->flag & I915_MMIO_MAY_WRITE))
+				return -EINVAL;
+			if(DRM_COPY_FROM_USER(buf, mmio->data, e->size)) {
+				DRM_ERROR("DRM_COPY_TO_USER failed\n");
+				return -EFAULT;
+			}
+			for (i = 0; i < e->size / 4; i++)
+				I915_WRITE(e->offset + i * 4, buf[i]);
+			break;
+	}
+	return 0;
+}
+
+static int i915_set_status_page(struct drm_device *dev, void *data,
+				struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_hws_addr_t *hws = data;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+	DRM_DEBUG("set status page addr 0x%08x\n", (u32)hws->addr);
+
+	dev_priv->status_gfx_addr = hws->addr & (0x1ffff<<12);
+
+	dev_priv->hws_map.offset = dev->agp->base + hws->addr;
+	dev_priv->hws_map.size = 4*1024;
+	dev_priv->hws_map.type = 0;
+	dev_priv->hws_map.flags = 0;
+	dev_priv->hws_map.mtrr = 0;
+
+	drm_core_ioremap(&dev_priv->hws_map, dev);
+	if (dev_priv->hws_map.handle == NULL) {
+		dev->dev_private = (void *)dev_priv;
+		i915_dma_cleanup(dev);
+		dev_priv->status_gfx_addr = 0;
+		DRM_ERROR("can not ioremap virtual address for"
+				" G33 hw status page\n");
+		return -ENOMEM;
+	}
+	dev_priv->hw_status_page = dev_priv->hws_map.handle;
+
+	memset(dev_priv->hw_status_page, 0, PAGE_SIZE);
+	I915_WRITE(0x02080, dev_priv->status_gfx_addr);
+	DRM_DEBUG("load hws 0x2080 with gfx mem 0x%x\n",
+			dev_priv->status_gfx_addr);
+	DRM_DEBUG("load hws at %p\n", dev_priv->hw_status_page);
+	return 0;
+}
+
+int i915_driver_load(struct drm_device *dev, unsigned long flags)
+{
+	/* i915 has 4 more counters */
+	dev->counters += 4;
+	dev->types[6] = _DRM_STAT_IRQ;
+	dev->types[7] = _DRM_STAT_PRIMARY;
+	dev->types[8] = _DRM_STAT_SECONDARY;
+	dev->types[9] = _DRM_STAT_DMA;
+
+	return 0;
+}
+
+void i915_driver_lastclose(struct drm_device * dev)
+{
+	if (dev->dev_private) {
+		drm_i915_private_t *dev_priv = dev->dev_private;
+		i915_do_cleanup_pageflip(dev);
+		i915_mem_takedown(&(dev_priv->agp_heap));
+	}
+	i915_dma_cleanup(dev);
+}
+
+void i915_driver_preclose(struct drm_device * dev, struct drm_file *file_priv)
+{
+	if (dev->dev_private) {
+		drm_i915_private_t *dev_priv = dev->dev_private;
+		i915_mem_release(dev, file_priv, dev_priv->agp_heap);
+	}
+}
+
+struct drm_ioctl_desc i915_ioctls[] = {
+	DRM_IOCTL_DEF(DRM_I915_INIT, i915_dma_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_I915_FLUSH, i915_flush_ioctl, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_I915_FLIP, i915_flip_bufs, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_I915_BATCHBUFFER, i915_batchbuffer, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_I915_IRQ_EMIT, i915_irq_emit, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_I915_IRQ_WAIT, i915_irq_wait, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_I915_GETPARAM, i915_getparam, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_I915_SETPARAM, i915_setparam, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_I915_ALLOC, i915_mem_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_I915_FREE, i915_mem_free, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_I915_INIT_HEAP, i915_mem_init_heap, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_I915_CMDBUFFER, i915_cmdbuffer, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_I915_DESTROY_HEAP,  i915_mem_destroy_heap, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY ),
+	DRM_IOCTL_DEF(DRM_I915_SET_VBLANK_PIPE,  i915_vblank_pipe_set, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY ),
+	DRM_IOCTL_DEF(DRM_I915_GET_VBLANK_PIPE,  i915_vblank_pipe_get, DRM_AUTH ),
+	DRM_IOCTL_DEF(DRM_I915_VBLANK_SWAP, i915_vblank_swap, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_I915_MMIO, i915_mmio, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_I915_HWS_ADDR, i915_set_status_page, DRM_AUTH),
+};
+
+int i915_max_ioctl = DRM_ARRAY_SIZE(i915_ioctls);
+
+/**
+ * Determine if the device really is AGP or not.
+ *
+ * All Intel graphics chipsets are treated as AGP, even if they are really
+ * PCI-e.
+ *
+ * \param dev   The device to be tested.
+ *
+ * \returns
+ * A value of 1 is always retured to indictate every i9x5 is AGP.
+ */
+int i915_driver_device_is_agp(struct drm_device * dev)
+{
+	return 1;
+}
+
+
Index: git/shared-core/i915_drm.h
===================================================================
--- git.orig/shared-core/i915_drm.h	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/i915_drm.h	2008-12-12 17:35:22.000000000 +0000
@@ -1,7 +1,7 @@
 /*
  * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
  * All Rights Reserved.
- * 
+ *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -9,11 +9,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -21,7 +21,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
+ *
  */
 
 #ifndef _I915_DRM_H_
@@ -39,7 +39,7 @@
 				 * of chars for next/prev indices */
 #define I915_LOG_MIN_TEX_REGION_SIZE 14
 
-typedef struct _drm_i915_init {
+typedef struct drm_i915_init {
 	enum {
 		I915_INIT_DMA = 0x01,
 		I915_CLEANUP_DMA = 0x02,
@@ -63,8 +63,8 @@
 	unsigned int chipset;
 } drm_i915_init_t;
 
-typedef struct _drm_i915_sarea {
-	drm_tex_region_t texList[I915_NR_TEX_REGIONS + 1];
+typedef struct drm_i915_sarea {
+	struct drm_tex_region texList[I915_NR_TEX_REGIONS + 1];
 	int last_upload;	/* last time texture was uploaded */
 	int last_enqueue;	/* last time a buffer was enqueued */
 	int last_dispatch;	/* age of the most recently dispatched buffer */
@@ -105,14 +105,20 @@
 	unsigned int rotated_tiled;
 	unsigned int rotated2_tiled;
 
-	int pipeA_x;
-	int pipeA_y;
-	int pipeA_w;
-	int pipeA_h;
-	int pipeB_x;
-	int pipeB_y;
-	int pipeB_w;
-	int pipeB_h;
+	int planeA_x;
+	int planeA_y;
+	int planeA_w;
+	int planeA_h;
+	int planeB_x;
+	int planeB_y;
+	int planeB_w;
+	int planeB_h;
+
+	/* Triple buffering */
+	drm_handle_t third_handle;
+	int third_offset;
+	int third_size;
+	unsigned int third_tiled;
 } drm_i915_sarea_t;
 
 /* Driver specific fence types and classes.
@@ -152,10 +158,13 @@
 #define DRM_I915_SET_VBLANK_PIPE	0x0d
 #define DRM_I915_GET_VBLANK_PIPE	0x0e
 #define DRM_I915_VBLANK_SWAP	0x0f
+#define DRM_I915_MMIO		0x10
+#define DRM_I915_HWS_ADDR	0x11
+#define DRM_I915_EXECBUFFER	0x12
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
 #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
-#define DRM_IOCTL_I915_FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLIP)
+#define DRM_IOCTL_I915_FLIP		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_FLIP, drm_i915_flip_t)
 #define DRM_IOCTL_I915_BATCHBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_BATCHBUFFER, drm_i915_batchbuffer_t)
 #define DRM_IOCTL_I915_IRQ_EMIT         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_IRQ_EMIT, drm_i915_irq_emit_t)
 #define DRM_IOCTL_I915_IRQ_WAIT         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_IRQ_WAIT, drm_i915_irq_wait_t)
@@ -169,30 +178,42 @@
 #define DRM_IOCTL_I915_SET_VBLANK_PIPE	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
 #define DRM_IOCTL_I915_GET_VBLANK_PIPE	DRM_IOR( DRM_COMMAND_BASE + DRM_I915_GET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
 #define DRM_IOCTL_I915_VBLANK_SWAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_VBLANK_SWAP, drm_i915_vblank_swap_t)
+#define DRM_IOCTL_I915_EXECBUFFER	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_EXECBUFFER, struct drm_i915_execbuffer)
 
+/* Asynchronous page flipping:
+ */
+typedef struct drm_i915_flip {
+	/*
+	 * This is really talking about planes, and we could rename it
+	 * except for the fact that some of the duplicated i915_drm.h files
+	 * out there check for HAVE_I915_FLIP and so might pick up this
+	 * version.
+	 */
+	int pipes;
+} drm_i915_flip_t;
 
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
  */
-typedef struct _drm_i915_batchbuffer {
+typedef struct drm_i915_batchbuffer {
 	int start;		/* agp offset */
 	int used;		/* nr bytes in use */
 	int DR1;		/* hw flags for GFX_OP_DRAWRECT_INFO */
 	int DR4;		/* window origin for GFX_OP_DRAWRECT_INFO */
 	int num_cliprects;	/* mulitpass with multiple cliprects? */
-	drm_clip_rect_t __user *cliprects;	/* pointer to userspace cliprects */
+	struct drm_clip_rect __user *cliprects;	/* pointer to userspace cliprects */
 } drm_i915_batchbuffer_t;
 
 /* As above, but pass a pointer to userspace buffer which can be
  * validated by the kernel prior to sending to hardware.
  */
-typedef struct _drm_i915_cmdbuffer {
+typedef struct drm_i915_cmdbuffer {
 	char __user *buf;	/* pointer to userspace command buffer */
 	int sz;			/* nr bytes in buf */
 	int DR1;		/* hw flags for GFX_OP_DRAWRECT_INFO */
 	int DR4;		/* window origin for GFX_OP_DRAWRECT_INFO */
 	int num_cliprects;	/* mulitpass with multiple cliprects? */
-	drm_clip_rect_t __user *cliprects;	/* pointer to userspace cliprects */
+	struct drm_clip_rect __user *cliprects;	/* pointer to userspace cliprects */
 } drm_i915_cmdbuffer_t;
 
 /* Userspace can request & wait on irq's:
@@ -269,8 +290,76 @@
  */
 typedef struct drm_i915_vblank_swap {
 	drm_drawable_t drawable;
-	drm_vblank_seq_type_t seqtype;
+	enum drm_vblank_seq_type seqtype;
 	unsigned int sequence;
 } drm_i915_vblank_swap_t;
 
+#define I915_MMIO_READ	0
+#define I915_MMIO_WRITE 1
+
+#define I915_MMIO_MAY_READ	0x1
+#define I915_MMIO_MAY_WRITE	0x2
+
+#define MMIO_REGS_IA_PRIMATIVES_COUNT		0
+#define MMIO_REGS_IA_VERTICES_COUNT		1
+#define MMIO_REGS_VS_INVOCATION_COUNT		2
+#define MMIO_REGS_GS_PRIMITIVES_COUNT		3
+#define MMIO_REGS_GS_INVOCATION_COUNT		4
+#define MMIO_REGS_CL_PRIMITIVES_COUNT		5
+#define MMIO_REGS_CL_INVOCATION_COUNT		6
+#define MMIO_REGS_PS_INVOCATION_COUNT		7
+#define MMIO_REGS_PS_DEPTH_COUNT		8
+
+typedef struct drm_i915_mmio_entry {
+	unsigned int flag;
+	unsigned int offset;
+	unsigned int size;
+}drm_i915_mmio_entry_t;
+
+typedef struct drm_i915_mmio {
+	unsigned int read_write:1;
+	unsigned int reg:31;
+	void __user *data;
+} drm_i915_mmio_t;
+
+typedef struct drm_i915_hws_addr {
+	uint64_t addr;
+} drm_i915_hws_addr_t;
+
+/*
+ * Relocation header is 4 uint32_ts
+ * 0 - (16-bit relocation type << 16)| 16 bit reloc count
+ * 1 - buffer handle for another list of relocs
+ * 2-3 - spare.
+ */
+#define I915_RELOC_HEADER 4
+
+/*
+ * type 0 relocation has 4-uint32_t stride
+ * 0 - offset into buffer
+ * 1 - delta to add in
+ * 2 - index into buffer list
+ * 3 - reserved (for optimisations later).
+ */
+#define I915_RELOC_TYPE_0 0
+#define I915_RELOC0_STRIDE 4
+
+struct drm_i915_op_arg {
+	uint64_t next;
+	uint32_t reloc_handle;
+	int handled;
+	union {
+		struct drm_bo_op_req req;
+		struct drm_bo_arg_rep rep;
+	} d;
+
+};
+
+struct drm_i915_execbuffer {
+	uint64_t ops_list;
+	uint32_t num_buffers;
+	struct drm_i915_batchbuffer batch;
+	struct drm_fence_arg fence_arg;
+};
+
 #endif				/* _I915_DRM_H_ */
Index: git/shared-core/i915_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/i915_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,676 @@
+/* i915_drv.h -- Private header for the I915 driver -*- linux-c -*-
+ */
+/*
+ * 
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ */
+
+#ifndef _I915_DRV_H_
+#define _I915_DRV_H_
+
+#include "i915_reg.h"
+
+/* General customization:
+ */
+
+#define DRIVER_AUTHOR		"Tungsten Graphics, Inc."
+
+#define DRIVER_NAME		"i915"
+#define DRIVER_DESC		"Intel Graphics"
+#define DRIVER_DATE		"20070209"
+
+#if defined(__linux__)
+#define I915_HAVE_FENCE
+#define I915_HAVE_BUFFER
+#endif
+
+/* Interface history:
+ *
+ * 1.1: Original.
+ * 1.2: Add Power Management
+ * 1.3: Add vblank support
+ * 1.4: Fix cmdbuffer path, add heap destroy
+ * 1.5: Add vblank pipe configuration
+ * 1.6: - New ioctl for scheduling buffer swaps on vertical blank
+ *      - Support vertical blank on secondary display pipe
+ * 1.8: New ioctl for ARB_Occlusion_Query
+ * 1.9: Usable page flipping and triple buffering
+ * 1.10: Plane/pipe disentangling
+ */
+#define DRIVER_MAJOR		1
+#if defined(I915_HAVE_FENCE) && defined(I915_HAVE_BUFFER)
+#define DRIVER_MINOR		10
+#else
+#define DRIVER_MINOR		6
+#endif
+#define DRIVER_PATCHLEVEL	0
+
+#define DRM_DRIVER_PRIVATE_T drm_i915_private_t
+
+typedef struct _drm_i915_ring_buffer {
+	int tail_mask;
+	unsigned long Start;
+	unsigned long End;
+	unsigned long Size;
+	u8 *virtual_start;
+	int head;
+	int tail;
+	int space;
+	drm_local_map_t map;
+} drm_i915_ring_buffer_t;
+
+struct mem_block {
+	struct mem_block *next;
+	struct mem_block *prev;
+	int start;
+	int size;
+	struct drm_file *file_priv; /* NULL: free, -1: heap, other: real files */
+};
+
+typedef struct _drm_i915_vbl_swap {
+	struct list_head head;
+	drm_drawable_t drw_id;
+	unsigned int plane;
+	unsigned int sequence;
+	int flip;
+} drm_i915_vbl_swap_t;
+
+typedef struct drm_i915_private {
+	drm_buffer_object_t *ring_buffer;
+	drm_local_map_t *sarea;
+	drm_local_map_t *mmio_map;
+
+	unsigned long mmiobase;
+	unsigned long mmiolen;
+
+	drm_i915_sarea_t *sarea_priv;
+	drm_i915_ring_buffer_t ring;
+
+	drm_dma_handle_t *status_page_dmah;
+	void *hw_status_page;
+	dma_addr_t dma_status_page;
+	uint32_t counter;
+	unsigned int status_gfx_addr;
+	drm_local_map_t hws_map;
+
+	unsigned int cpp;
+	int use_mi_batchbuffer_start;
+
+	wait_queue_head_t irq_queue;
+	atomic_t irq_received;
+	atomic_t irq_emitted;
+
+	int tex_lru_log_granularity;
+	int allow_batchbuffer;
+	struct mem_block *agp_heap;
+	unsigned int sr01, adpa, ppcr, dvob, dvoc, lvds;
+	int vblank_pipe;
+	DRM_SPINTYPE user_irq_lock;
+	int user_irq_refcount;
+	int fence_irq_on;
+	uint32_t irq_enable_reg;
+	int irq_enabled;
+
+#ifdef I915_HAVE_FENCE
+	uint32_t flush_sequence;
+	uint32_t flush_flags;
+	uint32_t flush_pending;
+	uint32_t saved_flush_status;
+#endif
+#ifdef I915_HAVE_BUFFER
+	void *agp_iomap;
+#endif
+	DRM_SPINTYPE swaps_lock;
+	drm_i915_vbl_swap_t vbl_swaps;
+	unsigned int swaps_pending;
+
+	/* LVDS info */
+	int backlight_duty_cycle;  /* restore backlight to this value */
+	bool panel_wants_dither;
+	struct drm_display_mode *panel_fixed_mode;
+
+	/* Register state */
+	u32 saveDSPACNTR;
+	u32 saveDSPBCNTR;
+	u32 savePIPEACONF;
+	u32 savePIPEBCONF;
+	u32 savePIPEASRC;
+	u32 savePIPEBSRC;
+	u32 saveFPA0;
+	u32 saveFPA1;
+	u32 saveDPLL_A;
+	u32 saveDPLL_A_MD;
+	u32 saveHTOTAL_A;
+	u32 saveHBLANK_A;
+	u32 saveHSYNC_A;
+	u32 saveVTOTAL_A;
+	u32 saveVBLANK_A;
+	u32 saveVSYNC_A;
+	u32 saveDSPASTRIDE;
+	u32 saveDSPASIZE;
+	u32 saveDSPAPOS;
+	u32 saveDSPABASE;
+	u32 saveDSPASURF;
+	u32 saveFPB0;
+	u32 saveFPB1;
+	u32 saveDPLL_B;
+	u32 saveDPLL_B_MD;
+	u32 saveHTOTAL_B;
+	u32 saveHBLANK_B;
+	u32 saveHSYNC_B;
+	u32 saveVTOTAL_B;
+	u32 saveVBLANK_B;
+	u32 saveVSYNC_B;
+	u32 saveDSPBSTRIDE;
+	u32 saveDSPBSIZE;
+	u32 saveDSPBPOS;
+	u32 saveDSPBBASE;
+	u32 saveDSPBSURF;
+	u32 saveVCLK_DIVISOR_VGA0;
+	u32 saveVCLK_DIVISOR_VGA1;
+	u32 saveVCLK_POST_DIV;
+	u32 saveVGACNTRL;
+	u32 saveADPA;
+	u32 saveLVDS;
+	u32 saveDVOA;
+	u32 saveDVOB;
+	u32 saveDVOC;
+	u32 savePP_ON;
+	u32 savePP_OFF;
+	u32 savePP_CONTROL;
+	u32 savePP_CYCLE;
+	u32 savePFIT_CONTROL;
+	u32 savePaletteA[256];
+	u32 savePaletteB[256];
+	u32 saveSWF[17];
+	u32 saveBLC_PWM_CTL;
+} drm_i915_private_t;
+
+enum intel_chip_family {
+	CHIP_I8XX = 0x01,
+	CHIP_I9XX = 0x02,
+	CHIP_I915 = 0x04,
+	CHIP_I965 = 0x08,
+	CHIP_POULSBO = 0x10,
+};
+
+extern struct drm_ioctl_desc i915_ioctls[];
+extern int i915_max_ioctl;
+
+				/* i915_dma.c */
+extern void i915_kernel_lost_context(struct drm_device * dev);
+extern int i915_driver_load(struct drm_device *, unsigned long flags);
+extern void i915_driver_lastclose(struct drm_device * dev);
+extern void i915_driver_preclose(struct drm_device *dev,
+				 struct drm_file *file_priv);
+extern int i915_driver_device_is_agp(struct drm_device * dev);
+extern long i915_compat_ioctl(struct file *filp, unsigned int cmd,
+			      unsigned long arg);
+extern void i915_emit_breadcrumb(struct drm_device *dev);
+extern void i915_dispatch_flip(struct drm_device * dev, int pipes, int sync);
+extern int i915_emit_mi_flush(struct drm_device *dev, uint32_t flush);
+extern int i915_driver_firstopen(struct drm_device *dev);
+extern int i915_dma_cleanup(drm_device_t * dev);
+
+/* i915_irq.c */
+extern int i915_irq_emit(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv);
+extern int i915_irq_wait(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv);
+
+extern int i915_driver_vblank_wait(struct drm_device *dev, unsigned int *sequence);
+extern int i915_driver_vblank_wait2(struct drm_device *dev, unsigned int *sequence);
+extern irqreturn_t i915_driver_irq_handler(DRM_IRQ_ARGS);
+extern void i915_driver_irq_preinstall(struct drm_device * dev);
+extern void i915_driver_irq_postinstall(struct drm_device * dev);
+extern void i915_driver_irq_uninstall(struct drm_device * dev);
+extern int i915_vblank_pipe_set(struct drm_device *dev, void *data,
+				struct drm_file *file_priv);
+extern int i915_vblank_pipe_get(struct drm_device *dev, void *data,
+				struct drm_file *file_priv);
+extern int i915_emit_irq(struct drm_device * dev);
+extern void i915_user_irq_on(drm_i915_private_t *dev_priv);
+extern void i915_user_irq_off(drm_i915_private_t *dev_priv);
+extern int i915_vblank_swap(struct drm_device *dev, void *data,
+			    struct drm_file *file_priv);
+
+/* i915_mem.c */
+extern int i915_mem_alloc(struct drm_device *dev, void *data,
+			  struct drm_file *file_priv);
+extern int i915_mem_free(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv);
+extern int i915_mem_init_heap(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv);
+extern int i915_mem_destroy_heap(struct drm_device *dev, void *data,
+				 struct drm_file *file_priv);
+extern void i915_mem_takedown(struct mem_block **heap);
+extern void i915_mem_release(struct drm_device * dev,
+			     struct drm_file *file_priv,
+			     struct mem_block *heap);
+#ifdef I915_HAVE_FENCE
+/* i915_fence.c */
+
+
+extern void i915_fence_handler(struct drm_device *dev);
+extern int i915_fence_emit_sequence(struct drm_device *dev, uint32_t class,
+				    uint32_t flags,
+				    uint32_t *sequence, 
+				    uint32_t *native_type);
+extern void i915_poke_flush(struct drm_device *dev, uint32_t class);
+extern int i915_fence_has_irq(struct drm_device *dev, uint32_t class, uint32_t flags);
+#endif
+
+#ifdef I915_HAVE_BUFFER
+/* i915_buffer.c */
+extern struct drm_ttm_backend *i915_create_ttm_backend_entry(struct drm_device *dev);
+extern int i915_fence_types(struct drm_buffer_object *bo, uint32_t *fclass, 
+	                    uint32_t *type);
+extern int i915_invalidate_caches(struct drm_device *dev, uint64_t buffer_flags);
+extern int i915_init_mem_type(struct drm_device *dev, uint32_t type,
+			       struct drm_mem_type_manager *man);
+extern uint32_t i915_evict_mask(struct drm_buffer_object *bo);
+extern int i915_move(struct drm_buffer_object *bo, int evict,
+	      	int no_wait, struct drm_bo_mem_reg *new_mem);
+
+#endif
+
+
+/* modesetting */
+extern void intel_modeset_init(drm_device_t *dev);
+extern void intel_modeset_cleanup(drm_device_t *dev);
+
+
+#define I915_READ(reg)          DRM_READ32(dev_priv->mmio_map, (reg))
+#define I915_WRITE(reg,val)     DRM_WRITE32(dev_priv->mmio_map, (reg), (val))
+#define I915_READ16(reg) 	DRM_READ16(dev_priv->mmio_map, (reg))
+#define I915_WRITE16(reg,val)	DRM_WRITE16(dev_priv->mmio_map, (reg), (val))
+
+#define I915_VERBOSE 0
+
+#define RING_LOCALS	unsigned int outring, ringmask, outcount; \
+			volatile char *virt;
+
+#define BEGIN_LP_RING(n) do {				\
+	if (I915_VERBOSE)				\
+		DRM_DEBUG("BEGIN_LP_RING(%d) in %s\n",	\
+	                         (n), __FUNCTION__);           \
+	if (dev_priv->ring.space < (n)*4)                      \
+		i915_wait_ring(dev, (n)*4, __FUNCTION__);      \
+	outcount = 0;					\
+	outring = dev_priv->ring.tail;			\
+	ringmask = dev_priv->ring.tail_mask;		\
+	virt = dev_priv->ring.virtual_start;		\
+} while (0)
+
+#define OUT_RING(n) do {					\
+	if (I915_VERBOSE) DRM_DEBUG("   OUT_RING %x\n", (int)(n));	\
+	*(volatile unsigned int *)(virt + outring) = (n);		\
+	outcount++;						\
+	outring += 4;						\
+	outring &= ringmask;					\
+} while (0)
+
+#define ADVANCE_LP_RING() do {						\
+	if (I915_VERBOSE) DRM_DEBUG("ADVANCE_LP_RING %x\n", outring);	\
+	dev_priv->ring.tail = outring;					\
+	dev_priv->ring.space -= outcount * 4;				\
+	I915_WRITE(LP_RING + RING_TAIL, outring);			\
+} while(0)
+
+extern int i915_wait_ring(struct drm_device * dev, int n, const char *caller);
+
+/*
+ * The Bridge device's PCI config space has information about the
+ * fb aperture size and the amount of pre-reserved memory.
+ */
+#define INTEL_GMCH_CTRL		0x52
+#define INTEL_GMCH_ENABLED	0x4
+#define INTEL_GMCH_MEM_MASK	0x1
+#define INTEL_GMCH_MEM_64M	0x1
+#define INTEL_GMCH_MEM_128M	0
+
+#define INTEL_855_GMCH_GMS_MASK		(0x7 << 4)
+#define INTEL_855_GMCH_GMS_DISABLED	(0x0 << 4)
+#define INTEL_855_GMCH_GMS_STOLEN_1M	(0x1 << 4)
+#define INTEL_855_GMCH_GMS_STOLEN_4M	(0x2 << 4)
+#define INTEL_855_GMCH_GMS_STOLEN_8M	(0x3 << 4)
+#define INTEL_855_GMCH_GMS_STOLEN_16M	(0x4 << 4)
+#define INTEL_855_GMCH_GMS_STOLEN_32M	(0x5 << 4)
+
+#define INTEL_915G_GMCH_GMS_STOLEN_48M	(0x6 << 4)
+#define INTEL_915G_GMCH_GMS_STOLEN_64M	(0x7 << 4)
+
+#define GFX_OP_USER_INTERRUPT 		((0<<29)|(2<<23))
+#define GFX_OP_BREAKPOINT_INTERRUPT	((0<<29)|(1<<23))
+#define CMD_REPORT_HEAD			(7<<23)
+#define CMD_STORE_DWORD_IDX		((0x21<<23) | 0x1)
+#define CMD_OP_BATCH_BUFFER  ((0x0<<29)|(0x30<<23)|0x1)
+
+#define CMD_MI_FLUSH         (0x04 << 23)
+#define MI_NO_WRITE_FLUSH    (1 << 2)
+#define MI_READ_FLUSH        (1 << 0)
+#define MI_EXE_FLUSH         (1 << 1)
+#define MI_END_SCENE         (1 << 4) /* flush binner and incr scene count */
+#define MI_SCENE_COUNT       (1 << 3) /* just increment scene count */
+
+/* Packet to load a register value from the ring/batch command stream:
+ */
+#define CMD_MI_LOAD_REGISTER_IMM	((0x22 << 23)|0x1)
+
+#define BB1_START_ADDR_MASK   (~0x7)
+#define BB1_PROTECTED         (1<<0)
+#define BB1_UNPROTECTED       (0<<0)
+#define BB2_END_ADDR_MASK     (~0x7)
+
+/* Interrupt bits:
+ */
+#define USER_INT_FLAG    (1<<1)
+#define VSYNC_PIPEB_FLAG (1<<5)
+#define VSYNC_PIPEA_FLAG (1<<7)
+#define HWB_OOM_FLAG     (1<<13) /* binner out of memory */
+
+#define I915REG_HWSTAM		0x02098
+#define I915REG_INT_IDENTITY_R	0x020a4
+#define I915REG_INT_MASK_R 	0x020a8
+#define I915REG_INT_ENABLE_R	0x020a0
+#define I915REG_INSTPM	        0x020c0
+
+#define I915REG_PIPEASTAT	0x70024
+#define I915REG_PIPEBSTAT	0x71024
+
+#define I915_VBLANK_INTERRUPT_ENABLE	(1UL<<17)
+#define I915_VBLANK_CLEAR		(1UL<<1)
+
+#define GPIOA			0x5010
+#define GPIOB			0x5014
+#define GPIOC			0x5018
+#define GPIOD			0x501c
+#define GPIOE			0x5020
+#define GPIOF			0x5024
+#define GPIOG			0x5028
+#define GPIOH			0x502c
+# define GPIO_CLOCK_DIR_MASK		(1 << 0)
+# define GPIO_CLOCK_DIR_IN		(0 << 1)
+# define GPIO_CLOCK_DIR_OUT		(1 << 1)
+# define GPIO_CLOCK_VAL_MASK		(1 << 2)
+# define GPIO_CLOCK_VAL_OUT		(1 << 3)
+# define GPIO_CLOCK_VAL_IN		(1 << 4)
+# define GPIO_CLOCK_PULLUP_DISABLE	(1 << 5)
+# define GPIO_DATA_DIR_MASK		(1 << 8)
+# define GPIO_DATA_DIR_IN		(0 << 9)
+# define GPIO_DATA_DIR_OUT		(1 << 9)
+# define GPIO_DATA_VAL_MASK		(1 << 10)
+# define GPIO_DATA_VAL_OUT		(1 << 11)
+# define GPIO_DATA_VAL_IN		(1 << 12)
+# define GPIO_DATA_PULLUP_DISABLE	(1 << 13)
+
+/* p317, 319
+ */
+#define VCLK2_VCO_M        0x6008 /* treat as 16 bit? (includes msbs) */
+#define VCLK2_VCO_N        0x600a
+#define VCLK2_VCO_DIV_SEL  0x6012
+
+#define VCLK_DIVISOR_VGA0   0x6000
+#define VCLK_DIVISOR_VGA1   0x6004
+#define VCLK_POST_DIV	    0x6010
+/** Selects a post divisor of 4 instead of 2. */
+# define VGA1_PD_P2_DIV_4	(1 << 15)
+/** Overrides the p2 post divisor field */
+# define VGA1_PD_P1_DIV_2	(1 << 13)
+# define VGA1_PD_P1_SHIFT	8
+/** P1 value is 2 greater than this field */
+# define VGA1_PD_P1_MASK	(0x1f << 8)
+/** Selects a post divisor of 4 instead of 2. */
+# define VGA0_PD_P2_DIV_4	(1 << 7)
+/** Overrides the p2 post divisor field */
+# define VGA0_PD_P1_DIV_2	(1 << 5)
+# define VGA0_PD_P1_SHIFT	0
+/** P1 value is 2 greater than this field */
+# define VGA0_PD_P1_MASK	(0x1f << 0)
+
+#define POST_DIV_SELECT        0x70
+#define POST_DIV_1             0x00
+#define POST_DIV_2             0x10
+#define POST_DIV_4             0x20
+#define POST_DIV_8             0x30
+#define POST_DIV_16            0x40
+#define POST_DIV_32            0x50
+#define VCO_LOOP_DIV_BY_4M     0x00
+#define VCO_LOOP_DIV_BY_16M    0x04
+
+#define SRX_INDEX		0x3c4
+#define SRX_DATA		0x3c5
+#define SR01			1
+#define SR01_SCREEN_OFF 	(1<<5)
+
+#define PPCR			0x61204
+#define PPCR_ON			(1<<0)
+
+#define DVOA			0x61120
+#define DVOA_ON			(1<<31)
+#define DVOB			0x61140
+#define DVOB_ON			(1<<31)
+#define DVOC			0x61160
+#define DVOC_ON			(1<<31)
+#define LVDS			0x61180
+#define LVDS_ON			(1<<31)
+
+#define ADPA			0x61100
+#define ADPA_DPMS_MASK		(~(3<<10))
+#define ADPA_DPMS_ON		(0<<10)
+#define ADPA_DPMS_SUSPEND	(1<<10)
+#define ADPA_DPMS_STANDBY	(2<<10)
+#define ADPA_DPMS_OFF		(3<<10)
+
+#define NOPID                   0x2094
+#define LP_RING     		0x2030
+#define HP_RING     		0x2040
+/* The binner has its own ring buffer:
+ */
+#define HWB_RING		0x2400
+
+#define RING_TAIL      		0x00
+#define TAIL_ADDR		0x001FFFF8
+#define RING_HEAD      		0x04
+#define HEAD_WRAP_COUNT     	0xFFE00000
+#define HEAD_WRAP_ONE       	0x00200000
+#define HEAD_ADDR           	0x001FFFFC
+#define RING_START     		0x08
+#define START_ADDR          	0x0xFFFFF000
+#define RING_LEN       		0x0C
+#define RING_NR_PAGES       	0x001FF000
+#define RING_REPORT_MASK    	0x00000006
+#define RING_REPORT_64K     	0x00000002
+#define RING_REPORT_128K    	0x00000004
+#define RING_NO_REPORT      	0x00000000
+#define RING_VALID_MASK     	0x00000001
+#define RING_VALID          	0x00000001
+#define RING_INVALID        	0x00000000
+
+/* Instruction parser error reg:
+ */
+#define IPEIR			0x2088
+
+/* Scratch pad debug 0 reg:
+ */
+#define SCPD0			0x209c
+
+/* Error status reg:
+ */
+#define ESR			0x20b8
+
+/* Secondary DMA fetch address debug reg:
+ */
+#define DMA_FADD_S		0x20d4
+
+/* Cache mode 0 reg.  
+ *  - Manipulating render cache behaviour is central
+ *    to the concept of zone rendering, tuning this reg can help avoid
+ *    unnecessary render cache reads and even writes (for z/stencil)
+ *    at beginning and end of scene.
+ *
+ * - To change a bit, write to this reg with a mask bit set and the
+ * bit of interest either set or cleared.  EG: (BIT<<16) | BIT to set.
+ */
+#define Cache_Mode_0		0x2120
+#define CM0_MASK_SHIFT          16
+#define CM0_IZ_OPT_DISABLE      (1<<6)
+#define CM0_ZR_OPT_DISABLE      (1<<5)
+#define CM0_DEPTH_EVICT_DISABLE (1<<4)
+#define CM0_COLOR_EVICT_DISABLE (1<<3)
+#define CM0_DEPTH_WRITE_DISABLE (1<<1)
+#define CM0_RC_OP_FLUSH_DISABLE (1<<0)
+
+
+/* Graphics flush control.  A CPU write flushes the GWB of all writes.
+ * The data is discarded.
+ */
+#define GFX_FLSH_CNTL		0x2170
+
+/* Binner control.  Defines the location of the bin pointer list:
+ */
+#define BINCTL			0x2420
+#define BC_MASK			(1 << 9)
+
+/* Binned scene info.  
+ */
+#define BINSCENE		0x2428
+#define BS_OP_LOAD		(1 << 8)
+#define BS_MASK			(1 << 22)
+
+/* Bin command parser debug reg:
+ */
+#define BCPD			0x2480
+
+/* Bin memory control debug reg:
+ */
+#define BMCD			0x2484
+
+/* Bin data cache debug reg:
+ */
+#define BDCD			0x2488
+
+/* Binner pointer cache debug reg: 
+ */
+#define BPCD			0x248c
+
+/* Binner scratch pad debug reg:
+ */
+#define BINSKPD			0x24f0
+
+/* HWB scratch pad debug reg:
+ */
+#define HWBSKPD			0x24f4
+
+/* Binner memory pool reg:
+ */
+#define BMP_BUFFER		0x2430
+#define BMP_PAGE_SIZE_4K	(0 << 10)
+#define BMP_BUFFER_SIZE_SHIFT	1
+#define BMP_ENABLE		(1 << 0)
+
+/* Get/put memory from the binner memory pool:
+ */
+#define BMP_GET			0x2438
+#define BMP_PUT			0x2440
+#define BMP_OFFSET_SHIFT	5
+
+/* 3D state packets:
+ */
+#define GFX_OP_RASTER_RULES    ((0x3<<29)|(0x7<<24))
+
+#define GFX_OP_SCISSOR         ((0x3<<29)|(0x1c<<24)|(0x10<<19))
+#define SC_UPDATE_SCISSOR       (0x1<<1)
+#define SC_ENABLE_MASK          (0x1<<0)
+#define SC_ENABLE               (0x1<<0)
+
+#define GFX_OP_LOAD_INDIRECT   ((0x3<<29)|(0x1d<<24)|(0x7<<16))
+
+#define GFX_OP_SCISSOR_INFO    ((0x3<<29)|(0x1d<<24)|(0x81<<16)|(0x1))
+#define SCI_YMIN_MASK      (0xffff<<16)
+#define SCI_XMIN_MASK      (0xffff<<0)
+#define SCI_YMAX_MASK      (0xffff<<16)
+#define SCI_XMAX_MASK      (0xffff<<0)
+
+#define GFX_OP_SCISSOR_ENABLE	 ((0x3<<29)|(0x1c<<24)|(0x10<<19))
+#define GFX_OP_SCISSOR_RECT	 ((0x3<<29)|(0x1d<<24)|(0x81<<16)|1)
+#define GFX_OP_COLOR_FACTOR      ((0x3<<29)|(0x1d<<24)|(0x1<<16)|0x0)
+#define GFX_OP_STIPPLE           ((0x3<<29)|(0x1d<<24)|(0x83<<16))
+#define GFX_OP_MAP_INFO          ((0x3<<29)|(0x1d<<24)|0x4)
+#define GFX_OP_DESTBUFFER_VARS   ((0x3<<29)|(0x1d<<24)|(0x85<<16)|0x0)
+#define GFX_OP_DRAWRECT_INFO     ((0x3<<29)|(0x1d<<24)|(0x80<<16)|(0x3))
+
+#define GFX_OP_DRAWRECT_INFO_I965  ((0x7900<<16)|0x2)
+
+#define SRC_COPY_BLT_CMD                ((2<<29)|(0x43<<22)|4)
+#define XY_SRC_COPY_BLT_CMD		((2<<29)|(0x53<<22)|6)
+#define XY_MONO_SRC_COPY_IMM_BLT	((2<<29)|(0x71<<22)|5)
+#define XY_SRC_COPY_BLT_WRITE_ALPHA	(1<<21)
+#define XY_SRC_COPY_BLT_WRITE_RGB	(1<<20)
+#define   BLT_DEPTH_8			(0<<24)
+#define   BLT_DEPTH_16_565		(1<<24)
+#define   BLT_DEPTH_16_1555		(2<<24)
+#define   BLT_DEPTH_32			(3<<24)
+#define   BLT_ROP_GXCOPY		(0xcc<<16)
+
+#define MI_BATCH_BUFFER 	((0x30<<23)|1)
+#define MI_BATCH_BUFFER_START 	(0x31<<23)
+#define MI_BATCH_BUFFER_END 	(0xA<<23)
+#define MI_BATCH_NON_SECURE	(1)
+
+#define MI_BATCH_NON_SECURE_I965 (1<<8)
+
+#define MI_WAIT_FOR_EVENT       ((0x3<<23))
+#define MI_WAIT_FOR_PLANE_B_FLIP      (1<<6)
+#define MI_WAIT_FOR_PLANE_A_FLIP      (1<<2)
+#define MI_WAIT_FOR_PLANE_A_SCANLINES (1<<1)
+
+#define MI_LOAD_SCAN_LINES_INCL  ((0x12<<23))
+
+#define CMD_OP_DISPLAYBUFFER_INFO ((0x0<<29)|(0x14<<23)|2)
+#define ASYNC_FLIP                (1<<22)
+#define DISPLAY_PLANE_A           (0<<20)
+#define DISPLAY_PLANE_B           (1<<20)
+
+/* Display regs */
+#define DSPACNTR                0x70180
+#define DSPBCNTR                0x71180
+#define DISPPLANE_SEL_PIPE_MASK                 (1<<24)
+
+/* Define the region of interest for the binner:
+ */
+#define CMD_OP_BIN_CONTROL	 ((0x3<<29)|(0x1d<<24)|(0x84<<16)|4)
+
+#define CMD_OP_DESTBUFFER_INFO	 ((0x3<<29)|(0x1d<<24)|(0x8e<<16)|1)
+
+#define BREADCRUMB_BITS 31
+#define BREADCRUMB_MASK ((1U << BREADCRUMB_BITS) - 1)
+
+#define READ_BREADCRUMB(dev_priv)  (((volatile u32*)(dev_priv->hw_status_page))[5])
+#define READ_HWSP(dev_priv, reg)  (((volatile u32*)(dev_priv->hw_status_page))[reg])
+
+#define PRIMARY_RINGBUFFER_SIZE         (128*1024)
+
+#endif
Index: git/shared-core/i915_irq.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/i915_irq.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,752 @@
+/* i915_irq.c -- IRQ support for the I915 -*- linux-c -*-
+ */
+/*
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "i915_drm.h"
+#include "i915_drv.h"
+
+#define USER_INT_FLAG (1<<1)
+#define VSYNC_PIPEB_FLAG (1<<5)
+#define VSYNC_PIPEA_FLAG (1<<7)
+
+#define MAX_NOPID ((u32)~0)
+
+/**
+ * i915_get_pipe - return the the pipe associated with a given plane
+ * @dev: DRM device
+ * @plane: plane to look for
+ *
+ * We need to get the pipe associated with a given plane to correctly perform
+ * vblank driven swapping, and they may not always be equal.  So look up the
+ * pipe associated with @plane here.
+ */
+static int
+i915_get_pipe(struct drm_device *dev, int plane)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+	u32 dspcntr;
+
+	dspcntr = plane ? I915_READ(DSPBCNTR) : I915_READ(DSPACNTR);
+
+	return dspcntr & DISPPLANE_SEL_PIPE_MASK ? 1 : 0;
+}
+
+/**
+ * Emit a synchronous flip.
+ *
+ * This function must be called with the drawable spinlock held.
+ */
+static void
+i915_dispatch_vsync_flip(struct drm_device *dev, struct drm_drawable_info *drw,
+			 int plane)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+	drm_i915_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	u16 x1, y1, x2, y2;
+	int pf_planes = 1 << plane;
+
+	DRM_SPINLOCK_ASSERT(&dev->drw_lock);
+
+	/* If the window is visible on the other plane, we have to flip on that
+	 * plane as well.
+	 */
+	if (plane == 1) {
+		x1 = sarea_priv->planeA_x;
+		y1 = sarea_priv->planeA_y;
+		x2 = x1 + sarea_priv->planeA_w;
+		y2 = y1 + sarea_priv->planeA_h;
+	} else {
+		x1 = sarea_priv->planeB_x;
+		y1 = sarea_priv->planeB_y;
+		x2 = x1 + sarea_priv->planeB_w;
+		y2 = y1 + sarea_priv->planeB_h;
+	}
+
+	if (x2 > 0 && y2 > 0) {
+		int i, num_rects = drw->num_rects;
+		struct drm_clip_rect *rect = drw->rects;
+
+		for (i = 0; i < num_rects; i++)
+			if (!(rect[i].x1 >= x2 || rect[i].y1 >= y2 ||
+			      rect[i].x2 <= x1 || rect[i].y2 <= y1)) {
+				pf_planes = 0x3;
+
+				break;
+			}
+	}
+
+	i915_dispatch_flip(dev, pf_planes, 1);
+}
+
+/**
+ * Emit blits for scheduled buffer swaps.
+ *
+ * This function will be called with the HW lock held.
+ */
+static void i915_vblank_tasklet(struct drm_device *dev)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+	struct list_head *list, *tmp, hits, *hit;
+	int nhits, nrects, slice[2], upper[2], lower[2], i, num_pages;
+	unsigned counter[2] = { atomic_read(&dev->vbl_received),
+				atomic_read(&dev->vbl_received2) };
+	struct drm_drawable_info *drw;
+	drm_i915_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	u32 cpp = dev_priv->cpp,  offsets[3];
+	u32 cmd = (cpp == 4) ? (XY_SRC_COPY_BLT_CMD |
+				XY_SRC_COPY_BLT_WRITE_ALPHA |
+				XY_SRC_COPY_BLT_WRITE_RGB)
+			     : XY_SRC_COPY_BLT_CMD;
+	u32 pitchropcpp = (sarea_priv->pitch * cpp) | (0xcc << 16) |
+			  (cpp << 23) | (1 << 24);
+	RING_LOCALS;
+
+	DRM_DEBUG("\n");
+
+	INIT_LIST_HEAD(&hits);
+
+	nhits = nrects = 0;
+
+	/* No irqsave/restore necessary.  This tasklet may be run in an
+	 * interrupt context or normal context, but we don't have to worry
+	 * about getting interrupted by something acquiring the lock, because
+	 * we are the interrupt context thing that acquires the lock.
+	 */
+	DRM_SPINLOCK(&dev_priv->swaps_lock);
+
+	/* Find buffer swaps scheduled for this vertical blank */
+	list_for_each_safe(list, tmp, &dev_priv->vbl_swaps.head) {
+		drm_i915_vbl_swap_t *vbl_swap =
+			list_entry(list, drm_i915_vbl_swap_t, head);
+		int pipe = i915_get_pipe(dev, vbl_swap->plane);
+
+		if ((counter[pipe] - vbl_swap->sequence) > (1<<23))
+			continue;
+
+		list_del(list);
+		dev_priv->swaps_pending--;
+
+		DRM_SPINUNLOCK(&dev_priv->swaps_lock);
+		DRM_SPINLOCK(&dev->drw_lock);
+
+		drw = drm_get_drawable_info(dev, vbl_swap->drw_id);
+
+		if (!drw) {
+			DRM_SPINUNLOCK(&dev->drw_lock);
+			drm_free(vbl_swap, sizeof(*vbl_swap), DRM_MEM_DRIVER);
+			DRM_SPINLOCK(&dev_priv->swaps_lock);
+			continue;
+		}
+
+		list_for_each(hit, &hits) {
+			drm_i915_vbl_swap_t *swap_cmp =
+				list_entry(hit, drm_i915_vbl_swap_t, head);
+			struct drm_drawable_info *drw_cmp =
+				drm_get_drawable_info(dev, swap_cmp->drw_id);
+
+			if (drw_cmp &&
+			    drw_cmp->rects[0].y1 > drw->rects[0].y1) {
+				list_add_tail(list, hit);
+				break;
+			}
+		}
+
+		DRM_SPINUNLOCK(&dev->drw_lock);
+
+		/* List of hits was empty, or we reached the end of it */
+		if (hit == &hits)
+			list_add_tail(list, hits.prev);
+
+		nhits++;
+
+		DRM_SPINLOCK(&dev_priv->swaps_lock);
+	}
+
+	DRM_SPINUNLOCK(&dev->drw_lock);
+
+	if (nhits == 0) {
+		return;
+	}
+
+	i915_kernel_lost_context(dev);
+
+	upper[0] = upper[1] = 0;
+	slice[0] = max(sarea_priv->planeA_h / nhits, 1);
+	slice[1] = max(sarea_priv->planeB_h / nhits, 1);
+	lower[0] = sarea_priv->planeA_y + slice[0];
+	lower[1] = sarea_priv->planeB_y + slice[0];
+
+	offsets[0] = sarea_priv->front_offset;
+	offsets[1] = sarea_priv->back_offset;
+	offsets[2] = sarea_priv->third_offset;
+	num_pages = sarea_priv->third_handle ? 3 : 2;
+
+	DRM_SPINLOCK(&dev->drw_lock);
+
+	/* Emit blits for buffer swaps, partitioning both outputs into as many
+	 * slices as there are buffer swaps scheduled in order to avoid tearing
+	 * (based on the assumption that a single buffer swap would always
+	 * complete before scanout starts).
+	 */
+	for (i = 0; i++ < nhits;
+	     upper[0] = lower[0], lower[0] += slice[0],
+	     upper[1] = lower[1], lower[1] += slice[1]) {
+		int init_drawrect = 1;
+
+		if (i == nhits)
+			lower[0] = lower[1] = sarea_priv->height;
+
+		list_for_each(hit, &hits) {
+			drm_i915_vbl_swap_t *swap_hit =
+				list_entry(hit, drm_i915_vbl_swap_t, head);
+			struct drm_clip_rect *rect;
+			int num_rects, plane, front, back;
+			unsigned short top, bottom;
+
+			drw = drm_get_drawable_info(dev, swap_hit->drw_id);
+
+			if (!drw)
+				continue;
+
+			plane = swap_hit->plane;
+
+			if (swap_hit->flip) {
+				i915_dispatch_vsync_flip(dev, drw, plane);
+				continue;
+			}
+
+			if (init_drawrect) {
+				BEGIN_LP_RING(6);
+
+				OUT_RING(GFX_OP_DRAWRECT_INFO);
+				OUT_RING(0);
+				OUT_RING(0);
+				OUT_RING(sarea_priv->width | sarea_priv->height << 16);
+				OUT_RING(sarea_priv->width | sarea_priv->height << 16);
+				OUT_RING(0);
+
+				ADVANCE_LP_RING();
+
+				sarea_priv->ctxOwner = DRM_KERNEL_CONTEXT;
+
+				init_drawrect = 0;
+			}
+
+			rect = drw->rects;
+			top = upper[plane];
+			bottom = lower[plane];
+
+			front = (dev_priv->sarea_priv->pf_current_page >>
+				 (2 * plane)) & 0x3;
+			back = (front + 1) % num_pages;
+
+			for (num_rects = drw->num_rects; num_rects--; rect++) {
+				int y1 = max(rect->y1, top);
+				int y2 = min(rect->y2, bottom);
+
+				if (y1 >= y2)
+					continue;
+
+				BEGIN_LP_RING(8);
+
+				OUT_RING(cmd);
+				OUT_RING(pitchropcpp);
+				OUT_RING((y1 << 16) | rect->x1);
+				OUT_RING((y2 << 16) | rect->x2);
+				OUT_RING(offsets[front]);
+				OUT_RING((y1 << 16) | rect->x1);
+				OUT_RING(pitchropcpp & 0xffff);
+				OUT_RING(offsets[back]);
+
+				ADVANCE_LP_RING();
+			}
+		}
+	}
+
+	DRM_SPINUNLOCK(&dev->drw_lock);
+
+	list_for_each_safe(hit, tmp, &hits) {
+		drm_i915_vbl_swap_t *swap_hit =
+			list_entry(hit, drm_i915_vbl_swap_t, head);
+
+		list_del(hit);
+
+		drm_free(swap_hit, sizeof(*swap_hit), DRM_MEM_DRIVER);
+	}
+}
+
+irqreturn_t i915_driver_irq_handler(DRM_IRQ_ARGS)
+{
+	struct drm_device *dev = (struct drm_device *) arg;
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+	u16 temp;
+	u32 pipea_stats, pipeb_stats;
+
+	pipea_stats = I915_READ(I915REG_PIPEASTAT);
+	pipeb_stats = I915_READ(I915REG_PIPEBSTAT);
+		
+	temp = I915_READ16(I915REG_INT_IDENTITY_R);
+	temp &= (dev_priv->irq_enable_reg | USER_INT_FLAG);
+
+#if 0
+	DRM_DEBUG("%s flag=%08x\n", __FUNCTION__, temp);
+#endif
+	if (temp == 0)
+		return IRQ_NONE;
+
+	I915_WRITE16(I915REG_INT_IDENTITY_R, temp);
+	(void) I915_READ16(I915REG_INT_IDENTITY_R);
+	DRM_READMEMORYBARRIER();
+
+	dev_priv->sarea_priv->last_dispatch = READ_BREADCRUMB(dev_priv);
+
+	if (temp & USER_INT_FLAG) {
+		DRM_WAKEUP(&dev_priv->irq_queue);
+#ifdef I915_HAVE_FENCE
+		i915_fence_handler(dev);
+#endif
+	}
+
+	if (temp & (VSYNC_PIPEA_FLAG | VSYNC_PIPEB_FLAG)) {
+		int vblank_pipe = dev_priv->vblank_pipe;
+
+		if ((vblank_pipe &
+		     (DRM_I915_VBLANK_PIPE_A | DRM_I915_VBLANK_PIPE_B))
+		    == (DRM_I915_VBLANK_PIPE_A | DRM_I915_VBLANK_PIPE_B)) {
+			if (temp & VSYNC_PIPEA_FLAG)
+				atomic_inc(&dev->vbl_received);
+			if (temp & VSYNC_PIPEB_FLAG)
+				atomic_inc(&dev->vbl_received2);
+		} else if (((temp & VSYNC_PIPEA_FLAG) &&
+			    (vblank_pipe & DRM_I915_VBLANK_PIPE_A)) ||
+			   ((temp & VSYNC_PIPEB_FLAG) &&
+			    (vblank_pipe & DRM_I915_VBLANK_PIPE_B)))
+			atomic_inc(&dev->vbl_received);
+
+		DRM_WAKEUP(&dev->vbl_queue);
+		drm_vbl_send_signals(dev);
+
+		if (dev_priv->swaps_pending > 0)
+			drm_locked_tasklet(dev, i915_vblank_tasklet);
+		I915_WRITE(I915REG_PIPEASTAT, 
+			pipea_stats|I915_VBLANK_INTERRUPT_ENABLE|
+			I915_VBLANK_CLEAR);
+		I915_WRITE(I915REG_PIPEBSTAT,
+			pipeb_stats|I915_VBLANK_INTERRUPT_ENABLE|
+			I915_VBLANK_CLEAR);
+	}
+
+	return IRQ_HANDLED;
+}
+
+int i915_emit_irq(struct drm_device * dev)
+{
+	
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	RING_LOCALS;
+
+	i915_kernel_lost_context(dev);
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	i915_emit_breadcrumb(dev);
+
+	BEGIN_LP_RING(2);
+	OUT_RING(0);
+	OUT_RING(GFX_OP_USER_INTERRUPT);
+	ADVANCE_LP_RING();
+
+	return dev_priv->counter;
+
+
+}
+
+void i915_user_irq_on(drm_i915_private_t *dev_priv)
+{
+	DRM_SPINLOCK(&dev_priv->user_irq_lock);
+	if (dev_priv->irq_enabled && (++dev_priv->user_irq_refcount == 1)){
+		dev_priv->irq_enable_reg |= USER_INT_FLAG;
+		I915_WRITE16(I915REG_INT_ENABLE_R, dev_priv->irq_enable_reg);
+	}
+	DRM_SPINUNLOCK(&dev_priv->user_irq_lock);
+
+}
+		
+void i915_user_irq_off(drm_i915_private_t *dev_priv)
+{
+	DRM_SPINLOCK(&dev_priv->user_irq_lock);
+	if (dev_priv->irq_enabled && (--dev_priv->user_irq_refcount == 0)) {
+		//		dev_priv->irq_enable_reg &= ~USER_INT_FLAG;
+		//		I915_WRITE16(I915REG_INT_ENABLE_R, dev_priv->irq_enable_reg);
+	}
+	DRM_SPINUNLOCK(&dev_priv->user_irq_lock);
+}
+		
+
+static int i915_wait_irq(struct drm_device * dev, int irq_nr)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+	int ret = 0;
+
+	DRM_DEBUG("%s irq_nr=%d breadcrumb=%d\n", __FUNCTION__, irq_nr,
+		  READ_BREADCRUMB(dev_priv));
+
+	if (READ_BREADCRUMB(dev_priv) >= irq_nr)
+		return 0;
+
+	dev_priv->sarea_priv->perf_boxes |= I915_BOX_WAIT;
+	
+	i915_user_irq_on(dev_priv);
+	DRM_WAIT_ON(ret, dev_priv->irq_queue, 3 * DRM_HZ,
+		    READ_BREADCRUMB(dev_priv) >= irq_nr);
+	i915_user_irq_off(dev_priv);
+
+	if (ret == -EBUSY) {
+		DRM_ERROR("%s: EBUSY -- rec: %d emitted: %d\n",
+			  __FUNCTION__,
+			  READ_BREADCRUMB(dev_priv), (int)dev_priv->counter);
+	}
+
+	dev_priv->sarea_priv->last_dispatch = READ_BREADCRUMB(dev_priv);
+	return ret;
+}
+
+static int i915_driver_vblank_do_wait(struct drm_device *dev,
+				      unsigned int *sequence,
+				      atomic_t *counter)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	unsigned int cur_vblank;
+	int ret = 0;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
+		    (((cur_vblank = atomic_read(counter))
+			- *sequence) <= (1<<23)));
+	
+	*sequence = cur_vblank;
+
+	return ret;
+}
+
+int i915_driver_vblank_wait(struct drm_device *dev, unsigned int *sequence)
+{
+	return i915_driver_vblank_do_wait(dev, sequence, &dev->vbl_received);
+}
+
+int i915_driver_vblank_wait2(struct drm_device *dev, unsigned int *sequence)
+{
+	return i915_driver_vblank_do_wait(dev, sequence, &dev->vbl_received2);
+}
+
+/* Needs the lock as it touches the ring.
+ */
+int i915_irq_emit(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_irq_emit_t *emit = data;
+	int result;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	result = i915_emit_irq(dev);
+
+	if (DRM_COPY_TO_USER(emit->irq_seq, &result, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/* Doesn't need the hardware lock.
+ */
+int i915_irq_wait(struct drm_device *dev, void *data,
+		  struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_irq_wait_t *irqwait = data;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	return i915_wait_irq(dev, irqwait->irq_seq);
+}
+
+static void i915_enable_interrupt (struct drm_device *dev)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+	
+	dev_priv->irq_enable_reg = USER_INT_FLAG; 
+	if (dev_priv->vblank_pipe & DRM_I915_VBLANK_PIPE_A)
+		dev_priv->irq_enable_reg |= VSYNC_PIPEA_FLAG;
+	if (dev_priv->vblank_pipe & DRM_I915_VBLANK_PIPE_B)
+		dev_priv->irq_enable_reg |= VSYNC_PIPEB_FLAG;
+
+	I915_WRITE16(I915REG_INT_ENABLE_R, dev_priv->irq_enable_reg);
+	dev_priv->irq_enabled = 1;
+}
+
+/* Set the vblank monitor pipe
+ */
+int i915_vblank_pipe_set(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_vblank_pipe_t *pipe = data;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (pipe->pipe & ~(DRM_I915_VBLANK_PIPE_A|DRM_I915_VBLANK_PIPE_B)) {
+		DRM_ERROR("%s called with invalid pipe 0x%x\n", 
+			  __FUNCTION__, pipe->pipe);
+		return -EINVAL;
+	}
+
+	dev_priv->vblank_pipe = pipe->pipe;
+
+	i915_enable_interrupt (dev);
+
+	return 0;
+}
+
+int i915_vblank_pipe_get(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_vblank_pipe_t *pipe = data;
+	u16 flag;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	flag = I915_READ(I915REG_INT_ENABLE_R);
+	pipe->pipe = 0;
+	if (flag & VSYNC_PIPEA_FLAG)
+		pipe->pipe |= DRM_I915_VBLANK_PIPE_A;
+	if (flag & VSYNC_PIPEB_FLAG)
+		pipe->pipe |= DRM_I915_VBLANK_PIPE_B;
+
+	return 0;
+}
+
+/**
+ * Schedule buffer swap at given vertical blank.
+ */
+int i915_vblank_swap(struct drm_device *dev, void *data,
+		     struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_vblank_swap_t *swap = data;
+	drm_i915_vbl_swap_t *vbl_swap;
+	unsigned int pipe, seqtype, curseq, plane;
+	unsigned long irqflags;
+	struct list_head *list;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __func__);
+		return -EINVAL;
+	}
+
+	if (dev_priv->sarea_priv->rotation) {
+		DRM_DEBUG("Rotation not supported\n");
+		return -EINVAL;
+	}
+
+	if (swap->seqtype & ~(_DRM_VBLANK_RELATIVE | _DRM_VBLANK_ABSOLUTE |
+			     _DRM_VBLANK_SECONDARY | _DRM_VBLANK_NEXTONMISS |
+			     _DRM_VBLANK_FLIP)) {
+		DRM_ERROR("Invalid sequence type 0x%x\n", swap->seqtype);
+		return -EINVAL;
+	}
+
+	plane = (swap->seqtype & _DRM_VBLANK_SECONDARY) ? 1 : 0;
+	pipe = i915_get_pipe(dev, plane);
+
+	seqtype = swap->seqtype & (_DRM_VBLANK_RELATIVE | _DRM_VBLANK_ABSOLUTE);
+
+	if (!(dev_priv->vblank_pipe & (1 << pipe))) {
+		DRM_ERROR("Invalid pipe %d\n", pipe);
+		return -EINVAL;
+	}
+
+	curseq = atomic_read(pipe ? &dev->vbl_received2 : &dev->vbl_received);
+
+	if (seqtype == _DRM_VBLANK_RELATIVE)
+		swap->sequence += curseq;
+
+	if ((curseq - swap->sequence) <= (1<<23)) {
+		if (swap->seqtype & _DRM_VBLANK_NEXTONMISS) {
+			swap->sequence = curseq + 1;
+		} else {
+			DRM_DEBUG("Missed target sequence\n");
+			return -EINVAL;
+		}
+	}
+
+	if (swap->seqtype & _DRM_VBLANK_FLIP) {
+		swap->sequence--;
+
+		if ((curseq - swap->sequence) <= (1<<23)) {
+			struct drm_drawable_info *drw;
+
+			LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+			DRM_SPINLOCK_IRQSAVE(&dev->drw_lock, irqflags);
+
+			drw = drm_get_drawable_info(dev, swap->drawable);
+
+			if (!drw) {
+				DRM_SPINUNLOCK_IRQRESTORE(&dev->drw_lock,
+				    irqflags);
+				DRM_DEBUG("Invalid drawable ID %d\n",
+					  swap->drawable);
+				return -EINVAL;
+			}
+
+			i915_dispatch_vsync_flip(dev, drw, plane);
+
+			DRM_SPINUNLOCK_IRQRESTORE(&dev->drw_lock, irqflags);
+
+			return 0;
+		}
+	}
+
+	DRM_SPINLOCK_IRQSAVE(&dev_priv->swaps_lock, irqflags);
+
+	list_for_each(list, &dev_priv->vbl_swaps.head) {
+		vbl_swap = list_entry(list, drm_i915_vbl_swap_t, head);
+
+		if (vbl_swap->drw_id == swap->drawable &&
+		    vbl_swap->plane == plane &&
+		    vbl_swap->sequence == swap->sequence) {
+			vbl_swap->flip = (swap->seqtype & _DRM_VBLANK_FLIP);
+			DRM_SPINUNLOCK_IRQRESTORE(&dev_priv->swaps_lock, irqflags);
+			DRM_DEBUG("Already scheduled\n");
+			return 0;
+		}
+	}
+
+	DRM_SPINUNLOCK_IRQRESTORE(&dev_priv->swaps_lock, irqflags);
+
+	if (dev_priv->swaps_pending >= 100) {
+		DRM_DEBUG("Too many swaps queued\n");
+		return -EBUSY;
+	}
+
+	vbl_swap = drm_calloc(1, sizeof(vbl_swap), DRM_MEM_DRIVER);
+
+	if (!vbl_swap) {
+		DRM_ERROR("Failed to allocate memory to queue swap\n");
+		return -ENOMEM;
+	}
+
+	DRM_DEBUG("\n");
+
+	vbl_swap->drw_id = swap->drawable;
+	vbl_swap->plane = plane;
+	vbl_swap->sequence = swap->sequence;
+	vbl_swap->flip = (swap->seqtype & _DRM_VBLANK_FLIP);
+
+	if (vbl_swap->flip)
+		swap->sequence++;
+
+	DRM_SPINLOCK_IRQSAVE(&dev_priv->swaps_lock, irqflags);
+
+	list_add_tail((struct list_head *)vbl_swap, &dev_priv->vbl_swaps.head);
+	dev_priv->swaps_pending++;
+
+	DRM_SPINUNLOCK_IRQRESTORE(&dev_priv->swaps_lock, irqflags);
+
+	return 0;
+}
+
+/* drm_dma.h hooks
+*/
+void i915_driver_irq_preinstall(struct drm_device * dev)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+
+	I915_WRITE16(I915REG_HWSTAM, 0xeffe);
+	I915_WRITE16(I915REG_INT_MASK_R, 0x0);
+	I915_WRITE16(I915REG_INT_ENABLE_R, 0x0);
+}
+
+void i915_driver_irq_postinstall(struct drm_device * dev)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+
+	DRM_SPININIT(&dev_priv->swaps_lock, "swap");
+	INIT_LIST_HEAD(&dev_priv->vbl_swaps.head);
+	dev_priv->swaps_pending = 0;
+
+	DRM_SPININIT(&dev_priv->user_irq_lock, "userirq");
+	dev_priv->user_irq_refcount = 0;
+
+	i915_enable_interrupt(dev);
+	DRM_INIT_WAITQUEUE(&dev_priv->irq_queue);
+
+	/*
+	 * Initialize the hardware status page IRQ location.
+	 */
+
+	I915_WRITE(I915REG_INSTPM, ( 1 << 5) | ( 1 << 21));
+}
+
+void i915_driver_irq_uninstall(struct drm_device * dev)
+{
+	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
+	u16 temp;
+	if (!dev_priv)
+		return;
+
+	dev_priv->irq_enabled = 0;
+	I915_WRITE16(I915REG_HWSTAM, 0xffff);
+	I915_WRITE16(I915REG_INT_MASK_R, 0xffff);
+	I915_WRITE16(I915REG_INT_ENABLE_R, 0x0);
+
+	temp = I915_READ16(I915REG_INT_IDENTITY_R);
+	I915_WRITE16(I915REG_INT_IDENTITY_R, temp);
+}
Index: git/shared-core/i915_mem.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/i915_mem.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,386 @@
+/* i915_mem.c -- Simple agp/fb memory manager for i915 -*- linux-c -*-
+ */
+/*
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "i915_drm.h"
+#include "i915_drv.h"
+
+/* This memory manager is integrated into the global/local lru
+ * mechanisms used by the clients.  Specifically, it operates by
+ * setting the 'in_use' fields of the global LRU to indicate whether
+ * this region is privately allocated to a client.
+ *
+ * This does require the client to actually respect that field.
+ *
+ * Currently no effort is made to allocate 'private' memory in any
+ * clever way - the LRU information isn't used to determine which
+ * block to allocate, and the ring is drained prior to allocations --
+ * in other words allocation is expensive.
+ */
+static void mark_block(struct drm_device * dev, struct mem_block *p, int in_use)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	struct drm_tex_region *list;
+	unsigned shift, nr;
+	unsigned start;
+	unsigned end;
+	unsigned i;
+	int age;
+
+	shift = dev_priv->tex_lru_log_granularity;
+	nr = I915_NR_TEX_REGIONS;
+
+	start = p->start >> shift;
+	end = (p->start + p->size - 1) >> shift;
+
+	age = ++sarea_priv->texAge;
+	list = sarea_priv->texList;
+
+	/* Mark the regions with the new flag and update their age.  Move
+	 * them to head of list to preserve LRU semantics.
+	 */
+	for (i = start; i <= end; i++) {
+		list[i].in_use = in_use;
+		list[i].age = age;
+
+		/* remove_from_list(i)
+		 */
+		list[(unsigned)list[i].next].prev = list[i].prev;
+		list[(unsigned)list[i].prev].next = list[i].next;
+
+		/* insert_at_head(list, i)
+		 */
+		list[i].prev = nr;
+		list[i].next = list[nr].next;
+		list[(unsigned)list[nr].next].prev = i;
+		list[nr].next = i;
+	}
+}
+
+/* Very simple allocator for agp memory, working on a static range
+ * already mapped into each client's address space.
+ */
+
+static struct mem_block *split_block(struct mem_block *p, int start, int size,
+				     struct drm_file *file_priv)
+{
+	/* Maybe cut off the start of an existing block */
+	if (start > p->start) {
+		struct mem_block *newblock =
+		    drm_alloc(sizeof(*newblock), DRM_MEM_BUFLISTS);
+		if (!newblock)
+			goto out;
+		newblock->start = start;
+		newblock->size = p->size - (start - p->start);
+		newblock->file_priv = NULL;
+		newblock->next = p->next;
+		newblock->prev = p;
+		p->next->prev = newblock;
+		p->next = newblock;
+		p->size -= newblock->size;
+		p = newblock;
+	}
+
+	/* Maybe cut off the end of an existing block */
+	if (size < p->size) {
+		struct mem_block *newblock =
+		    drm_alloc(sizeof(*newblock), DRM_MEM_BUFLISTS);
+		if (!newblock)
+			goto out;
+		newblock->start = start + size;
+		newblock->size = p->size - size;
+		newblock->file_priv = NULL;
+		newblock->next = p->next;
+		newblock->prev = p;
+		p->next->prev = newblock;
+		p->next = newblock;
+		p->size = size;
+	}
+
+      out:
+	/* Our block is in the middle */
+	p->file_priv = file_priv;
+	return p;
+}
+
+static struct mem_block *alloc_block(struct mem_block *heap, int size,
+				     int align2, struct drm_file *file_priv)
+{
+	struct mem_block *p;
+	int mask = (1 << align2) - 1;
+
+	for (p = heap->next; p != heap; p = p->next) {
+		int start = (p->start + mask) & ~mask;
+		if (p->file_priv == NULL && start + size <= p->start + p->size)
+			return split_block(p, start, size, file_priv);
+	}
+
+	return NULL;
+}
+
+static struct mem_block *find_block(struct mem_block *heap, int start)
+{
+	struct mem_block *p;
+
+	for (p = heap->next; p != heap; p = p->next)
+		if (p->start == start)
+			return p;
+
+	return NULL;
+}
+
+static void free_block(struct mem_block *p)
+{
+	p->file_priv = NULL;
+
+	/* Assumes a single contiguous range.  Needs a special file_priv in
+	 * 'heap' to stop it being subsumed.
+	 */
+	if (p->next->file_priv == NULL) {
+		struct mem_block *q = p->next;
+		p->size += q->size;
+		p->next = q->next;
+		p->next->prev = p;
+		drm_free(q, sizeof(*q), DRM_MEM_BUFLISTS);
+	}
+
+	if (p->prev->file_priv == NULL) {
+		struct mem_block *q = p->prev;
+		q->size += p->size;
+		q->next = p->next;
+		q->next->prev = q;
+		drm_free(p, sizeof(*q), DRM_MEM_BUFLISTS);
+	}
+}
+
+/* Initialize.  How to check for an uninitialized heap?
+ */
+static int init_heap(struct mem_block **heap, int start, int size)
+{
+	struct mem_block *blocks = drm_alloc(sizeof(*blocks), DRM_MEM_BUFLISTS);
+
+	if (!blocks)
+		return -ENOMEM;
+
+	*heap = drm_alloc(sizeof(**heap), DRM_MEM_BUFLISTS);
+	if (!*heap) {
+		drm_free(blocks, sizeof(*blocks), DRM_MEM_BUFLISTS);
+		return -ENOMEM;
+	}
+
+	blocks->start = start;
+	blocks->size = size;
+	blocks->file_priv = NULL;
+	blocks->next = blocks->prev = *heap;
+
+	memset(*heap, 0, sizeof(**heap));
+	(*heap)->file_priv = (struct drm_file *) - 1;
+	(*heap)->next = (*heap)->prev = blocks;
+	return 0;
+}
+
+/* Free all blocks associated with the releasing file.
+ */
+void i915_mem_release(struct drm_device * dev, struct drm_file *file_priv,
+		      struct mem_block *heap)
+{
+	struct mem_block *p;
+
+	if (!heap || !heap->next)
+		return;
+
+	for (p = heap->next; p != heap; p = p->next) {
+		if (p->file_priv == file_priv) {
+			p->file_priv = NULL;
+			mark_block(dev, p, 0);
+		}
+	}
+
+	/* Assumes a single contiguous range.  Needs a special file_priv in
+	 * 'heap' to stop it being subsumed.
+	 */
+	for (p = heap->next; p != heap; p = p->next) {
+		while (p->file_priv == NULL && p->next->file_priv == NULL) {
+			struct mem_block *q = p->next;
+			p->size += q->size;
+			p->next = q->next;
+			p->next->prev = p;
+			drm_free(q, sizeof(*q), DRM_MEM_BUFLISTS);
+		}
+	}
+}
+
+/* Shutdown.
+ */
+void i915_mem_takedown(struct mem_block **heap)
+{
+	struct mem_block *p;
+
+	if (!*heap)
+		return;
+
+	for (p = (*heap)->next; p != *heap;) {
+		struct mem_block *q = p;
+		p = p->next;
+		drm_free(q, sizeof(*q), DRM_MEM_BUFLISTS);
+	}
+
+	drm_free(*heap, sizeof(**heap), DRM_MEM_BUFLISTS);
+	*heap = NULL;
+}
+
+static struct mem_block **get_heap(drm_i915_private_t * dev_priv, int region)
+{
+	switch (region) {
+	case I915_MEM_REGION_AGP:
+		return &dev_priv->agp_heap;
+	default:
+		return NULL;
+	}
+}
+
+/* IOCTL HANDLERS */
+
+int i915_mem_alloc(struct drm_device *dev, void *data,
+		   struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_mem_alloc_t *alloc = data;
+	struct mem_block *block, **heap;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	heap = get_heap(dev_priv, alloc->region);
+	if (!heap || !*heap)
+		return -EFAULT;
+
+	/* Make things easier on ourselves: all allocations at least
+	 * 4k aligned.
+	 */
+	if (alloc->alignment < 12)
+		alloc->alignment = 12;
+
+	block = alloc_block(*heap, alloc->size, alloc->alignment, file_priv);
+
+	if (!block)
+		return -ENOMEM;
+
+	mark_block(dev, block, 1);
+
+	if (DRM_COPY_TO_USER(alloc->region_offset, &block->start,
+			     sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+int i915_mem_free(struct drm_device *dev, void *data,
+		  struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_mem_free_t *memfree = data;
+	struct mem_block *block, **heap;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	heap = get_heap(dev_priv, memfree->region);
+	if (!heap || !*heap)
+		return -EFAULT;
+
+	block = find_block(*heap, memfree->region_offset);
+	if (!block)
+		return -EFAULT;
+
+	if (block->file_priv != file_priv)
+		return -EPERM;
+
+	mark_block(dev, block, 0);
+	free_block(block);
+	return 0;
+}
+
+int i915_mem_init_heap(struct drm_device *dev, void *data,
+		       struct drm_file *file_priv)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_mem_init_heap_t *initheap = data;
+	struct mem_block **heap;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	heap = get_heap(dev_priv, initheap->region);
+	if (!heap)
+		return -EFAULT;
+
+	if (*heap) {
+		DRM_ERROR("heap already initialized?");
+		return -EFAULT;
+	}
+
+	return init_heap(heap, initheap->start, initheap->size);
+}
+
+int i915_mem_destroy_heap( struct drm_device *dev, void *data,
+			   struct drm_file *file_priv )
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_i915_mem_destroy_heap_t *destroyheap = data;
+	struct mem_block **heap;
+
+	if ( !dev_priv ) {
+		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	heap = get_heap( dev_priv, destroyheap->region );
+	if (!heap) {
+		DRM_ERROR("get_heap failed");
+		return -EFAULT;
+	}
+	
+	if (!*heap) {
+		DRM_ERROR("heap not initialized?");
+		return -EFAULT;
+	}
+
+	i915_mem_takedown( heap );
+	return 0;
+}
Index: git/shared-core/imagine_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/imagine_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2005 Adam Jackson.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * ADAM JACKSON BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* derived from tdfx_drv.h */
+
+#ifndef __IMAGINE_DRV_H__
+#define __IMAGINE_DRV_H__
+
+#define DRIVER_AUTHOR       "Adam Jackson"
+#define DRIVER_NAME         "imagine"
+#define DRIVER_DESC         "#9 Imagine128 and Ticket 2 Ride"
+#define DRIVER_DATE         "20050328"
+#define DRIVER_MAJOR        0
+#define DRIVER_MINOR        0
+#define DRIVER_PATCHLEVEL   1
+
+enum imagine_family {
+    IMAGINE_128,
+    IMAGINE_128_2,
+    IMAGINE_T2R,
+    IMAGINE_REV4
+};
+
+#endif /* __IMAGINE_DRV_H__ */
Index: git/shared-core/mach64_dma.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/mach64_dma.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,1532 @@
+/* mach64_dma.c -- DMA support for mach64 (Rage Pro) driver -*- linux-c -*- */
+/**
+ * \file mach64_dma.c
+ * DMA support for mach64 (Rage Pro) driver
+ *
+ * \author Gareth Hughes <gareth@valinux.com>
+ * \author Frank C. Earl <fearl@airmail.net>
+ * \author Leif Delgass <ldelgass@retinalburn.net>
+ * \author Jose Fonseca <j_r_fonseca@yahoo.co.uk>
+ */
+
+/*
+ * Copyright 2000 Gareth Hughes
+ * Copyright 2002 Frank C. Earl
+ * Copyright 2002-2003 Leif Delgass
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT OWNER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "mach64_drm.h"
+#include "mach64_drv.h"
+
+/*******************************************************************/
+/** \name Engine, FIFO control */
+/*@{*/
+
+/**
+ * Waits for free entries in the FIFO.
+ *
+ * \note Most writes to Mach64 registers are automatically routed through
+ * command FIFO which is 16 entry deep. Prior to writing to any draw engine
+ * register one has to ensure that enough FIFO entries are available by calling
+ * this function.  Failure to do so may cause the engine to lock.
+ *
+ * \param dev_priv pointer to device private data structure.
+ * \param entries number of free entries in the FIFO to wait for.
+ * 
+ * \returns zero on success, or -EBUSY if the timeout (specificed by
+ * drm_mach64_private::usec_timeout) occurs.
+ */
+int mach64_do_wait_for_fifo(drm_mach64_private_t * dev_priv, int entries)
+{
+	int slots = 0, i;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		slots = (MACH64_READ(MACH64_FIFO_STAT) & MACH64_FIFO_SLOT_MASK);
+		if (slots <= (0x8000 >> entries))
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+	DRM_INFO("%s failed! slots=%d entries=%d\n", __FUNCTION__, slots,
+		 entries);
+	return -EBUSY;
+}
+
+/**
+ * Wait for the draw engine to be idle.
+ */
+int mach64_do_wait_for_idle(drm_mach64_private_t * dev_priv)
+{
+	int i, ret;
+
+	ret = mach64_do_wait_for_fifo(dev_priv, 16);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (!(MACH64_READ(MACH64_GUI_STAT) & MACH64_GUI_ACTIVE)) {
+			return 0;
+		}
+		DRM_UDELAY(1);
+	}
+
+	DRM_INFO("%s failed! GUI_STAT=0x%08x\n", __FUNCTION__,
+		 MACH64_READ(MACH64_GUI_STAT));
+	mach64_dump_ring_info(dev_priv);
+	return -EBUSY;
+}
+
+/**
+ * Wait for free entries in the ring buffer.
+ *
+ * The Mach64 bus master can be configured to act as a virtual FIFO, using a
+ * circular buffer (commonly referred as "ring buffer" in other drivers) with
+ * pointers to engine commands. This allows the CPU to do other things while
+ * the graphics engine is busy, i.e., DMA mode.
+ *
+ * This function should be called before writing new entries to the ring
+ * buffer.
+ * 
+ * \param dev_priv pointer to device private data structure.
+ * \param n number of free entries in the ring buffer to wait for.
+ * 
+ * \returns zero on success, or -EBUSY if the timeout (specificed by
+ * drm_mach64_private_t::usec_timeout) occurs.
+ *
+ * \sa mach64_dump_ring_info()
+ */
+int mach64_wait_ring(drm_mach64_private_t * dev_priv, int n)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	int i;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		mach64_update_ring_snapshot(dev_priv);
+		if (ring->space >= n) {
+			if (i > 0) {
+				DRM_DEBUG("%s: %d usecs\n", __FUNCTION__, i);
+			}
+			return 0;
+		}
+		DRM_UDELAY(1);
+	}
+
+	/* FIXME: This is being ignored... */
+	DRM_ERROR("failed!\n");
+	mach64_dump_ring_info(dev_priv);
+	return -EBUSY;
+}
+
+/**
+ * Wait until all DMA requests have been processed... 
+ *
+ * \sa mach64_wait_ring()
+ */
+static int mach64_ring_idle(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	u32 head;
+	int i;
+
+	head = ring->head;
+	i = 0;
+	while (i < dev_priv->usec_timeout) {
+		mach64_update_ring_snapshot(dev_priv);
+		if (ring->head == ring->tail &&
+		    !(MACH64_READ(MACH64_GUI_STAT) & MACH64_GUI_ACTIVE)) {
+			if (i > 0) {
+				DRM_DEBUG("%s: %d usecs\n", __FUNCTION__, i);
+			}
+			return 0;
+		}
+		if (ring->head == head) {
+			++i;
+		} else {
+			head = ring->head;
+			i = 0;
+		}
+		DRM_UDELAY(1);
+	}
+
+	DRM_INFO("%s failed! GUI_STAT=0x%08x\n", __FUNCTION__,
+		 MACH64_READ(MACH64_GUI_STAT));
+	mach64_dump_ring_info(dev_priv);
+	return -EBUSY;
+}
+
+/**
+ * Reset the the ring buffer descriptors.
+ *
+ * \sa mach64_do_engine_reset()
+ */
+static void mach64_ring_reset(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+
+	mach64_do_release_used_buffers(dev_priv);
+	ring->head_addr = ring->start_addr;
+	ring->head = ring->tail = 0;
+	ring->space = ring->size;
+
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     ring->head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);
+
+	dev_priv->ring_running = 0;
+}
+
+/**
+ * Ensure the all the queued commands will be processed.
+ */
+int mach64_do_dma_flush(drm_mach64_private_t * dev_priv)
+{
+	/* FIXME: It's not necessary to wait for idle when flushing
+	 * we just need to ensure the ring will be completely processed
+	 * in finite time without another ioctl
+	 */
+	return mach64_ring_idle(dev_priv);
+}
+
+/**
+ * Stop all DMA activity.
+ */
+int mach64_do_dma_idle(drm_mach64_private_t * dev_priv)
+{
+	int ret;
+
+	/* wait for completion */
+	if ((ret = mach64_ring_idle(dev_priv)) < 0) {
+		DRM_ERROR("%s failed BM_GUI_TABLE=0x%08x tail: %u\n",
+			  __FUNCTION__, MACH64_READ(MACH64_BM_GUI_TABLE),
+			  dev_priv->ring.tail);
+		return ret;
+	}
+
+	mach64_ring_stop(dev_priv);
+
+	/* clean up after pass */
+	mach64_do_release_used_buffers(dev_priv);
+	return 0;
+}
+
+/**
+ * Reset the engine.  This will stop the DMA if it is running.
+ */
+int mach64_do_engine_reset(drm_mach64_private_t * dev_priv)
+{
+	u32 tmp;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	/* Kill off any outstanding DMA transfers.
+	 */
+	tmp = MACH64_READ(MACH64_BUS_CNTL);
+	MACH64_WRITE(MACH64_BUS_CNTL, tmp | MACH64_BUS_MASTER_DIS);
+
+	/* Reset the GUI engine (high to low transition).
+	 */
+	tmp = MACH64_READ(MACH64_GEN_TEST_CNTL);
+	MACH64_WRITE(MACH64_GEN_TEST_CNTL, tmp & ~MACH64_GUI_ENGINE_ENABLE);
+	/* Enable the GUI engine
+	 */
+	tmp = MACH64_READ(MACH64_GEN_TEST_CNTL);
+	MACH64_WRITE(MACH64_GEN_TEST_CNTL, tmp | MACH64_GUI_ENGINE_ENABLE);
+
+	/* ensure engine is not locked up by clearing any FIFO or HOST errors
+	 */
+	tmp = MACH64_READ(MACH64_BUS_CNTL);
+	MACH64_WRITE(MACH64_BUS_CNTL, tmp | 0x00a00000);
+
+	/* Once GUI engine is restored, disable bus mastering */
+	MACH64_WRITE(MACH64_SRC_CNTL, 0);
+
+	/* Reset descriptor ring */
+	mach64_ring_reset(dev_priv);
+
+	return 0;
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name Debugging output */
+/*@{*/
+
+/**
+ * Dump engine registers values.
+ */
+void mach64_dump_engine_info(drm_mach64_private_t * dev_priv)
+{
+	DRM_INFO("\n");
+	if (!dev_priv->is_pci) {
+		DRM_INFO("           AGP_BASE = 0x%08x\n",
+			 MACH64_READ(MACH64_AGP_BASE));
+		DRM_INFO("           AGP_CNTL = 0x%08x\n",
+			 MACH64_READ(MACH64_AGP_CNTL));
+	}
+	DRM_INFO("     ALPHA_TST_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_ALPHA_TST_CNTL));
+	DRM_INFO("\n");
+	DRM_INFO("         BM_COMMAND = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_COMMAND));
+	DRM_INFO("BM_FRAME_BUF_OFFSET = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_FRAME_BUF_OFFSET));
+	DRM_INFO("       BM_GUI_TABLE = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_GUI_TABLE));
+	DRM_INFO("          BM_STATUS = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_STATUS));
+	DRM_INFO(" BM_SYSTEM_MEM_ADDR = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_SYSTEM_MEM_ADDR));
+	DRM_INFO("    BM_SYSTEM_TABLE = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_SYSTEM_TABLE));
+	DRM_INFO("           BUS_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_BUS_CNTL));
+	DRM_INFO("\n");
+	/* DRM_INFO( "         CLOCK_CNTL = 0x%08x\n", MACH64_READ( MACH64_CLOCK_CNTL ) ); */
+	DRM_INFO("        CLR_CMP_CLR = 0x%08x\n",
+		 MACH64_READ(MACH64_CLR_CMP_CLR));
+	DRM_INFO("       CLR_CMP_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_CLR_CMP_CNTL));
+	/* DRM_INFO( "        CLR_CMP_MSK = 0x%08x\n", MACH64_READ( MACH64_CLR_CMP_MSK ) ); */
+	DRM_INFO("     CONFIG_CHIP_ID = 0x%08x\n",
+		 MACH64_READ(MACH64_CONFIG_CHIP_ID));
+	DRM_INFO("        CONFIG_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_CONFIG_CNTL));
+	DRM_INFO("       CONFIG_STAT0 = 0x%08x\n",
+		 MACH64_READ(MACH64_CONFIG_STAT0));
+	DRM_INFO("       CONFIG_STAT1 = 0x%08x\n",
+		 MACH64_READ(MACH64_CONFIG_STAT1));
+	DRM_INFO("       CONFIG_STAT2 = 0x%08x\n",
+		 MACH64_READ(MACH64_CONFIG_STAT2));
+	DRM_INFO("            CRC_SIG = 0x%08x\n", MACH64_READ(MACH64_CRC_SIG));
+	DRM_INFO("  CUSTOM_MACRO_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_CUSTOM_MACRO_CNTL));
+	DRM_INFO("\n");
+	/* DRM_INFO( "           DAC_CNTL = 0x%08x\n", MACH64_READ( MACH64_DAC_CNTL ) ); */
+	/* DRM_INFO( "           DAC_REGS = 0x%08x\n", MACH64_READ( MACH64_DAC_REGS ) ); */
+	DRM_INFO("        DP_BKGD_CLR = 0x%08x\n",
+		 MACH64_READ(MACH64_DP_BKGD_CLR));
+	DRM_INFO("        DP_FRGD_CLR = 0x%08x\n",
+		 MACH64_READ(MACH64_DP_FRGD_CLR));
+	DRM_INFO("             DP_MIX = 0x%08x\n", MACH64_READ(MACH64_DP_MIX));
+	DRM_INFO("       DP_PIX_WIDTH = 0x%08x\n",
+		 MACH64_READ(MACH64_DP_PIX_WIDTH));
+	DRM_INFO("             DP_SRC = 0x%08x\n", MACH64_READ(MACH64_DP_SRC));
+	DRM_INFO("      DP_WRITE_MASK = 0x%08x\n",
+		 MACH64_READ(MACH64_DP_WRITE_MASK));
+	DRM_INFO("         DSP_CONFIG = 0x%08x\n",
+		 MACH64_READ(MACH64_DSP_CONFIG));
+	DRM_INFO("         DSP_ON_OFF = 0x%08x\n",
+		 MACH64_READ(MACH64_DSP_ON_OFF));
+	DRM_INFO("           DST_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_DST_CNTL));
+	DRM_INFO("      DST_OFF_PITCH = 0x%08x\n",
+		 MACH64_READ(MACH64_DST_OFF_PITCH));
+	DRM_INFO("\n");
+	/* DRM_INFO( "       EXT_DAC_REGS = 0x%08x\n", MACH64_READ( MACH64_EXT_DAC_REGS ) ); */
+	DRM_INFO("       EXT_MEM_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_EXT_MEM_CNTL));
+	DRM_INFO("\n");
+	DRM_INFO("          FIFO_STAT = 0x%08x\n",
+		 MACH64_READ(MACH64_FIFO_STAT));
+	DRM_INFO("\n");
+	DRM_INFO("      GEN_TEST_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_GEN_TEST_CNTL));
+	/* DRM_INFO( "              GP_IO = 0x%08x\n", MACH64_READ( MACH64_GP_IO ) ); */
+	DRM_INFO("   GUI_CMDFIFO_DATA = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_CMDFIFO_DATA));
+	DRM_INFO("  GUI_CMDFIFO_DEBUG = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_CMDFIFO_DEBUG));
+	DRM_INFO("           GUI_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_CNTL));
+	DRM_INFO("           GUI_STAT = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_STAT));
+	DRM_INFO("      GUI_TRAJ_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_TRAJ_CNTL));
+	DRM_INFO("\n");
+	DRM_INFO("          HOST_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_HOST_CNTL));
+	DRM_INFO("           HW_DEBUG = 0x%08x\n",
+		 MACH64_READ(MACH64_HW_DEBUG));
+	DRM_INFO("\n");
+	DRM_INFO("    MEM_ADDR_CONFIG = 0x%08x\n",
+		 MACH64_READ(MACH64_MEM_ADDR_CONFIG));
+	DRM_INFO("       MEM_BUF_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_MEM_BUF_CNTL));
+	DRM_INFO("\n");
+	DRM_INFO("           PAT_REG0 = 0x%08x\n",
+		 MACH64_READ(MACH64_PAT_REG0));
+	DRM_INFO("           PAT_REG1 = 0x%08x\n",
+		 MACH64_READ(MACH64_PAT_REG1));
+	DRM_INFO("\n");
+	DRM_INFO("            SC_LEFT = 0x%08x\n", MACH64_READ(MACH64_SC_LEFT));
+	DRM_INFO("           SC_RIGHT = 0x%08x\n",
+		 MACH64_READ(MACH64_SC_RIGHT));
+	DRM_INFO("             SC_TOP = 0x%08x\n", MACH64_READ(MACH64_SC_TOP));
+	DRM_INFO("          SC_BOTTOM = 0x%08x\n",
+		 MACH64_READ(MACH64_SC_BOTTOM));
+	DRM_INFO("\n");
+	DRM_INFO("      SCALE_3D_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_SCALE_3D_CNTL));
+	DRM_INFO("       SCRATCH_REG0 = 0x%08x\n",
+		 MACH64_READ(MACH64_SCRATCH_REG0));
+	DRM_INFO("       SCRATCH_REG1 = 0x%08x\n",
+		 MACH64_READ(MACH64_SCRATCH_REG1));
+	DRM_INFO("         SETUP_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_SETUP_CNTL));
+	DRM_INFO("           SRC_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_SRC_CNTL));
+	DRM_INFO("\n");
+	DRM_INFO("           TEX_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_TEX_CNTL));
+	DRM_INFO("     TEX_SIZE_PITCH = 0x%08x\n",
+		 MACH64_READ(MACH64_TEX_SIZE_PITCH));
+	DRM_INFO("       TIMER_CONFIG = 0x%08x\n",
+		 MACH64_READ(MACH64_TIMER_CONFIG));
+	DRM_INFO("\n");
+	DRM_INFO("             Z_CNTL = 0x%08x\n", MACH64_READ(MACH64_Z_CNTL));
+	DRM_INFO("        Z_OFF_PITCH = 0x%08x\n",
+		 MACH64_READ(MACH64_Z_OFF_PITCH));
+	DRM_INFO("\n");
+}
+
+#define MACH64_DUMP_CONTEXT	3
+
+/**
+ * Used by mach64_dump_ring_info() to dump the contents of the current buffer
+ * pointed by the ring head.
+ */
+static void mach64_dump_buf_info(drm_mach64_private_t * dev_priv,
+				 struct drm_buf * buf)
+{
+	u32 addr = GETBUFADDR(buf);
+	u32 used = buf->used >> 2;
+	u32 sys_addr = MACH64_READ(MACH64_BM_SYSTEM_MEM_ADDR);
+	u32 *p = GETBUFPTR(buf);
+	int skipped = 0;
+
+	DRM_INFO("buffer contents:\n");
+
+	while (used) {
+		u32 reg, count;
+
+		reg = le32_to_cpu(*p++);
+		if (addr <= GETBUFADDR(buf) + MACH64_DUMP_CONTEXT * 4 ||
+		    (addr >= sys_addr - MACH64_DUMP_CONTEXT * 4 &&
+		     addr <= sys_addr + MACH64_DUMP_CONTEXT * 4) ||
+		    addr >=
+		    GETBUFADDR(buf) + buf->used - MACH64_DUMP_CONTEXT * 4) {
+			DRM_INFO("%08x:  0x%08x\n", addr, reg);
+		}
+		addr += 4;
+		used--;
+
+		count = (reg >> 16) + 1;
+		reg = reg & 0xffff;
+		reg = MMSELECT(reg);
+		while (count && used) {
+			if (addr <= GETBUFADDR(buf) + MACH64_DUMP_CONTEXT * 4 ||
+			    (addr >= sys_addr - MACH64_DUMP_CONTEXT * 4 &&
+			     addr <= sys_addr + MACH64_DUMP_CONTEXT * 4) ||
+			    addr >=
+			    GETBUFADDR(buf) + buf->used -
+			    MACH64_DUMP_CONTEXT * 4) {
+				DRM_INFO("%08x:    0x%04x = 0x%08x\n", addr,
+					 reg, le32_to_cpu(*p));
+				skipped = 0;
+			} else {
+				if (!skipped) {
+					DRM_INFO("  ...\n");
+					skipped = 1;
+				}
+			}
+			p++;
+			addr += 4;
+			used--;
+
+			reg += 4;
+			count--;
+		}
+	}
+
+	DRM_INFO("\n");
+}
+
+/**
+ * Dump the ring state and contents, including the contents of the buffer being
+ * processed by the graphics engine.
+ */
+void mach64_dump_ring_info(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	int i, skipped;
+
+	DRM_INFO("\n");
+
+	DRM_INFO("ring contents:\n");
+	DRM_INFO("  head_addr: 0x%08x head: %u tail: %u\n\n",
+		 ring->head_addr, ring->head, ring->tail);
+
+	skipped = 0;
+	for (i = 0; i < ring->size / sizeof(u32); i += 4) {
+		if (i <= MACH64_DUMP_CONTEXT * 4 ||
+		    i >= ring->size / sizeof(u32) - MACH64_DUMP_CONTEXT * 4 ||
+		    (i >= ring->tail - MACH64_DUMP_CONTEXT * 4 &&
+		     i <= ring->tail + MACH64_DUMP_CONTEXT * 4) ||
+		    (i >= ring->head - MACH64_DUMP_CONTEXT * 4 &&
+		     i <= ring->head + MACH64_DUMP_CONTEXT * 4)) {
+			DRM_INFO("  0x%08x:  0x%08x 0x%08x 0x%08x 0x%08x%s%s\n",
+				 (u32)(ring->start_addr + i * sizeof(u32)),
+				 le32_to_cpu(((u32 *) ring->start)[i + 0]),
+				 le32_to_cpu(((u32 *) ring->start)[i + 1]),
+				 le32_to_cpu(((u32 *) ring->start)[i + 2]),
+				 le32_to_cpu(((u32 *) ring->start)[i + 3]),
+				 i == ring->head ? " (head)" : "",
+				 i == ring->tail ? " (tail)" : "");
+			skipped = 0;
+		} else {
+			if (!skipped) {
+				DRM_INFO("  ...\n");
+				skipped = 1;
+			}
+		}
+	}
+
+	DRM_INFO("\n");
+
+	if (ring->head >= 0 && ring->head < ring->size / sizeof(u32)) {
+		struct list_head *ptr;
+		u32 addr = le32_to_cpu(((u32 *) ring->start)[ring->head + 1]);
+
+		list_for_each(ptr, &dev_priv->pending) {
+			drm_mach64_freelist_t *entry =
+			    list_entry(ptr, drm_mach64_freelist_t, list);
+			struct drm_buf *buf = entry->buf;
+
+			u32 buf_addr = GETBUFADDR(buf);
+
+			if (buf_addr <= addr && addr < buf_addr + buf->used) {
+				mach64_dump_buf_info(dev_priv, buf);
+			}
+		}
+	}
+
+	DRM_INFO("\n");
+	DRM_INFO("       BM_GUI_TABLE = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_GUI_TABLE));
+	DRM_INFO("\n");
+	DRM_INFO("BM_FRAME_BUF_OFFSET = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_FRAME_BUF_OFFSET));
+	DRM_INFO(" BM_SYSTEM_MEM_ADDR = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_SYSTEM_MEM_ADDR));
+	DRM_INFO("         BM_COMMAND = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_COMMAND));
+	DRM_INFO("\n");
+	DRM_INFO("          BM_STATUS = 0x%08x\n",
+		 MACH64_READ(MACH64_BM_STATUS));
+	DRM_INFO("           BUS_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_BUS_CNTL));
+	DRM_INFO("          FIFO_STAT = 0x%08x\n",
+		 MACH64_READ(MACH64_FIFO_STAT));
+	DRM_INFO("           GUI_STAT = 0x%08x\n",
+		 MACH64_READ(MACH64_GUI_STAT));
+	DRM_INFO("           SRC_CNTL = 0x%08x\n",
+		 MACH64_READ(MACH64_SRC_CNTL));
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name DMA test and initialization */
+/*@{*/
+
+/**
+ * Perform a simple DMA operation using the pattern registers to test whether
+ * DMA works.
+ *
+ * \return zero if successful.
+ *
+ * \note This function was the testbed for many experiences regarding Mach64
+ * DMA operation. It is left here since it so tricky to get DMA operating
+ * properly in some architectures and hardware.
+ */
+static int mach64_bm_dma_test(struct drm_device * dev)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_dma_handle_t *cpu_addr_dmah;
+	u32 data_addr;
+	u32 *table, *data;
+	u32 expected[2];
+	u32 src_cntl, pat_reg0, pat_reg1;
+	int i, count, failed;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	table = (u32 *) dev_priv->ring.start;
+
+	/* FIXME: get a dma buffer from the freelist here */
+	DRM_DEBUG("Allocating data memory ...\n");
+	cpu_addr_dmah =
+	    drm_pci_alloc(dev, 0x1000, 0x1000, 0xfffffffful);
+	if (!cpu_addr_dmah) {
+		DRM_INFO("data-memory allocation failed!\n");
+		return -ENOMEM;
+	} else {
+		data = (u32 *) cpu_addr_dmah->vaddr;
+		data_addr = (u32) cpu_addr_dmah->busaddr;
+	}
+
+	/* Save the X server's value for SRC_CNTL and restore it
+	 * in case our test fails.  This prevents the X server
+	 * from disabling it's cache for this register
+	 */
+	src_cntl = MACH64_READ(MACH64_SRC_CNTL);
+	pat_reg0 = MACH64_READ(MACH64_PAT_REG0);
+	pat_reg1 = MACH64_READ(MACH64_PAT_REG1);
+
+	mach64_do_wait_for_fifo(dev_priv, 3);
+
+	MACH64_WRITE(MACH64_SRC_CNTL, 0);
+	MACH64_WRITE(MACH64_PAT_REG0, 0x11111111);
+	MACH64_WRITE(MACH64_PAT_REG1, 0x11111111);
+
+	mach64_do_wait_for_idle(dev_priv);
+
+	for (i = 0; i < 2; i++) {
+		u32 reg;
+		reg = MACH64_READ((MACH64_PAT_REG0 + i * 4));
+		DRM_DEBUG("(Before DMA Transfer) reg %d = 0x%08x\n", i, reg);
+		if (reg != 0x11111111) {
+			DRM_INFO("Error initializing test registers\n");
+			DRM_INFO("resetting engine ...\n");
+			mach64_do_engine_reset(dev_priv);
+			DRM_INFO("freeing data buffer memory.\n");
+			drm_pci_free(dev, cpu_addr_dmah);
+			return -EIO;
+		}
+	}
+
+	/* fill up a buffer with sets of 2 consecutive writes starting with PAT_REG0 */
+	count = 0;
+
+	data[count++] = cpu_to_le32(DMAREG(MACH64_PAT_REG0) | (1 << 16));
+	data[count++] = expected[0] = 0x22222222;
+	data[count++] = expected[1] = 0xaaaaaaaa;
+
+	while (count < 1020) {
+		data[count++] =
+		    cpu_to_le32(DMAREG(MACH64_PAT_REG0) | (1 << 16));
+		data[count++] = 0x22222222;
+		data[count++] = 0xaaaaaaaa;
+	}
+	data[count++] = cpu_to_le32(DMAREG(MACH64_SRC_CNTL) | (0 << 16));
+	data[count++] = 0;
+
+	DRM_DEBUG("Preparing table ...\n");
+	table[MACH64_DMA_FRAME_BUF_OFFSET] = cpu_to_le32(MACH64_BM_ADDR +
+							 MACH64_APERTURE_OFFSET);
+	table[MACH64_DMA_SYS_MEM_ADDR] = cpu_to_le32(data_addr);
+	table[MACH64_DMA_COMMAND] = cpu_to_le32(count * sizeof(u32)
+						| MACH64_DMA_HOLD_OFFSET
+						| MACH64_DMA_EOL);
+	table[MACH64_DMA_RESERVED] = 0;
+
+	DRM_DEBUG("table[0] = 0x%08x\n", table[0]);
+	DRM_DEBUG("table[1] = 0x%08x\n", table[1]);
+	DRM_DEBUG("table[2] = 0x%08x\n", table[2]);
+	DRM_DEBUG("table[3] = 0x%08x\n", table[3]);
+
+	for (i = 0; i < 6; i++) {
+		DRM_DEBUG(" data[%d] = 0x%08x\n", i, data[i]);
+	}
+	DRM_DEBUG(" ...\n");
+	for (i = count - 5; i < count; i++) {
+		DRM_DEBUG(" data[%d] = 0x%08x\n", i, data[i]);
+	}
+
+	DRM_MEMORYBARRIER();
+
+	DRM_DEBUG("waiting for idle...\n");
+	if ((i = mach64_do_wait_for_idle(dev_priv))) {
+		DRM_INFO("mach64_do_wait_for_idle failed (result=%d)\n", i);
+		DRM_INFO("resetting engine ...\n");
+		mach64_do_engine_reset(dev_priv);
+		mach64_do_wait_for_fifo(dev_priv, 3);
+		MACH64_WRITE(MACH64_SRC_CNTL, src_cntl);
+		MACH64_WRITE(MACH64_PAT_REG0, pat_reg0);
+		MACH64_WRITE(MACH64_PAT_REG1, pat_reg1);
+		DRM_INFO("freeing data buffer memory.\n");
+		drm_pci_free(dev, cpu_addr_dmah);
+		return i;
+	}
+	DRM_DEBUG("waiting for idle...done\n");
+
+	DRM_DEBUG("BUS_CNTL = 0x%08x\n", MACH64_READ(MACH64_BUS_CNTL));
+	DRM_DEBUG("SRC_CNTL = 0x%08x\n", MACH64_READ(MACH64_SRC_CNTL));
+	DRM_DEBUG("\n");
+	DRM_DEBUG("data bus addr = 0x%08x\n", data_addr);
+	DRM_DEBUG("table bus addr = 0x%08x\n", dev_priv->ring.start_addr);
+
+	DRM_DEBUG("starting DMA transfer...\n");
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     dev_priv->ring.start_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);
+
+	MACH64_WRITE(MACH64_SRC_CNTL,
+		     MACH64_SRC_BM_ENABLE | MACH64_SRC_BM_SYNC |
+		     MACH64_SRC_BM_OP_SYSTEM_TO_REG);
+
+	/* Kick off the transfer */
+	DRM_DEBUG("starting DMA transfer... done.\n");
+	MACH64_WRITE(MACH64_DST_HEIGHT_WIDTH, 0);
+
+	DRM_DEBUG("waiting for idle...\n");
+
+	if ((i = mach64_do_wait_for_idle(dev_priv))) {
+		/* engine locked up, dump register state and reset */
+		DRM_INFO("mach64_do_wait_for_idle failed (result=%d)\n", i);
+		mach64_dump_engine_info(dev_priv);
+		DRM_INFO("resetting engine ...\n");
+		mach64_do_engine_reset(dev_priv);
+		mach64_do_wait_for_fifo(dev_priv, 3);
+		MACH64_WRITE(MACH64_SRC_CNTL, src_cntl);
+		MACH64_WRITE(MACH64_PAT_REG0, pat_reg0);
+		MACH64_WRITE(MACH64_PAT_REG1, pat_reg1);
+		DRM_INFO("freeing data buffer memory.\n");
+		drm_pci_free(dev, cpu_addr_dmah);
+		return i;
+	}
+
+	DRM_DEBUG("waiting for idle...done\n");
+
+	/* restore SRC_CNTL */
+	mach64_do_wait_for_fifo(dev_priv, 1);
+	MACH64_WRITE(MACH64_SRC_CNTL, src_cntl);
+
+	failed = 0;
+
+	/* Check register values to see if the GUI master operation succeeded */
+	for (i = 0; i < 2; i++) {
+		u32 reg;
+		reg = MACH64_READ((MACH64_PAT_REG0 + i * 4));
+		DRM_DEBUG("(After DMA Transfer) reg %d = 0x%08x\n", i, reg);
+		if (reg != expected[i]) {
+			failed = -1;
+		}
+	}
+
+	/* restore pattern registers */
+	mach64_do_wait_for_fifo(dev_priv, 2);
+	MACH64_WRITE(MACH64_PAT_REG0, pat_reg0);
+	MACH64_WRITE(MACH64_PAT_REG1, pat_reg1);
+
+	DRM_DEBUG("freeing data buffer memory.\n");
+	drm_pci_free(dev, cpu_addr_dmah);
+	DRM_DEBUG("returning ...\n");
+
+	return failed;
+}
+
+/**
+ * Called during the DMA initialization ioctl to initialize all the necessary
+ * software and hardware state for DMA operation.
+ */
+static int mach64_do_dma_init(struct drm_device * dev, drm_mach64_init_t * init)
+{
+	drm_mach64_private_t *dev_priv;
+	u32 tmp;
+	int i, ret;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	dev_priv = drm_alloc(sizeof(drm_mach64_private_t), DRM_MEM_DRIVER);
+	if (dev_priv == NULL)
+		return -ENOMEM;
+
+	memset(dev_priv, 0, sizeof(drm_mach64_private_t));
+
+	dev_priv->is_pci = init->is_pci;
+
+	dev_priv->fb_bpp = init->fb_bpp;
+	dev_priv->front_offset = init->front_offset;
+	dev_priv->front_pitch = init->front_pitch;
+	dev_priv->back_offset = init->back_offset;
+	dev_priv->back_pitch = init->back_pitch;
+
+	dev_priv->depth_bpp = init->depth_bpp;
+	dev_priv->depth_offset = init->depth_offset;
+	dev_priv->depth_pitch = init->depth_pitch;
+
+	dev_priv->front_offset_pitch = (((dev_priv->front_pitch / 8) << 22) |
+					(dev_priv->front_offset >> 3));
+	dev_priv->back_offset_pitch = (((dev_priv->back_pitch / 8) << 22) |
+				       (dev_priv->back_offset >> 3));
+	dev_priv->depth_offset_pitch = (((dev_priv->depth_pitch / 8) << 22) |
+					(dev_priv->depth_offset >> 3));
+
+	dev_priv->usec_timeout = 1000000;
+
+	/* Set up the freelist, placeholder list and pending list */
+	INIT_LIST_HEAD(&dev_priv->free_list);
+	INIT_LIST_HEAD(&dev_priv->placeholders);
+	INIT_LIST_HEAD(&dev_priv->pending);
+
+	dev_priv->sarea = drm_getsarea(dev);
+	if (!dev_priv->sarea) {
+		DRM_ERROR("can not find sarea!\n");
+		dev->dev_private = (void *)dev_priv;
+		mach64_do_cleanup_dma(dev);
+		return -EINVAL;
+	}
+	dev_priv->fb = drm_core_findmap(dev, init->fb_offset);
+	if (!dev_priv->fb) {
+		DRM_ERROR("can not find frame buffer map!\n");
+		dev->dev_private = (void *)dev_priv;
+		mach64_do_cleanup_dma(dev);
+		return -EINVAL;
+	}
+	dev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);
+	if (!dev_priv->mmio) {
+		DRM_ERROR("can not find mmio map!\n");
+		dev->dev_private = (void *)dev_priv;
+		mach64_do_cleanup_dma(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->ring_map = drm_core_findmap(dev, init->ring_offset);
+	if (!dev_priv->ring_map) {
+		DRM_ERROR("can not find ring map!\n");
+		dev->dev_private = (void *)dev_priv;
+		mach64_do_cleanup_dma(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->sarea_priv = (drm_mach64_sarea_t *)
+	    ((u8 *) dev_priv->sarea->handle + init->sarea_priv_offset);
+
+	if (!dev_priv->is_pci) {
+		drm_core_ioremap(dev_priv->ring_map, dev);
+		if (!dev_priv->ring_map->handle) {
+			DRM_ERROR("can not ioremap virtual address for"
+				  " descriptor ring\n");
+			dev->dev_private = (void *)dev_priv;
+			mach64_do_cleanup_dma(dev);
+			return -ENOMEM;
+		}
+		dev->agp_buffer_token = init->buffers_offset;
+		dev->agp_buffer_map =
+		    drm_core_findmap(dev, init->buffers_offset);
+		if (!dev->agp_buffer_map) {
+			DRM_ERROR("can not find dma buffer map!\n");
+			dev->dev_private = (void *)dev_priv;
+			mach64_do_cleanup_dma(dev);
+			return -EINVAL;
+		}
+		/* there might be a nicer way to do this -
+		   dev isn't passed all the way though the mach64 - DA */
+		dev_priv->dev_buffers = dev->agp_buffer_map;
+
+		drm_core_ioremap(dev->agp_buffer_map, dev);
+		if (!dev->agp_buffer_map->handle) {
+			DRM_ERROR("can not ioremap virtual address for"
+				  " dma buffer\n");
+			dev->dev_private = (void *)dev_priv;
+			mach64_do_cleanup_dma(dev);
+			return -ENOMEM;
+		}
+		dev_priv->agp_textures =
+		    drm_core_findmap(dev, init->agp_textures_offset);
+		if (!dev_priv->agp_textures) {
+			DRM_ERROR("can not find agp texture region!\n");
+			dev->dev_private = (void *)dev_priv;
+			mach64_do_cleanup_dma(dev);
+			return -EINVAL;
+		}
+	}
+
+	dev->dev_private = (void *)dev_priv;
+
+	dev_priv->driver_mode = init->dma_mode;
+
+	/* changing the FIFO size from the default causes problems with DMA */
+	tmp = MACH64_READ(MACH64_GUI_CNTL);
+	if ((tmp & MACH64_CMDFIFO_SIZE_MASK) != MACH64_CMDFIFO_SIZE_128) {
+		DRM_INFO("Setting FIFO size to 128 entries\n");
+		/* FIFO must be empty to change the FIFO depth */
+		if ((ret = mach64_do_wait_for_idle(dev_priv))) {
+			DRM_ERROR
+			    ("wait for idle failed before changing FIFO depth!\n");
+			mach64_do_cleanup_dma(dev);
+			return ret;
+		}
+		MACH64_WRITE(MACH64_GUI_CNTL, ((tmp & ~MACH64_CMDFIFO_SIZE_MASK)
+					       | MACH64_CMDFIFO_SIZE_128));
+		/* need to read GUI_STAT for proper sync according to docs */
+		if ((ret = mach64_do_wait_for_idle(dev_priv))) {
+			DRM_ERROR
+			    ("wait for idle failed when changing FIFO depth!\n");
+			mach64_do_cleanup_dma(dev);
+			return ret;
+		}
+	}
+
+	dev_priv->ring.size = 0x4000;	/* 16KB */
+	dev_priv->ring.start = dev_priv->ring_map->handle;
+	dev_priv->ring.start_addr = (u32) dev_priv->ring_map->offset;
+
+	memset(dev_priv->ring.start, 0, dev_priv->ring.size);
+	DRM_INFO("descriptor ring: cpu addr %p, bus addr: 0x%08x\n",
+		 dev_priv->ring.start, dev_priv->ring.start_addr);
+
+	ret = 0;
+	if (dev_priv->driver_mode != MACH64_MODE_MMIO) {
+
+		/* enable block 1 registers and bus mastering */
+		MACH64_WRITE(MACH64_BUS_CNTL, ((MACH64_READ(MACH64_BUS_CNTL)
+						| MACH64_BUS_EXT_REG_EN)
+					       & ~MACH64_BUS_MASTER_DIS));
+
+		/* try a DMA GUI-mastering pass and fall back to MMIO if it fails */
+		DRM_DEBUG("Starting DMA test...\n");
+		if ((ret = mach64_bm_dma_test(dev))) {
+			dev_priv->driver_mode = MACH64_MODE_MMIO;
+		}
+	}
+
+	switch (dev_priv->driver_mode) {
+	case MACH64_MODE_MMIO:
+		MACH64_WRITE(MACH64_BUS_CNTL, (MACH64_READ(MACH64_BUS_CNTL)
+					       | MACH64_BUS_EXT_REG_EN
+					       | MACH64_BUS_MASTER_DIS));
+		if (init->dma_mode == MACH64_MODE_MMIO)
+			DRM_INFO("Forcing pseudo-DMA mode\n");
+		else
+			DRM_INFO
+			    ("DMA test failed (ret=%d), using pseudo-DMA mode\n",
+			     ret);
+		break;
+	case MACH64_MODE_DMA_SYNC:
+		DRM_INFO("DMA test succeeded, using synchronous DMA mode\n");
+		break;
+	case MACH64_MODE_DMA_ASYNC:
+	default:
+		DRM_INFO("DMA test succeeded, using asynchronous DMA mode\n");
+	}
+
+	dev_priv->ring_running = 0;
+
+	/* setup offsets for physical address of table start and end */
+	dev_priv->ring.head_addr = dev_priv->ring.start_addr;
+	dev_priv->ring.head = dev_priv->ring.tail = 0;
+	dev_priv->ring.tail_mask = (dev_priv->ring.size / sizeof(u32)) - 1;
+	dev_priv->ring.space = dev_priv->ring.size;
+
+	/* setup physical address and size of descriptor table */
+	mach64_do_wait_for_fifo(dev_priv, 1);
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     (dev_priv->ring.
+		      head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB));
+
+	/* init frame counter */
+	dev_priv->sarea_priv->frames_queued = 0;
+	for (i = 0; i < MACH64_MAX_QUEUED_FRAMES; i++) {
+		dev_priv->frame_ofs[i] = ~0;	/* All ones indicates placeholder */
+	}
+
+	/* Allocate the DMA buffer freelist */
+	if ((ret = mach64_init_freelist(dev))) {
+		DRM_ERROR("Freelist allocation failed\n");
+		mach64_do_cleanup_dma(dev);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*******************************************************************/
+/** MMIO Pseudo-DMA (intended primarily for debugging, not performance)
+ */
+
+int mach64_do_dispatch_pseudo_dma(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	volatile u32 *ring_read;
+	struct list_head *ptr;
+	drm_mach64_freelist_t *entry;
+	struct drm_buf *buf = NULL;
+	u32 *buf_ptr;
+	u32 used, reg, target;
+	int fifo, count, found, ret, no_idle_wait;
+
+	fifo = count = reg = no_idle_wait = 0;
+	target = MACH64_BM_ADDR;
+
+	if ((ret = mach64_do_wait_for_idle(dev_priv)) < 0) {
+		DRM_INFO
+		    ("%s: idle failed before pseudo-dma dispatch, resetting engine\n",
+		     __FUNCTION__);
+		mach64_dump_engine_info(dev_priv);
+		mach64_do_engine_reset(dev_priv);
+		return ret;
+	}
+
+	ring_read = (u32 *) ring->start;
+
+	while (ring->tail != ring->head) {
+		u32 buf_addr, new_target, offset;
+		u32 bytes, remaining, head, eol;
+
+		head = ring->head;
+
+		new_target =
+		    le32_to_cpu(ring_read[head++]) - MACH64_APERTURE_OFFSET;
+		buf_addr = le32_to_cpu(ring_read[head++]);
+		eol = le32_to_cpu(ring_read[head]) & MACH64_DMA_EOL;
+		bytes = le32_to_cpu(ring_read[head++])
+		    & ~(MACH64_DMA_HOLD_OFFSET | MACH64_DMA_EOL);
+		head++;
+		head &= ring->tail_mask;
+
+		/* can't wait for idle between a blit setup descriptor
+		 * and a HOSTDATA descriptor or the engine will lock
+		 */
+		if (new_target == MACH64_BM_HOSTDATA
+		    && target == MACH64_BM_ADDR)
+			no_idle_wait = 1;
+
+		target = new_target;
+
+		found = 0;
+		offset = 0;
+		list_for_each(ptr, &dev_priv->pending) {
+			entry = list_entry(ptr, drm_mach64_freelist_t, list);
+			buf = entry->buf;
+			offset = buf_addr - GETBUFADDR(buf);
+			if (offset >= 0 && offset < MACH64_BUFFER_SIZE) {
+				found = 1;
+				break;
+			}
+		}
+
+		if (!found || buf == NULL) {
+			DRM_ERROR
+			    ("Couldn't find pending buffer: head: %u tail: %u buf_addr: 0x%08x %s\n",
+			     head, ring->tail, buf_addr, (eol ? "eol" : ""));
+			mach64_dump_ring_info(dev_priv);
+			mach64_do_engine_reset(dev_priv);
+			return -EINVAL;
+		}
+
+		/* Hand feed the buffer to the card via MMIO, waiting for the fifo
+		 * every 16 writes
+		 */
+		DRM_DEBUG("target: (0x%08x) %s\n", target,
+			  (target ==
+			   MACH64_BM_HOSTDATA ? "BM_HOSTDATA" : "BM_ADDR"));
+		DRM_DEBUG("offset: %u bytes: %u used: %u\n", offset, bytes,
+			  buf->used);
+
+		remaining = (buf->used - offset) >> 2;	/* dwords remaining in buffer */
+		used = bytes >> 2;	/* dwords in buffer for this descriptor */
+		buf_ptr = (u32 *) ((char *)GETBUFPTR(buf) + offset);
+
+		while (used) {
+
+			if (count == 0) {
+				if (target == MACH64_BM_HOSTDATA) {
+					reg = DMAREG(MACH64_HOST_DATA0);
+					count =
+					    (remaining > 16) ? 16 : remaining;
+					fifo = 0;
+				} else {
+					reg = le32_to_cpu(*buf_ptr++);
+					used--;
+					count = (reg >> 16) + 1;
+				}
+
+				reg = reg & 0xffff;
+				reg = MMSELECT(reg);
+			}
+			while (count && used) {
+				if (!fifo) {
+					if (no_idle_wait) {
+						if ((ret =
+						     mach64_do_wait_for_fifo
+						     (dev_priv, 16)) < 0) {
+							no_idle_wait = 0;
+							return ret;
+						}
+					} else {
+						if ((ret =
+						     mach64_do_wait_for_idle
+						     (dev_priv)) < 0) {
+							return ret;
+						}
+					}
+					fifo = 16;
+				}
+				--fifo;
+				MACH64_WRITE(reg, le32_to_cpu(*buf_ptr++));
+				used--;
+				remaining--;
+
+				reg += 4;
+				count--;
+			}
+		}
+		ring->head = head;
+		ring->head_addr = ring->start_addr + (ring->head * sizeof(u32));
+		ring->space += (4 * sizeof(u32));
+	}
+
+	if ((ret = mach64_do_wait_for_idle(dev_priv)) < 0) {
+		return ret;
+	}
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     ring->head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);
+
+	DRM_DEBUG("%s completed\n", __FUNCTION__);
+	return 0;
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name DMA cleanup */
+/*@{*/
+
+int mach64_do_cleanup_dma(struct drm_device * dev)
+{
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	/* Make sure interrupts are disabled here because the uninstall ioctl
+	 * may not have been called from userspace and after dev_private
+	 * is freed, it's too late.
+	 */
+	if (dev->irq)
+		drm_irq_uninstall(dev);
+
+	if (dev->dev_private) {
+		drm_mach64_private_t *dev_priv = dev->dev_private;
+
+		if (!dev_priv->is_pci) {
+			if (dev_priv->ring_map)
+				drm_core_ioremapfree(dev_priv->ring_map, dev);
+
+			if (dev->agp_buffer_map) {
+				drm_core_ioremapfree(dev->agp_buffer_map, dev);
+				dev->agp_buffer_map = NULL;
+			}
+		}
+
+		mach64_destroy_freelist(dev);
+
+		drm_free(dev_priv, sizeof(drm_mach64_private_t),
+			 DRM_MEM_DRIVER);
+		dev->dev_private = NULL;
+	}
+
+	return 0;
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name IOCTL handlers */
+/*@{*/
+
+int mach64_dma_init(struct drm_device *dev, void *data,
+		    struct drm_file *file_priv)
+{
+	drm_mach64_init_t *init = data;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	switch (init->func) {
+	case DRM_MACH64_INIT_DMA:
+		return mach64_do_dma_init(dev, init);
+	case DRM_MACH64_CLEANUP_DMA:
+		return mach64_do_cleanup_dma(dev);
+	}
+
+	return -EINVAL;
+}
+
+int mach64_dma_idle(struct drm_device *dev, void *data,
+		    struct drm_file *file_priv)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	return mach64_do_dma_idle(dev_priv);
+}
+
+int mach64_dma_flush(struct drm_device *dev, void *data,
+		     struct drm_file *file_priv)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	return mach64_do_dma_flush(dev_priv);
+}
+
+int mach64_engine_reset(struct drm_device *dev, void *data,
+			struct drm_file *file_priv)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	return mach64_do_engine_reset(dev_priv);
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name Freelist management */
+/*@{*/
+
+int mach64_init_freelist(struct drm_device * dev)
+{
+	struct drm_device_dma *dma = dev->dma;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_freelist_t *entry;
+	struct list_head *ptr;
+	int i;
+
+	DRM_DEBUG("%s: adding %d buffers to freelist\n", __FUNCTION__,
+		  dma->buf_count);
+
+	for (i = 0; i < dma->buf_count; i++) {
+		if ((entry =
+		     (drm_mach64_freelist_t *)
+		     drm_alloc(sizeof(drm_mach64_freelist_t),
+			       DRM_MEM_BUFLISTS)) == NULL)
+			return -ENOMEM;
+		memset(entry, 0, sizeof(drm_mach64_freelist_t));
+		entry->buf = dma->buflist[i];
+		ptr = &entry->list;
+		list_add_tail(ptr, &dev_priv->free_list);
+	}
+
+	return 0;
+}
+
+void mach64_destroy_freelist(struct drm_device * dev)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_freelist_t *entry;
+	struct list_head *ptr;
+	struct list_head *tmp;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	list_for_each_safe(ptr, tmp, &dev_priv->pending) {
+		list_del(ptr);
+		entry = list_entry(ptr, drm_mach64_freelist_t, list);
+		drm_free(entry, sizeof(*entry), DRM_MEM_BUFLISTS);
+	}
+	list_for_each_safe(ptr, tmp, &dev_priv->placeholders) {
+		list_del(ptr);
+		entry = list_entry(ptr, drm_mach64_freelist_t, list);
+		drm_free(entry, sizeof(*entry), DRM_MEM_BUFLISTS);
+	}
+
+	list_for_each_safe(ptr, tmp, &dev_priv->free_list) {
+		list_del(ptr);
+		entry = list_entry(ptr, drm_mach64_freelist_t, list);
+		drm_free(entry, sizeof(*entry), DRM_MEM_BUFLISTS);
+	}
+}
+
+/* IMPORTANT: This function should only be called when the engine is idle or locked up,
+ * as it assumes all buffers in the pending list have been completed by the hardware.
+ */
+int mach64_do_release_used_buffers(drm_mach64_private_t * dev_priv)
+{
+	struct list_head *ptr;
+	struct list_head *tmp;
+	drm_mach64_freelist_t *entry;
+	int i;
+
+	if (list_empty(&dev_priv->pending))
+		return 0;
+
+	/* Iterate the pending list and move all buffers into the freelist... */
+	i = 0;
+	list_for_each_safe(ptr, tmp, &dev_priv->pending) {
+		entry = list_entry(ptr, drm_mach64_freelist_t, list);
+		if (entry->discard) {
+			entry->buf->pending = 0;
+			list_del(ptr);
+			list_add_tail(ptr, &dev_priv->free_list);
+			i++;
+		}
+	}
+
+	DRM_DEBUG("%s: released %d buffers from pending list\n", __FUNCTION__,
+		  i);
+
+	return 0;
+}
+
+static int mach64_do_reclaim_completed(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	struct list_head *ptr;
+	struct list_head *tmp;
+	drm_mach64_freelist_t *entry;
+	u32 head, tail, ofs;
+
+	mach64_ring_tick(dev_priv, ring);
+	head = ring->head;
+	tail = ring->tail;
+
+	if (head == tail) {
+#if MACH64_EXTRA_CHECKING
+		if (MACH64_READ(MACH64_GUI_STAT) & MACH64_GUI_ACTIVE) {
+			DRM_ERROR("Empty ring with non-idle engine!\n");
+			mach64_dump_ring_info(dev_priv);
+			return -1;
+		}
+#endif
+		/* last pass is complete, so release everything */
+		mach64_do_release_used_buffers(dev_priv);
+		DRM_DEBUG("%s: idle engine, freed all buffers.\n",
+		     __FUNCTION__);
+		if (list_empty(&dev_priv->free_list)) {
+			DRM_ERROR("Freelist empty with idle engine\n");
+			return -1;
+		}
+		return 0;
+	}
+	/* Look for a completed buffer and bail out of the loop
+	 * as soon as we find one -- don't waste time trying
+	 * to free extra bufs here, leave that to do_release_used_buffers
+	 */
+	list_for_each_safe(ptr, tmp, &dev_priv->pending) {
+		entry = list_entry(ptr, drm_mach64_freelist_t, list);
+		ofs = entry->ring_ofs;
+		if (entry->discard &&
+		    ((head < tail && (ofs < head || ofs >= tail)) ||
+		     (head > tail && (ofs < head && ofs >= tail)))) {
+#if MACH64_EXTRA_CHECKING
+			int i;
+
+			for (i = head; i != tail; i = (i + 4) & ring->tail_mask)
+			{
+				u32 o1 = le32_to_cpu(((u32 *) ring->
+						 start)[i + 1]);
+				u32 o2 = GETBUFADDR(entry->buf);
+
+				if (o1 == o2) {
+					DRM_ERROR
+					    ("Attempting to free used buffer: "
+					     "i=%d  buf=0x%08x\n",
+					     i, o1);
+					mach64_dump_ring_info(dev_priv);
+					return -1;
+				}
+			}
+#endif
+			/* found a processed buffer */
+			entry->buf->pending = 0;
+			list_del(ptr);
+			list_add_tail(ptr, &dev_priv->free_list);
+			DRM_DEBUG
+			    ("%s: freed processed buffer (head=%d tail=%d "
+			     "buf ring ofs=%d).\n",
+			     __FUNCTION__, head, tail, ofs);
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+struct drm_buf *mach64_freelist_get(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	drm_mach64_freelist_t *entry;
+	struct list_head *ptr;
+	int t;
+
+	if (list_empty(&dev_priv->free_list)) {
+		if (list_empty(&dev_priv->pending)) {
+			DRM_ERROR
+			    ("Couldn't get buffer - pending and free lists empty\n");
+			t = 0;
+			list_for_each(ptr, &dev_priv->placeholders) {
+				t++;
+			}
+			DRM_INFO("Placeholders: %d\n", t);
+			return NULL;
+		}
+
+		for (t = 0; t < dev_priv->usec_timeout; t++) {
+			int ret;
+
+			ret = mach64_do_reclaim_completed(dev_priv);
+			if (ret == 0)
+				goto _freelist_entry_found;
+			if (ret < 0)
+				return NULL;
+
+			DRM_UDELAY(1);
+		}
+		mach64_dump_ring_info(dev_priv);
+		DRM_ERROR
+		    ("timeout waiting for buffers: ring head_addr: 0x%08x head: %d tail: %d\n",
+		     ring->head_addr, ring->head, ring->tail);
+		return NULL;
+	}
+
+      _freelist_entry_found:
+	ptr = dev_priv->free_list.next;
+	list_del(ptr);
+	entry = list_entry(ptr, drm_mach64_freelist_t, list);
+	entry->buf->used = 0;
+	list_add_tail(ptr, &dev_priv->placeholders);
+	return entry->buf;
+}
+
+int mach64_freelist_put(drm_mach64_private_t * dev_priv, struct drm_buf * copy_buf)
+{
+	struct list_head *ptr;
+	drm_mach64_freelist_t *entry;
+
+#if MACH64_EXTRA_CHECKING
+	list_for_each(ptr, &dev_priv->pending) {
+		entry = list_entry(ptr, drm_mach64_freelist_t, list);
+		if (copy_buf == entry->buf) {
+			DRM_ERROR("%s: Trying to release a pending buf\n",
+			     __FUNCTION__);
+			return -EFAULT;
+		}
+	}
+#endif
+	ptr = dev_priv->placeholders.next;
+	entry = list_entry(ptr, drm_mach64_freelist_t, list);
+	copy_buf->pending = 0;
+	copy_buf->used = 0;
+	entry->buf = copy_buf;
+	entry->discard = 1;
+	list_del(ptr);
+	list_add_tail(ptr, &dev_priv->free_list);
+
+	return 0;
+}
+
+/*@}*/
+
+
+/*******************************************************************/
+/** \name DMA buffer request and submission IOCTL handler */
+/*@{*/
+
+static int mach64_dma_get_buffers(struct drm_device *dev,
+				  struct drm_file *file_priv,
+				  struct drm_dma * d)
+{
+	int i;
+	struct drm_buf *buf;
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = mach64_freelist_get(dev_priv);
+#if MACH64_EXTRA_CHECKING
+		if (!buf)
+			return -EFAULT;
+#else
+		if (!buf)
+			return -EAGAIN;
+#endif
+
+		buf->file_priv = file_priv;
+
+		if (DRM_COPY_TO_USER(&d->request_indices[i], &buf->idx,
+				     sizeof(buf->idx)))
+			return -EFAULT;
+		if (DRM_COPY_TO_USER(&d->request_sizes[i], &buf->total,
+				     sizeof(buf->total)))
+			return -EFAULT;
+
+		d->granted_count++;
+	}
+	return 0;
+}
+
+int mach64_dma_buffers(struct drm_device *dev, void *data,
+		       struct drm_file *file_priv)
+{
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_dma *d = data;
+	int ret = 0;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	/* Please don't send us buffers.
+	 */
+	if (d->send_count != 0) {
+		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
+			  DRM_CURRENTPID, d->send_count);
+		return -EINVAL;
+	}
+
+	/* We'll send you buffers.
+	 */
+	if (d->request_count < 0 || d->request_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
+			  DRM_CURRENTPID, d->request_count, dma->buf_count);
+		ret = -EINVAL;
+	}
+
+	d->granted_count = 0;
+
+	if (d->request_count) {
+		ret = mach64_dma_get_buffers(dev, file_priv, d);
+	}
+
+	return ret;
+}
+
+void mach64_driver_lastclose(struct drm_device * dev)
+{
+	mach64_do_cleanup_dma(dev);
+}
+
+/*@}*/
Index: git/shared-core/mach64_drm.h
===================================================================
--- git.orig/shared-core/mach64_drm.h	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/mach64_drm.h	2008-12-12 17:35:22.000000000 +0000
@@ -130,7 +130,7 @@
 
 	/* The current cliprects, or a subset thereof.
 	 */
-	drm_clip_rect_t boxes[MACH64_NR_SAREA_CLIPRECTS];
+	struct drm_clip_rect boxes[MACH64_NR_SAREA_CLIPRECTS];
 	unsigned int nbox;
 
 	/* Counters for client-side throttling of rendering clients.
@@ -139,7 +139,7 @@
 
 	/* Texture memory LRU.
 	 */
-	drm_tex_region_t tex_list[MACH64_NR_TEX_HEAPS][MACH64_NR_TEX_REGIONS +
+	struct drm_tex_region tex_list[MACH64_NR_TEX_HEAPS][MACH64_NR_TEX_REGIONS +
 						       1];
 	unsigned int tex_age[MACH64_NR_TEX_HEAPS];
 	int ctx_owner;
Index: git/shared-core/mach64_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/mach64_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,1058 @@
+/* mach64_drv.h -- Private header for mach64 driver -*- linux-c -*-
+ * Created: Fri Nov 24 22:07:58 2000 by gareth@valinux.com
+ */
+/*
+ * Copyright 2000 Gareth Hughes
+ * Copyright 2002 Frank C. Earl
+ * Copyright 2002-2003 Leif Delgass
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT OWNER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Frank C. Earl <fearl@airmail.net>
+ *    Leif Delgass <ldelgass@retinalburn.net>
+ *    JosFonseca <j_r_fonseca@yahoo.co.uk>
+ */
+
+#ifndef __MACH64_DRV_H__
+#define __MACH64_DRV_H__
+
+/* General customization:
+ */
+
+#define DRIVER_AUTHOR		"Gareth Hughes, Leif Delgass, Jos Fonseca"
+
+#define DRIVER_NAME		"mach64"
+#define DRIVER_DESC		"DRM module for the ATI Rage Pro"
+#define DRIVER_DATE		"20060718"
+
+#define DRIVER_MAJOR		2
+#define DRIVER_MINOR		0
+#define DRIVER_PATCHLEVEL	0
+
+/* FIXME: remove these when not needed */
+/* Development driver options */
+#define MACH64_EXTRA_CHECKING     0	/* Extra sanity checks for DMA/freelist management */
+#define MACH64_VERBOSE		  0	/* Verbose debugging output */
+
+typedef struct drm_mach64_freelist {
+	struct list_head list;	/* List pointers for free_list, placeholders, or pending list */
+	struct drm_buf *buf;		/* Pointer to the buffer */
+	int discard;		/* This flag is set when we're done (re)using a buffer */
+	u32 ring_ofs;		/* dword offset in ring of last descriptor for this buffer */
+} drm_mach64_freelist_t;
+
+typedef struct drm_mach64_descriptor_ring {
+	void *start;		/* write pointer (cpu address) to start of descriptor ring */
+	u32 start_addr;		/* bus address of beginning of descriptor ring */
+	int size;		/* size of ring in bytes */
+
+	u32 head_addr;		/* bus address of descriptor ring head */
+	u32 head;		/* dword offset of descriptor ring head */
+	u32 tail;		/* dword offset of descriptor ring tail */
+	u32 tail_mask;		/* mask used to wrap ring */
+	int space;		/* number of free bytes in ring */
+} drm_mach64_descriptor_ring_t;
+
+typedef struct drm_mach64_private {
+	drm_mach64_sarea_t *sarea_priv;
+
+	int is_pci;
+	drm_mach64_dma_mode_t driver_mode;	/* Async DMA, sync DMA, or MMIO */
+
+	int usec_timeout;	/* Timeout for the wait functions */
+
+	drm_mach64_descriptor_ring_t ring;	/* DMA descriptor table (ring buffer) */
+	int ring_running;	/* Is bus mastering is enabled */
+
+	struct list_head free_list;	/* Free-list head */
+	struct list_head placeholders;	/* Placeholder list for buffers held by clients */
+	struct list_head pending;	/* Buffers pending completion */
+
+	u32 frame_ofs[MACH64_MAX_QUEUED_FRAMES];	/* dword ring offsets of most recent frame swaps */
+
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+
+	u32 front_offset_pitch;
+	u32 back_offset_pitch;
+	u32 depth_offset_pitch;
+
+	drm_local_map_t *sarea;
+	drm_local_map_t *fb;
+	drm_local_map_t *mmio;
+	drm_local_map_t *ring_map;
+	drm_local_map_t *dev_buffers;	/* this is a pointer to a structure in dev */
+	drm_local_map_t *agp_textures;
+} drm_mach64_private_t;
+
+extern struct drm_ioctl_desc mach64_ioctls[];
+extern int mach64_max_ioctl;
+
+				/* mach64_dma.c */
+extern int mach64_dma_init(struct drm_device *dev, void *data,
+			   struct drm_file *file_priv);
+extern int mach64_dma_idle(struct drm_device *dev, void *data,
+			   struct drm_file *file_priv);
+extern int mach64_dma_flush(struct drm_device *dev, void *data,
+			    struct drm_file *file_priv);
+extern int mach64_engine_reset(struct drm_device *dev, void *data,
+			       struct drm_file *file_priv);
+extern int mach64_dma_buffers(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv);
+extern void mach64_driver_lastclose(struct drm_device * dev);
+
+extern int mach64_init_freelist(struct drm_device * dev);
+extern void mach64_destroy_freelist(struct drm_device * dev);
+extern struct drm_buf *mach64_freelist_get(drm_mach64_private_t * dev_priv);
+extern int mach64_freelist_put(drm_mach64_private_t * dev_priv,
+			       struct drm_buf * copy_buf);
+
+extern int mach64_do_wait_for_fifo(drm_mach64_private_t * dev_priv,
+				   int entries);
+extern int mach64_do_wait_for_idle(drm_mach64_private_t * dev_priv);
+extern int mach64_wait_ring(drm_mach64_private_t * dev_priv, int n);
+extern int mach64_do_dispatch_pseudo_dma(drm_mach64_private_t * dev_priv);
+extern int mach64_do_release_used_buffers(drm_mach64_private_t * dev_priv);
+extern void mach64_dump_engine_info(drm_mach64_private_t * dev_priv);
+extern void mach64_dump_ring_info(drm_mach64_private_t * dev_priv);
+extern int mach64_do_engine_reset(drm_mach64_private_t * dev_priv);
+
+extern int mach64_do_dma_idle(drm_mach64_private_t * dev_priv);
+extern int mach64_do_dma_flush(drm_mach64_private_t * dev_priv);
+extern int mach64_do_cleanup_dma(struct drm_device * dev);
+
+				/* mach64_state.c */
+extern int mach64_dma_clear(struct drm_device *dev, void *data,
+			    struct drm_file *file_priv);
+extern int mach64_dma_swap(struct drm_device *dev, void *data,
+			   struct drm_file *file_priv);
+extern int mach64_dma_vertex(struct drm_device *dev, void *data,
+			     struct drm_file *file_priv);
+extern int mach64_dma_blit(struct drm_device *dev, void *data,
+			   struct drm_file *file_priv);
+extern int mach64_get_param(struct drm_device *dev, void *data,
+			    struct drm_file *file_priv);
+extern int mach64_driver_vblank_wait(struct drm_device * dev,
+				     unsigned int *sequence);
+
+extern irqreturn_t mach64_driver_irq_handler(DRM_IRQ_ARGS);
+extern void mach64_driver_irq_preinstall(struct drm_device * dev);
+extern void mach64_driver_irq_postinstall(struct drm_device * dev);
+extern void mach64_driver_irq_uninstall(struct drm_device * dev);
+
+/* ================================================================
+ * Registers
+ */
+
+#define MACH64_AGP_BASE				0x0148
+#define MACH64_AGP_CNTL				0x014c
+#define MACH64_ALPHA_TST_CNTL			0x0550
+
+#define MACH64_DSP_CONFIG 			0x0420
+#define MACH64_DSP_ON_OFF 			0x0424
+#define MACH64_EXT_MEM_CNTL 			0x04ac
+#define MACH64_GEN_TEST_CNTL 			0x04d0
+#define MACH64_HW_DEBUG 			0x047c
+#define MACH64_MEM_ADDR_CONFIG 			0x0434
+#define MACH64_MEM_BUF_CNTL 			0x042c
+#define MACH64_MEM_CNTL 			0x04b0
+
+#define MACH64_BM_ADDR				0x0648
+#define MACH64_BM_COMMAND			0x0188
+#define MACH64_BM_DATA				0x0648
+#define MACH64_BM_FRAME_BUF_OFFSET		0x0180
+#define MACH64_BM_GUI_TABLE			0x01b8
+#define MACH64_BM_GUI_TABLE_CMD			0x064c
+#	define MACH64_CIRCULAR_BUF_SIZE_16KB		(0 << 0)
+#	define MACH64_CIRCULAR_BUF_SIZE_32KB		(1 << 0)
+#	define MACH64_CIRCULAR_BUF_SIZE_64KB		(2 << 0)
+#	define MACH64_CIRCULAR_BUF_SIZE_128KB		(3 << 0)
+#	define MACH64_LAST_DESCRIPTOR			(1 << 31)
+#define MACH64_BM_HOSTDATA			0x0644
+#define MACH64_BM_STATUS			0x018c
+#define MACH64_BM_SYSTEM_MEM_ADDR		0x0184
+#define MACH64_BM_SYSTEM_TABLE			0x01bc
+#define MACH64_BUS_CNTL				0x04a0
+#	define MACH64_BUS_MSTR_RESET			(1 << 1)
+#	define MACH64_BUS_APER_REG_DIS			(1 << 4)
+#	define MACH64_BUS_FLUSH_BUF			(1 << 2)
+#	define MACH64_BUS_MASTER_DIS			(1 << 6)
+#	define MACH64_BUS_EXT_REG_EN			(1 << 27)
+
+#define MACH64_CLR_CMP_CLR			0x0700
+#define MACH64_CLR_CMP_CNTL			0x0708
+#define MACH64_CLR_CMP_MASK			0x0704
+#define MACH64_CONFIG_CHIP_ID 			0x04e0
+#define MACH64_CONFIG_CNTL 			0x04dc
+#define MACH64_CONFIG_STAT0 			0x04e4
+#define MACH64_CONFIG_STAT1 			0x0494
+#define MACH64_CONFIG_STAT2 			0x0498
+#define MACH64_CONTEXT_LOAD_CNTL		0x072c
+#define MACH64_CONTEXT_MASK			0x0720
+#define MACH64_COMPOSITE_SHADOW_ID		0x0798
+#define MACH64_CRC_SIG 				0x04e8
+#define MACH64_CUSTOM_MACRO_CNTL 		0x04d4
+
+#define MACH64_DP_BKGD_CLR			0x06c0
+#define MACH64_DP_FOG_CLR			0x06c4
+#define MACH64_DP_FGRD_BKGD_CLR			0x06e0
+#define MACH64_DP_FRGD_CLR			0x06c4
+#define MACH64_DP_FGRD_CLR_MIX			0x06dc
+
+#define MACH64_DP_MIX				0x06d4
+#	define BKGD_MIX_NOT_D				(0 << 0)
+#	define BKGD_MIX_ZERO				(1 << 0)
+#	define BKGD_MIX_ONE				(2 << 0)
+#	define MACH64_BKGD_MIX_D			(3 << 0)
+#	define BKGD_MIX_NOT_S				(4 << 0)
+#	define BKGD_MIX_D_XOR_S				(5 << 0)
+#	define BKGD_MIX_NOT_D_XOR_S			(6 << 0)
+#	define MACH64_BKGD_MIX_S			(7 << 0)
+#	define BKGD_MIX_NOT_D_OR_NOT_S			(8 << 0)
+#	define BKGD_MIX_D_OR_NOT_S			(9 << 0)
+#	define BKGD_MIX_NOT_D_OR_S			(10 << 0)
+#	define BKGD_MIX_D_OR_S				(11 << 0)
+#	define BKGD_MIX_D_AND_S				(12 << 0)
+#	define BKGD_MIX_NOT_D_AND_S			(13 << 0)
+#	define BKGD_MIX_D_AND_NOT_S			(14 << 0)
+#	define BKGD_MIX_NOT_D_AND_NOT_S			(15 << 0)
+#	define BKGD_MIX_D_PLUS_S_DIV2			(23 << 0)
+#	define FRGD_MIX_NOT_D				(0 << 16)
+#	define FRGD_MIX_ZERO				(1 << 16)
+#	define FRGD_MIX_ONE				(2 << 16)
+#	define FRGD_MIX_D				(3 << 16)
+#	define FRGD_MIX_NOT_S				(4 << 16)
+#	define FRGD_MIX_D_XOR_S				(5 << 16)
+#	define FRGD_MIX_NOT_D_XOR_S			(6 << 16)
+#	define MACH64_FRGD_MIX_S			(7 << 16)
+#	define FRGD_MIX_NOT_D_OR_NOT_S			(8 << 16)
+#	define FRGD_MIX_D_OR_NOT_S			(9 << 16)
+#	define FRGD_MIX_NOT_D_OR_S			(10 << 16)
+#	define FRGD_MIX_D_OR_S				(11 << 16)
+#	define FRGD_MIX_D_AND_S				(12 << 16)
+#	define FRGD_MIX_NOT_D_AND_S			(13 << 16)
+#	define FRGD_MIX_D_AND_NOT_S			(14 << 16)
+#	define FRGD_MIX_NOT_D_AND_NOT_S			(15 << 16)
+#	define FRGD_MIX_D_PLUS_S_DIV2			(23 << 16)
+
+#define MACH64_DP_PIX_WIDTH			0x06d0
+#	define MACH64_HOST_TRIPLE_ENABLE		(1 << 13)
+#	define MACH64_BYTE_ORDER_MSB_TO_LSB		(0 << 24)
+#	define MACH64_BYTE_ORDER_LSB_TO_MSB		(1 << 24)
+
+#define MACH64_DP_SRC				0x06d8
+#	define MACH64_BKGD_SRC_BKGD_CLR			(0 << 0)
+#	define MACH64_BKGD_SRC_FRGD_CLR			(1 << 0)
+#	define MACH64_BKGD_SRC_HOST			(2 << 0)
+#	define MACH64_BKGD_SRC_BLIT			(3 << 0)
+#	define MACH64_BKGD_SRC_PATTERN			(4 << 0)
+#	define MACH64_BKGD_SRC_3D			(5 << 0)
+#	define MACH64_FRGD_SRC_BKGD_CLR			(0 << 8)
+#	define MACH64_FRGD_SRC_FRGD_CLR			(1 << 8)
+#	define MACH64_FRGD_SRC_HOST			(2 << 8)
+#	define MACH64_FRGD_SRC_BLIT			(3 << 8)
+#	define MACH64_FRGD_SRC_PATTERN			(4 << 8)
+#	define MACH64_FRGD_SRC_3D			(5 << 8)
+#	define MACH64_MONO_SRC_ONE			(0 << 16)
+#	define MACH64_MONO_SRC_PATTERN			(1 << 16)
+#	define MACH64_MONO_SRC_HOST			(2 << 16)
+#	define MACH64_MONO_SRC_BLIT			(3 << 16)
+
+#define MACH64_DP_WRITE_MASK			0x06c8
+
+#define MACH64_DST_CNTL				0x0530
+#	define MACH64_DST_X_RIGHT_TO_LEFT		(0 << 0)
+#	define MACH64_DST_X_LEFT_TO_RIGHT		(1 << 0)
+#	define MACH64_DST_Y_BOTTOM_TO_TOP		(0 << 1)
+#	define MACH64_DST_Y_TOP_TO_BOTTOM		(1 << 1)
+#	define MACH64_DST_X_MAJOR			(0 << 2)
+#	define MACH64_DST_Y_MAJOR			(1 << 2)
+#	define MACH64_DST_X_TILE			(1 << 3)
+#	define MACH64_DST_Y_TILE			(1 << 4)
+#	define MACH64_DST_LAST_PEL			(1 << 5)
+#	define MACH64_DST_POLYGON_ENABLE		(1 << 6)
+#	define MACH64_DST_24_ROTATION_ENABLE		(1 << 7)
+
+#define MACH64_DST_HEIGHT_WIDTH			0x0518
+#define MACH64_DST_OFF_PITCH			0x0500
+#define MACH64_DST_WIDTH_HEIGHT			0x06ec
+#define MACH64_DST_X_Y				0x06e8
+#define MACH64_DST_Y_X				0x050c
+
+#define MACH64_FIFO_STAT			0x0710
+#	define MACH64_FIFO_SLOT_MASK			0x0000ffff
+#	define MACH64_FIFO_ERR				(1 << 31)
+
+#define MACH64_GEN_TEST_CNTL			0x04d0
+#	define MACH64_GUI_ENGINE_ENABLE			(1 << 8)
+#define MACH64_GUI_CMDFIFO_DEBUG		0x0170
+#define MACH64_GUI_CMDFIFO_DATA			0x0174
+#define MACH64_GUI_CNTL				0x0178
+#       define MACH64_CMDFIFO_SIZE_MASK                 0x00000003ul
+#       define MACH64_CMDFIFO_SIZE_192                  0x00000000ul
+#       define MACH64_CMDFIFO_SIZE_128                  0x00000001ul
+#       define MACH64_CMDFIFO_SIZE_64                   0x00000002ul
+#define MACH64_GUI_STAT				0x0738
+#	define MACH64_GUI_ACTIVE			(1 << 0)
+#define MACH64_GUI_TRAJ_CNTL			0x0730
+
+#define MACH64_HOST_CNTL			0x0640
+#define MACH64_HOST_DATA0			0x0600
+
+#define MACH64_ONE_OVER_AREA			0x029c
+#define MACH64_ONE_OVER_AREA_UC			0x0300
+
+#define MACH64_PAT_REG0				0x0680
+#define MACH64_PAT_REG1				0x0684
+
+#define MACH64_SC_LEFT                          0x06a0
+#define MACH64_SC_RIGHT                         0x06a4
+#define MACH64_SC_LEFT_RIGHT                    0x06a8
+#define MACH64_SC_TOP                           0x06ac
+#define MACH64_SC_BOTTOM                        0x06b0
+#define MACH64_SC_TOP_BOTTOM                    0x06b4
+
+#define MACH64_SCALE_3D_CNTL			0x05fc
+#define MACH64_SCRATCH_REG0			0x0480
+#define MACH64_SCRATCH_REG1			0x0484
+#define MACH64_SECONDARY_TEX_OFF		0x0778
+#define MACH64_SETUP_CNTL			0x0304
+#define MACH64_SRC_CNTL				0x05b4
+#	define MACH64_SRC_BM_ENABLE			(1 << 8)
+#	define MACH64_SRC_BM_SYNC			(1 << 9)
+#	define MACH64_SRC_BM_OP_FRAME_TO_SYSTEM		(0 << 10)
+#	define MACH64_SRC_BM_OP_SYSTEM_TO_FRAME		(1 << 10)
+#	define MACH64_SRC_BM_OP_REG_TO_SYSTEM		(2 << 10)
+#	define MACH64_SRC_BM_OP_SYSTEM_TO_REG		(3 << 10)
+#define MACH64_SRC_HEIGHT1			0x0594
+#define MACH64_SRC_HEIGHT2			0x05ac
+#define MACH64_SRC_HEIGHT1_WIDTH1		0x0598
+#define MACH64_SRC_HEIGHT2_WIDTH2		0x05b0
+#define MACH64_SRC_OFF_PITCH			0x0580
+#define MACH64_SRC_WIDTH1			0x0590
+#define MACH64_SRC_Y_X				0x058c
+
+#define MACH64_TEX_0_OFF			0x05c0
+#define MACH64_TEX_CNTL				0x0774
+#define MACH64_TEX_SIZE_PITCH			0x0770
+#define MACH64_TIMER_CONFIG 			0x0428
+
+#define MACH64_VERTEX_1_ARGB			0x0254
+#define MACH64_VERTEX_1_S			0x0240
+#define MACH64_VERTEX_1_SECONDARY_S		0x0328
+#define MACH64_VERTEX_1_SECONDARY_T		0x032c
+#define MACH64_VERTEX_1_SECONDARY_W		0x0330
+#define MACH64_VERTEX_1_SPEC_ARGB		0x024c
+#define MACH64_VERTEX_1_T			0x0244
+#define MACH64_VERTEX_1_W			0x0248
+#define MACH64_VERTEX_1_X_Y			0x0258
+#define MACH64_VERTEX_1_Z			0x0250
+#define MACH64_VERTEX_2_ARGB			0x0274
+#define MACH64_VERTEX_2_S			0x0260
+#define MACH64_VERTEX_2_SECONDARY_S		0x0334
+#define MACH64_VERTEX_2_SECONDARY_T		0x0338
+#define MACH64_VERTEX_2_SECONDARY_W		0x033c
+#define MACH64_VERTEX_2_SPEC_ARGB		0x026c
+#define MACH64_VERTEX_2_T			0x0264
+#define MACH64_VERTEX_2_W			0x0268
+#define MACH64_VERTEX_2_X_Y			0x0278
+#define MACH64_VERTEX_2_Z			0x0270
+#define MACH64_VERTEX_3_ARGB			0x0294
+#define MACH64_VERTEX_3_S			0x0280
+#define MACH64_VERTEX_3_SECONDARY_S		0x02a0
+#define MACH64_VERTEX_3_SECONDARY_T		0x02a4
+#define MACH64_VERTEX_3_SECONDARY_W		0x02a8
+#define MACH64_VERTEX_3_SPEC_ARGB		0x028c
+#define MACH64_VERTEX_3_T			0x0284
+#define MACH64_VERTEX_3_W			0x0288
+#define MACH64_VERTEX_3_X_Y			0x0298
+#define MACH64_VERTEX_3_Z			0x0290
+
+#define MACH64_Z_CNTL				0x054c
+#define MACH64_Z_OFF_PITCH			0x0548
+
+#define MACH64_CRTC_VLINE_CRNT_VLINE		0x0410
+#	define MACH64_CRTC_VLINE_MASK		        0x000007ff
+#	define MACH64_CRTC_CRNT_VLINE_MASK		0x07ff0000
+#define MACH64_CRTC_OFF_PITCH			0x0414
+#define MACH64_CRTC_INT_CNTL			0x0418
+#	define MACH64_CRTC_VBLANK			(1 << 0)
+#	define MACH64_CRTC_VBLANK_INT_EN		(1 << 1)
+#	define MACH64_CRTC_VBLANK_INT			(1 << 2)
+#	define MACH64_CRTC_VLINE_INT_EN			(1 << 3)
+#	define MACH64_CRTC_VLINE_INT			(1 << 4)
+#	define MACH64_CRTC_VLINE_SYNC			(1 << 5)	/* 0=even, 1=odd */
+#	define MACH64_CRTC_FRAME			(1 << 6)	/* 0=even, 1=odd */
+#	define MACH64_CRTC_SNAPSHOT_INT_EN		(1 << 7)
+#	define MACH64_CRTC_SNAPSHOT_INT			(1 << 8)
+#	define MACH64_CRTC_I2C_INT_EN			(1 << 9)
+#	define MACH64_CRTC_I2C_INT			(1 << 10)
+#	define MACH64_CRTC2_VBLANK			(1 << 11)	/* LT Pro */
+#	define MACH64_CRTC2_VBLANK_INT_EN		(1 << 12)	/* LT Pro */
+#	define MACH64_CRTC2_VBLANK_INT			(1 << 13)	/* LT Pro */
+#	define MACH64_CRTC2_VLINE_INT_EN		(1 << 14)	/* LT Pro */
+#	define MACH64_CRTC2_VLINE_INT			(1 << 15)	/* LT Pro */
+#	define MACH64_CRTC_CAPBUF0_INT_EN		(1 << 16)
+#	define MACH64_CRTC_CAPBUF0_INT			(1 << 17)
+#	define MACH64_CRTC_CAPBUF1_INT_EN		(1 << 18)
+#	define MACH64_CRTC_CAPBUF1_INT			(1 << 19)
+#	define MACH64_CRTC_OVERLAY_EOF_INT_EN		(1 << 20)
+#	define MACH64_CRTC_OVERLAY_EOF_INT		(1 << 21)
+#	define MACH64_CRTC_ONESHOT_CAP_INT_EN		(1 << 22)
+#	define MACH64_CRTC_ONESHOT_CAP_INT		(1 << 23)
+#	define MACH64_CRTC_BUSMASTER_EOL_INT_EN		(1 << 24)
+#	define MACH64_CRTC_BUSMASTER_EOL_INT		(1 << 25)
+#	define MACH64_CRTC_GP_INT_EN			(1 << 26)
+#	define MACH64_CRTC_GP_INT			(1 << 27)
+#	define MACH64_CRTC2_VLINE_SYNC			(1 << 28) /* LT Pro */	/* 0=even, 1=odd */
+#	define MACH64_CRTC_SNAPSHOT2_INT_EN		(1 << 29)	/* LT Pro */
+#	define MACH64_CRTC_SNAPSHOT2_INT		(1 << 30)	/* LT Pro */
+#	define MACH64_CRTC_VBLANK2_INT			(1 << 31)
+#	define MACH64_CRTC_INT_ENS				\
+		(						\
+			MACH64_CRTC_VBLANK_INT_EN |		\
+			MACH64_CRTC_VLINE_INT_EN |		\
+			MACH64_CRTC_SNAPSHOT_INT_EN |		\
+			MACH64_CRTC_I2C_INT_EN |		\
+			MACH64_CRTC2_VBLANK_INT_EN |		\
+			MACH64_CRTC2_VLINE_INT_EN |		\
+			MACH64_CRTC_CAPBUF0_INT_EN |		\
+			MACH64_CRTC_CAPBUF1_INT_EN |		\
+			MACH64_CRTC_OVERLAY_EOF_INT_EN |	\
+			MACH64_CRTC_ONESHOT_CAP_INT_EN |	\
+			MACH64_CRTC_BUSMASTER_EOL_INT_EN |	\
+			MACH64_CRTC_GP_INT_EN |			\
+			MACH64_CRTC_SNAPSHOT2_INT_EN |		\
+			0					\
+		)
+#	define MACH64_CRTC_INT_ACKS			\
+		(					\
+			MACH64_CRTC_VBLANK_INT |	\
+			MACH64_CRTC_VLINE_INT |		\
+			MACH64_CRTC_SNAPSHOT_INT |	\
+			MACH64_CRTC_I2C_INT |		\
+			MACH64_CRTC2_VBLANK_INT |	\
+			MACH64_CRTC2_VLINE_INT |	\
+			MACH64_CRTC_CAPBUF0_INT |	\
+			MACH64_CRTC_CAPBUF1_INT |	\
+			MACH64_CRTC_OVERLAY_EOF_INT |	\
+			MACH64_CRTC_ONESHOT_CAP_INT |	\
+			MACH64_CRTC_BUSMASTER_EOL_INT |	\
+			MACH64_CRTC_GP_INT |		\
+			MACH64_CRTC_SNAPSHOT2_INT |	\
+			MACH64_CRTC_VBLANK2_INT |	\
+			0				\
+		)
+
+#define MACH64_DATATYPE_CI8				2
+#define MACH64_DATATYPE_ARGB1555			3
+#define MACH64_DATATYPE_RGB565				4
+#define MACH64_DATATYPE_ARGB8888			6
+#define MACH64_DATATYPE_RGB332				7
+#define MACH64_DATATYPE_Y8				8
+#define MACH64_DATATYPE_RGB8				9
+#define MACH64_DATATYPE_VYUY422				11
+#define MACH64_DATATYPE_YVYU422				12
+#define MACH64_DATATYPE_AYUV444				14
+#define MACH64_DATATYPE_ARGB4444			15
+
+#define MACH64_READ(reg)	DRM_READ32(dev_priv->mmio, (reg) )
+#define MACH64_WRITE(reg,val)	DRM_WRITE32(dev_priv->mmio, (reg), (val) )
+
+#define DWMREG0		0x0400
+#define DWMREG0_END	0x07ff
+#define DWMREG1		0x0000
+#define DWMREG1_END	0x03ff
+
+#define ISREG0(r)	(((r) >= DWMREG0) && ((r) <= DWMREG0_END))
+#define DMAREG0(r)	(((r) - DWMREG0) >> 2)
+#define DMAREG1(r)	((((r) - DWMREG1) >> 2 ) | 0x0100)
+#define DMAREG(r)	(ISREG0(r) ? DMAREG0(r) : DMAREG1(r))
+
+#define MMREG0		0x0000
+#define MMREG0_END	0x00ff
+
+#define ISMMREG0(r)	(((r) >= MMREG0) && ((r) <= MMREG0_END))
+#define MMSELECT0(r)	(((r) << 2) + DWMREG0)
+#define MMSELECT1(r)	(((((r) & 0xff) << 2) + DWMREG1))
+#define MMSELECT(r)	(ISMMREG0(r) ? MMSELECT0(r) : MMSELECT1(r))
+
+/* ================================================================
+ * DMA constants
+ */
+
+/* DMA descriptor field indices:
+ * The descriptor fields are loaded into the read-only
+ * BM_* system bus master registers during a bus-master operation
+ */
+#define MACH64_DMA_FRAME_BUF_OFFSET	0	/* BM_FRAME_BUF_OFFSET */
+#define MACH64_DMA_SYS_MEM_ADDR		1	/* BM_SYSTEM_MEM_ADDR */
+#define MACH64_DMA_COMMAND		2	/* BM_COMMAND */
+#define MACH64_DMA_RESERVED		3	/* BM_STATUS */
+
+/* BM_COMMAND descriptor field flags */
+#define MACH64_DMA_HOLD_OFFSET		(1<<30)	/* Don't increment DMA_FRAME_BUF_OFFSET */
+#define MACH64_DMA_EOL			(1<<31)	/* End of descriptor list flag */
+
+#define MACH64_DMA_CHUNKSIZE	        0x1000	/* 4kB per DMA descriptor */
+#define MACH64_APERTURE_OFFSET	        0x7ff800	/* frame-buffer offset for gui-masters */
+
+/* ================================================================
+ * Misc helper macros
+ */
+
+static __inline__ void mach64_set_dma_eol(volatile u32 * addr)
+{
+#if defined(__i386__)
+	int nr = 31;
+
+	/* Taken from include/asm-i386/bitops.h linux header */
+	__asm__ __volatile__("lock;" "btsl %1,%0":"=m"(*addr)
+			     :"Ir"(nr));
+#elif defined(__powerpc__)
+	u32 old;
+	u32 mask = cpu_to_le32(MACH64_DMA_EOL);
+
+	/* Taken from the include/asm-ppc/bitops.h linux header */
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3 \n\
+	or	%0,%0,%2 \n\
+	stwcx.	%0,0,%3 \n\
+	bne-	1b":"=&r"(old), "=m"(*addr)
+			     :"r"(mask), "r"(addr), "m"(*addr)
+			     :"cc");
+#elif defined(__alpha__)
+	u32 temp;
+	u32 mask = MACH64_DMA_EOL;
+
+	/* Taken from the include/asm-alpha/bitops.h linux header */
+	__asm__ __volatile__("1:	ldl_l %0,%3\n"
+			     "	bis %0,%2,%0\n"
+			     "	stl_c %0,%1\n"
+			     "	beq %0,2f\n"
+			     ".subsection 2\n"
+			     "2:	br 1b\n"
+			     ".previous":"=&r"(temp), "=m"(*addr)
+			     :"Ir"(mask), "m"(*addr));
+#else
+	u32 mask = cpu_to_le32(MACH64_DMA_EOL);
+
+	*addr |= mask;
+#endif
+}
+
+static __inline__ void mach64_clear_dma_eol(volatile u32 * addr)
+{
+#if defined(__i386__)
+	int nr = 31;
+
+	/* Taken from include/asm-i386/bitops.h linux header */
+	__asm__ __volatile__("lock;" "btrl %1,%0":"=m"(*addr)
+			     :"Ir"(nr));
+#elif defined(__powerpc__)
+	u32 old;
+	u32 mask = cpu_to_le32(MACH64_DMA_EOL);
+
+	/* Taken from the include/asm-ppc/bitops.h linux header */
+	__asm__ __volatile__("\n\
+1:	lwarx	%0,0,%3 \n\
+	andc	%0,%0,%2 \n\
+	stwcx.	%0,0,%3 \n\
+	bne-	1b":"=&r"(old), "=m"(*addr)
+			     :"r"(mask), "r"(addr), "m"(*addr)
+			     :"cc");
+#elif defined(__alpha__)
+	u32 temp;
+	u32 mask = ~MACH64_DMA_EOL;
+
+	/* Taken from the include/asm-alpha/bitops.h linux header */
+	__asm__ __volatile__("1:	ldl_l %0,%3\n"
+			     "	and %0,%2,%0\n"
+			     "	stl_c %0,%1\n"
+			     "	beq %0,2f\n"
+			     ".subsection 2\n"
+			     "2:	br 1b\n"
+			     ".previous":"=&r"(temp), "=m"(*addr)
+			     :"Ir"(mask), "m"(*addr));
+#else
+	u32 mask = cpu_to_le32(~MACH64_DMA_EOL);
+
+	*addr &= mask;
+#endif
+}
+
+static __inline__ void mach64_ring_start(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+
+	DRM_DEBUG("%s: head_addr: 0x%08x head: %d tail: %d space: %d\n",
+		  __FUNCTION__,
+		  ring->head_addr, ring->head, ring->tail, ring->space);
+
+	if (mach64_do_wait_for_idle(dev_priv) < 0) {
+		mach64_do_engine_reset(dev_priv);
+	}
+
+	if (dev_priv->driver_mode != MACH64_MODE_MMIO) {
+		/* enable bus mastering and block 1 registers */
+		MACH64_WRITE(MACH64_BUS_CNTL,
+			     (MACH64_READ(MACH64_BUS_CNTL) &
+			      ~MACH64_BUS_MASTER_DIS)
+			     | MACH64_BUS_EXT_REG_EN);
+		mach64_do_wait_for_idle(dev_priv);
+	}
+
+	/* reset descriptor table ring head */
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     ring->head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);
+
+	dev_priv->ring_running = 1;
+}
+
+static __inline__ void mach64_ring_resume(drm_mach64_private_t * dev_priv,
+					  drm_mach64_descriptor_ring_t * ring)
+{
+	DRM_DEBUG("%s: head_addr: 0x%08x head: %d tail: %d space: %d\n",
+		  __FUNCTION__,
+		  ring->head_addr, ring->head, ring->tail, ring->space);
+
+	/* reset descriptor table ring head */
+	MACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,
+		     ring->head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);
+
+	if (dev_priv->driver_mode == MACH64_MODE_MMIO) {
+		mach64_do_dispatch_pseudo_dma(dev_priv);
+	} else {
+		/* enable GUI bus mastering, and sync the bus master to the GUI */
+		MACH64_WRITE(MACH64_SRC_CNTL,
+			     MACH64_SRC_BM_ENABLE | MACH64_SRC_BM_SYNC |
+			     MACH64_SRC_BM_OP_SYSTEM_TO_REG);
+
+		/* kick off the transfer */
+		MACH64_WRITE(MACH64_DST_HEIGHT_WIDTH, 0);
+		if (dev_priv->driver_mode == MACH64_MODE_DMA_SYNC) {
+			if ((mach64_do_wait_for_idle(dev_priv)) < 0) {
+				DRM_ERROR("%s: idle failed, resetting engine\n",
+					  __FUNCTION__);
+				mach64_dump_engine_info(dev_priv);
+				mach64_do_engine_reset(dev_priv);
+				return;
+			}
+			mach64_do_release_used_buffers(dev_priv);
+		}
+	}
+}
+
+static __inline__ void mach64_ring_tick(drm_mach64_private_t * dev_priv,
+					drm_mach64_descriptor_ring_t * ring)
+{
+	DRM_DEBUG("%s: head_addr: 0x%08x head: %d tail: %d space: %d\n",
+		  __FUNCTION__,
+		  ring->head_addr, ring->head, ring->tail, ring->space);
+
+	if (!dev_priv->ring_running) {
+		mach64_ring_start(dev_priv);
+
+		if (ring->head != ring->tail) {
+			mach64_ring_resume(dev_priv, ring);
+		}
+	} else {
+		/* GUI_ACTIVE must be read before BM_GUI_TABLE to
+		 * correctly determine the ring head
+		 */
+		int gui_active =
+		    MACH64_READ(MACH64_GUI_STAT) & MACH64_GUI_ACTIVE;
+
+		ring->head_addr = MACH64_READ(MACH64_BM_GUI_TABLE) & 0xfffffff0;
+
+		if (gui_active) {
+			/* If not idle, BM_GUI_TABLE points one descriptor
+			 * past the current head
+			 */
+			if (ring->head_addr == ring->start_addr) {
+				ring->head_addr += ring->size;
+			}
+			ring->head_addr -= 4 * sizeof(u32);
+		}
+
+		if (ring->head_addr < ring->start_addr ||
+		    ring->head_addr >= ring->start_addr + ring->size) {
+			DRM_ERROR("bad ring head address: 0x%08x\n",
+				  ring->head_addr);
+			mach64_dump_ring_info(dev_priv);
+			mach64_do_engine_reset(dev_priv);
+			return;
+		}
+
+		ring->head = (ring->head_addr - ring->start_addr) / sizeof(u32);
+
+		if (!gui_active && ring->head != ring->tail) {
+			mach64_ring_resume(dev_priv, ring);
+		}
+	}
+}
+
+static __inline__ void mach64_ring_stop(drm_mach64_private_t * dev_priv)
+{
+	DRM_DEBUG("%s: head_addr: 0x%08x head: %d tail: %d space: %d\n",
+		  __FUNCTION__,
+		  dev_priv->ring.head_addr, dev_priv->ring.head,
+		  dev_priv->ring.tail, dev_priv->ring.space);
+
+	/* restore previous SRC_CNTL to disable busmastering */
+	mach64_do_wait_for_fifo(dev_priv, 1);
+	MACH64_WRITE(MACH64_SRC_CNTL, 0);
+
+	/* disable busmastering but keep the block 1 registers enabled */
+	mach64_do_wait_for_idle(dev_priv);
+	MACH64_WRITE(MACH64_BUS_CNTL, MACH64_READ(MACH64_BUS_CNTL)
+		     | MACH64_BUS_MASTER_DIS | MACH64_BUS_EXT_REG_EN);
+
+	dev_priv->ring_running = 0;
+}
+
+static __inline__ void
+mach64_update_ring_snapshot(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	mach64_ring_tick(dev_priv, ring);
+
+	ring->space = (ring->head - ring->tail) * sizeof(u32);
+	if (ring->space <= 0) {
+		ring->space += ring->size;
+	}
+}
+
+/* ================================================================
+ * DMA descriptor ring macros
+ */
+
+#define RING_LOCALS									\
+	int _ring_tail, _ring_write; unsigned int _ring_mask; volatile u32 *_ring
+
+#define RING_WRITE_OFS  _ring_write
+
+#define BEGIN_RING( n ) 								\
+do {											\
+	if ( MACH64_VERBOSE ) {								\
+		DRM_INFO( "BEGIN_RING( %d ) in %s\n",					\
+			   (n), __FUNCTION__ );						\
+	}										\
+	if ( dev_priv->ring.space <= (n) * sizeof(u32) ) {				\
+		int ret;								\
+		if ((ret=mach64_wait_ring( dev_priv, (n) * sizeof(u32))) < 0 ) {	\
+			DRM_ERROR( "wait_ring failed, resetting engine\n");		\
+			mach64_dump_engine_info( dev_priv );				\
+			mach64_do_engine_reset( dev_priv );				\
+			return ret;							\
+		}									\
+	}										\
+	dev_priv->ring.space -= (n) * sizeof(u32);					\
+	_ring = (u32 *) dev_priv->ring.start;						\
+	_ring_tail = _ring_write = dev_priv->ring.tail;					\
+	_ring_mask = dev_priv->ring.tail_mask;						\
+} while (0)
+
+#define OUT_RING( x )						\
+do {								\
+	if ( MACH64_VERBOSE ) {					\
+		DRM_INFO( "   OUT_RING( 0x%08x ) at 0x%x\n",	\
+			   (unsigned int)(x), _ring_write );	\
+	}							\
+	_ring[_ring_write++] = cpu_to_le32( x );		\
+	_ring_write &= _ring_mask;				\
+} while (0)
+
+#define ADVANCE_RING() 							\
+do {									\
+	if ( MACH64_VERBOSE ) {						\
+		DRM_INFO( "ADVANCE_RING() wr=0x%06x tail=0x%06x\n",	\
+			  _ring_write, _ring_tail );			\
+	}								\
+	DRM_MEMORYBARRIER();						\
+	mach64_clear_dma_eol( &_ring[(_ring_tail - 2) & _ring_mask] );	\
+	DRM_MEMORYBARRIER();						\
+	dev_priv->ring.tail = _ring_write;				\
+	mach64_ring_tick( dev_priv, &(dev_priv)->ring );		\
+} while (0)
+
+/* ================================================================
+ * DMA macros
+ */
+
+#define DMALOCALS				\
+	drm_mach64_freelist_t *_entry = NULL;	\
+	struct drm_buf *_buf = NULL; 		\
+	u32 *_buf_wptr; int _outcount
+
+#define GETBUFPTR( __buf )						\
+((dev_priv->is_pci) ? 							\
+	((u32 *)(__buf)->address) : 					\
+	((u32 *)((char *)dev_priv->dev_buffers->handle + (__buf)->offset)))
+
+#define GETBUFADDR( __buf ) ((u32)(__buf)->bus_address)
+
+#define GETRINGOFFSET() (_entry->ring_ofs)
+
+static __inline__ int mach64_find_pending_buf_entry(drm_mach64_private_t *
+						    dev_priv,
+						    drm_mach64_freelist_t **
+						    entry, struct drm_buf * buf)
+{
+	struct list_head *ptr;
+#if MACH64_EXTRA_CHECKING
+	if (list_empty(&dev_priv->pending)) {
+		DRM_ERROR("Empty pending list in %s\n", __FUNCTION__);
+		return -EINVAL;
+	}
+#endif
+	ptr = dev_priv->pending.prev;
+	*entry = list_entry(ptr, drm_mach64_freelist_t, list);
+	while ((*entry)->buf != buf) {
+		if (ptr == &dev_priv->pending) {
+			return -EFAULT;
+		}
+		ptr = ptr->prev;
+		*entry = list_entry(ptr, drm_mach64_freelist_t, list);
+	}
+	return 0;
+}
+
+#define DMASETPTR( _p ) 			\
+do {						\
+	_buf = (_p);				\
+	_outcount = 0;				\
+	_buf_wptr = GETBUFPTR( _buf );		\
+} while(0)
+
+/* FIXME: use a private set of smaller buffers for state emits, clears, and swaps? */
+#define DMAGETPTR( file_priv, dev_priv, n )				\
+do {									\
+	if ( MACH64_VERBOSE ) {						\
+		DRM_INFO( "DMAGETPTR( %d ) in %s\n",			\
+			  n, __FUNCTION__ );				\
+	}								\
+	_buf = mach64_freelist_get( dev_priv );				\
+	if (_buf == NULL) {						\
+		DRM_ERROR("%s: couldn't get buffer in DMAGETPTR\n",	\
+			   __FUNCTION__ );				\
+		return -EAGAIN;					\
+	}								\
+	if (_buf->pending) {						\
+	        DRM_ERROR("%s: pending buf in DMAGETPTR\n",		\
+			   __FUNCTION__ );				\
+		return -EFAULT;					\
+	}								\
+	_buf->file_priv = file_priv;					\
+	_outcount = 0;							\
+									\
+        _buf_wptr = GETBUFPTR( _buf );					\
+} while (0)
+
+#define DMAOUTREG( reg, val )					\
+do {								\
+	if ( MACH64_VERBOSE ) {					\
+		DRM_INFO( "   DMAOUTREG( 0x%x = 0x%08x )\n",	\
+			  reg, val );				\
+	}							\
+	_buf_wptr[_outcount++] = cpu_to_le32(DMAREG(reg));	\
+	_buf_wptr[_outcount++] = cpu_to_le32((val));		\
+	_buf->used += 8;					\
+} while (0)
+
+#define DMAADVANCE( dev_priv, _discard )						     \
+do {											     \
+	struct list_head *ptr;								     \
+	RING_LOCALS;									     \
+											     \
+	if ( MACH64_VERBOSE ) {								     \
+		DRM_INFO( "DMAADVANCE() in %s\n", __FUNCTION__ );			     \
+	}										     \
+											     \
+	if (_buf->used <= 0) {								     \
+		DRM_ERROR( "DMAADVANCE() in %s: sending empty buf %d\n",		     \
+				   __FUNCTION__, _buf->idx );				     \
+		return -EFAULT;							     \
+	}										     \
+	if (_buf->pending) {								     \
+                /* This is a resued buffer, so we need to find it in the pending list */     \
+		int ret;								     \
+		if ( (ret=mach64_find_pending_buf_entry(dev_priv, &_entry, _buf)) ) {	     \
+			DRM_ERROR( "DMAADVANCE() in %s: couldn't find pending buf %d\n",     \
+				   __FUNCTION__, _buf->idx );				     \
+			return ret;							     \
+		}									     \
+		if (_entry->discard) {							     \
+			DRM_ERROR( "DMAADVANCE() in %s: sending discarded pending buf %d\n", \
+				   __FUNCTION__, _buf->idx );				     \
+			return -EFAULT;						     \
+		}									     \
+     	} else {									     \
+		if (list_empty(&dev_priv->placeholders)) {				     \
+			DRM_ERROR( "DMAADVANCE() in %s: empty placeholder list\n",	     \
+			   	__FUNCTION__ );						     \
+			return -EFAULT;						     \
+		}									     \
+		ptr = dev_priv->placeholders.next;					     \
+		list_del(ptr);								     \
+		_entry = list_entry(ptr, drm_mach64_freelist_t, list);			     \
+		_buf->pending = 1;							     \
+		_entry->buf = _buf;							     \
+		list_add_tail(ptr, &dev_priv->pending);					     \
+	}										     \
+	_entry->discard = (_discard);							     \
+	ADD_BUF_TO_RING( dev_priv );							     \
+} while (0)
+
+#define DMADISCARDBUF()									\
+do {											\
+	if (_entry == NULL) {								\
+		int ret;								\
+		if ( (ret=mach64_find_pending_buf_entry(dev_priv, &_entry, _buf)) ) {	\
+			DRM_ERROR( "%s: couldn't find pending buf %d\n",		\
+				   __FUNCTION__, _buf->idx );				\
+			return ret;							\
+		}									\
+	}										\
+	_entry->discard = 1;								\
+} while(0)
+
+#define ADD_BUF_TO_RING( dev_priv )							\
+do {											\
+	int bytes, pages, remainder;							\
+	u32 address, page;								\
+	int i;										\
+											\
+	bytes = _buf->used;								\
+	address = GETBUFADDR( _buf );							\
+											\
+	pages = (bytes + MACH64_DMA_CHUNKSIZE - 1) / MACH64_DMA_CHUNKSIZE;		\
+											\
+	BEGIN_RING( pages * 4 );							\
+											\
+	for ( i = 0 ; i < pages-1 ; i++ ) {						\
+		page = address + i * MACH64_DMA_CHUNKSIZE;				\
+		OUT_RING( MACH64_APERTURE_OFFSET + MACH64_BM_ADDR );			\
+		OUT_RING( page );							\
+		OUT_RING( MACH64_DMA_CHUNKSIZE | MACH64_DMA_HOLD_OFFSET );		\
+		OUT_RING( 0 );								\
+	}										\
+											\
+	/* generate the final descriptor for any remaining commands in this buffer */	\
+	page = address + i * MACH64_DMA_CHUNKSIZE;					\
+	remainder = bytes - i * MACH64_DMA_CHUNKSIZE;					\
+											\
+	/* Save dword offset of last descriptor for this buffer.			\
+	 * This is needed to check for completion of the buffer in freelist_get		\
+	 */										\
+	_entry->ring_ofs = RING_WRITE_OFS;						\
+											\
+	OUT_RING( MACH64_APERTURE_OFFSET + MACH64_BM_ADDR );				\
+	OUT_RING( page );								\
+	OUT_RING( remainder | MACH64_DMA_HOLD_OFFSET | MACH64_DMA_EOL );		\
+	OUT_RING( 0 );									\
+											\
+	ADVANCE_RING();									\
+} while(0)
+
+#define DMAADVANCEHOSTDATA( dev_priv )							\
+do {											\
+	struct list_head *ptr;								\
+	RING_LOCALS;									\
+											\
+	if ( MACH64_VERBOSE ) {								\
+		DRM_INFO( "DMAADVANCEHOSTDATA() in %s\n", __FUNCTION__ );		\
+	}										\
+											\
+	if (_buf->used <= 0) {								\
+		DRM_ERROR( "DMAADVANCEHOSTDATA() in %s: sending empty buf %d\n",	\
+				   __FUNCTION__, _buf->idx );				\
+		return -EFAULT;							\
+	}										\
+	if (list_empty(&dev_priv->placeholders)) {					\
+		DRM_ERROR( "%s: empty placeholder list in DMAADVANCEHOSTDATA()\n",	\
+			   __FUNCTION__ );						\
+		return -EFAULT;							\
+	}										\
+											\
+        ptr = dev_priv->placeholders.next;						\
+	list_del(ptr);									\
+	_entry = list_entry(ptr, drm_mach64_freelist_t, list);				\
+	_entry->buf = _buf;								\
+	_entry->buf->pending = 1;							\
+	list_add_tail(ptr, &dev_priv->pending);						\
+	_entry->discard = 1;								\
+	ADD_HOSTDATA_BUF_TO_RING( dev_priv );						\
+} while (0)
+
+#define ADD_HOSTDATA_BUF_TO_RING( dev_priv )						 \
+do {											 \
+	int bytes, pages, remainder;							 \
+	u32 address, page;								 \
+	int i;										 \
+											 \
+	bytes = _buf->used - MACH64_HOSTDATA_BLIT_OFFSET;				 \
+	pages = (bytes + MACH64_DMA_CHUNKSIZE - 1) / MACH64_DMA_CHUNKSIZE;		 \
+	address = GETBUFADDR( _buf );							 \
+											 \
+	BEGIN_RING( 4 + pages * 4 );							 \
+											 \
+	OUT_RING( MACH64_APERTURE_OFFSET + MACH64_BM_ADDR );				 \
+	OUT_RING( address );								 \
+	OUT_RING( MACH64_HOSTDATA_BLIT_OFFSET | MACH64_DMA_HOLD_OFFSET );		 \
+	OUT_RING( 0 );									 \
+											 \
+	address += MACH64_HOSTDATA_BLIT_OFFSET;						 \
+											 \
+	for ( i = 0 ; i < pages-1 ; i++ ) {						 \
+		page = address + i * MACH64_DMA_CHUNKSIZE;				 \
+		OUT_RING( MACH64_APERTURE_OFFSET + MACH64_BM_HOSTDATA );		 \
+		OUT_RING( page );							 \
+		OUT_RING( MACH64_DMA_CHUNKSIZE | MACH64_DMA_HOLD_OFFSET );		 \
+		OUT_RING( 0 );								 \
+	}										 \
+											 \
+	/* generate the final descriptor for any remaining commands in this buffer */	 \
+	page = address + i * MACH64_DMA_CHUNKSIZE;					 \
+	remainder = bytes - i * MACH64_DMA_CHUNKSIZE;					 \
+											 \
+	/* Save dword offset of last descriptor for this buffer.			 \
+	 * This is needed to check for completion of the buffer in freelist_get		 \
+	 */										 \
+	_entry->ring_ofs = RING_WRITE_OFS;						 \
+											 \
+	OUT_RING( MACH64_APERTURE_OFFSET + MACH64_BM_HOSTDATA );			 \
+	OUT_RING( page );								 \
+	OUT_RING( remainder | MACH64_DMA_HOLD_OFFSET | MACH64_DMA_EOL );		 \
+	OUT_RING( 0 );									 \
+											 \
+	ADVANCE_RING();									 \
+} while(0)
+
+#endif				/* __MACH64_DRV_H__ */
Index: git/shared-core/mach64_irq.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/mach64_irq.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,136 @@
+/* mach64_irq.c -- IRQ handling for ATI Mach64 -*- linux-c -*-
+ * Created: Tue Feb 25, 2003 by Leif Delgass, based on radeon_irq.c/r128_irq.c
+ */
+/*-
+ * Copyright (C) The Weather Channel, Inc.  2002.
+ * Copyright 2003 Leif Delgass
+ * All Rights Reserved.
+ *
+ * The Weather Channel (TM) funded Tungsten Graphics to develop the
+ * initial release of the Radeon 8500 driver under the XFree86 license.
+ * This notice must be preserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ *    Eric Anholt <anholt@FreeBSD.org>
+ *    Leif Delgass <ldelgass@retinalburn.net>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "mach64_drm.h"
+#include "mach64_drv.h"
+
+irqreturn_t mach64_driver_irq_handler(DRM_IRQ_ARGS)
+{
+	struct drm_device *dev = (struct drm_device *) arg;
+	drm_mach64_private_t *dev_priv =
+	    (drm_mach64_private_t *) dev->dev_private;
+	int status;
+
+	status = MACH64_READ(MACH64_CRTC_INT_CNTL);
+
+	/* VBLANK interrupt */
+	if (status & MACH64_CRTC_VBLANK_INT) {
+		/* Mask off all interrupt ack bits before setting the ack bit, since
+		 * there may be other handlers outside the DRM.
+		 *
+		 * NOTE: On mach64, you need to keep the enable bits set when doing
+		 * the ack, despite what the docs say about not acking and enabling
+		 * in a single write.
+		 */
+		MACH64_WRITE(MACH64_CRTC_INT_CNTL,
+			     (status & ~MACH64_CRTC_INT_ACKS)
+			     | MACH64_CRTC_VBLANK_INT);
+
+		atomic_inc(&dev->vbl_received);
+		DRM_WAKEUP(&dev->vbl_queue);
+		drm_vbl_send_signals(dev);
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+int mach64_driver_vblank_wait(struct drm_device * dev, unsigned int *sequence)
+{
+	unsigned int cur_vblank;
+	int ret = 0;
+
+	/* Assume that the user has missed the current sequence number
+	 * by about a day rather than she wants to wait for years
+	 * using vertical blanks...
+	 */
+	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
+		    (((cur_vblank = atomic_read(&dev->vbl_received))
+		      - *sequence) <= (1 << 23)));
+
+	*sequence = cur_vblank;
+
+	return ret;
+}
+
+/* drm_dma.h hooks
+*/
+void mach64_driver_irq_preinstall(struct drm_device * dev)
+{
+	drm_mach64_private_t *dev_priv =
+	    (drm_mach64_private_t *) dev->dev_private;
+
+	u32 status = MACH64_READ(MACH64_CRTC_INT_CNTL);
+
+	DRM_DEBUG("before install CRTC_INT_CTNL: 0x%08x\n", status);
+
+	/* Disable and clear VBLANK interrupt */
+	MACH64_WRITE(MACH64_CRTC_INT_CNTL, (status & ~MACH64_CRTC_VBLANK_INT_EN)
+		     | MACH64_CRTC_VBLANK_INT);
+}
+
+void mach64_driver_irq_postinstall(struct drm_device * dev)
+{
+	drm_mach64_private_t *dev_priv =
+	    (drm_mach64_private_t *) dev->dev_private;
+
+	/* Turn on VBLANK interrupt */
+	MACH64_WRITE(MACH64_CRTC_INT_CNTL, MACH64_READ(MACH64_CRTC_INT_CNTL)
+		     | MACH64_CRTC_VBLANK_INT_EN);
+
+	DRM_DEBUG("after install CRTC_INT_CTNL: 0x%08x\n",
+		  MACH64_READ(MACH64_CRTC_INT_CNTL));
+
+}
+
+void mach64_driver_irq_uninstall(struct drm_device * dev)
+{
+	drm_mach64_private_t *dev_priv =
+	    (drm_mach64_private_t *) dev->dev_private;
+	if (!dev_priv)
+		return;
+
+	/* Disable and clear VBLANK interrupt */
+	MACH64_WRITE(MACH64_CRTC_INT_CNTL,
+		     (MACH64_READ(MACH64_CRTC_INT_CNTL) &
+		      ~MACH64_CRTC_VBLANK_INT_EN)
+		     | MACH64_CRTC_VBLANK_INT);
+
+	DRM_DEBUG("after uninstall CRTC_INT_CTNL: 0x%08x\n",
+		  MACH64_READ(MACH64_CRTC_INT_CNTL));
+}
Index: git/shared-core/mach64_state.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/mach64_state.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,897 @@
+/* mach64_state.c -- State support for mach64 (Rage Pro) driver -*- linux-c -*-
+ * Created: Sun Dec 03 19:20:26 2000 by gareth@valinux.com
+ */
+/*
+ * Copyright 2000 Gareth Hughes
+ * Copyright 2002-2003 Leif Delgass
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT OWNER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Leif Delgass <ldelgass@retinalburn.net>
+ *    JosFonseca <j_r_fonseca@yahoo.co.uk>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "mach64_drm.h"
+#include "mach64_drv.h"
+
+/* Interface history:
+ *
+ * 1.0 - Initial mach64 DRM
+ *
+ */
+struct drm_ioctl_desc mach64_ioctls[] = {
+	DRM_IOCTL_DEF(DRM_MACH64_INIT, mach64_dma_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_MACH64_CLEAR, mach64_dma_clear, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MACH64_SWAP, mach64_dma_swap, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MACH64_IDLE, mach64_dma_idle, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MACH64_RESET, mach64_engine_reset, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MACH64_VERTEX, mach64_dma_vertex, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MACH64_BLIT, mach64_dma_blit, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MACH64_FLUSH, mach64_dma_flush, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MACH64_GETPARAM, mach64_get_param, DRM_AUTH),
+};
+
+int mach64_max_ioctl = DRM_ARRAY_SIZE(mach64_ioctls);
+
+/* ================================================================
+ * DMA hardware state programming functions
+ */
+
+static void mach64_print_dirty(const char *msg, unsigned int flags)
+{
+	DRM_DEBUG("%s: (0x%x) %s%s%s%s%s%s%s%s%s%s%s%s\n",
+		  msg,
+		  flags,
+		  (flags & MACH64_UPLOAD_DST_OFF_PITCH) ? "dst_off_pitch, " :
+		  "",
+		  (flags & MACH64_UPLOAD_Z_ALPHA_CNTL) ? "z_alpha_cntl, " : "",
+		  (flags & MACH64_UPLOAD_SCALE_3D_CNTL) ? "scale_3d_cntl, " :
+		  "", (flags & MACH64_UPLOAD_DP_FOG_CLR) ? "dp_fog_clr, " : "",
+		  (flags & MACH64_UPLOAD_DP_WRITE_MASK) ? "dp_write_mask, " :
+		  "",
+		  (flags & MACH64_UPLOAD_DP_PIX_WIDTH) ? "dp_pix_width, " : "",
+		  (flags & MACH64_UPLOAD_SETUP_CNTL) ? "setup_cntl, " : "",
+		  (flags & MACH64_UPLOAD_MISC) ? "misc, " : "",
+		  (flags & MACH64_UPLOAD_TEXTURE) ? "texture, " : "",
+		  (flags & MACH64_UPLOAD_TEX0IMAGE) ? "tex0 image, " : "",
+		  (flags & MACH64_UPLOAD_TEX1IMAGE) ? "tex1 image, " : "",
+		  (flags & MACH64_UPLOAD_CLIPRECTS) ? "cliprects, " : "");
+}
+
+/* Mach64 doesn't have hardware cliprects, just one hardware scissor,
+ * so the GL scissor is intersected with each cliprect here
+ */
+/* This function returns 0 on success, 1 for no intersection, and
+ * negative for an error
+ */
+static int mach64_emit_cliprect(struct drm_file *file_priv,
+				drm_mach64_private_t * dev_priv,
+				struct drm_clip_rect * box)
+{
+	u32 sc_left_right, sc_top_bottom;
+	struct drm_clip_rect scissor;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_context_regs_t *regs = &sarea_priv->context_state;
+	DMALOCALS;
+
+	DRM_DEBUG("%s: box=%p\n", __FUNCTION__, box);
+
+	/* Get GL scissor */
+	/* FIXME: store scissor in SAREA as a cliprect instead of in
+	 * hardware format, or do intersection client-side
+	 */
+	scissor.x1 = regs->sc_left_right & 0xffff;
+	scissor.x2 = (regs->sc_left_right & 0xffff0000) >> 16;
+	scissor.y1 = regs->sc_top_bottom & 0xffff;
+	scissor.y2 = (regs->sc_top_bottom & 0xffff0000) >> 16;
+
+	/* Intersect GL scissor with cliprect */
+	if (box->x1 > scissor.x1)
+		scissor.x1 = box->x1;
+	if (box->y1 > scissor.y1)
+		scissor.y1 = box->y1;
+	if (box->x2 < scissor.x2)
+		scissor.x2 = box->x2;
+	if (box->y2 < scissor.y2)
+		scissor.y2 = box->y2;
+	/* positive return means skip */
+	if (scissor.x1 >= scissor.x2)
+		return 1;
+	if (scissor.y1 >= scissor.y2)
+		return 1;
+
+	DMAGETPTR(file_priv, dev_priv, 2);	/* returns on failure to get buffer */
+
+	sc_left_right = ((scissor.x1 << 0) | (scissor.x2 << 16));
+	sc_top_bottom = ((scissor.y1 << 0) | (scissor.y2 << 16));
+
+	DMAOUTREG(MACH64_SC_LEFT_RIGHT, sc_left_right);
+	DMAOUTREG(MACH64_SC_TOP_BOTTOM, sc_top_bottom);
+
+	DMAADVANCE(dev_priv, 1);
+
+	return 0;
+}
+
+static __inline__ int mach64_emit_state(struct drm_file *file_priv,
+					drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_context_regs_t *regs = &sarea_priv->context_state;
+	unsigned int dirty = sarea_priv->dirty;
+	u32 offset = ((regs->tex_size_pitch & 0xf0) >> 2);
+	DMALOCALS;
+
+	if (MACH64_VERBOSE) {
+		mach64_print_dirty(__FUNCTION__, dirty);
+	} else {
+		DRM_DEBUG("%s: dirty=0x%08x\n", __FUNCTION__, dirty);
+	}
+
+	DMAGETPTR(file_priv, dev_priv, 17);	/* returns on failure to get buffer */
+
+	if (dirty & MACH64_UPLOAD_MISC) {
+		DMAOUTREG(MACH64_DP_MIX, regs->dp_mix);
+		DMAOUTREG(MACH64_DP_SRC, regs->dp_src);
+		DMAOUTREG(MACH64_CLR_CMP_CNTL, regs->clr_cmp_cntl);
+		DMAOUTREG(MACH64_GUI_TRAJ_CNTL, regs->gui_traj_cntl);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_MISC;
+	}
+
+	if (dirty & MACH64_UPLOAD_DST_OFF_PITCH) {
+		DMAOUTREG(MACH64_DST_OFF_PITCH, regs->dst_off_pitch);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_DST_OFF_PITCH;
+	}
+	if (dirty & MACH64_UPLOAD_Z_OFF_PITCH) {
+		DMAOUTREG(MACH64_Z_OFF_PITCH, regs->z_off_pitch);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_Z_OFF_PITCH;
+	}
+	if (dirty & MACH64_UPLOAD_Z_ALPHA_CNTL) {
+		DMAOUTREG(MACH64_Z_CNTL, regs->z_cntl);
+		DMAOUTREG(MACH64_ALPHA_TST_CNTL, regs->alpha_tst_cntl);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_Z_ALPHA_CNTL;
+	}
+	if (dirty & MACH64_UPLOAD_SCALE_3D_CNTL) {
+		DMAOUTREG(MACH64_SCALE_3D_CNTL, regs->scale_3d_cntl);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_SCALE_3D_CNTL;
+	}
+	if (dirty & MACH64_UPLOAD_DP_FOG_CLR) {
+		DMAOUTREG(MACH64_DP_FOG_CLR, regs->dp_fog_clr);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_DP_FOG_CLR;
+	}
+	if (dirty & MACH64_UPLOAD_DP_WRITE_MASK) {
+		DMAOUTREG(MACH64_DP_WRITE_MASK, regs->dp_write_mask);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_DP_WRITE_MASK;
+	}
+	if (dirty & MACH64_UPLOAD_DP_PIX_WIDTH) {
+		DMAOUTREG(MACH64_DP_PIX_WIDTH, regs->dp_pix_width);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_DP_PIX_WIDTH;
+	}
+	if (dirty & MACH64_UPLOAD_SETUP_CNTL) {
+		DMAOUTREG(MACH64_SETUP_CNTL, regs->setup_cntl);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_SETUP_CNTL;
+	}
+
+	if (dirty & MACH64_UPLOAD_TEXTURE) {
+		DMAOUTREG(MACH64_TEX_SIZE_PITCH, regs->tex_size_pitch);
+		DMAOUTREG(MACH64_TEX_CNTL, regs->tex_cntl);
+		DMAOUTREG(MACH64_SECONDARY_TEX_OFF, regs->secondary_tex_off);
+		DMAOUTREG(MACH64_TEX_0_OFF + offset, regs->tex_offset);
+		sarea_priv->dirty &= ~MACH64_UPLOAD_TEXTURE;
+	}
+
+	DMAADVANCE(dev_priv, 1);
+
+	sarea_priv->dirty &= MACH64_UPLOAD_CLIPRECTS;
+
+	return 0;
+
+}
+
+/* ================================================================
+ * DMA command dispatch functions
+ */
+
+static int mach64_dma_dispatch_clear(struct drm_device * dev,
+				     struct drm_file *file_priv,
+				     unsigned int flags,
+				     int cx, int cy, int cw, int ch,
+				     unsigned int clear_color,
+				     unsigned int clear_depth)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_context_regs_t *ctx = &sarea_priv->context_state;
+	int nbox = sarea_priv->nbox;
+	struct drm_clip_rect *pbox = sarea_priv->boxes;
+	u32 fb_bpp, depth_bpp;
+	int i;
+	DMALOCALS;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	switch (dev_priv->fb_bpp) {
+	case 16:
+		fb_bpp = MACH64_DATATYPE_RGB565;
+		break;
+	case 32:
+		fb_bpp = MACH64_DATATYPE_ARGB8888;
+		break;
+	default:
+		return -EINVAL;
+	}
+	switch (dev_priv->depth_bpp) {
+	case 16:
+		depth_bpp = MACH64_DATATYPE_RGB565;
+		break;
+	case 24:
+	case 32:
+		depth_bpp = MACH64_DATATYPE_ARGB8888;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (!nbox)
+		return 0;
+
+	DMAGETPTR(file_priv, dev_priv, nbox * 31);	/* returns on failure to get buffer */
+
+	for (i = 0; i < nbox; i++) {
+		int x = pbox[i].x1;
+		int y = pbox[i].y1;
+		int w = pbox[i].x2 - x;
+		int h = pbox[i].y2 - y;
+
+		DRM_DEBUG("dispatch clear %d,%d-%d,%d flags 0x%x\n",
+			  pbox[i].x1, pbox[i].y1,
+			  pbox[i].x2, pbox[i].y2, flags);
+
+		if (flags & (MACH64_FRONT | MACH64_BACK)) {
+			/* Setup for color buffer clears
+			 */
+
+			DMAOUTREG(MACH64_Z_CNTL, 0);
+			DMAOUTREG(MACH64_SCALE_3D_CNTL, 0);
+
+			DMAOUTREG(MACH64_SC_LEFT_RIGHT, ctx->sc_left_right);
+			DMAOUTREG(MACH64_SC_TOP_BOTTOM, ctx->sc_top_bottom);
+
+			DMAOUTREG(MACH64_CLR_CMP_CNTL, 0);
+			DMAOUTREG(MACH64_GUI_TRAJ_CNTL,
+				  (MACH64_DST_X_LEFT_TO_RIGHT |
+				   MACH64_DST_Y_TOP_TO_BOTTOM));
+
+			DMAOUTREG(MACH64_DP_PIX_WIDTH, ((fb_bpp << 0) |
+							(fb_bpp << 4) |
+							(fb_bpp << 8) |
+							(fb_bpp << 16) |
+							(fb_bpp << 28)));
+
+			DMAOUTREG(MACH64_DP_FRGD_CLR, clear_color);
+			DMAOUTREG(MACH64_DP_WRITE_MASK, ctx->dp_write_mask);
+			DMAOUTREG(MACH64_DP_MIX, (MACH64_BKGD_MIX_D |
+						  MACH64_FRGD_MIX_S));
+			DMAOUTREG(MACH64_DP_SRC, (MACH64_BKGD_SRC_FRGD_CLR |
+						  MACH64_FRGD_SRC_FRGD_CLR |
+						  MACH64_MONO_SRC_ONE));
+
+		}
+
+		if (flags & MACH64_FRONT) {
+
+			DMAOUTREG(MACH64_DST_OFF_PITCH,
+				  dev_priv->front_offset_pitch);
+			DMAOUTREG(MACH64_DST_X_Y, (y << 16) | x);
+			DMAOUTREG(MACH64_DST_WIDTH_HEIGHT, (h << 16) | w);
+
+		}
+
+		if (flags & MACH64_BACK) {
+
+			DMAOUTREG(MACH64_DST_OFF_PITCH,
+				  dev_priv->back_offset_pitch);
+			DMAOUTREG(MACH64_DST_X_Y, (y << 16) | x);
+			DMAOUTREG(MACH64_DST_WIDTH_HEIGHT, (h << 16) | w);
+
+		}
+
+		if (flags & MACH64_DEPTH) {
+			/* Setup for depth buffer clear
+			 */
+			DMAOUTREG(MACH64_Z_CNTL, 0);
+			DMAOUTREG(MACH64_SCALE_3D_CNTL, 0);
+
+			DMAOUTREG(MACH64_SC_LEFT_RIGHT, ctx->sc_left_right);
+			DMAOUTREG(MACH64_SC_TOP_BOTTOM, ctx->sc_top_bottom);
+
+			DMAOUTREG(MACH64_CLR_CMP_CNTL, 0);
+			DMAOUTREG(MACH64_GUI_TRAJ_CNTL,
+				  (MACH64_DST_X_LEFT_TO_RIGHT |
+				   MACH64_DST_Y_TOP_TO_BOTTOM));
+
+			DMAOUTREG(MACH64_DP_PIX_WIDTH, ((depth_bpp << 0) |
+							(depth_bpp << 4) |
+							(depth_bpp << 8) |
+							(depth_bpp << 16) |
+							(depth_bpp << 28)));
+
+			DMAOUTREG(MACH64_DP_FRGD_CLR, clear_depth);
+			DMAOUTREG(MACH64_DP_WRITE_MASK, 0xffffffff);
+			DMAOUTREG(MACH64_DP_MIX, (MACH64_BKGD_MIX_D |
+						  MACH64_FRGD_MIX_S));
+			DMAOUTREG(MACH64_DP_SRC, (MACH64_BKGD_SRC_FRGD_CLR |
+						  MACH64_FRGD_SRC_FRGD_CLR |
+						  MACH64_MONO_SRC_ONE));
+
+			DMAOUTREG(MACH64_DST_OFF_PITCH,
+				  dev_priv->depth_offset_pitch);
+			DMAOUTREG(MACH64_DST_X_Y, (y << 16) | x);
+			DMAOUTREG(MACH64_DST_WIDTH_HEIGHT, (h << 16) | w);
+		}
+	}
+
+	DMAADVANCE(dev_priv, 1);
+
+	return 0;
+}
+
+static int mach64_dma_dispatch_swap(struct drm_device * dev,
+				    struct drm_file *file_priv)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int nbox = sarea_priv->nbox;
+	struct drm_clip_rect *pbox = sarea_priv->boxes;
+	u32 fb_bpp;
+	int i;
+	DMALOCALS;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	switch (dev_priv->fb_bpp) {
+	case 16:
+		fb_bpp = MACH64_DATATYPE_RGB565;
+		break;
+	case 32:
+	default:
+		fb_bpp = MACH64_DATATYPE_ARGB8888;
+		break;
+	}
+
+	if (!nbox)
+		return 0;
+
+	DMAGETPTR(file_priv, dev_priv, 13 + nbox * 4);	/* returns on failure to get buffer */
+
+	DMAOUTREG(MACH64_Z_CNTL, 0);
+	DMAOUTREG(MACH64_SCALE_3D_CNTL, 0);
+
+	DMAOUTREG(MACH64_SC_LEFT_RIGHT, 0 | (8191 << 16));	/* no scissor */
+	DMAOUTREG(MACH64_SC_TOP_BOTTOM, 0 | (16383 << 16));
+
+	DMAOUTREG(MACH64_CLR_CMP_CNTL, 0);
+	DMAOUTREG(MACH64_GUI_TRAJ_CNTL, (MACH64_DST_X_LEFT_TO_RIGHT |
+					 MACH64_DST_Y_TOP_TO_BOTTOM));
+
+	DMAOUTREG(MACH64_DP_PIX_WIDTH, ((fb_bpp << 0) |
+					(fb_bpp << 4) |
+					(fb_bpp << 8) |
+					(fb_bpp << 16) | (fb_bpp << 28)));
+
+	DMAOUTREG(MACH64_DP_WRITE_MASK, 0xffffffff);
+	DMAOUTREG(MACH64_DP_MIX, (MACH64_BKGD_MIX_D | MACH64_FRGD_MIX_S));
+	DMAOUTREG(MACH64_DP_SRC, (MACH64_BKGD_SRC_BKGD_CLR |
+				  MACH64_FRGD_SRC_BLIT | MACH64_MONO_SRC_ONE));
+
+	DMAOUTREG(MACH64_SRC_OFF_PITCH, dev_priv->back_offset_pitch);
+	DMAOUTREG(MACH64_DST_OFF_PITCH, dev_priv->front_offset_pitch);
+
+	for (i = 0; i < nbox; i++) {
+		int x = pbox[i].x1;
+		int y = pbox[i].y1;
+		int w = pbox[i].x2 - x;
+		int h = pbox[i].y2 - y;
+
+		DRM_DEBUG("dispatch swap %d,%d-%d,%d\n",
+			  pbox[i].x1, pbox[i].y1, pbox[i].x2, pbox[i].y2);
+
+		DMAOUTREG(MACH64_SRC_WIDTH1, w);
+		DMAOUTREG(MACH64_SRC_Y_X, (x << 16) | y);
+		DMAOUTREG(MACH64_DST_Y_X, (x << 16) | y);
+		DMAOUTREG(MACH64_DST_WIDTH_HEIGHT, (h << 16) | w);
+
+	}
+
+	DMAADVANCE(dev_priv, 1);
+
+	if (dev_priv->driver_mode == MACH64_MODE_DMA_ASYNC) {
+		for (i = 0; i < MACH64_MAX_QUEUED_FRAMES - 1; i++) {
+			dev_priv->frame_ofs[i] = dev_priv->frame_ofs[i + 1];
+		}
+		dev_priv->frame_ofs[i] = GETRINGOFFSET();
+
+		dev_priv->sarea_priv->frames_queued++;
+	}
+
+	return 0;
+}
+
+static int mach64_do_get_frames_queued(drm_mach64_private_t * dev_priv)
+{
+	drm_mach64_descriptor_ring_t *ring = &dev_priv->ring;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int i, start;
+	u32 head, tail, ofs;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	if (sarea_priv->frames_queued == 0)
+		return 0;
+
+	tail = ring->tail;
+	mach64_ring_tick(dev_priv, ring);
+	head = ring->head;
+
+	start = (MACH64_MAX_QUEUED_FRAMES -
+		 DRM_MIN(MACH64_MAX_QUEUED_FRAMES, sarea_priv->frames_queued));
+
+	if (head == tail) {
+		sarea_priv->frames_queued = 0;
+		for (i = start; i < MACH64_MAX_QUEUED_FRAMES; i++) {
+			dev_priv->frame_ofs[i] = ~0;
+		}
+		return 0;
+	}
+
+	for (i = start; i < MACH64_MAX_QUEUED_FRAMES; i++) {
+		ofs = dev_priv->frame_ofs[i];
+		DRM_DEBUG("frame_ofs[%d] ofs: %d\n", i, ofs);
+		if (ofs == ~0 ||
+		    (head < tail && (ofs < head || ofs >= tail)) ||
+		    (head > tail && (ofs < head && ofs >= tail))) {
+			sarea_priv->frames_queued =
+			    (MACH64_MAX_QUEUED_FRAMES - 1) - i;
+			dev_priv->frame_ofs[i] = ~0;
+		}
+	}
+
+	return sarea_priv->frames_queued;
+}
+
+/* Copy and verify a client submited buffer.
+ * FIXME: Make an assembly optimized version
+ */
+static __inline__ int copy_from_user_vertex(u32 *to,
+					    const u32 __user *ufrom,
+					    unsigned long bytes)
+{
+	unsigned long n = bytes;	/* dwords remaining in buffer */
+	u32 *from, *orig_from;
+
+	from = drm_alloc(bytes, DRM_MEM_DRIVER);
+	if (from == NULL)
+		return -ENOMEM;
+
+	if (DRM_COPY_FROM_USER(from, ufrom, bytes)) {
+		drm_free(from, bytes, DRM_MEM_DRIVER);
+		return -EFAULT;
+	}
+	orig_from = from; /* we'll be modifying the "from" ptr, so save it */
+
+	n >>= 2;
+
+	while (n > 1) {
+		u32 data, reg, count;
+
+		data = *from++;
+
+		n--;
+
+		reg = le32_to_cpu(data);
+		count = (reg >> 16) + 1;
+		if (count <= n) {
+			n -= count;
+			reg &= 0xffff;
+
+			/* This is an exact match of Mach64's Setup Engine registers,
+			 * excluding SETUP_CNTL (1_C1).
+			 */
+			if ((reg >= 0x0190 && reg < 0x01c1) ||
+			    (reg >= 0x01ca && reg <= 0x01cf)) {
+				*to++ = data;
+				memcpy(to, from, count << 2);
+				from += count;
+				to += count;
+			} else {
+				DRM_ERROR("%s: Got bad command: 0x%04x\n",
+					  __FUNCTION__, reg);
+				drm_free(orig_from, bytes, DRM_MEM_DRIVER);
+				return -EACCES;
+			}
+		} else {
+			DRM_ERROR
+			    ("%s: Got bad command count(=%u) dwords remaining=%lu\n",
+			     __FUNCTION__, count, n);
+			drm_free(orig_from, bytes, DRM_MEM_DRIVER);
+			return -EINVAL;
+		}
+	}
+
+	drm_free(orig_from, bytes, DRM_MEM_DRIVER);
+	if (n == 0)
+		return 0;
+	else {
+		DRM_ERROR("%s: Bad buf->used(=%lu)\n", __FUNCTION__, bytes);
+		return -EINVAL;
+	}
+}
+
+static int mach64_dma_dispatch_vertex(struct drm_device * dev,
+				      struct drm_file *file_priv,
+				      drm_mach64_vertex_t * vertex)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	struct drm_buf *copy_buf;
+	void *buf = vertex->buf;
+	unsigned long used = vertex->used;
+	int ret = 0;
+	int i = 0;
+	int done = 0;
+	int verify_ret = 0;
+	DMALOCALS;
+
+	DRM_DEBUG("%s: buf=%p used=%lu nbox=%d\n",
+		  __FUNCTION__, buf, used, sarea_priv->nbox);
+
+	if (!used)
+		goto _vertex_done;
+
+	copy_buf = mach64_freelist_get(dev_priv);
+	if (copy_buf == NULL) {
+		DRM_ERROR("%s: couldn't get buffer\n", __FUNCTION__);
+		return -EAGAIN;
+	}
+
+	verify_ret = copy_from_user_vertex(GETBUFPTR(copy_buf), buf, used);
+
+	if (verify_ret != 0) {
+		mach64_freelist_put(dev_priv, copy_buf);
+		goto _vertex_done;
+	}
+
+	copy_buf->used = used;
+
+	DMASETPTR(copy_buf);
+
+	if (sarea_priv->dirty & ~MACH64_UPLOAD_CLIPRECTS) {
+		ret = mach64_emit_state(file_priv, dev_priv);
+		if (ret < 0)
+			return ret;
+	}
+
+	do {
+		/* Emit the next cliprect */
+		if (i < sarea_priv->nbox) {
+			ret = mach64_emit_cliprect(file_priv, dev_priv,
+						   &sarea_priv->boxes[i]);
+			if (ret < 0) {
+				/* failed to get buffer */
+				return ret;
+			} else if (ret != 0) {
+				/* null intersection with scissor */
+				continue;
+			}
+		}
+		if ((i >= sarea_priv->nbox - 1))
+			done = 1;
+
+		/* Add the buffer to the DMA queue */
+		DMAADVANCE(dev_priv, done);
+
+	} while (++i < sarea_priv->nbox);
+
+	if (!done) {
+		if (copy_buf->pending) {
+			DMADISCARDBUF();
+		} else {
+			/* This buffer wasn't used (no cliprects), so place it
+			 * back on the free list
+			 */
+			mach64_freelist_put(dev_priv, copy_buf);
+		}
+	}
+
+_vertex_done:
+	sarea_priv->dirty &= ~MACH64_UPLOAD_CLIPRECTS;
+	sarea_priv->nbox = 0;
+
+	return verify_ret;
+}
+
+static __inline__ int copy_from_user_blit(u32 *to,
+					  const u32 __user *ufrom,
+					  unsigned long bytes)
+{
+	to = (u32 *)((char *)to + MACH64_HOSTDATA_BLIT_OFFSET);
+
+	if (DRM_COPY_FROM_USER(to, ufrom, bytes)) {
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int mach64_dma_dispatch_blit(struct drm_device * dev,
+				    struct drm_file *file_priv,
+				    drm_mach64_blit_t * blit)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	int dword_shift, dwords;
+	unsigned long used;
+	struct drm_buf *copy_buf;
+	int verify_ret = 0;
+	DMALOCALS;
+
+	/* The compiler won't optimize away a division by a variable,
+	 * even if the only legal values are powers of two.  Thus, we'll
+	 * use a shift instead.
+	 */
+	switch (blit->format) {
+	case MACH64_DATATYPE_ARGB8888:
+		dword_shift = 0;
+		break;
+	case MACH64_DATATYPE_ARGB1555:
+	case MACH64_DATATYPE_RGB565:
+	case MACH64_DATATYPE_VYUY422:
+	case MACH64_DATATYPE_YVYU422:
+	case MACH64_DATATYPE_ARGB4444:
+		dword_shift = 1;
+		break;
+	case MACH64_DATATYPE_CI8:
+	case MACH64_DATATYPE_RGB8:
+		dword_shift = 2;
+		break;
+	default:
+		DRM_ERROR("invalid blit format %d\n", blit->format);
+		return -EINVAL;
+	}
+
+	/* Set buf->used to the bytes of blit data based on the blit dimensions
+	 * and verify the size.  When the setup is emitted to the buffer with
+	 * the DMA* macros below, buf->used is incremented to include the bytes
+	 * used for setup as well as the blit data.
+	 */
+	dwords = (blit->width * blit->height) >> dword_shift;
+	used = dwords << 2;
+	if (used <= 0 ||
+	    used > MACH64_BUFFER_SIZE - MACH64_HOSTDATA_BLIT_OFFSET) {
+		DRM_ERROR("Invalid blit size: %lu bytes\n", used);
+		return -EINVAL;
+	}
+
+	copy_buf = mach64_freelist_get(dev_priv);
+	if (copy_buf == NULL) {
+		DRM_ERROR("%s: couldn't get buffer\n", __FUNCTION__);
+		return -EAGAIN;
+	}
+
+	verify_ret = copy_from_user_blit(GETBUFPTR(copy_buf), blit->buf, used);
+
+	if (verify_ret != 0) {
+		mach64_freelist_put(dev_priv, copy_buf);
+		goto _blit_done;
+	}
+
+	copy_buf->used = used;
+
+	/* FIXME: Use a last buffer flag and reduce the state emitted for subsequent,
+	 * continuation buffers?
+	 */
+
+	/* Blit via BM_HOSTDATA (gui-master) - like HOST_DATA[0-15], but doesn't require
+	 * a register command every 16 dwords.  State setup is added at the start of the
+	 * buffer -- the client leaves space for this based on MACH64_HOSTDATA_BLIT_OFFSET
+	 */
+	DMASETPTR(copy_buf);
+
+	DMAOUTREG(MACH64_Z_CNTL, 0);
+	DMAOUTREG(MACH64_SCALE_3D_CNTL, 0);
+
+	DMAOUTREG(MACH64_SC_LEFT_RIGHT, 0 | (8191 << 16));	/* no scissor */
+	DMAOUTREG(MACH64_SC_TOP_BOTTOM, 0 | (16383 << 16));
+
+	DMAOUTREG(MACH64_CLR_CMP_CNTL, 0);	/* disable */
+	DMAOUTREG(MACH64_GUI_TRAJ_CNTL,
+		  MACH64_DST_X_LEFT_TO_RIGHT | MACH64_DST_Y_TOP_TO_BOTTOM);
+
+	DMAOUTREG(MACH64_DP_PIX_WIDTH, (blit->format << 0)	/* dst pix width */
+		  |(blit->format << 4)	/* composite pix width */
+		  |(blit->format << 8)	/* src pix width */
+		  |(blit->format << 16)	/* host data pix width */
+		  |(blit->format << 28)	/* scaler/3D pix width */
+	    );
+
+	DMAOUTREG(MACH64_DP_WRITE_MASK, 0xffffffff);	/* enable all planes */
+	DMAOUTREG(MACH64_DP_MIX, MACH64_BKGD_MIX_D | MACH64_FRGD_MIX_S);
+	DMAOUTREG(MACH64_DP_SRC,
+		  MACH64_BKGD_SRC_BKGD_CLR
+		  | MACH64_FRGD_SRC_HOST | MACH64_MONO_SRC_ONE);
+
+	DMAOUTREG(MACH64_DST_OFF_PITCH,
+		  (blit->pitch << 22) | (blit->offset >> 3));
+	DMAOUTREG(MACH64_DST_X_Y, (blit->y << 16) | blit->x);
+	DMAOUTREG(MACH64_DST_WIDTH_HEIGHT, (blit->height << 16) | blit->width);
+
+	DRM_DEBUG("%s: %lu bytes\n", __FUNCTION__, used);
+
+	/* Add the buffer to the queue */
+	DMAADVANCEHOSTDATA(dev_priv);
+
+_blit_done:
+	return verify_ret;
+}
+
+/* ================================================================
+ * IOCTL functions
+ */
+
+int mach64_dma_clear(struct drm_device *dev, void *data,
+		     struct drm_file *file_priv)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_clear_t *clear = data;
+	int ret;
+
+	DRM_DEBUG("%s: pid=%d\n", __FUNCTION__, DRM_CURRENTPID);
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (sarea_priv->nbox > MACH64_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MACH64_NR_SAREA_CLIPRECTS;
+
+	ret = mach64_dma_dispatch_clear(dev, file_priv, clear->flags,
+					clear->x, clear->y, clear->w, clear->h,
+					clear->clear_color,
+					clear->clear_depth);
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	sarea_priv->dirty |= (MACH64_UPLOAD_CONTEXT | MACH64_UPLOAD_MISC);
+	return ret;
+}
+
+int mach64_dma_swap(struct drm_device *dev, void *data,
+		    struct drm_file *file_priv)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int ret;
+
+	DRM_DEBUG("%s: pid=%d\n", __FUNCTION__, DRM_CURRENTPID);
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (sarea_priv->nbox > MACH64_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MACH64_NR_SAREA_CLIPRECTS;
+
+	ret = mach64_dma_dispatch_swap(dev, file_priv);
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	sarea_priv->dirty |= (MACH64_UPLOAD_CONTEXT | MACH64_UPLOAD_MISC);
+	return ret;
+}
+
+int mach64_dma_vertex(struct drm_device *dev, void *data,
+		      struct drm_file *file_priv)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_vertex_t *vertex = data;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("%s: pid=%d buf=%p used=%lu discard=%d\n",
+		  __FUNCTION__, DRM_CURRENTPID,
+		  vertex->buf, vertex->used, vertex->discard);
+
+	if (vertex->prim < 0 || vertex->prim > MACH64_PRIM_POLYGON) {
+		DRM_ERROR("buffer prim %d\n", vertex->prim);
+		return -EINVAL;
+	}
+
+	if (vertex->used > MACH64_BUFFER_SIZE || (vertex->used & 3) != 0) {
+		DRM_ERROR("Invalid vertex buffer size: %lu bytes\n",
+			  vertex->used);
+		return -EINVAL;
+	}
+
+	if (sarea_priv->nbox > MACH64_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MACH64_NR_SAREA_CLIPRECTS;
+
+	return mach64_dma_dispatch_vertex(dev, file_priv, vertex);
+}
+
+int mach64_dma_blit(struct drm_device *dev, void *data,
+		    struct drm_file *file_priv)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mach64_blit_t *blit = data;
+	int ret;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	ret = mach64_dma_dispatch_blit(dev, file_priv, blit);
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	sarea_priv->dirty |= (MACH64_UPLOAD_CONTEXT |
+			      MACH64_UPLOAD_MISC | MACH64_UPLOAD_CLIPRECTS);
+
+	return ret;
+}
+
+int mach64_get_param(struct drm_device *dev, void *data,
+		     struct drm_file *file_priv)
+{
+	drm_mach64_private_t *dev_priv = dev->dev_private;
+	drm_mach64_getparam_t *param = data;
+	int value;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	switch (param->param) {
+	case MACH64_PARAM_FRAMES_QUEUED:
+		/* Needs lock since it calls mach64_ring_tick() */
+		LOCK_TEST_WITH_RETURN(dev, file_priv);
+		value = mach64_do_get_frames_queued(dev_priv);
+		break;
+	case MACH64_PARAM_IRQ_NR:
+		value = dev->irq;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (DRM_COPY_TO_USER(param->value, &value, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
Index: git/shared-core/mga_dma.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/mga_dma.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,1164 @@
+/* mga_dma.c -- DMA support for mga g200/g400 -*- linux-c -*-
+ * Created: Mon Dec 13 01:50:01 1999 by jhartmann@precisioninsight.com
+ */
+/* Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file mga_dma.c
+ * DMA support for MGA G200 / G400.
+ * 
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ * \author Jeff Hartmann <jhartmann@valinux.com>
+ * \author Keith Whitwell <keith@tungstengraphics.com>
+ * \author Gareth Hughes <gareth@valinux.com>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "drm_sarea.h"
+#include "mga_drm.h"
+#include "mga_drv.h"
+
+#define MGA_DEFAULT_USEC_TIMEOUT	10000
+#define MGA_FREELIST_DEBUG		0
+
+#define MINIMAL_CLEANUP    0
+#define FULL_CLEANUP       1
+static int mga_do_cleanup_dma(struct drm_device * dev, int full_cleanup);
+
+/* ================================================================
+ * Engine control
+ */
+
+int mga_do_wait_for_idle(drm_mga_private_t * dev_priv)
+{
+	u32 status = 0;
+	int i;
+	DRM_DEBUG("\n");
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		status = MGA_READ(MGA_STATUS) & MGA_ENGINE_IDLE_MASK;
+		if (status == MGA_ENDPRDMASTS) {
+			MGA_WRITE8(MGA_CRTC_INDEX, 0);
+			return 0;
+		}
+		DRM_UDELAY(1);
+	}
+
+#if MGA_DMA_DEBUG
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x\n", status);
+#endif
+	return -EBUSY;
+}
+
+static int mga_do_dma_reset(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_primary_buffer_t *primary = &dev_priv->prim;
+
+	DRM_DEBUG("\n");
+
+	/* The primary DMA stream should look like new right about now.
+	 */
+	primary->tail = 0;
+	primary->space = primary->size;
+	primary->last_flush = 0;
+
+	sarea_priv->last_wrap = 0;
+
+	/* FIXME: Reset counters, buffer ages etc...
+	 */
+
+	/* FIXME: What else do we need to reinitialize?  WARP stuff?
+	 */
+
+	return 0;
+}
+
+/* ================================================================
+ * Primary DMA stream
+ */
+
+void mga_do_dma_flush(drm_mga_private_t * dev_priv)
+{
+	drm_mga_primary_buffer_t *primary = &dev_priv->prim;
+	u32 head, tail;
+	u32 status = 0;
+	int i;
+	DMA_LOCALS;
+	DRM_DEBUG("\n");
+
+	/* We need to wait so that we can do an safe flush */
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		status = MGA_READ(MGA_STATUS) & MGA_ENGINE_IDLE_MASK;
+		if (status == MGA_ENDPRDMASTS)
+			break;
+		DRM_UDELAY(1);
+	}
+
+	if (primary->tail == primary->last_flush) {
+		DRM_DEBUG("   bailing out...\n");
+		return;
+	}
+
+	tail = primary->tail + dev_priv->primary->offset;
+
+	/* We need to pad the stream between flushes, as the card
+	 * actually (partially?) reads the first of these commands.
+	 * See page 4-16 in the G400 manual, middle of the page or so.
+	 */
+	BEGIN_DMA(1);
+
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000, MGA_DMAPAD, 0x00000000);
+
+	ADVANCE_DMA();
+
+	primary->last_flush = primary->tail;
+
+	head = MGA_READ(MGA_PRIMADDRESS);
+
+	if (head <= tail) {
+		primary->space = primary->size - primary->tail;
+	} else {
+		primary->space = head - tail;
+	}
+
+	DRM_DEBUG("   head = 0x%06lx\n", head - dev_priv->primary->offset);
+	DRM_DEBUG("   tail = 0x%06lx\n", tail - dev_priv->primary->offset);
+	DRM_DEBUG("  space = 0x%06x\n", primary->space);
+
+	mga_flush_write_combine();
+	MGA_WRITE(MGA_PRIMEND, tail | dev_priv->dma_access);
+
+	DRM_DEBUG("done.\n");
+}
+
+void mga_do_dma_wrap_start(drm_mga_private_t * dev_priv)
+{
+	drm_mga_primary_buffer_t *primary = &dev_priv->prim;
+	u32 head, tail;
+	DMA_LOCALS;
+	DRM_DEBUG("\n");
+
+	BEGIN_DMA_WRAP();
+
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000, MGA_DMAPAD, 0x00000000);
+
+	ADVANCE_DMA();
+
+	tail = primary->tail + dev_priv->primary->offset;
+
+	primary->tail = 0;
+	primary->last_flush = 0;
+	primary->last_wrap++;
+
+	head = MGA_READ(MGA_PRIMADDRESS);
+
+	if (head == dev_priv->primary->offset) {
+		primary->space = primary->size;
+	} else {
+		primary->space = head - dev_priv->primary->offset;
+	}
+
+	DRM_DEBUG("   head = 0x%06lx\n", head - dev_priv->primary->offset);
+	DRM_DEBUG("   tail = 0x%06x\n", primary->tail);
+	DRM_DEBUG("   wrap = %d\n", primary->last_wrap);
+	DRM_DEBUG("  space = 0x%06x\n", primary->space);
+
+	mga_flush_write_combine();
+	MGA_WRITE(MGA_PRIMEND, tail | dev_priv->dma_access);
+
+	set_bit(0, &primary->wrapped);
+	DRM_DEBUG("done.\n");
+}
+
+void mga_do_dma_wrap_end(drm_mga_private_t * dev_priv)
+{
+	drm_mga_primary_buffer_t *primary = &dev_priv->prim;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	u32 head = dev_priv->primary->offset;
+	DRM_DEBUG("\n");
+
+	sarea_priv->last_wrap++;
+	DRM_DEBUG("   wrap = %d\n", sarea_priv->last_wrap);
+
+	mga_flush_write_combine();
+	MGA_WRITE(MGA_PRIMADDRESS, head | MGA_DMA_GENERAL);
+
+	clear_bit(0, &primary->wrapped);
+	DRM_DEBUG("done.\n");
+}
+
+/* ================================================================
+ * Freelist management
+ */
+
+#define MGA_BUFFER_USED		~0
+#define MGA_BUFFER_FREE		0
+
+#if MGA_FREELIST_DEBUG
+static void mga_freelist_print(struct drm_device * dev)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_freelist_t *entry;
+
+	DRM_INFO("\n");
+	DRM_INFO("current dispatch: last=0x%x done=0x%x\n",
+		 dev_priv->sarea_priv->last_dispatch,
+		 (unsigned int)(MGA_READ(MGA_PRIMADDRESS) -
+				dev_priv->primary->offset));
+	DRM_INFO("current freelist:\n");
+
+	for (entry = dev_priv->head->next; entry; entry = entry->next) {
+		DRM_INFO("   %p   idx=%2d  age=0x%x 0x%06lx\n",
+			 entry, entry->buf->idx, entry->age.head,
+			 entry->age.head - dev_priv->primary->offset);
+	}
+	DRM_INFO("\n");
+}
+#endif
+
+static int mga_freelist_init(struct drm_device * dev, drm_mga_private_t * dev_priv)
+{
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_mga_buf_priv_t *buf_priv;
+	drm_mga_freelist_t *entry;
+	int i;
+	DRM_DEBUG("count=%d\n", dma->buf_count);
+
+	dev_priv->head = drm_alloc(sizeof(drm_mga_freelist_t), DRM_MEM_DRIVER);
+	if (dev_priv->head == NULL)
+		return -ENOMEM;
+
+	memset(dev_priv->head, 0, sizeof(drm_mga_freelist_t));
+	SET_AGE(&dev_priv->head->age, MGA_BUFFER_USED, 0);
+
+	for (i = 0; i < dma->buf_count; i++) {
+		buf = dma->buflist[i];
+		buf_priv = buf->dev_private;
+
+		entry = drm_alloc(sizeof(drm_mga_freelist_t), DRM_MEM_DRIVER);
+		if (entry == NULL)
+			return -ENOMEM;
+
+		memset(entry, 0, sizeof(drm_mga_freelist_t));
+
+		entry->next = dev_priv->head->next;
+		entry->prev = dev_priv->head;
+		SET_AGE(&entry->age, MGA_BUFFER_FREE, 0);
+		entry->buf = buf;
+
+		if (dev_priv->head->next != NULL)
+			dev_priv->head->next->prev = entry;
+		if (entry->next == NULL)
+			dev_priv->tail = entry;
+
+		buf_priv->list_entry = entry;
+		buf_priv->discard = 0;
+		buf_priv->dispatched = 0;
+
+		dev_priv->head->next = entry;
+	}
+
+	return 0;
+}
+
+static void mga_freelist_cleanup(struct drm_device * dev)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_freelist_t *entry;
+	drm_mga_freelist_t *next;
+	DRM_DEBUG("\n");
+
+	entry = dev_priv->head;
+	while (entry) {
+		next = entry->next;
+		drm_free(entry, sizeof(drm_mga_freelist_t), DRM_MEM_DRIVER);
+		entry = next;
+	}
+
+	dev_priv->head = dev_priv->tail = NULL;
+}
+
+#if 0
+/* FIXME: Still needed?
+ */
+static void mga_freelist_reset(struct drm_device * dev)
+{
+	drm_device_dma_t *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_mga_buf_priv_t *buf_priv;
+	int i;
+
+	for (i = 0; i < dma->buf_count; i++) {
+		buf = dma->buflist[i];
+		buf_priv = buf->dev_private;
+		SET_AGE(&buf_priv->list_entry->age, MGA_BUFFER_FREE, 0);
+	}
+}
+#endif
+
+static struct drm_buf *mga_freelist_get(struct drm_device * dev)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_freelist_t *next;
+	drm_mga_freelist_t *prev;
+	drm_mga_freelist_t *tail = dev_priv->tail;
+	u32 head, wrap;
+	DRM_DEBUG("\n");
+
+	head = MGA_READ(MGA_PRIMADDRESS);
+	wrap = dev_priv->sarea_priv->last_wrap;
+
+	DRM_DEBUG("   tail=0x%06lx %d\n",
+		  tail->age.head ?
+		  tail->age.head - dev_priv->primary->offset : 0,
+		  tail->age.wrap);
+	DRM_DEBUG("   head=0x%06lx %d\n",
+		  head - dev_priv->primary->offset, wrap);
+
+	if (TEST_AGE(&tail->age, head, wrap)) {
+		prev = dev_priv->tail->prev;
+		next = dev_priv->tail;
+		prev->next = NULL;
+		next->prev = next->next = NULL;
+		dev_priv->tail = prev;
+		SET_AGE(&next->age, MGA_BUFFER_USED, 0);
+		return next->buf;
+	}
+
+	DRM_DEBUG("returning NULL!\n");
+	return NULL;
+}
+
+int mga_freelist_put(struct drm_device * dev, struct drm_buf * buf)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
+	drm_mga_freelist_t *head, *entry, *prev;
+
+	DRM_DEBUG("age=0x%06lx wrap=%d\n",
+		  buf_priv->list_entry->age.head -
+		  dev_priv->primary->offset, buf_priv->list_entry->age.wrap);
+
+	entry = buf_priv->list_entry;
+	head = dev_priv->head;
+
+	if (buf_priv->list_entry->age.head == MGA_BUFFER_USED) {
+		SET_AGE(&entry->age, MGA_BUFFER_FREE, 0);
+		prev = dev_priv->tail;
+		prev->next = entry;
+		entry->prev = prev;
+		entry->next = NULL;
+	} else {
+		prev = head->next;
+		head->next = entry;
+		prev->prev = entry;
+		entry->prev = head;
+		entry->next = prev;
+	}
+
+	return 0;
+}
+
+/* ================================================================
+ * DMA initialization, cleanup
+ */
+
+int mga_driver_load(struct drm_device *dev, unsigned long flags)
+{
+	drm_mga_private_t * dev_priv;
+
+	dev_priv = drm_alloc(sizeof(drm_mga_private_t), DRM_MEM_DRIVER);
+	if (!dev_priv)
+		return -ENOMEM;
+
+	dev->dev_private = (void *)dev_priv;
+	memset(dev_priv, 0, sizeof(drm_mga_private_t));
+
+	dev_priv->usec_timeout = MGA_DEFAULT_USEC_TIMEOUT;
+	dev_priv->chipset = flags;
+
+	dev_priv->mmio_base = drm_get_resource_start(dev, 1);
+	dev_priv->mmio_size = drm_get_resource_len(dev, 1);
+
+	dev->counters += 3;
+	dev->types[6] = _DRM_STAT_IRQ;
+	dev->types[7] = _DRM_STAT_PRIMARY;
+	dev->types[8] = _DRM_STAT_SECONDARY;
+
+	return 0;
+}
+
+/**
+ * Bootstrap the driver for AGP DMA.
+ * 
+ * \todo
+ * Investigate whether there is any benifit to storing the WARP microcode in
+ * AGP memory.  If not, the microcode may as well always be put in PCI
+ * memory.
+ *
+ * \todo
+ * This routine needs to set dma_bs->agp_mode to the mode actually configured
+ * in the hardware.  Looking just at the Linux AGP driver code, I don't see
+ * an easy way to determine this.
+ *
+ * \sa mga_do_dma_bootstrap, mga_do_pci_dma_bootstrap
+ */
+static int mga_do_agp_dma_bootstrap(struct drm_device *dev,
+				    drm_mga_dma_bootstrap_t * dma_bs)
+{
+	drm_mga_private_t * const dev_priv = (drm_mga_private_t *) dev->dev_private;
+	unsigned int warp_size = mga_warp_microcode_size(dev_priv);
+	int err;
+	unsigned  offset;
+	const unsigned secondary_size = dma_bs->secondary_bin_count
+		* dma_bs->secondary_bin_size;
+	const unsigned agp_size = (dma_bs->agp_size << 20);
+	struct drm_buf_desc req;
+	struct drm_agp_mode mode;
+	struct drm_agp_info info;
+	struct drm_agp_buffer agp_req;
+	struct drm_agp_binding bind_req;
+
+	/* Acquire AGP. */
+	err = drm_agp_acquire(dev);
+	if (err) {
+		DRM_ERROR("Unable to acquire AGP: %d\n", err);
+		return err;
+	}
+
+	err = drm_agp_info(dev, &info);
+	if (err) {
+		DRM_ERROR("Unable to get AGP info: %d\n", err);
+		return err;
+	}
+
+	mode.mode = (info.mode & ~0x07) | dma_bs->agp_mode;
+	err = drm_agp_enable(dev, mode);
+	if (err) {
+		DRM_ERROR("Unable to enable AGP (mode = 0x%lx)\n", mode.mode);
+		return err;
+	}
+
+	/* In addition to the usual AGP mode configuration, the G200 AGP cards
+	 * need to have the AGP mode "manually" set.
+	 */
+
+	if (dev_priv->chipset == MGA_CARD_TYPE_G200) {
+		if (mode.mode & 0x02) {
+			MGA_WRITE(MGA_AGP_PLL, MGA_AGP2XPLL_ENABLE);
+		} else {
+			MGA_WRITE(MGA_AGP_PLL, MGA_AGP2XPLL_DISABLE);
+		}
+	}
+
+
+	/* Allocate and bind AGP memory. */
+	agp_req.size = agp_size;
+	agp_req.type = 0;
+	err = drm_agp_alloc( dev, & agp_req );
+	if (err) {
+		dev_priv->agp_size = 0;
+		DRM_ERROR("Unable to allocate %uMB AGP memory\n",
+			  dma_bs->agp_size);
+		return err;
+	}
+
+	dev_priv->agp_size = agp_size;
+	dev_priv->agp_handle = agp_req.handle;
+
+	bind_req.handle = agp_req.handle;
+	bind_req.offset = 0;
+	err = drm_agp_bind( dev, &bind_req );
+	if (err) {
+		DRM_ERROR("Unable to bind AGP memory: %d\n", err);
+		return err;
+	}
+
+	/* Make drm_addbufs happy by not trying to create a mapping for less
+	 * than a page.
+	 */
+	if (warp_size < PAGE_SIZE)
+		warp_size = PAGE_SIZE;
+
+	offset = 0;
+	err = drm_addmap( dev, offset, warp_size,
+			  _DRM_AGP, _DRM_READ_ONLY, & dev_priv->warp );
+	if (err) {
+		DRM_ERROR("Unable to map WARP microcode: %d\n", err);
+		return err;
+	}
+
+	offset += warp_size;
+	err = drm_addmap( dev, offset, dma_bs->primary_size,
+			  _DRM_AGP, _DRM_READ_ONLY, & dev_priv->primary );
+	if (err) {
+		DRM_ERROR("Unable to map primary DMA region: %d\n", err);
+		return err;
+	}
+
+	offset += dma_bs->primary_size;
+	err = drm_addmap( dev, offset, secondary_size,
+			  _DRM_AGP, 0, & dev->agp_buffer_map );
+	if (err) {
+		DRM_ERROR("Unable to map secondary DMA region: %d\n", err);
+		return err;
+	}
+
+	(void) memset( &req, 0, sizeof(req) );
+	req.count = dma_bs->secondary_bin_count;
+	req.size = dma_bs->secondary_bin_size;
+	req.flags = _DRM_AGP_BUFFER;
+	req.agp_start = offset;
+
+	err = drm_addbufs_agp( dev, & req );
+	if (err) {
+		DRM_ERROR("Unable to add secondary DMA buffers: %d\n", err);
+		return err;
+	}
+
+#ifdef __linux__
+	{
+		struct drm_map_list *_entry;
+		unsigned long agp_token = 0;
+
+		list_for_each_entry(_entry, &dev->maplist, head) {
+			if (_entry->map == dev->agp_buffer_map)
+				agp_token = _entry->user_token;
+		}
+		if (!agp_token)
+			return -EFAULT;
+
+		dev->agp_buffer_token = agp_token;
+	}
+#endif
+
+	offset += secondary_size;
+	err = drm_addmap( dev, offset, agp_size - offset,
+			  _DRM_AGP, 0, & dev_priv->agp_textures );
+	if (err) {
+		DRM_ERROR("Unable to map AGP texture region: %d\n", err);
+		return err;
+	}
+
+	drm_core_ioremap(dev_priv->warp, dev);
+	drm_core_ioremap(dev_priv->primary, dev);
+	drm_core_ioremap(dev->agp_buffer_map, dev);
+
+	if (!dev_priv->warp->handle ||
+	    !dev_priv->primary->handle || !dev->agp_buffer_map->handle) {
+		DRM_ERROR("failed to ioremap agp regions! (%p, %p, %p)\n",
+			  dev_priv->warp->handle, dev_priv->primary->handle,
+			  dev->agp_buffer_map->handle);
+		return -ENOMEM;
+	}
+
+	dev_priv->dma_access = MGA_PAGPXFER;
+	dev_priv->wagp_enable = MGA_WAGP_ENABLE;
+
+	DRM_INFO("Initialized card for AGP DMA.\n");
+	return 0;
+}
+
+/**
+ * Bootstrap the driver for PCI DMA.
+ * 
+ * \todo
+ * The algorithm for decreasing the size of the primary DMA buffer could be
+ * better.  The size should be rounded up to the nearest page size, then
+ * decrease the request size by a single page each pass through the loop.
+ *
+ * \todo
+ * Determine whether the maximum address passed to drm_pci_alloc is correct.
+ * The same goes for drm_addbufs_pci.
+ * 
+ * \sa mga_do_dma_bootstrap, mga_do_agp_dma_bootstrap
+ */
+static int mga_do_pci_dma_bootstrap(struct drm_device * dev,
+				    drm_mga_dma_bootstrap_t * dma_bs)
+{
+	drm_mga_private_t * const dev_priv = (drm_mga_private_t *) dev->dev_private;
+	unsigned int warp_size = mga_warp_microcode_size(dev_priv);
+	unsigned int primary_size;
+	unsigned int bin_count;
+	int err;
+	struct drm_buf_desc req;
+
+	
+	if (dev->dma == NULL) {
+		DRM_ERROR("dev->dma is NULL\n");
+		return -EFAULT;
+	}
+
+	/* Make drm_addbufs happy by not trying to create a mapping for less
+	 * than a page.
+	 */
+	if (warp_size < PAGE_SIZE)
+		warp_size = PAGE_SIZE;
+
+	/* The proper alignment is 0x100 for this mapping */
+	err = drm_addmap(dev, 0, warp_size, _DRM_CONSISTENT,
+			 _DRM_READ_ONLY, &dev_priv->warp);
+	if (err != 0) {
+		DRM_ERROR("Unable to create mapping for WARP microcode: %d\n",
+			  err);
+		return err;
+	}
+
+	/* Other than the bottom two bits being used to encode other
+	 * information, there don't appear to be any restrictions on the
+	 * alignment of the primary or secondary DMA buffers.
+	 */
+
+	for ( primary_size = dma_bs->primary_size
+	      ; primary_size != 0
+	      ; primary_size >>= 1 ) {
+		/* The proper alignment for this mapping is 0x04 */
+		err = drm_addmap(dev, 0, primary_size, _DRM_CONSISTENT,
+				 _DRM_READ_ONLY, &dev_priv->primary);
+		if (!err)
+			break;
+	}
+
+	if (err != 0) {
+		DRM_ERROR("Unable to allocate primary DMA region: %d\n", err);
+		return -ENOMEM;
+	}
+
+	if (dev_priv->primary->size != dma_bs->primary_size) {
+		DRM_INFO("Primary DMA buffer size reduced from %u to %u.\n",
+			 dma_bs->primary_size, 
+			 (unsigned) dev_priv->primary->size);
+		dma_bs->primary_size = dev_priv->primary->size;
+	}
+
+	for ( bin_count = dma_bs->secondary_bin_count
+	      ; bin_count > 0 
+	      ; bin_count-- ) {
+		(void) memset( &req, 0, sizeof(req) );
+		req.count = bin_count;
+		req.size = dma_bs->secondary_bin_size;
+
+		err = drm_addbufs_pci( dev, & req );
+		if (!err) {
+			break;
+		}
+	}
+	
+	if (bin_count == 0) {
+		DRM_ERROR("Unable to add secondary DMA buffers: %d\n", err);
+		return err;
+	}
+
+	if (bin_count != dma_bs->secondary_bin_count) {
+		DRM_INFO("Secondary PCI DMA buffer bin count reduced from %u "
+			 "to %u.\n", dma_bs->secondary_bin_count, bin_count);
+
+		dma_bs->secondary_bin_count = bin_count;
+	}
+
+	dev_priv->dma_access = 0;
+	dev_priv->wagp_enable = 0;
+
+	dma_bs->agp_mode = 0;
+
+	DRM_INFO("Initialized card for PCI DMA.\n");
+	return 0;
+}
+
+
+static int mga_do_dma_bootstrap(struct drm_device * dev,
+				drm_mga_dma_bootstrap_t * dma_bs)
+{
+	const int is_agp = (dma_bs->agp_mode != 0) && drm_device_is_agp(dev);
+	int err;
+	drm_mga_private_t * const dev_priv =
+		(drm_mga_private_t *) dev->dev_private;
+
+
+	dev_priv->used_new_dma_init = 1;
+
+	/* The first steps are the same for both PCI and AGP based DMA.  Map
+	 * the cards MMIO registers and map a status page.
+	 */
+	err = drm_addmap( dev, dev_priv->mmio_base, dev_priv->mmio_size,
+			  _DRM_REGISTERS, _DRM_READ_ONLY, & dev_priv->mmio );
+	if (err) {
+		DRM_ERROR("Unable to map MMIO region: %d\n", err);
+		return err;
+	}
+
+
+	err = drm_addmap( dev, 0, SAREA_MAX, _DRM_SHM,
+			  _DRM_READ_ONLY | _DRM_LOCKED | _DRM_KERNEL,
+			  & dev_priv->status );
+	if (err) {
+		DRM_ERROR("Unable to map status region: %d\n", err);
+		return err;
+	}
+
+
+	/* The DMA initialization procedure is slightly different for PCI and
+	 * AGP cards.  AGP cards just allocate a large block of AGP memory and
+	 * carve off portions of it for internal uses.  The remaining memory
+	 * is returned to user-mode to be used for AGP textures.
+	 */
+
+	if (is_agp) {
+		err = mga_do_agp_dma_bootstrap(dev, dma_bs);
+	}
+	
+	/* If we attempted to initialize the card for AGP DMA but failed,
+	 * clean-up any mess that may have been created.
+	 */
+
+	if (err) {
+		mga_do_cleanup_dma(dev, MINIMAL_CLEANUP);
+	}
+
+
+	/* Not only do we want to try and initialized PCI cards for PCI DMA,
+	 * but we also try to initialized AGP cards that could not be
+	 * initialized for AGP DMA.  This covers the case where we have an AGP
+	 * card in a system with an unsupported AGP chipset.  In that case the
+	 * card will be detected as AGP, but we won't be able to allocate any
+	 * AGP memory, etc.
+	 */
+
+	if (!is_agp || err) {
+		err = mga_do_pci_dma_bootstrap(dev, dma_bs);
+	}
+
+
+	return err;
+}
+
+int mga_dma_bootstrap(struct drm_device *dev, void *data,
+		      struct drm_file *file_priv)
+{
+	drm_mga_dma_bootstrap_t *bootstrap = data;
+	int err;
+	static const int modes[] = { 0, 1, 2, 2, 4, 4, 4, 4 };
+	const drm_mga_private_t * const dev_priv = 
+		(drm_mga_private_t *) dev->dev_private;
+
+
+	err = mga_do_dma_bootstrap(dev, bootstrap);
+	if (err) {
+		mga_do_cleanup_dma(dev, FULL_CLEANUP);
+		return err;
+	}
+
+	if (dev_priv->agp_textures != NULL) {
+		bootstrap->texture_handle = dev_priv->agp_textures->offset;
+		bootstrap->texture_size = dev_priv->agp_textures->size;
+	} else {
+		bootstrap->texture_handle = 0;
+		bootstrap->texture_size = 0;
+	}
+
+	bootstrap->agp_mode = modes[bootstrap->agp_mode & 0x07];
+
+	return 0;
+}
+
+
+static int mga_do_init_dma(struct drm_device * dev, drm_mga_init_t * init)
+{
+	drm_mga_private_t *dev_priv;
+	int ret;
+	DRM_DEBUG("\n");
+
+
+	dev_priv = dev->dev_private;
+
+	if (init->sgram) {
+		dev_priv->clear_cmd = MGA_DWGCTL_CLEAR | MGA_ATYPE_BLK;
+	} else {
+		dev_priv->clear_cmd = MGA_DWGCTL_CLEAR | MGA_ATYPE_RSTR;
+	}
+	dev_priv->maccess = init->maccess;
+
+	dev_priv->fb_cpp = init->fb_cpp;
+	dev_priv->front_offset = init->front_offset;
+	dev_priv->front_pitch = init->front_pitch;
+	dev_priv->back_offset = init->back_offset;
+	dev_priv->back_pitch = init->back_pitch;
+
+	dev_priv->depth_cpp = init->depth_cpp;
+	dev_priv->depth_offset = init->depth_offset;
+	dev_priv->depth_pitch = init->depth_pitch;
+
+	/* FIXME: Need to support AGP textures...
+	 */
+	dev_priv->texture_offset = init->texture_offset[0];
+	dev_priv->texture_size = init->texture_size[0];
+
+	dev_priv->sarea = drm_getsarea(dev);
+	if (!dev_priv->sarea) {
+		DRM_ERROR("failed to find sarea!\n");
+		return -EINVAL;
+	}
+
+	if (! dev_priv->used_new_dma_init) {
+
+		dev_priv->dma_access = MGA_PAGPXFER;
+		dev_priv->wagp_enable = MGA_WAGP_ENABLE;
+
+		dev_priv->status = drm_core_findmap(dev, init->status_offset);
+		if (!dev_priv->status) {
+			DRM_ERROR("failed to find status page!\n");
+			return -EINVAL;
+		}
+		dev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);
+		if (!dev_priv->mmio) {
+			DRM_ERROR("failed to find mmio region!\n");
+			return -EINVAL;
+		}
+		dev_priv->warp = drm_core_findmap(dev, init->warp_offset);
+		if (!dev_priv->warp) {
+			DRM_ERROR("failed to find warp microcode region!\n");
+			return -EINVAL;
+		}
+		dev_priv->primary = drm_core_findmap(dev, init->primary_offset);
+		if (!dev_priv->primary) {
+			DRM_ERROR("failed to find primary dma region!\n");
+			return -EINVAL;
+		}
+		dev->agp_buffer_token = init->buffers_offset;
+		dev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);
+		if (!dev->agp_buffer_map) {
+			DRM_ERROR("failed to find dma buffer region!\n");
+			return -EINVAL;
+		}
+
+		drm_core_ioremap(dev_priv->warp, dev);
+		drm_core_ioremap(dev_priv->primary, dev);
+		drm_core_ioremap(dev->agp_buffer_map, dev);
+	}
+
+	dev_priv->sarea_priv =
+	    (drm_mga_sarea_t *) ((u8 *) dev_priv->sarea->handle +
+				 init->sarea_priv_offset);
+
+	if (!dev_priv->warp->handle ||
+	    !dev_priv->primary->handle ||
+	    ((dev_priv->dma_access != 0) &&
+	     ((dev->agp_buffer_map == NULL) ||
+	      (dev->agp_buffer_map->handle == NULL)))) {
+		DRM_ERROR("failed to ioremap agp regions!\n");
+		return -ENOMEM;
+	}
+
+	ret = mga_warp_install_microcode(dev_priv);
+	if (ret != 0) {
+		DRM_ERROR("failed to install WARP ucode: %d!\n", ret);
+		return ret;
+	}
+
+	ret = mga_warp_init(dev_priv);
+	if (ret != 0) {
+		DRM_ERROR("failed to init WARP engine: %d!\n", ret);
+		return ret;
+	}
+
+	dev_priv->prim.status = (u32 *) dev_priv->status->handle;
+
+	mga_do_wait_for_idle(dev_priv);
+
+	/* Init the primary DMA registers.
+	 */
+	MGA_WRITE(MGA_PRIMADDRESS, dev_priv->primary->offset | MGA_DMA_GENERAL);
+#if 0
+	MGA_WRITE(MGA_PRIMPTR, virt_to_bus((void *)dev_priv->prim.status) | MGA_PRIMPTREN0 |	/* Soft trap, SECEND, SETUPEND */
+		  MGA_PRIMPTREN1);	/* DWGSYNC */
+#endif
+
+	dev_priv->prim.start = (u8 *) dev_priv->primary->handle;
+	dev_priv->prim.end = ((u8 *) dev_priv->primary->handle
+			      + dev_priv->primary->size);
+	dev_priv->prim.size = dev_priv->primary->size;
+
+	dev_priv->prim.tail = 0;
+	dev_priv->prim.space = dev_priv->prim.size;
+	dev_priv->prim.wrapped = 0;
+
+	dev_priv->prim.last_flush = 0;
+	dev_priv->prim.last_wrap = 0;
+
+	dev_priv->prim.high_mark = 256 * DMA_BLOCK_SIZE;
+
+	dev_priv->prim.status[0] = dev_priv->primary->offset;
+	dev_priv->prim.status[1] = 0;
+
+	dev_priv->sarea_priv->last_wrap = 0;
+	dev_priv->sarea_priv->last_frame.head = 0;
+	dev_priv->sarea_priv->last_frame.wrap = 0;
+
+	if (mga_freelist_init(dev, dev_priv) < 0) {
+		DRM_ERROR("could not initialize freelist\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int mga_do_cleanup_dma(struct drm_device * dev, int full_cleanup)
+{
+	int err = 0;
+	DRM_DEBUG("\n");
+
+	/* Make sure interrupts are disabled here because the uninstall ioctl
+	 * may not have been called from userspace and after dev_private
+	 * is freed, it's too late.
+	 */
+	if (dev->irq_enabled)
+		drm_irq_uninstall(dev);
+
+	if (dev->dev_private) {
+		drm_mga_private_t *dev_priv = dev->dev_private;
+
+		if ((dev_priv->warp != NULL)
+		    && (dev_priv->warp->type != _DRM_CONSISTENT))
+			drm_core_ioremapfree(dev_priv->warp, dev);
+
+		if ((dev_priv->primary != NULL) 
+		    && (dev_priv->primary->type != _DRM_CONSISTENT))
+			drm_core_ioremapfree(dev_priv->primary, dev);
+
+		if (dev->agp_buffer_map != NULL)
+			drm_core_ioremapfree(dev->agp_buffer_map, dev);
+
+		if (dev_priv->used_new_dma_init) {
+			if (dev_priv->agp_handle != 0) {
+				struct drm_agp_binding unbind_req;
+				struct drm_agp_buffer free_req;
+
+				unbind_req.handle = dev_priv->agp_handle;
+				drm_agp_unbind(dev, &unbind_req);
+
+				free_req.handle = dev_priv->agp_handle;
+				drm_agp_free(dev, &free_req);
+
+				dev_priv->agp_textures = NULL;
+				dev_priv->agp_size = 0;
+				dev_priv->agp_handle = 0;
+			}
+
+			if ((dev->agp != NULL) && dev->agp->acquired) {
+				err = drm_agp_release(dev);
+			}
+		}
+
+		dev_priv->warp = NULL;
+		dev_priv->primary = NULL;
+		dev_priv->sarea = NULL;
+		dev_priv->sarea_priv = NULL;
+		dev->agp_buffer_map = NULL;
+
+		if (full_cleanup) {
+			dev_priv->mmio = NULL;
+			dev_priv->status = NULL;
+			dev_priv->used_new_dma_init = 0;
+		}
+
+		memset(&dev_priv->prim, 0, sizeof(dev_priv->prim));
+		dev_priv->warp_pipe = 0;
+		memset(dev_priv->warp_pipe_phys, 0, sizeof(dev_priv->warp_pipe_phys));
+
+		if (dev_priv->head != NULL) {
+			mga_freelist_cleanup(dev);
+		}
+	}
+
+	return 0;
+}
+
+int mga_dma_init(struct drm_device *dev, void *data,
+		 struct drm_file *file_priv)
+{
+	drm_mga_init_t *init = data;
+	int err;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	switch (init->func) {
+	case MGA_INIT_DMA:
+		err = mga_do_init_dma(dev, init);
+		if (err) {
+			(void) mga_do_cleanup_dma(dev, FULL_CLEANUP);
+		}
+		return err;
+	case MGA_CLEANUP_DMA:
+		return mga_do_cleanup_dma(dev, FULL_CLEANUP);
+	}
+
+	return -EINVAL;
+}
+
+/* ================================================================
+ * Primary DMA stream management
+ */
+
+int mga_dma_flush(struct drm_device *dev, void *data,
+		  struct drm_file *file_priv)
+{
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
+	struct drm_lock *lock = data;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	DRM_DEBUG("%s%s%s\n",
+		  (lock->flags & _DRM_LOCK_FLUSH) ? "flush, " : "",
+		  (lock->flags & _DRM_LOCK_FLUSH_ALL) ? "flush all, " : "",
+		  (lock->flags & _DRM_LOCK_QUIESCENT) ? "idle, " : "");
+
+	WRAP_WAIT_WITH_RETURN(dev_priv);
+
+	if (lock->flags & (_DRM_LOCK_FLUSH | _DRM_LOCK_FLUSH_ALL)) {
+		mga_do_dma_flush(dev_priv);
+	}
+
+	if (lock->flags & _DRM_LOCK_QUIESCENT) {
+#if MGA_DMA_DEBUG
+		int ret = mga_do_wait_for_idle(dev_priv);
+		if (ret < 0)
+			DRM_INFO("%s: -EBUSY\n", __FUNCTION__);
+		return ret;
+#else
+		return mga_do_wait_for_idle(dev_priv);
+#endif
+	} else {
+		return 0;
+	}
+}
+
+int mga_dma_reset(struct drm_device *dev, void *data,
+		  struct drm_file *file_priv)
+{
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	return mga_do_dma_reset(dev_priv);
+}
+
+/* ================================================================
+ * DMA buffer management
+ */
+
+static int mga_dma_get_buffers(struct drm_device * dev,
+			       struct drm_file *file_priv, struct drm_dma * d)
+{
+	struct drm_buf *buf;
+	int i;
+
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = mga_freelist_get(dev);
+		if (!buf)
+			return -EAGAIN;
+
+		buf->file_priv = file_priv;
+
+		if (DRM_COPY_TO_USER(&d->request_indices[i],
+				     &buf->idx, sizeof(buf->idx)))
+			return -EFAULT;
+		if (DRM_COPY_TO_USER(&d->request_sizes[i],
+				     &buf->total, sizeof(buf->total)))
+			return -EFAULT;
+
+		d->granted_count++;
+	}
+	return 0;
+}
+
+int mga_dma_buffers(struct drm_device *dev, void *data,
+		    struct drm_file *file_priv)
+{
+	struct drm_device_dma *dma = dev->dma;
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
+	struct drm_dma *d = data;
+	int ret = 0;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	/* Please don't send us buffers.
+	 */
+	if (d->send_count != 0) {
+		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
+			  DRM_CURRENTPID, d->send_count);
+		return -EINVAL;
+	}
+
+	/* We'll send you buffers.
+	 */
+	if (d->request_count < 0 || d->request_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
+			  DRM_CURRENTPID, d->request_count, dma->buf_count);
+		return -EINVAL;
+	}
+
+	WRAP_TEST_WITH_RETURN(dev_priv);
+
+	d->granted_count = 0;
+
+	if (d->request_count) {
+		ret = mga_dma_get_buffers(dev, file_priv, d);
+	}
+
+	return ret;
+}
+
+/**
+ * Called just before the module is unloaded.
+ */
+int mga_driver_unload(struct drm_device * dev)
+{
+	drm_free(dev->dev_private, sizeof(drm_mga_private_t), DRM_MEM_DRIVER);
+	dev->dev_private = NULL;
+
+	return 0;
+}
+
+/**
+ * Called when the last opener of the device is closed.
+ */
+void mga_driver_lastclose(struct drm_device * dev)
+{
+	mga_do_cleanup_dma(dev, FULL_CLEANUP);
+}
+
+int mga_driver_dma_quiescent(struct drm_device * dev)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	return mga_do_wait_for_idle(dev_priv);
+}
Index: git/shared-core/mga_drm.h
===================================================================
--- git.orig/shared-core/mga_drm.h	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/mga_drm.h	2008-12-12 17:35:22.000000000 +0000
@@ -181,7 +181,7 @@
 
 	/* The current cliprects, or a subset thereof.
 	 */
-	drm_clip_rect_t boxes[MGA_NR_SAREA_CLIPRECTS];
+	struct drm_clip_rect boxes[MGA_NR_SAREA_CLIPRECTS];
 	unsigned int nbox;
 
 	/* Information about the most recently used 3d drawable.  The
@@ -202,7 +202,7 @@
 	unsigned int exported_nback;
 	int exported_back_x, exported_front_x, exported_w;
 	int exported_back_y, exported_front_y, exported_h;
-	drm_clip_rect_t exported_boxes[MGA_NR_SAREA_CLIPRECTS];
+	struct drm_clip_rect exported_boxes[MGA_NR_SAREA_CLIPRECTS];
 
 	/* Counters for aging textures and for client-side throttling.
 	 */
@@ -216,7 +216,7 @@
 
 	/* LRU lists for texture memory in agp space and on the card.
 	 */
-	drm_tex_region_t texList[MGA_NR_TEX_HEAPS][MGA_NR_TEX_REGIONS + 1];
+	struct drm_tex_region texList[MGA_NR_TEX_HEAPS][MGA_NR_TEX_REGIONS + 1];
 	unsigned int texAge[MGA_NR_TEX_HEAPS];
 
 	/* Mechanism to validate card state.
@@ -302,10 +302,10 @@
 typedef struct drm_mga_dma_bootstrap {
 	/**
 	 * \name AGP texture region
-	 * 
+	 *
 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, these fields will
 	 * be filled in with the actual AGP texture settings.
-	 * 
+	 *
 	 * \warning
 	 * If these fields are non-zero, but dma_mga_dma_bootstrap::agp_mode
 	 * is zero, it means that PCI memory (most likely through the use of
@@ -319,7 +319,7 @@
 
 	/**
 	 * Requested size of the primary DMA region.
-	 * 
+	 *
 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be
 	 * filled in with the actual AGP mode.  If AGP was not available
 	 */
@@ -328,18 +328,18 @@
 
 	/**
 	 * Requested number of secondary DMA buffers.
-	 * 
+	 *
 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be
 	 * filled in with the actual number of secondary DMA buffers
 	 * allocated.  Particularly when PCI DMA is used, this may be
 	 * (subtantially) less than the number requested.
 	 */
 	uint32_t secondary_bin_count;
-	
-	
+
+
 	/**
 	 * Requested size of each secondary DMA buffer.
-	 * 
+	 *
 	 * While the kernel \b is free to reduce
 	 * dma_mga_dma_bootstrap::secondary_bin_count, it is \b not allowed
 	 * to reduce dma_mga_dma_bootstrap::secondary_bin_size.
@@ -352,7 +352,7 @@
 	 * \c AGPSTAT2_2X, and \c AGPSTAT2_4X are supported.  If this value is
 	 * zero, it means that PCI DMA should be used, even if AGP is
 	 * possible.
-	 * 
+	 *
 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be
 	 * filled in with the actual AGP mode.  If AGP was not available
 	 * (i.e., PCI DMA was used), this value will be zero.
Index: git/shared-core/mga_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/mga_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,688 @@
+/* mga_drv.h -- Private header for the Matrox G200/G400 driver -*- linux-c -*-
+ * Created: Mon Dec 13 01:50:01 1999 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ */
+
+#ifndef __MGA_DRV_H__
+#define __MGA_DRV_H__
+
+/* General customization:
+ */
+
+#define DRIVER_AUTHOR		"Gareth Hughes, VA Linux Systems Inc."
+
+#define DRIVER_NAME		"mga"
+#define DRIVER_DESC		"Matrox G200/G400"
+#define DRIVER_DATE		"20060319"
+
+#define DRIVER_MAJOR		3
+#define DRIVER_MINOR		2
+#define DRIVER_PATCHLEVEL	2
+
+typedef struct drm_mga_primary_buffer {
+	u8 *start;
+	u8 *end;
+	int size;
+
+	u32 tail;
+	int space;
+	volatile long wrapped;
+
+	volatile u32 *status;
+
+	u32 last_flush;
+	u32 last_wrap;
+
+	u32 high_mark;
+} drm_mga_primary_buffer_t;
+
+typedef struct drm_mga_freelist {
+	struct drm_mga_freelist *next;
+	struct drm_mga_freelist *prev;
+	drm_mga_age_t age;
+	struct drm_buf *buf;
+} drm_mga_freelist_t;
+
+typedef struct {
+	drm_mga_freelist_t *list_entry;
+	int discard;
+	int dispatched;
+} drm_mga_buf_priv_t;
+
+typedef struct drm_mga_private {
+	drm_mga_primary_buffer_t prim;
+	drm_mga_sarea_t *sarea_priv;
+
+	drm_mga_freelist_t *head;
+	drm_mga_freelist_t *tail;
+
+	unsigned int warp_pipe;
+	unsigned long warp_pipe_phys[MGA_MAX_WARP_PIPES];
+
+	int chipset;
+	int usec_timeout;
+
+	/**
+	 * If set, the new DMA initialization sequence was used.  This is
+	 * primarilly used to select how the driver should uninitialized its
+	 * internal DMA structures.
+	 */
+	int used_new_dma_init;
+
+	/**
+	 * If AGP memory is used for DMA buffers, this will be the value
+	 * \c MGA_PAGPXFER.  Otherwise, it will be zero (for a PCI transfer).
+	 */
+	u32 dma_access;
+
+	/**
+	 * If AGP memory is used for DMA buffers, this will be the value
+	 * \c MGA_WAGP_ENABLE.  Otherwise, it will be zero (for a PCI
+	 * transfer).
+	 */
+	u32 wagp_enable;
+
+	/**
+	 * \name MMIO region parameters.
+	 * 
+	 * \sa drm_mga_private_t::mmio
+	 */
+	/*@{*/
+	u32 mmio_base;             /**< Bus address of base of MMIO. */
+	u32 mmio_size;             /**< Size of the MMIO region. */
+	/*@}*/
+
+	u32 clear_cmd;
+	u32 maccess;
+
+	wait_queue_head_t fence_queue;
+	atomic_t last_fence_retired;
+	u32 next_fence_to_post;
+
+	unsigned int fb_cpp;
+	unsigned int front_offset;
+	unsigned int front_pitch;
+	unsigned int back_offset;
+	unsigned int back_pitch;
+
+	unsigned int depth_cpp;
+	unsigned int depth_offset;
+	unsigned int depth_pitch;
+
+	unsigned int texture_offset;
+	unsigned int texture_size;
+
+	drm_local_map_t *sarea;
+	drm_local_map_t *mmio;
+	drm_local_map_t *status;
+	drm_local_map_t *warp;
+	drm_local_map_t *primary;
+	drm_local_map_t *agp_textures;
+	
+	unsigned long agp_handle;
+	unsigned int agp_size;
+} drm_mga_private_t;
+
+extern struct drm_ioctl_desc mga_ioctls[];
+extern int mga_max_ioctl;
+
+				/* mga_dma.c */
+extern int mga_dma_bootstrap(struct drm_device *dev, void *data,
+			     struct drm_file *file_priv);
+extern int mga_dma_init(struct drm_device *dev, void *data,
+			struct drm_file *file_priv);
+extern int mga_dma_flush(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv);
+extern int mga_dma_reset(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv);
+extern int mga_dma_buffers(struct drm_device *dev, void *data,
+			   struct drm_file *file_priv);
+extern int mga_driver_load(struct drm_device *dev, unsigned long flags);
+extern int mga_driver_unload(struct drm_device * dev);
+extern void mga_driver_lastclose(struct drm_device * dev);
+extern int mga_driver_dma_quiescent(struct drm_device * dev);
+
+extern int mga_do_wait_for_idle(drm_mga_private_t * dev_priv);
+
+extern void mga_do_dma_flush(drm_mga_private_t * dev_priv);
+extern void mga_do_dma_wrap_start(drm_mga_private_t * dev_priv);
+extern void mga_do_dma_wrap_end(drm_mga_private_t * dev_priv);
+
+extern int mga_freelist_put(struct drm_device * dev, struct drm_buf * buf);
+
+				/* mga_warp.c */
+extern unsigned int mga_warp_microcode_size(const drm_mga_private_t * dev_priv);
+extern int mga_warp_install_microcode(drm_mga_private_t * dev_priv);
+extern int mga_warp_init(drm_mga_private_t * dev_priv);
+
+				/* mga_irq.c */
+extern int mga_driver_fence_wait(struct drm_device * dev, unsigned int *sequence);
+extern int mga_driver_vblank_wait(struct drm_device * dev, unsigned int *sequence);
+extern irqreturn_t mga_driver_irq_handler(DRM_IRQ_ARGS);
+extern void mga_driver_irq_preinstall(struct drm_device * dev);
+extern void mga_driver_irq_postinstall(struct drm_device * dev);
+extern void mga_driver_irq_uninstall(struct drm_device * dev);
+extern long mga_compat_ioctl(struct file *filp, unsigned int cmd,
+			     unsigned long arg);
+
+#define mga_flush_write_combine()	DRM_WRITEMEMORYBARRIER()
+
+#if defined(__linux__) && defined(__alpha__)
+#define MGA_BASE( reg )		((unsigned long)(dev_priv->mmio->handle))
+#define MGA_ADDR( reg )		(MGA_BASE(reg) + reg)
+
+#define MGA_DEREF( reg )	*(volatile u32 *)MGA_ADDR( reg )
+#define MGA_DEREF8( reg )	*(volatile u8 *)MGA_ADDR( reg )
+
+#define MGA_READ( reg )		(_MGA_READ((u32 *)MGA_ADDR(reg)))
+#define MGA_READ8( reg )	(_MGA_READ((u8 *)MGA_ADDR(reg)))
+#define MGA_WRITE( reg, val )	do { DRM_WRITEMEMORYBARRIER(); MGA_DEREF( reg ) = val; } while (0)
+#define MGA_WRITE8( reg, val )  do { DRM_WRITEMEMORYBARRIER(); MGA_DEREF8( reg ) = val; } while (0)
+
+static inline u32 _MGA_READ(u32 * addr)
+{
+	DRM_MEMORYBARRIER();
+	return *(volatile u32 *)addr;
+}
+#else
+#define MGA_READ8( reg )	DRM_READ8(dev_priv->mmio, (reg))
+#define MGA_READ( reg )		DRM_READ32(dev_priv->mmio, (reg))
+#define MGA_WRITE8( reg, val )  DRM_WRITE8(dev_priv->mmio, (reg), (val))
+#define MGA_WRITE( reg, val )	DRM_WRITE32(dev_priv->mmio, (reg), (val))
+#endif
+
+#define DWGREG0 	0x1c00
+#define DWGREG0_END 	0x1dff
+#define DWGREG1		0x2c00
+#define DWGREG1_END	0x2dff
+
+#define ISREG0(r)	(r >= DWGREG0 && r <= DWGREG0_END)
+#define DMAREG0(r)	(u8)((r - DWGREG0) >> 2)
+#define DMAREG1(r)	(u8)(((r - DWGREG1) >> 2) | 0x80)
+#define DMAREG(r)	(ISREG0(r) ? DMAREG0(r) : DMAREG1(r))
+
+/* ================================================================
+ * Helper macross...
+ */
+
+#define MGA_EMIT_STATE( dev_priv, dirty )				\
+do {									\
+	if ( (dirty) & ~MGA_UPLOAD_CLIPRECTS ) {			\
+		if ( dev_priv->chipset >= MGA_CARD_TYPE_G400 ) {	\
+			mga_g400_emit_state( dev_priv );		\
+		} else {						\
+			mga_g200_emit_state( dev_priv );		\
+		}							\
+	}								\
+} while (0)
+
+#define WRAP_TEST_WITH_RETURN( dev_priv )				\
+do {									\
+	if ( test_bit( 0, &dev_priv->prim.wrapped ) ) {			\
+		if ( mga_is_idle( dev_priv ) ) {			\
+			mga_do_dma_wrap_end( dev_priv );		\
+		} else if ( dev_priv->prim.space <			\
+			    dev_priv->prim.high_mark ) {		\
+			if ( MGA_DMA_DEBUG )				\
+				DRM_INFO( "%s: wrap...\n", __FUNCTION__ );	\
+			return -EBUSY;			\
+		}							\
+	}								\
+} while (0)
+
+#define WRAP_WAIT_WITH_RETURN( dev_priv )				\
+do {									\
+	if ( test_bit( 0, &dev_priv->prim.wrapped ) ) {			\
+		if ( mga_do_wait_for_idle( dev_priv ) < 0 ) {		\
+			if ( MGA_DMA_DEBUG )				\
+				DRM_INFO( "%s: wrap...\n", __FUNCTION__ );	\
+			return -EBUSY;			\
+		}							\
+		mga_do_dma_wrap_end( dev_priv );			\
+	}								\
+} while (0)
+
+/* ================================================================
+ * Primary DMA command stream
+ */
+
+#define MGA_VERBOSE	0
+
+#define DMA_LOCALS	unsigned int write; volatile u8 *prim;
+
+#define DMA_BLOCK_SIZE	(5 * sizeof(u32))
+
+#define BEGIN_DMA( n )							\
+do {									\
+	if ( MGA_VERBOSE ) {						\
+		DRM_INFO( "BEGIN_DMA( %d ) in %s\n",			\
+			  (n), __FUNCTION__ );				\
+		DRM_INFO( "   space=0x%x req=0x%Zx\n",			\
+			  dev_priv->prim.space, (n) * DMA_BLOCK_SIZE );	\
+	}								\
+	prim = dev_priv->prim.start;					\
+	write = dev_priv->prim.tail;					\
+} while (0)
+
+#define BEGIN_DMA_WRAP()						\
+do {									\
+	if ( MGA_VERBOSE ) {						\
+		DRM_INFO( "BEGIN_DMA() in %s\n", __FUNCTION__ );		\
+		DRM_INFO( "   space=0x%x\n", dev_priv->prim.space );	\
+	}								\
+	prim = dev_priv->prim.start;					\
+	write = dev_priv->prim.tail;					\
+} while (0)
+
+#define ADVANCE_DMA()							\
+do {									\
+	dev_priv->prim.tail = write;					\
+	if ( MGA_VERBOSE ) {						\
+		DRM_INFO( "ADVANCE_DMA() tail=0x%05x sp=0x%x\n",	\
+			  write, dev_priv->prim.space );		\
+	}								\
+} while (0)
+
+#define FLUSH_DMA()							\
+do {									\
+	if ( 0 ) {							\
+		DRM_INFO( "%s:\n", __FUNCTION__ );				\
+		DRM_INFO( "   tail=0x%06x head=0x%06lx\n",		\
+			  dev_priv->prim.tail,				\
+			  MGA_READ( MGA_PRIMADDRESS ) -			\
+			  dev_priv->primary->offset );			\
+	}								\
+	if ( !test_bit( 0, &dev_priv->prim.wrapped ) ) {		\
+		if ( dev_priv->prim.space <				\
+		     dev_priv->prim.high_mark ) {			\
+			mga_do_dma_wrap_start( dev_priv );		\
+		} else {						\
+			mga_do_dma_flush( dev_priv );			\
+		}							\
+	}								\
+} while (0)
+
+/* Never use this, always use DMA_BLOCK(...) for primary DMA output.
+ */
+#define DMA_WRITE( offset, val )					\
+do {									\
+	if ( MGA_VERBOSE ) {						\
+		DRM_INFO( "   DMA_WRITE( 0x%08x ) at 0x%04Zx\n",	\
+			  (u32)(val), write + (offset) * sizeof(u32) );	\
+	}								\
+	*(volatile u32 *)(prim + write + (offset) * sizeof(u32)) = val;	\
+} while (0)
+
+#define DMA_BLOCK( reg0, val0, reg1, val1, reg2, val2, reg3, val3 )	\
+do {									\
+	DMA_WRITE( 0, ((DMAREG( reg0 ) << 0) |				\
+		       (DMAREG( reg1 ) << 8) |				\
+		       (DMAREG( reg2 ) << 16) |				\
+		       (DMAREG( reg3 ) << 24)) );			\
+	DMA_WRITE( 1, val0 );						\
+	DMA_WRITE( 2, val1 );						\
+	DMA_WRITE( 3, val2 );						\
+	DMA_WRITE( 4, val3 );						\
+	write += DMA_BLOCK_SIZE;					\
+} while (0)
+
+/* Buffer aging via primary DMA stream head pointer.
+ */
+
+#define SET_AGE( age, h, w )						\
+do {									\
+	(age)->head = h;						\
+	(age)->wrap = w;						\
+} while (0)
+
+#define TEST_AGE( age, h, w )		( (age)->wrap < w ||		\
+					  ( (age)->wrap == w &&		\
+					    (age)->head < h ) )
+
+#define AGE_BUFFER( buf_priv )						\
+do {									\
+	drm_mga_freelist_t *entry = (buf_priv)->list_entry;		\
+	if ( (buf_priv)->dispatched ) {					\
+		entry->age.head = (dev_priv->prim.tail +		\
+				   dev_priv->primary->offset);		\
+		entry->age.wrap = dev_priv->sarea_priv->last_wrap;	\
+	} else {							\
+		entry->age.head = 0;					\
+		entry->age.wrap = 0;					\
+	}								\
+} while (0)
+
+#define MGA_ENGINE_IDLE_MASK		(MGA_SOFTRAPEN |		\
+					 MGA_DWGENGSTS |		\
+					 MGA_ENDPRDMASTS)
+#define MGA_DMA_IDLE_MASK		(MGA_SOFTRAPEN |		\
+					 MGA_ENDPRDMASTS)
+
+#define MGA_DMA_DEBUG			0
+
+/* A reduced set of the mga registers.
+ */
+#define MGA_CRTC_INDEX			0x1fd4
+#define MGA_CRTC_DATA			0x1fd5
+
+/* CRTC11 */
+#define MGA_VINTCLR			(1 << 4)
+#define MGA_VINTEN			(1 << 5)
+
+#define MGA_ALPHACTRL 			0x2c7c
+#define MGA_AR0 			0x1c60
+#define MGA_AR1 			0x1c64
+#define MGA_AR2 			0x1c68
+#define MGA_AR3 			0x1c6c
+#define MGA_AR4 			0x1c70
+#define MGA_AR5 			0x1c74
+#define MGA_AR6 			0x1c78
+
+#define MGA_CXBNDRY			0x1c80
+#define MGA_CXLEFT 			0x1ca0
+#define MGA_CXRIGHT			0x1ca4
+
+#define MGA_DMAPAD 			0x1c54
+#define MGA_DSTORG 			0x2cb8
+#define MGA_DWGCTL 			0x1c00
+#	define MGA_OPCOD_MASK			(15 << 0)
+#	define MGA_OPCOD_TRAP			(4 << 0)
+#	define MGA_OPCOD_TEXTURE_TRAP		(6 << 0)
+#	define MGA_OPCOD_BITBLT			(8 << 0)
+#	define MGA_OPCOD_ILOAD			(9 << 0)
+#	define MGA_ATYPE_MASK			(7 << 4)
+#	define MGA_ATYPE_RPL			(0 << 4)
+#	define MGA_ATYPE_RSTR			(1 << 4)
+#	define MGA_ATYPE_ZI			(3 << 4)
+#	define MGA_ATYPE_BLK			(4 << 4)
+#	define MGA_ATYPE_I			(7 << 4)
+#	define MGA_LINEAR			(1 << 7)
+#	define MGA_ZMODE_MASK			(7 << 8)
+#	define MGA_ZMODE_NOZCMP			(0 << 8)
+#	define MGA_ZMODE_ZE			(2 << 8)
+#	define MGA_ZMODE_ZNE			(3 << 8)
+#	define MGA_ZMODE_ZLT			(4 << 8)
+#	define MGA_ZMODE_ZLTE			(5 << 8)
+#	define MGA_ZMODE_ZGT			(6 << 8)
+#	define MGA_ZMODE_ZGTE			(7 << 8)
+#	define MGA_SOLID			(1 << 11)
+#	define MGA_ARZERO			(1 << 12)
+#	define MGA_SGNZERO			(1 << 13)
+#	define MGA_SHIFTZERO			(1 << 14)
+#	define MGA_BOP_MASK			(15 << 16)
+#	define MGA_BOP_ZERO			(0 << 16)
+#	define MGA_BOP_DST			(10 << 16)
+#	define MGA_BOP_SRC			(12 << 16)
+#	define MGA_BOP_ONE			(15 << 16)
+#	define MGA_TRANS_SHIFT			20
+#	define MGA_TRANS_MASK			(15 << 20)
+#	define MGA_BLTMOD_MASK			(15 << 25)
+#	define MGA_BLTMOD_BMONOLEF		(0 << 25)
+#	define MGA_BLTMOD_BMONOWF		(4 << 25)
+#	define MGA_BLTMOD_PLAN			(1 << 25)
+#	define MGA_BLTMOD_BFCOL			(2 << 25)
+#	define MGA_BLTMOD_BU32BGR		(3 << 25)
+#	define MGA_BLTMOD_BU32RGB		(7 << 25)
+#	define MGA_BLTMOD_BU24BGR		(11 << 25)
+#	define MGA_BLTMOD_BU24RGB		(15 << 25)
+#	define MGA_PATTERN			(1 << 29)
+#	define MGA_TRANSC			(1 << 30)
+#	define MGA_CLIPDIS			(1 << 31)
+#define MGA_DWGSYNC			0x2c4c
+
+#define MGA_FCOL 			0x1c24
+#define MGA_FIFOSTATUS 			0x1e10
+#define MGA_FOGCOL 			0x1cf4
+#define MGA_FXBNDRY			0x1c84
+#define MGA_FXLEFT 			0x1ca8
+#define MGA_FXRIGHT			0x1cac
+
+#define MGA_ICLEAR 			0x1e18
+#	define MGA_SOFTRAPICLR			(1 << 0)
+#	define MGA_VLINEICLR			(1 << 5)
+#define MGA_IEN 			0x1e1c
+#	define MGA_SOFTRAPIEN			(1 << 0)
+#	define MGA_VLINEIEN			(1 << 5)
+
+#define MGA_LEN 			0x1c5c
+
+#define MGA_MACCESS			0x1c04
+
+#define MGA_PITCH 			0x1c8c
+#define MGA_PLNWT 			0x1c1c
+#define MGA_PRIMADDRESS 		0x1e58
+#	define MGA_DMA_GENERAL			(0 << 0)
+#	define MGA_DMA_BLIT			(1 << 0)
+#	define MGA_DMA_VECTOR			(2 << 0)
+#	define MGA_DMA_VERTEX			(3 << 0)
+#define MGA_PRIMEND			0x1e5c
+#	define MGA_PRIMNOSTART			(1 << 0)
+#	define MGA_PAGPXFER			(1 << 1)
+#define MGA_PRIMPTR			0x1e50
+#	define MGA_PRIMPTREN0			(1 << 0)
+#	define MGA_PRIMPTREN1			(1 << 1)
+
+#define MGA_RST 			0x1e40
+#	define MGA_SOFTRESET			(1 << 0)
+#	define MGA_SOFTEXTRST			(1 << 1)
+
+#define MGA_SECADDRESS 			0x2c40
+#define MGA_SECEND 			0x2c44
+#define MGA_SETUPADDRESS 		0x2cd0
+#define MGA_SETUPEND 			0x2cd4
+#define MGA_SGN				0x1c58
+#define MGA_SOFTRAP			0x2c48
+#define MGA_SRCORG 			0x2cb4
+#	define MGA_SRMMAP_MASK			(1 << 0)
+#	define MGA_SRCMAP_FB			(0 << 0)
+#	define MGA_SRCMAP_SYSMEM		(1 << 0)
+#	define MGA_SRCACC_MASK			(1 << 1)
+#	define MGA_SRCACC_PCI			(0 << 1)
+#	define MGA_SRCACC_AGP			(1 << 1)
+#define MGA_STATUS 			0x1e14
+#	define MGA_SOFTRAPEN			(1 << 0)
+#	define MGA_VSYNCPEN			(1 << 4)
+#	define MGA_VLINEPEN			(1 << 5)
+#	define MGA_DWGENGSTS			(1 << 16)
+#	define MGA_ENDPRDMASTS			(1 << 17)
+#define MGA_STENCIL			0x2cc8
+#define MGA_STENCILCTL 			0x2ccc
+
+#define MGA_TDUALSTAGE0 		0x2cf8
+#define MGA_TDUALSTAGE1 		0x2cfc
+#define MGA_TEXBORDERCOL 		0x2c5c
+#define MGA_TEXCTL 			0x2c30
+#define MGA_TEXCTL2			0x2c3c
+#	define MGA_DUALTEX			(1 << 7)
+#	define MGA_G400_TC2_MAGIC		(1 << 15)
+#	define MGA_MAP1_ENABLE			(1 << 31)
+#define MGA_TEXFILTER 			0x2c58
+#define MGA_TEXHEIGHT 			0x2c2c
+#define MGA_TEXORG 			0x2c24
+#	define MGA_TEXORGMAP_MASK		(1 << 0)
+#	define MGA_TEXORGMAP_FB			(0 << 0)
+#	define MGA_TEXORGMAP_SYSMEM		(1 << 0)
+#	define MGA_TEXORGACC_MASK		(1 << 1)
+#	define MGA_TEXORGACC_PCI		(0 << 1)
+#	define MGA_TEXORGACC_AGP		(1 << 1)
+#define MGA_TEXORG1			0x2ca4
+#define MGA_TEXORG2			0x2ca8
+#define MGA_TEXORG3			0x2cac
+#define MGA_TEXORG4			0x2cb0
+#define MGA_TEXTRANS 			0x2c34
+#define MGA_TEXTRANSHIGH 		0x2c38
+#define MGA_TEXWIDTH 			0x2c28
+
+#define MGA_WACCEPTSEQ 			0x1dd4
+#define MGA_WCODEADDR 			0x1e6c
+#define MGA_WFLAG 			0x1dc4
+#define MGA_WFLAG1 			0x1de0
+#define MGA_WFLAGNB			0x1e64
+#define MGA_WFLAGNB1 			0x1e08
+#define MGA_WGETMSB			0x1dc8
+#define MGA_WIADDR 			0x1dc0
+#define MGA_WIADDR2			0x1dd8
+#	define MGA_WMODE_SUSPEND		(0 << 0)
+#	define MGA_WMODE_RESUME			(1 << 0)
+#	define MGA_WMODE_JUMP			(2 << 0)
+#	define MGA_WMODE_START			(3 << 0)
+#	define MGA_WAGP_ENABLE			(1 << 2)
+#define MGA_WMISC 			0x1e70
+#	define MGA_WUCODECACHE_ENABLE		(1 << 0)
+#	define MGA_WMASTER_ENABLE		(1 << 1)
+#	define MGA_WCACHEFLUSH_ENABLE		(1 << 3)
+#define MGA_WVRTXSZ			0x1dcc
+
+#define MGA_YBOT 			0x1c9c
+#define MGA_YDST 			0x1c90
+#define MGA_YDSTLEN			0x1c88
+#define MGA_YDSTORG			0x1c94
+#define MGA_YTOP 			0x1c98
+
+#define MGA_ZORG 			0x1c0c
+
+/* This finishes the current batch of commands
+ */
+#define MGA_EXEC 			0x0100
+
+/* AGP PLL encoding (for G200 only).
+ */
+#define MGA_AGP_PLL 			0x1e4c
+#	define MGA_AGP2XPLL_DISABLE		(0 << 0)
+#	define MGA_AGP2XPLL_ENABLE		(1 << 0)
+
+/* Warp registers
+ */
+#define MGA_WR0				0x2d00
+#define MGA_WR1				0x2d04
+#define MGA_WR2				0x2d08
+#define MGA_WR3				0x2d0c
+#define MGA_WR4				0x2d10
+#define MGA_WR5				0x2d14
+#define MGA_WR6				0x2d18
+#define MGA_WR7				0x2d1c
+#define MGA_WR8				0x2d20
+#define MGA_WR9				0x2d24
+#define MGA_WR10			0x2d28
+#define MGA_WR11			0x2d2c
+#define MGA_WR12			0x2d30
+#define MGA_WR13			0x2d34
+#define MGA_WR14			0x2d38
+#define MGA_WR15			0x2d3c
+#define MGA_WR16			0x2d40
+#define MGA_WR17			0x2d44
+#define MGA_WR18			0x2d48
+#define MGA_WR19			0x2d4c
+#define MGA_WR20			0x2d50
+#define MGA_WR21			0x2d54
+#define MGA_WR22			0x2d58
+#define MGA_WR23			0x2d5c
+#define MGA_WR24			0x2d60
+#define MGA_WR25			0x2d64
+#define MGA_WR26			0x2d68
+#define MGA_WR27			0x2d6c
+#define MGA_WR28			0x2d70
+#define MGA_WR29			0x2d74
+#define MGA_WR30			0x2d78
+#define MGA_WR31			0x2d7c
+#define MGA_WR32			0x2d80
+#define MGA_WR33			0x2d84
+#define MGA_WR34			0x2d88
+#define MGA_WR35			0x2d8c
+#define MGA_WR36			0x2d90
+#define MGA_WR37			0x2d94
+#define MGA_WR38			0x2d98
+#define MGA_WR39			0x2d9c
+#define MGA_WR40			0x2da0
+#define MGA_WR41			0x2da4
+#define MGA_WR42			0x2da8
+#define MGA_WR43			0x2dac
+#define MGA_WR44			0x2db0
+#define MGA_WR45			0x2db4
+#define MGA_WR46			0x2db8
+#define MGA_WR47			0x2dbc
+#define MGA_WR48			0x2dc0
+#define MGA_WR49			0x2dc4
+#define MGA_WR50			0x2dc8
+#define MGA_WR51			0x2dcc
+#define MGA_WR52			0x2dd0
+#define MGA_WR53			0x2dd4
+#define MGA_WR54			0x2dd8
+#define MGA_WR55			0x2ddc
+#define MGA_WR56			0x2de0
+#define MGA_WR57			0x2de4
+#define MGA_WR58			0x2de8
+#define MGA_WR59			0x2dec
+#define MGA_WR60			0x2df0
+#define MGA_WR61			0x2df4
+#define MGA_WR62			0x2df8
+#define MGA_WR63			0x2dfc
+#	define MGA_G400_WR_MAGIC		(1 << 6)
+#	define MGA_G400_WR56_MAGIC		0x46480000	/* 12800.0f */
+
+#define MGA_ILOAD_ALIGN		64
+#define MGA_ILOAD_MASK		(MGA_ILOAD_ALIGN - 1)
+
+#define MGA_DWGCTL_FLUSH	(MGA_OPCOD_TEXTURE_TRAP |		\
+				 MGA_ATYPE_I |				\
+				 MGA_ZMODE_NOZCMP |			\
+				 MGA_ARZERO |				\
+				 MGA_SGNZERO |				\
+				 MGA_BOP_SRC |				\
+				 (15 << MGA_TRANS_SHIFT))
+
+#define MGA_DWGCTL_CLEAR	(MGA_OPCOD_TRAP |			\
+				 MGA_ZMODE_NOZCMP |			\
+				 MGA_SOLID |				\
+				 MGA_ARZERO |				\
+				 MGA_SGNZERO |				\
+				 MGA_SHIFTZERO |			\
+				 MGA_BOP_SRC |				\
+				 (0 << MGA_TRANS_SHIFT) |		\
+				 MGA_BLTMOD_BMONOLEF |			\
+				 MGA_TRANSC |				\
+				 MGA_CLIPDIS)
+
+#define MGA_DWGCTL_COPY		(MGA_OPCOD_BITBLT |			\
+				 MGA_ATYPE_RPL |			\
+				 MGA_SGNZERO |				\
+				 MGA_SHIFTZERO |			\
+				 MGA_BOP_SRC |				\
+				 (0 << MGA_TRANS_SHIFT) |		\
+				 MGA_BLTMOD_BFCOL |			\
+				 MGA_CLIPDIS)
+
+/* Simple idle test.
+ */
+static __inline__ int mga_is_idle(drm_mga_private_t * dev_priv)
+{
+	u32 status = MGA_READ(MGA_STATUS) & MGA_ENGINE_IDLE_MASK;
+	return (status == MGA_ENDPRDMASTS);
+}
+
+#endif
Index: git/shared-core/mga_irq.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/mga_irq.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,150 @@
+/* mga_irq.c -- IRQ handling for radeon -*- linux-c -*-
+ */
+/*
+ * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
+ *
+ * The Weather Channel (TM) funded Tungsten Graphics to develop the
+ * initial release of the Radeon 8500 driver under the XFree86 license.
+ * This notice must be preserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ *    Eric Anholt <anholt@FreeBSD.org>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "mga_drm.h"
+#include "mga_drv.h"
+
+irqreturn_t mga_driver_irq_handler(DRM_IRQ_ARGS)
+{
+	struct drm_device *dev = (struct drm_device *) arg;
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
+	int status;
+	int handled = 0;
+
+	status = MGA_READ(MGA_STATUS);
+
+	/* VBLANK interrupt */
+	if (status & MGA_VLINEPEN) {
+		MGA_WRITE(MGA_ICLEAR, MGA_VLINEICLR);
+		atomic_inc(&dev->vbl_received);
+		DRM_WAKEUP(&dev->vbl_queue);
+		drm_vbl_send_signals(dev);
+		handled = 1;
+	}
+
+	/* SOFTRAP interrupt */
+	if (status & MGA_SOFTRAPEN) {
+		const u32 prim_start = MGA_READ(MGA_PRIMADDRESS);
+		const u32 prim_end   = MGA_READ(MGA_PRIMEND);
+
+
+		MGA_WRITE(MGA_ICLEAR, MGA_SOFTRAPICLR);
+
+		/* In addition to clearing the interrupt-pending bit, we
+		 * have to write to MGA_PRIMEND to re-start the DMA operation.
+		 */
+		if ( (prim_start & ~0x03) != (prim_end & ~0x03) ) {
+			MGA_WRITE(MGA_PRIMEND, prim_end);
+		}
+
+		atomic_inc(&dev_priv->last_fence_retired);
+		DRM_WAKEUP(&dev_priv->fence_queue);
+		handled = 1;
+	}
+
+	if ( handled ) {
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+int mga_driver_vblank_wait(struct drm_device * dev, unsigned int *sequence)
+{
+	unsigned int cur_vblank;
+	int ret = 0;
+
+	/* Assume that the user has missed the current sequence number
+	 * by about a day rather than she wants to wait for years
+	 * using vertical blanks...
+	 */
+	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
+		    (((cur_vblank = atomic_read(&dev->vbl_received))
+		      - *sequence) <= (1 << 23)));
+
+	*sequence = cur_vblank;
+
+	return ret;
+}
+
+int mga_driver_fence_wait(struct drm_device * dev, unsigned int *sequence)
+{
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
+	unsigned int cur_fence;
+	int ret = 0;
+
+	/* Assume that the user has missed the current sequence number
+	 * by about a day rather than she wants to wait for years
+	 * using fences.
+	 */
+	DRM_WAIT_ON(ret, dev_priv->fence_queue, 3 * DRM_HZ,
+		    (((cur_fence = atomic_read(&dev_priv->last_fence_retired))
+		      - *sequence) <= (1 << 23)));
+
+	*sequence = cur_fence;
+
+	return ret;
+}
+
+void mga_driver_irq_preinstall(struct drm_device * dev)
+{
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
+
+	/* Disable *all* interrupts */
+	MGA_WRITE(MGA_IEN, 0);
+	/* Clear bits if they're already high */
+	MGA_WRITE(MGA_ICLEAR, ~0);
+}
+
+void mga_driver_irq_postinstall(struct drm_device * dev)
+{
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
+
+	DRM_INIT_WAITQUEUE( &dev_priv->fence_queue );
+
+	/* Turn on vertical blank interrupt and soft trap interrupt. */
+	MGA_WRITE(MGA_IEN, MGA_VLINEIEN | MGA_SOFTRAPEN);
+}
+
+void mga_driver_irq_uninstall(struct drm_device * dev)
+{
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
+	if (!dev_priv)
+		return;
+
+	/* Disable *all* interrupts */
+	MGA_WRITE(MGA_IEN, 0);
+	
+	dev->irq_enabled = 0;
+}
Index: git/shared-core/mga_state.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/mga_state.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,1143 @@
+/* mga_state.c -- State support for MGA G200/G400 -*- linux-c -*-
+ * Created: Thu Jan 27 02:53:43 2000 by jhartmann@precisioninsight.com
+ */
+/*
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Jeff Hartmann <jhartmann@valinux.com>
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ *
+ * Rewritten by:
+ *    Gareth Hughes <gareth@valinux.com>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "mga_drm.h"
+#include "mga_drv.h"
+
+/* ================================================================
+ * DMA hardware state programming functions
+ */
+
+static void mga_emit_clip_rect(drm_mga_private_t * dev_priv,
+			       struct drm_clip_rect * box)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_context_regs_t *ctx = &sarea_priv->context_state;
+	unsigned int pitch = dev_priv->front_pitch;
+	DMA_LOCALS;
+
+	BEGIN_DMA(2);
+
+	/* Force reset of DWGCTL on G400 (eliminates clip disable bit).
+	 */
+	if (dev_priv->chipset >= MGA_CARD_TYPE_G400) {
+		DMA_BLOCK(MGA_DWGCTL, ctx->dwgctl,
+			  MGA_LEN + MGA_EXEC, 0x80000000,
+			  MGA_DWGCTL, ctx->dwgctl,
+			  MGA_LEN + MGA_EXEC, 0x80000000);
+	}
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_CXBNDRY, ((box->x2 - 1) << 16) | box->x1,
+		  MGA_YTOP, box->y1 * pitch,
+		  MGA_YBOT, (box->y2 - 1) * pitch);
+
+	ADVANCE_DMA();
+}
+
+static __inline__ void mga_g200_emit_context(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_context_regs_t *ctx = &sarea_priv->context_state;
+	DMA_LOCALS;
+
+	BEGIN_DMA(3);
+
+	DMA_BLOCK(MGA_DSTORG, ctx->dstorg,
+		  MGA_MACCESS, ctx->maccess,
+		  MGA_PLNWT, ctx->plnwt,
+		  MGA_DWGCTL, ctx->dwgctl);
+
+	DMA_BLOCK(MGA_ALPHACTRL, ctx->alphactrl,
+		  MGA_FOGCOL, ctx->fogcolor,
+		  MGA_WFLAG, ctx->wflag,
+		  MGA_ZORG, dev_priv->depth_offset);
+
+	DMA_BLOCK(MGA_FCOL, ctx->fcol,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000);
+
+	ADVANCE_DMA();
+}
+
+static __inline__ void mga_g400_emit_context(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_context_regs_t *ctx = &sarea_priv->context_state;
+	DMA_LOCALS;
+
+	BEGIN_DMA(4);
+
+	DMA_BLOCK(MGA_DSTORG, ctx->dstorg,
+		  MGA_MACCESS, ctx->maccess,
+		  MGA_PLNWT, ctx->plnwt,
+		  MGA_DWGCTL, ctx->dwgctl);
+
+	DMA_BLOCK(MGA_ALPHACTRL, ctx->alphactrl,
+		  MGA_FOGCOL, ctx->fogcolor,
+		  MGA_WFLAG, ctx->wflag,
+		  MGA_ZORG, dev_priv->depth_offset);
+
+	DMA_BLOCK(MGA_WFLAG1, ctx->wflag,
+		  MGA_TDUALSTAGE0, ctx->tdualstage0,
+		  MGA_TDUALSTAGE1, ctx->tdualstage1,
+		  MGA_FCOL, ctx->fcol);
+
+	DMA_BLOCK(MGA_STENCIL, ctx->stencil,
+		  MGA_STENCILCTL, ctx->stencilctl,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000);
+
+	ADVANCE_DMA();
+}
+
+static __inline__ void mga_g200_emit_tex0(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_texture_regs_t *tex = &sarea_priv->tex_state[0];
+	DMA_LOCALS;
+
+	BEGIN_DMA(4);
+
+	DMA_BLOCK(MGA_TEXCTL2, tex->texctl2,
+		  MGA_TEXCTL, tex->texctl,
+		  MGA_TEXFILTER, tex->texfilter,
+		  MGA_TEXBORDERCOL, tex->texbordercol);
+
+	DMA_BLOCK(MGA_TEXORG, tex->texorg,
+		  MGA_TEXORG1, tex->texorg1,
+		  MGA_TEXORG2, tex->texorg2,
+		  MGA_TEXORG3, tex->texorg3);
+
+	DMA_BLOCK(MGA_TEXORG4, tex->texorg4,
+		  MGA_TEXWIDTH, tex->texwidth,
+		  MGA_TEXHEIGHT, tex->texheight,
+		  MGA_WR24, tex->texwidth);
+
+	DMA_BLOCK(MGA_WR34, tex->texheight,
+		  MGA_TEXTRANS, 0x0000ffff,
+		  MGA_TEXTRANSHIGH, 0x0000ffff,
+		  MGA_DMAPAD, 0x00000000);
+
+	ADVANCE_DMA();
+}
+
+static __inline__ void mga_g400_emit_tex0(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_texture_regs_t *tex = &sarea_priv->tex_state[0];
+	DMA_LOCALS;
+
+/*  	printk("mga_g400_emit_tex0 %x %x %x\n", tex->texorg, */
+/*  	       tex->texctl, tex->texctl2); */
+
+	BEGIN_DMA(6);
+
+	DMA_BLOCK(MGA_TEXCTL2, tex->texctl2 | MGA_G400_TC2_MAGIC,
+		  MGA_TEXCTL, tex->texctl,
+		  MGA_TEXFILTER, tex->texfilter,
+		  MGA_TEXBORDERCOL, tex->texbordercol);
+
+	DMA_BLOCK(MGA_TEXORG, tex->texorg,
+		  MGA_TEXORG1, tex->texorg1,
+		  MGA_TEXORG2, tex->texorg2,
+		  MGA_TEXORG3, tex->texorg3);
+
+	DMA_BLOCK(MGA_TEXORG4, tex->texorg4,
+		  MGA_TEXWIDTH, tex->texwidth,
+		  MGA_TEXHEIGHT, tex->texheight,
+		  MGA_WR49, 0x00000000);
+
+	DMA_BLOCK(MGA_WR57, 0x00000000,
+		  MGA_WR53, 0x00000000,
+		  MGA_WR61, 0x00000000,
+		  MGA_WR52, MGA_G400_WR_MAGIC);
+
+	DMA_BLOCK(MGA_WR60, MGA_G400_WR_MAGIC,
+		  MGA_WR54, tex->texwidth | MGA_G400_WR_MAGIC,
+		  MGA_WR62, tex->texheight | MGA_G400_WR_MAGIC,
+		  MGA_DMAPAD, 0x00000000);
+
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_TEXTRANS, 0x0000ffff,
+		  MGA_TEXTRANSHIGH, 0x0000ffff);
+
+	ADVANCE_DMA();
+}
+
+static __inline__ void mga_g400_emit_tex1(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_texture_regs_t *tex = &sarea_priv->tex_state[1];
+	DMA_LOCALS;
+
+/*  	printk("mga_g400_emit_tex1 %x %x %x\n", tex->texorg,  */
+/*  	       tex->texctl, tex->texctl2); */
+
+	BEGIN_DMA(5);
+
+	DMA_BLOCK(MGA_TEXCTL2, (tex->texctl2 |
+				MGA_MAP1_ENABLE |
+				MGA_G400_TC2_MAGIC),
+		  MGA_TEXCTL, tex->texctl,
+		  MGA_TEXFILTER, tex->texfilter,
+		  MGA_TEXBORDERCOL, tex->texbordercol);
+
+	DMA_BLOCK(MGA_TEXORG, tex->texorg,
+		  MGA_TEXORG1, tex->texorg1,
+		  MGA_TEXORG2, tex->texorg2,
+		  MGA_TEXORG3, tex->texorg3);
+
+	DMA_BLOCK(MGA_TEXORG4, tex->texorg4,
+		  MGA_TEXWIDTH, tex->texwidth,
+		  MGA_TEXHEIGHT, tex->texheight,
+		  MGA_WR49, 0x00000000);
+
+	DMA_BLOCK(MGA_WR57, 0x00000000,
+		  MGA_WR53, 0x00000000,
+		  MGA_WR61, 0x00000000,
+		  MGA_WR52, tex->texwidth | MGA_G400_WR_MAGIC);
+
+	DMA_BLOCK(MGA_WR60, tex->texheight | MGA_G400_WR_MAGIC,
+		  MGA_TEXTRANS, 0x0000ffff,
+		  MGA_TEXTRANSHIGH, 0x0000ffff,
+		  MGA_TEXCTL2, tex->texctl2 | MGA_G400_TC2_MAGIC);
+
+	ADVANCE_DMA();
+}
+
+static __inline__ void mga_g200_emit_pipe(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int pipe = sarea_priv->warp_pipe;
+	DMA_LOCALS;
+
+	BEGIN_DMA(3);
+
+	DMA_BLOCK(MGA_WIADDR, MGA_WMODE_SUSPEND,
+		  MGA_WVRTXSZ, 0x00000007,
+		  MGA_WFLAG, 0x00000000,
+		  MGA_WR24, 0x00000000);
+
+	DMA_BLOCK(MGA_WR25, 0x00000100,
+		  MGA_WR34, 0x00000000,
+		  MGA_WR42, 0x0000ffff,
+		  MGA_WR60, 0x0000ffff);
+
+	/* Padding required to to hardware bug.
+	 */
+	DMA_BLOCK(MGA_DMAPAD, 0xffffffff,
+		  MGA_DMAPAD, 0xffffffff,
+		  MGA_DMAPAD, 0xffffffff,
+		  MGA_WIADDR, (dev_priv->warp_pipe_phys[pipe] |
+			       MGA_WMODE_START | dev_priv->wagp_enable));
+
+	ADVANCE_DMA();
+}
+
+static __inline__ void mga_g400_emit_pipe(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int pipe = sarea_priv->warp_pipe;
+	DMA_LOCALS;
+
+/*  	printk("mga_g400_emit_pipe %x\n", pipe); */
+
+	BEGIN_DMA(10);
+
+	DMA_BLOCK(MGA_WIADDR2, MGA_WMODE_SUSPEND,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000);
+
+	if (pipe & MGA_T2) {
+		DMA_BLOCK(MGA_WVRTXSZ, 0x00001e09,
+			  MGA_DMAPAD, 0x00000000,
+			  MGA_DMAPAD, 0x00000000,
+			  MGA_DMAPAD, 0x00000000);
+
+		DMA_BLOCK(MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x1e000000);
+	} else {
+		if (dev_priv->warp_pipe & MGA_T2) {
+			/* Flush the WARP pipe */
+			DMA_BLOCK(MGA_YDST, 0x00000000,
+				  MGA_FXLEFT, 0x00000000,
+				  MGA_FXRIGHT, 0x00000001,
+				  MGA_DWGCTL, MGA_DWGCTL_FLUSH);
+
+			DMA_BLOCK(MGA_LEN + MGA_EXEC, 0x00000001,
+				  MGA_DWGSYNC, 0x00007000,
+				  MGA_TEXCTL2, MGA_G400_TC2_MAGIC,
+				  MGA_LEN + MGA_EXEC, 0x00000000);
+
+			DMA_BLOCK(MGA_TEXCTL2, (MGA_DUALTEX |
+						MGA_G400_TC2_MAGIC),
+				  MGA_LEN + MGA_EXEC, 0x00000000,
+				  MGA_TEXCTL2, MGA_G400_TC2_MAGIC,
+				  MGA_DMAPAD, 0x00000000);
+		}
+
+		DMA_BLOCK(MGA_WVRTXSZ, 0x00001807,
+			  MGA_DMAPAD, 0x00000000,
+			  MGA_DMAPAD, 0x00000000,
+			  MGA_DMAPAD, 0x00000000);
+
+		DMA_BLOCK(MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x00000000,
+			  MGA_WACCEPTSEQ, 0x18000000);
+	}
+
+	DMA_BLOCK(MGA_WFLAG, 0x00000000,
+		  MGA_WFLAG1, 0x00000000,
+		  MGA_WR56, MGA_G400_WR56_MAGIC,
+		  MGA_DMAPAD, 0x00000000);
+
+	DMA_BLOCK(MGA_WR49, 0x00000000,	/* tex0              */
+		  MGA_WR57, 0x00000000,	/* tex0              */
+		  MGA_WR53, 0x00000000,	/* tex1              */
+		  MGA_WR61, 0x00000000);	/* tex1              */
+
+	DMA_BLOCK(MGA_WR54, MGA_G400_WR_MAGIC,	/* tex0 width        */
+		  MGA_WR62, MGA_G400_WR_MAGIC,	/* tex0 height       */
+		  MGA_WR52, MGA_G400_WR_MAGIC,	/* tex1 width        */
+		  MGA_WR60, MGA_G400_WR_MAGIC);	/* tex1 height       */
+
+	/* Padding required to to hardware bug */
+	DMA_BLOCK(MGA_DMAPAD, 0xffffffff,
+		  MGA_DMAPAD, 0xffffffff,
+		  MGA_DMAPAD, 0xffffffff,
+		  MGA_WIADDR2, (dev_priv->warp_pipe_phys[pipe] |
+				MGA_WMODE_START | dev_priv->wagp_enable));
+
+	ADVANCE_DMA();
+}
+
+static void mga_g200_emit_state(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int dirty = sarea_priv->dirty;
+
+	if (sarea_priv->warp_pipe != dev_priv->warp_pipe) {
+		mga_g200_emit_pipe(dev_priv);
+		dev_priv->warp_pipe = sarea_priv->warp_pipe;
+	}
+
+	if (dirty & MGA_UPLOAD_CONTEXT) {
+		mga_g200_emit_context(dev_priv);
+		sarea_priv->dirty &= ~MGA_UPLOAD_CONTEXT;
+	}
+
+	if (dirty & MGA_UPLOAD_TEX0) {
+		mga_g200_emit_tex0(dev_priv);
+		sarea_priv->dirty &= ~MGA_UPLOAD_TEX0;
+	}
+}
+
+static void mga_g400_emit_state(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int dirty = sarea_priv->dirty;
+	int multitex = sarea_priv->warp_pipe & MGA_T2;
+
+	if (sarea_priv->warp_pipe != dev_priv->warp_pipe) {
+		mga_g400_emit_pipe(dev_priv);
+		dev_priv->warp_pipe = sarea_priv->warp_pipe;
+	}
+
+	if (dirty & MGA_UPLOAD_CONTEXT) {
+		mga_g400_emit_context(dev_priv);
+		sarea_priv->dirty &= ~MGA_UPLOAD_CONTEXT;
+	}
+
+	if (dirty & MGA_UPLOAD_TEX0) {
+		mga_g400_emit_tex0(dev_priv);
+		sarea_priv->dirty &= ~MGA_UPLOAD_TEX0;
+	}
+
+	if ((dirty & MGA_UPLOAD_TEX1) && multitex) {
+		mga_g400_emit_tex1(dev_priv);
+		sarea_priv->dirty &= ~MGA_UPLOAD_TEX1;
+	}
+}
+
+/* ================================================================
+ * SAREA state verification
+ */
+
+/* Disallow all write destinations except the front and backbuffer.
+ */
+static int mga_verify_context(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_context_regs_t *ctx = &sarea_priv->context_state;
+
+	if (ctx->dstorg != dev_priv->front_offset &&
+	    ctx->dstorg != dev_priv->back_offset) {
+		DRM_ERROR("*** bad DSTORG: %x (front %x, back %x)\n\n",
+			  ctx->dstorg, dev_priv->front_offset,
+			  dev_priv->back_offset);
+		ctx->dstorg = 0;
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Disallow texture reads from PCI space.
+ */
+static int mga_verify_tex(drm_mga_private_t * dev_priv, int unit)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_texture_regs_t *tex = &sarea_priv->tex_state[unit];
+	unsigned int org;
+
+	org = tex->texorg & (MGA_TEXORGMAP_MASK | MGA_TEXORGACC_MASK);
+
+	if (org == (MGA_TEXORGMAP_SYSMEM | MGA_TEXORGACC_PCI)) {
+		DRM_ERROR("*** bad TEXORG: 0x%x, unit %d\n", tex->texorg, unit);
+		tex->texorg = 0;
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mga_verify_state(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int dirty = sarea_priv->dirty;
+	int ret = 0;
+
+	if (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;
+
+	if (dirty & MGA_UPLOAD_CONTEXT)
+		ret |= mga_verify_context(dev_priv);
+
+	if (dirty & MGA_UPLOAD_TEX0)
+		ret |= mga_verify_tex(dev_priv, 0);
+
+	if (dev_priv->chipset >= MGA_CARD_TYPE_G400) {
+		if (dirty & MGA_UPLOAD_TEX1)
+			ret |= mga_verify_tex(dev_priv, 1);
+
+		if (dirty & MGA_UPLOAD_PIPE)
+			ret |= (sarea_priv->warp_pipe > MGA_MAX_G400_PIPES);
+	} else {
+		if (dirty & MGA_UPLOAD_PIPE)
+			ret |= (sarea_priv->warp_pipe > MGA_MAX_G200_PIPES);
+	}
+
+	return (ret == 0);
+}
+
+static int mga_verify_iload(drm_mga_private_t * dev_priv,
+			    unsigned int dstorg, unsigned int length)
+{
+	if (dstorg < dev_priv->texture_offset ||
+	    dstorg + length > (dev_priv->texture_offset +
+			       dev_priv->texture_size)) {
+		DRM_ERROR("*** bad iload DSTORG: 0x%x\n", dstorg);
+		return -EINVAL;
+	}
+
+	if (length & MGA_ILOAD_MASK) {
+		DRM_ERROR("*** bad iload length: 0x%x\n",
+			  length & MGA_ILOAD_MASK);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mga_verify_blit(drm_mga_private_t * dev_priv,
+			   unsigned int srcorg, unsigned int dstorg)
+{
+	if ((srcorg & 0x3) == (MGA_SRCACC_PCI | MGA_SRCMAP_SYSMEM) ||
+	    (dstorg & 0x3) == (MGA_SRCACC_PCI | MGA_SRCMAP_SYSMEM)) {
+		DRM_ERROR("*** bad blit: src=0x%x dst=0x%x\n", srcorg, dstorg);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* ================================================================
+ *
+ */
+
+static void mga_dma_dispatch_clear(struct drm_device * dev, drm_mga_clear_t * clear)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_context_regs_t *ctx = &sarea_priv->context_state;
+	struct drm_clip_rect *pbox = sarea_priv->boxes;
+	int nbox = sarea_priv->nbox;
+	int i;
+	DMA_LOCALS;
+	DRM_DEBUG("\n");
+
+	BEGIN_DMA(1);
+
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DWGSYNC, 0x00007100,
+		  MGA_DWGSYNC, 0x00007000);
+
+	ADVANCE_DMA();
+
+	for (i = 0; i < nbox; i++) {
+		struct drm_clip_rect *box = &pbox[i];
+		u32 height = box->y2 - box->y1;
+
+		DRM_DEBUG("   from=%d,%d to=%d,%d\n",
+			  box->x1, box->y1, box->x2, box->y2);
+
+		if (clear->flags & MGA_FRONT) {
+			BEGIN_DMA(2);
+
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_PLNWT, clear->color_mask,
+				  MGA_YDSTLEN, (box->y1 << 16) | height,
+				  MGA_FXBNDRY, (box->x2 << 16) | box->x1);
+
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_FCOL, clear->clear_color,
+				  MGA_DSTORG, dev_priv->front_offset,
+				  MGA_DWGCTL + MGA_EXEC, dev_priv->clear_cmd);
+
+			ADVANCE_DMA();
+		}
+
+		if (clear->flags & MGA_BACK) {
+			BEGIN_DMA(2);
+
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_PLNWT, clear->color_mask,
+				  MGA_YDSTLEN, (box->y1 << 16) | height,
+				  MGA_FXBNDRY, (box->x2 << 16) | box->x1);
+
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_FCOL, clear->clear_color,
+				  MGA_DSTORG, dev_priv->back_offset,
+				  MGA_DWGCTL + MGA_EXEC, dev_priv->clear_cmd);
+
+			ADVANCE_DMA();
+		}
+
+		if (clear->flags & MGA_DEPTH) {
+			BEGIN_DMA(2);
+
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_PLNWT, clear->depth_mask,
+				  MGA_YDSTLEN, (box->y1 << 16) | height,
+				  MGA_FXBNDRY, (box->x2 << 16) | box->x1);
+
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_FCOL, clear->clear_depth,
+				  MGA_DSTORG, dev_priv->depth_offset,
+				  MGA_DWGCTL + MGA_EXEC, dev_priv->clear_cmd);
+
+			ADVANCE_DMA();
+		}
+
+	}
+
+	BEGIN_DMA(1);
+
+	/* Force reset of DWGCTL */
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_PLNWT, ctx->plnwt,
+		  MGA_DWGCTL, ctx->dwgctl);
+
+	ADVANCE_DMA();
+
+	FLUSH_DMA();
+}
+
+static void mga_dma_dispatch_swap(struct drm_device * dev)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_context_regs_t *ctx = &sarea_priv->context_state;
+	struct drm_clip_rect *pbox = sarea_priv->boxes;
+	int nbox = sarea_priv->nbox;
+	int i;
+	DMA_LOCALS;
+	DRM_DEBUG("\n");
+
+	sarea_priv->last_frame.head = dev_priv->prim.tail;
+	sarea_priv->last_frame.wrap = dev_priv->prim.last_wrap;
+
+	BEGIN_DMA(4 + nbox);
+
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DWGSYNC, 0x00007100,
+		  MGA_DWGSYNC, 0x00007000);
+
+	DMA_BLOCK(MGA_DSTORG, dev_priv->front_offset,
+		  MGA_MACCESS, dev_priv->maccess,
+		  MGA_SRCORG, dev_priv->back_offset,
+		  MGA_AR5, dev_priv->front_pitch);
+
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_PLNWT, 0xffffffff,
+		  MGA_DWGCTL, MGA_DWGCTL_COPY);
+
+	for (i = 0; i < nbox; i++) {
+		struct drm_clip_rect *box = &pbox[i];
+		u32 height = box->y2 - box->y1;
+		u32 start = box->y1 * dev_priv->front_pitch;
+
+		DRM_DEBUG("   from=%d,%d to=%d,%d\n",
+			  box->x1, box->y1, box->x2, box->y2);
+
+		DMA_BLOCK(MGA_AR0, start + box->x2 - 1,
+			  MGA_AR3, start + box->x1,
+			  MGA_FXBNDRY, ((box->x2 - 1) << 16) | box->x1,
+			  MGA_YDSTLEN + MGA_EXEC, (box->y1 << 16) | height);
+	}
+
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_PLNWT, ctx->plnwt,
+		  MGA_SRCORG, dev_priv->front_offset,
+		  MGA_DWGCTL, ctx->dwgctl);
+
+	ADVANCE_DMA();
+
+	FLUSH_DMA();
+
+	DRM_DEBUG("%s... done.\n", __FUNCTION__);
+}
+
+static void mga_dma_dispatch_vertex(struct drm_device * dev, struct drm_buf * buf)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	u32 address = (u32) buf->bus_address;
+	u32 length = (u32) buf->used;
+	int i = 0;
+	DMA_LOCALS;
+	DRM_DEBUG("vertex: buf=%d used=%d\n", buf->idx, buf->used);
+
+	if (buf->used) {
+		buf_priv->dispatched = 1;
+
+		MGA_EMIT_STATE(dev_priv, sarea_priv->dirty);
+
+		do {
+			if (i < sarea_priv->nbox) {
+				mga_emit_clip_rect(dev_priv,
+						   &sarea_priv->boxes[i]);
+			}
+
+			BEGIN_DMA(1);
+
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_DMAPAD, 0x00000000,
+				  MGA_SECADDRESS, (address |
+						   MGA_DMA_VERTEX),
+				  MGA_SECEND, ((address + length) |
+					       dev_priv->dma_access));
+
+			ADVANCE_DMA();
+		} while (++i < sarea_priv->nbox);
+	}
+
+	if (buf_priv->discard) {
+		AGE_BUFFER(buf_priv);
+		buf->pending = 0;
+		buf->used = 0;
+		buf_priv->dispatched = 0;
+
+		mga_freelist_put(dev, buf);
+	}
+
+	FLUSH_DMA();
+}
+
+static void mga_dma_dispatch_indices(struct drm_device * dev, struct drm_buf * buf,
+				     unsigned int start, unsigned int end)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	u32 address = (u32) buf->bus_address;
+	int i = 0;
+	DMA_LOCALS;
+	DRM_DEBUG("indices: buf=%d start=%d end=%d\n", buf->idx, start, end);
+
+	if (start != end) {
+		buf_priv->dispatched = 1;
+
+		MGA_EMIT_STATE(dev_priv, sarea_priv->dirty);
+
+		do {
+			if (i < sarea_priv->nbox) {
+				mga_emit_clip_rect(dev_priv,
+						   &sarea_priv->boxes[i]);
+			}
+
+			BEGIN_DMA(1);
+
+			DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+				  MGA_DMAPAD, 0x00000000,
+				  MGA_SETUPADDRESS, address + start,
+				  MGA_SETUPEND, ((address + end) |
+						 dev_priv->dma_access));
+
+			ADVANCE_DMA();
+		} while (++i < sarea_priv->nbox);
+	}
+
+	if (buf_priv->discard) {
+		AGE_BUFFER(buf_priv);
+		buf->pending = 0;
+		buf->used = 0;
+		buf_priv->dispatched = 0;
+
+		mga_freelist_put(dev, buf);
+	}
+
+	FLUSH_DMA();
+}
+
+/* This copies a 64 byte aligned agp region to the frambuffer with a
+ * standard blit, the ioctl needs to do checking.
+ */
+static void mga_dma_dispatch_iload(struct drm_device * dev, struct drm_buf * buf,
+				   unsigned int dstorg, unsigned int length)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
+	drm_mga_context_regs_t *ctx = &dev_priv->sarea_priv->context_state;
+	u32 srcorg = buf->bus_address | dev_priv->dma_access | MGA_SRCMAP_SYSMEM;
+	u32 y2;
+	DMA_LOCALS;
+	DRM_DEBUG("buf=%d used=%d\n", buf->idx, buf->used);
+
+	y2 = length / 64;
+
+	BEGIN_DMA(5);
+
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DWGSYNC, 0x00007100,
+		  MGA_DWGSYNC, 0x00007000);
+
+	DMA_BLOCK(MGA_DSTORG, dstorg,
+		  MGA_MACCESS, 0x00000000,
+		  MGA_SRCORG, srcorg,
+		  MGA_AR5, 64);
+
+	DMA_BLOCK(MGA_PITCH, 64,
+		  MGA_PLNWT, 0xffffffff,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DWGCTL, MGA_DWGCTL_COPY);
+
+	DMA_BLOCK(MGA_AR0, 63,
+		  MGA_AR3, 0,
+		  MGA_FXBNDRY, (63 << 16) | 0,
+		  MGA_YDSTLEN + MGA_EXEC, y2);
+
+	DMA_BLOCK(MGA_PLNWT, ctx->plnwt,
+		  MGA_SRCORG, dev_priv->front_offset,
+		  MGA_PITCH, dev_priv->front_pitch,
+		  MGA_DWGSYNC, 0x00007000);
+
+	ADVANCE_DMA();
+
+	AGE_BUFFER(buf_priv);
+
+	buf->pending = 0;
+	buf->used = 0;
+	buf_priv->dispatched = 0;
+
+	mga_freelist_put(dev, buf);
+
+	FLUSH_DMA();
+}
+
+static void mga_dma_dispatch_blit(struct drm_device * dev, drm_mga_blit_t * blit)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_context_regs_t *ctx = &sarea_priv->context_state;
+	struct drm_clip_rect *pbox = sarea_priv->boxes;
+	int nbox = sarea_priv->nbox;
+	u32 scandir = 0, i;
+	DMA_LOCALS;
+	DRM_DEBUG("\n");
+
+	BEGIN_DMA(4 + nbox);
+
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DWGSYNC, 0x00007100,
+		  MGA_DWGSYNC, 0x00007000);
+
+	DMA_BLOCK(MGA_DWGCTL, MGA_DWGCTL_COPY,
+		  MGA_PLNWT, blit->planemask,
+		  MGA_SRCORG, blit->srcorg,
+		  MGA_DSTORG, blit->dstorg);
+
+	DMA_BLOCK(MGA_SGN, scandir,
+		  MGA_MACCESS, dev_priv->maccess,
+		  MGA_AR5, blit->ydir * blit->src_pitch,
+		  MGA_PITCH, blit->dst_pitch);
+
+	for (i = 0; i < nbox; i++) {
+		int srcx = pbox[i].x1 + blit->delta_sx;
+		int srcy = pbox[i].y1 + blit->delta_sy;
+		int dstx = pbox[i].x1 + blit->delta_dx;
+		int dsty = pbox[i].y1 + blit->delta_dy;
+		int h = pbox[i].y2 - pbox[i].y1;
+		int w = pbox[i].x2 - pbox[i].x1 - 1;
+		int start;
+
+		if (blit->ydir == -1) {
+			srcy = blit->height - srcy - 1;
+		}
+
+		start = srcy * blit->src_pitch + srcx;
+
+		DMA_BLOCK(MGA_AR0, start + w,
+			  MGA_AR3, start,
+			  MGA_FXBNDRY, ((dstx + w) << 16) | (dstx & 0xffff),
+			  MGA_YDSTLEN + MGA_EXEC, (dsty << 16) | h);
+	}
+
+	/* Do something to flush AGP?
+	 */
+
+	/* Force reset of DWGCTL */
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_PLNWT, ctx->plnwt,
+		  MGA_PITCH, dev_priv->front_pitch,
+		  MGA_DWGCTL, ctx->dwgctl);
+
+	ADVANCE_DMA();
+}
+
+/* ================================================================
+ *
+ */
+
+static int mga_dma_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_clear_t *clear = data;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;
+
+	WRAP_TEST_WITH_RETURN(dev_priv);
+
+	mga_dma_dispatch_clear(dev, clear);
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	dev_priv->sarea_priv->dirty |= MGA_UPLOAD_CONTEXT;
+
+	return 0;
+}
+
+static int mga_dma_swap(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;
+
+	WRAP_TEST_WITH_RETURN(dev_priv);
+
+	mga_dma_dispatch_swap(dev);
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	dev_priv->sarea_priv->dirty |= MGA_UPLOAD_CONTEXT;
+
+	return 0;
+}
+
+static int mga_dma_vertex(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_mga_buf_priv_t *buf_priv;
+	drm_mga_vertex_t *vertex = data;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (vertex->idx < 0 || vertex->idx > dma->buf_count)
+		return -EINVAL;
+	buf = dma->buflist[vertex->idx];
+	buf_priv = buf->dev_private;
+
+	buf->used = vertex->used;
+	buf_priv->discard = vertex->discard;
+
+	if (!mga_verify_state(dev_priv)) {
+		if (vertex->discard) {
+			if (buf_priv->dispatched == 1)
+				AGE_BUFFER(buf_priv);
+			buf_priv->dispatched = 0;
+			mga_freelist_put(dev, buf);
+		}
+		return -EINVAL;
+	}
+
+	WRAP_TEST_WITH_RETURN(dev_priv);
+
+	mga_dma_dispatch_vertex(dev, buf);
+
+	return 0;
+}
+
+static int mga_dma_indices(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_mga_buf_priv_t *buf_priv;
+	drm_mga_indices_t *indices = data;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (indices->idx < 0 || indices->idx > dma->buf_count)
+		return -EINVAL;
+
+	buf = dma->buflist[indices->idx];
+	buf_priv = buf->dev_private;
+
+	buf_priv->discard = indices->discard;
+
+	if (!mga_verify_state(dev_priv)) {
+		if (indices->discard) {
+			if (buf_priv->dispatched == 1)
+				AGE_BUFFER(buf_priv);
+			buf_priv->dispatched = 0;
+			mga_freelist_put(dev, buf);
+		}
+		return -EINVAL;
+	}
+
+	WRAP_TEST_WITH_RETURN(dev_priv);
+
+	mga_dma_dispatch_indices(dev, buf, indices->start, indices->end);
+
+	return 0;
+}
+
+static int mga_dma_iload(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	struct drm_device_dma *dma = dev->dma;
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	struct drm_buf *buf;
+	drm_mga_buf_priv_t *buf_priv;
+	drm_mga_iload_t *iload = data;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+#if 0
+	if (mga_do_wait_for_idle(dev_priv) < 0) {
+		if (MGA_DMA_DEBUG)
+			DRM_INFO("%s: -EBUSY\n", __FUNCTION__);
+		return -EBUSY;
+	}
+#endif
+	if (iload->idx < 0 || iload->idx > dma->buf_count)
+		return -EINVAL;
+
+	buf = dma->buflist[iload->idx];
+	buf_priv = buf->dev_private;
+
+	if (mga_verify_iload(dev_priv, iload->dstorg, iload->length)) {
+		mga_freelist_put(dev, buf);
+		return -EINVAL;
+	}
+
+	WRAP_TEST_WITH_RETURN(dev_priv);
+
+	mga_dma_dispatch_iload(dev, buf, iload->dstorg, iload->length);
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	dev_priv->sarea_priv->dirty |= MGA_UPLOAD_CONTEXT;
+
+	return 0;
+}
+
+static int mga_dma_blit(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_blit_t *blit = data;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;
+
+	if (mga_verify_blit(dev_priv, blit->srcorg, blit->dstorg))
+		return -EINVAL;
+
+	WRAP_TEST_WITH_RETURN(dev_priv);
+
+	mga_dma_dispatch_blit(dev, blit);
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	dev_priv->sarea_priv->dirty |= MGA_UPLOAD_CONTEXT;
+
+	return 0;
+}
+
+static int mga_getparam(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_getparam_t *param = data;
+	int value;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
+
+	switch (param->param) {
+	case MGA_PARAM_IRQ_NR:
+		value = dev->irq;
+		break;
+	case MGA_PARAM_CARD_TYPE:
+		value = dev_priv->chipset;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (DRM_COPY_TO_USER(param->value, &value, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int mga_set_fence(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	u32 *fence = data;
+	DMA_LOCALS;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
+
+	/* I would normal do this assignment in the declaration of fence,
+	 * but dev_priv may be NULL.
+	 */
+
+	*fence = dev_priv->next_fence_to_post;
+	dev_priv->next_fence_to_post++;
+
+	BEGIN_DMA(1);
+	DMA_BLOCK(MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_DMAPAD, 0x00000000,
+		  MGA_SOFTRAP, 0x00000000);
+	ADVANCE_DMA();
+
+	return 0;
+}
+
+static int mga_wait_fence(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	u32 *fence = data;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
+
+	mga_driver_fence_wait(dev, fence);
+
+	return 0;
+}
+
+struct drm_ioctl_desc mga_ioctls[] = {
+	DRM_IOCTL_DEF(DRM_MGA_INIT, mga_dma_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_MGA_FLUSH, mga_dma_flush, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MGA_RESET, mga_dma_reset, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MGA_SWAP, mga_dma_swap, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MGA_CLEAR, mga_dma_clear, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MGA_VERTEX, mga_dma_vertex, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MGA_INDICES, mga_dma_indices, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MGA_ILOAD, mga_dma_iload, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MGA_BLIT, mga_dma_blit, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MGA_GETPARAM, mga_getparam, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MGA_SET_FENCE, mga_set_fence, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MGA_WAIT_FENCE, mga_wait_fence, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_MGA_DMA_BOOTSTRAP, mga_dma_bootstrap, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+
+};
+
+int mga_max_ioctl = DRM_ARRAY_SIZE(mga_ioctls);
Index: git/shared-core/mga_ucode.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/mga_ucode.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,11645 @@
+/* mga_ucode.h -- Matrox G200/G400 WARP engine microcode -*- linux-c -*-
+ * Created: Thu Jan 11 21:20:43 2001 by gareth@valinux.com
+ *
+ * Copyright 1999 Matrox Graphics Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * MATROX GRAPHICS INC., OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Kernel-based WARP engine management:
+ *    Gareth Hughes <gareth@valinux.com>
+ */
+
+/*
+ * WARP pipes are named according to the functions they perform, where:
+ *
+ *   - T stands for computation of texture stage 0
+ *   - T2 stands for computation of both texture stage 0 and texture stage 1
+ *   - G stands for computation of triangle intensity (Gouraud interpolation)
+ *   - Z stands for computation of Z buffer interpolation
+ *   - S stands for computation of specular highlight
+ *   - A stands for computation of the alpha channel
+ *   - F stands for computation of vertex fog interpolation
+ */
+
+static unsigned char warp_g200_tgz[] = {
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
+
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
+
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
+
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
+
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
+
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
+
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
+
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
+
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
+
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
+
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
+
+	0x72, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
+
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
+
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
+
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
+
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
+
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
+
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
+
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
+
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
+
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
+
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x60, 0x80, 0x15, 0xEA,
+
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
+
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
+
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
+
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
+
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
+
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
+
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
+
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
+
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
+
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
+
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
+
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
+
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
+
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
+
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
+
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
+
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
+
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
+
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
+
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
+
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
+
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
+
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
+
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
+
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
+
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
+
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
+
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
+
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
+
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
+
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
+
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
+
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
+
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
+
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
+
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
+
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
+
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
+
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
+
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
+
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
+
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
+
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
+
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
+
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
+
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
+
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
+
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
+
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
+
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
+
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
+
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
+
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
+
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
+
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
+
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
+
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
+
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
+
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
+
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
+
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
+
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
+
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
+
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
+
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
+
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
+
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
+
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x03, 0x80, 0x0A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0xC0, 0x33, 0xAF,
+	0x3C, 0x27, 0x4F, 0xE9,
+
+	0x57, 0x39, 0x20, 0xE9,
+	0x28, 0x19, 0x60, 0xEC,
+
+	0x2B, 0x32, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
+
+	0xB3, 0x05,
+	0x00, 0xE0,
+	0x16, 0x28, 0x20, 0xE9,
+
+	0x23, 0x3B, 0x33, 0xAD,
+	0x1E, 0x2B, 0x20, 0xE9,
+
+	0x1C, 0x80, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
+
+	0x85, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
+
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x84, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
+
+	0x82, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x7F, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+};
+
+static unsigned char warp_g200_tgza[] = {
+
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
+
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
+
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
+
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
+
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
+
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
+
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
+
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
+
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
+
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
+
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
+
+	0x7D, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
+
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
+
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
+
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
+
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
+
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
+
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
+
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
+
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
+
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
+
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x6B, 0x80, 0x15, 0xEA,
+
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
+
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
+
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
+
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
+
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
+
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
+
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
+
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
+
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
+
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
+
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
+
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
+
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
+
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
+
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
+
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
+
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
+
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
+
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
+
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
+
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
+
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
+
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
+
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
+
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
+
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
+
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
+
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
+
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
+
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
+
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
+
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
+
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
+
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
+
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
+
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
+
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
+
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
+
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
+
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
+
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
+
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
+
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
+
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
+
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
+
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
+
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
+
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
+
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
+
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
+
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
+
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
+
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
+
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
+
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
+
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
+
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
+
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
+
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
+
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
+
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
+
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
+
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
+
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
+
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
+
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
+
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
+
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x2D, 0x44, 0x4C, 0xB6,
+	0x25, 0x44, 0x54, 0xB6,
+
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
+
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x07, 0xC0, 0x44, 0xC6,
+
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0xC0, 0x33, 0xAF,
+	0x3C, 0x27, 0x4F, 0xE9,
+
+	0x1F, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x3F, 0x3D, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x07, 0x20,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x28, 0x19, 0x60, 0xEC,
+
+	0xB3, 0x05,
+	0x00, 0xE0,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x23, 0x3B, 0x33, 0xAD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x1F, 0x26, 0x1F, 0xDF,
+	0x9D, 0x1F, 0x4F, 0xE9,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x9E, 0x3F, 0x4F, 0xE9,
+
+	0x07, 0x07, 0x1F, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x9C, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
+
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
+
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
+
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
+
+	0x7A, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
+
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x79, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
+
+	0x77, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x74, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+};
+
+static unsigned char warp_g200_tgzaf[] = {
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
+
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
+
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
+
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
+
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
+
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
+
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
+
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
+
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
+
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
+
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
+
+	0x83, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
+
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
+
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
+
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
+
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
+
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
+
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
+
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
+
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
+
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
+
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
+
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x6F, 0x80, 0x15, 0xEA,
+
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
+
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
+
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
+
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
+
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
+
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
+
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
+
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
+
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
+
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
+
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
+
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
+
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
+
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
+
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
+
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
+
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
+
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
+
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
+
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
+
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
+
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
+
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
+
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
+
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
+
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
+
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
+
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
+
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
+
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
+
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
+
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
+
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
+
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
+
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
+
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
+
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
+
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
+
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
+
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
+
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
+
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
+
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
+
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
+
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
+
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
+
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
+
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
+
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
+
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
+
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
+
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
+
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
+
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
+
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
+
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
+
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
+
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
+
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
+
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
+
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
+
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
+
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
+
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
+
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
+
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
+
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
+
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x0D, 0x21, 0x1A, 0xB6,
+	0x05, 0x21, 0x31, 0xB6,
+
+	0x2D, 0x44, 0x4C, 0xB6,
+	0x25, 0x44, 0x54, 0xB6,
+
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
+
+	0x0D, 0x20,
+	0x05, 0x20,
+	0x2F, 0xC0, 0x21, 0xC6,
+
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0xC0, 0x33, 0xAF,
+	0x3C, 0x27, 0x4F, 0xE9,
+
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x07, 0xC0, 0x44, 0xC6,
+
+	0x17, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x2D, 0x20,
+
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
+
+	0x1F, 0x62, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x07, 0x20,
+
+	0x3F, 0x3D, 0x5D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x28, 0x19, 0x60, 0xEC,
+
+	0xB3, 0x05,
+	0x00, 0xE0,
+	0x17, 0x26, 0x17, 0xDF,
+
+	0x23, 0x3B, 0x33, 0xAD,
+	0x35, 0x17, 0x4F, 0xE9,
+
+	0x1F, 0x26, 0x1F, 0xDF,
+	0x9D, 0x1F, 0x4F, 0xE9,
+
+	0x9E, 0x3F, 0x4F, 0xE9,
+	0x39, 0x37, 0x4F, 0xE9,
+
+	0x2F, 0x2F, 0x17, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x07, 0x07, 0x1F, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x31, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x9C, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
+
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
+
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
+
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
+
+	0x74, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
+
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x73, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
+
+	0x71, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x6E, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+};
+
+static unsigned char warp_g200_tgzf[] = {
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
+
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
+
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
+
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
+
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
+
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
+
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
+
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
+
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
+
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
+
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
+
+	0x7F, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
+
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
+
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
+
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
+
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
+
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
+
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
+
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
+
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
+
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
+
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
+
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x6B, 0x80, 0x15, 0xEA,
+
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
+
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
+
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
+
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
+
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
+
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
+
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
+
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
+
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
+
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
+
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
+
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
+
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
+
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
+
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
+
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
+
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
+
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
+
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
+
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
+
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
+
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
+
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
+
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
+
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
+
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
+
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
+
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
+
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
+
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
+
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
+
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
+
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
+
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
+
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
+
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
+
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
+
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
+
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
+
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
+
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
+
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
+
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
+
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
+
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
+
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
+
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
+
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
+
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
+
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
+
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
+
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
+
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
+
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
+
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
+
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
+
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
+
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
+
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
+
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
+
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
+
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
+
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
+
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
+
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
+
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
+
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
+
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x0D, 0x21, 0x1A, 0xB6,
+	0x05, 0x21, 0x31, 0xB6,
+
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
+
+	0x0D, 0x20,
+	0x05, 0x20,
+	0x2F, 0xC0, 0x21, 0xC6,
+
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0xC0, 0x33, 0xAF,
+	0x3C, 0x27, 0x4F, 0xE9,
+
+	0x17, 0x50, 0x56, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x28, 0x19, 0x60, 0xEC,
+
+	0xB3, 0x05,
+	0x00, 0xE0,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x23, 0x3B, 0x33, 0xAD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x17, 0x26, 0x17, 0xDF,
+	0x35, 0x17, 0x4F, 0xE9,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x39, 0x37, 0x4F, 0xE9,
+
+	0x2F, 0x2F, 0x17, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x31, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
+
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
+
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
+
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
+
+	0x78, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
+
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x77, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
+
+	0x75, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x72, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+};
+
+static unsigned char warp_g200_tgzs[] = {
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
+
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
+
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
+
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
+
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
+
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
+
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
+
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
+
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
+
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
+
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
+
+	0x8B, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
+
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
+
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
+
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
+
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
+
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
+
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
+
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
+
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
+
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
+
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
+
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x77, 0x80, 0x15, 0xEA,
+
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
+
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
+
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
+
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
+
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
+
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
+
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
+
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
+
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
+
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
+
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
+
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
+
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
+
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
+
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
+
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
+
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
+
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
+
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
+
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
+
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
+
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
+
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
+
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
+
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
+
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
+
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
+
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
+
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
+
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
+
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
+
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
+
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
+
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
+
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
+
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
+
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
+
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
+
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
+
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
+
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
+
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
+
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
+
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
+
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
+
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
+
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
+
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
+
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
+
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
+
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
+
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
+
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
+
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
+
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
+
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
+
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
+
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
+
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
+
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
+
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
+
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
+
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
+
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
+
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
+
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
+
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
+
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x2D, 0x21, 0x1A, 0xB0,
+	0x25, 0x21, 0x31, 0xB0,
+
+	0x0D, 0x21, 0x1A, 0xB2,
+	0x05, 0x21, 0x31, 0xB2,
+
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
+
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x05, 0x20,
+	0x0D, 0x20,
+
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0xC0, 0x33, 0xAF,
+	0x2F, 0xC0, 0x21, 0xC0,
+
+	0x16, 0x42, 0x56, 0x9F,
+	0x3C, 0x27, 0x4F, 0xE9,
+
+	0x1E, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x21, 0x31, 0xB4,
+	0x2D, 0x21, 0x1A, 0xB4,
+
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0x05,
+	0x00, 0xE0,
+	0x28, 0x19, 0x60, 0xEC,
+
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
+
+	0x23, 0x3B, 0x33, 0xAD,
+	0x1E, 0x26, 0x1E, 0xDF,
+
+	0xA7, 0x1E, 0x4F, 0xE9,
+	0x17, 0x26, 0x16, 0xDF,
+
+	0x2D, 0x20,
+	0x00, 0xE0,
+	0xA8, 0x3F, 0x4F, 0xE9,
+
+	0x2F, 0x2F, 0x1E, 0xAF,
+	0x25, 0x20,
+	0x00, 0xE0,
+
+	0xA4, 0x16, 0x4F, 0xE9,
+	0x0F, 0xC0, 0x21, 0xC2,
+
+	0xA6, 0x80, 0x4F, 0xE9,
+	0x1F, 0x62, 0x57, 0x9F,
+
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x8F, 0x20,
+
+	0xA5, 0x37, 0x4F, 0xE9,
+	0x0F, 0x17, 0x0F, 0xAF,
+
+	0x06, 0xC0, 0x21, 0xC4,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0xA3, 0x80, 0x4F, 0xE9,
+
+	0x06, 0x20,
+	0x00, 0xE0,
+	0x1F, 0x26, 0x1F, 0xDF,
+
+	0xA1, 0x1F, 0x4F, 0xE9,
+	0xA2, 0x3F, 0x4F, 0xE9,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x06, 0x06, 0x1F, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA0, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
+
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
+
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
+
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
+
+	0x6C, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
+
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x6B, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
+
+	0x69, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x66, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+};
+
+static unsigned char warp_g200_tgzsa[] = {
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
+
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
+
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
+
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
+
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
+
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
+
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
+
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
+
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
+
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
+
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
+
+	0x8F, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
+
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
+
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
+
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
+
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
+
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
+
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
+
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
+
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
+
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
+
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
+
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x7B, 0x80, 0x15, 0xEA,
+
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
+
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
+
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
+
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
+
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
+
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
+
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
+
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
+
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
+
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
+
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
+
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
+
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
+
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
+
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
+
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
+
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
+
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
+
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
+
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
+
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
+
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
+
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
+
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
+
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
+
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
+
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
+
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
+
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
+
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
+
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
+
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
+
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
+
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
+
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
+
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
+
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
+
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
+
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
+
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
+
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
+
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
+
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
+
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
+
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
+
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
+
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
+
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
+
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
+
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
+
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
+
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
+
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
+
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
+
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
+
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
+
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
+
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
+
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
+
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
+
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
+
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
+
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
+
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
+
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
+
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
+
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
+
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x2D, 0x21, 0x1A, 0xB0,
+	0x25, 0x21, 0x31, 0xB0,
+
+	0x0D, 0x21, 0x1A, 0xB2,
+	0x05, 0x21, 0x31, 0xB2,
+
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
+
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x05, 0x20,
+	0x0D, 0x20,
+
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0xC0, 0x33, 0xAF,
+	0x2F, 0xC0, 0x21, 0xC0,
+
+	0x16, 0x42, 0x56, 0x9F,
+	0x3C, 0x27, 0x4F, 0xE9,
+
+	0x1E, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x21, 0x31, 0xB4,
+	0x2D, 0x21, 0x1A, 0xB4,
+
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0x05,
+	0x00, 0xE0,
+	0x28, 0x19, 0x60, 0xEC,
+
+	0x0D, 0x44, 0x4C, 0xB6,
+	0x05, 0x44, 0x54, 0xB6,
+
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
+
+	0x23, 0x3B, 0x33, 0xAD,
+	0x1E, 0x26, 0x1E, 0xDF,
+
+	0xA7, 0x1E, 0x4F, 0xE9,
+	0x17, 0x26, 0x16, 0xDF,
+
+	0x2D, 0x20,
+	0x00, 0xE0,
+	0xA8, 0x3F, 0x4F, 0xE9,
+
+	0x2F, 0x2F, 0x1E, 0xAF,
+	0x25, 0x20,
+	0x00, 0xE0,
+
+	0xA4, 0x16, 0x4F, 0xE9,
+	0x0F, 0xC0, 0x21, 0xC2,
+
+	0xA6, 0x80, 0x4F, 0xE9,
+	0x1F, 0x62, 0x57, 0x9F,
+
+	0x0D, 0x20,
+	0x05, 0x20,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x0F, 0x20,
+
+	0x17, 0x50, 0x56, 0x9F,
+	0xA5, 0x37, 0x4F, 0xE9,
+
+	0x06, 0xC0, 0x21, 0xC4,
+	0x0F, 0x17, 0x0F, 0xAF,
+
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x2F, 0xC0, 0x44, 0xC6,
+	0xA3, 0x80, 0x4F, 0xE9,
+
+	0x06, 0x20,
+	0x00, 0xE0,
+	0x1F, 0x26, 0x1F, 0xDF,
+
+	0x17, 0x26, 0x17, 0xDF,
+	0x9D, 0x17, 0x4F, 0xE9,
+
+	0xA1, 0x1F, 0x4F, 0xE9,
+	0xA2, 0x3F, 0x4F, 0xE9,
+
+	0x06, 0x06, 0x1F, 0xAF,
+	0x00, 0xE0,
+	0xAF, 0x20,
+
+	0x9E, 0x37, 0x4F, 0xE9,
+	0x2F, 0x17, 0x2F, 0xAF,
+
+	0xA0, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x9C, 0x80, 0x4F, 0xE9,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
+
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
+
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
+
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
+
+	0x68, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
+
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x67, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
+
+	0x65, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x62, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+};
+
+static unsigned char warp_g200_tgzsaf[] = {
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
+
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
+
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
+
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
+
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
+
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
+
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
+
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
+
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
+
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
+
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
+
+	0x94, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
+
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
+
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
+
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
+
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
+
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
+
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
+
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
+
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
+
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
+
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
+
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x80, 0x80, 0x15, 0xEA,
+
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
+
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
+
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
+
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
+
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
+
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
+
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
+
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
+
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
+
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
+
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
+
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
+
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
+
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
+
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
+
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
+
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
+
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
+
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
+
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
+
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
+
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
+
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
+
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
+
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
+
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
+
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
+
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
+
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
+
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
+
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
+
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
+
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
+
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
+
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
+
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
+
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
+
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
+
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
+
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
+
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
+
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
+
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
+
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
+
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
+
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
+
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
+
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
+
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
+
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
+
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
+
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
+
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
+
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
+
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
+
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
+
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
+
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
+
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
+
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
+
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
+
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
+
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
+
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
+
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
+
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
+
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
+
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x2D, 0x21, 0x1A, 0xB0,
+	0x25, 0x21, 0x31, 0xB0,
+
+	0x0D, 0x21, 0x1A, 0xB2,
+	0x05, 0x21, 0x31, 0xB2,
+
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
+
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x05, 0x20,
+	0x0D, 0x20,
+
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0xC0, 0x33, 0xAF,
+	0x2F, 0xC0, 0x21, 0xC0,
+
+	0x16, 0x42, 0x56, 0x9F,
+	0x3C, 0x27, 0x4F, 0xE9,
+
+	0x1E, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x21, 0x31, 0xB4,
+	0x2D, 0x21, 0x1A, 0xB4,
+
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0x05,
+	0x00, 0xE0,
+	0x28, 0x19, 0x60, 0xEC,
+
+	0x0D, 0x21, 0x1A, 0xB6,
+	0x05, 0x21, 0x31, 0xB6,
+
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
+
+	0x23, 0x3B, 0x33, 0xAD,
+	0x1E, 0x26, 0x1E, 0xDF,
+
+	0xA7, 0x1E, 0x4F, 0xE9,
+	0x17, 0x26, 0x16, 0xDF,
+
+	0x2D, 0x20,
+	0x00, 0xE0,
+	0xA8, 0x3F, 0x4F, 0xE9,
+
+	0x2F, 0x2F, 0x1E, 0xAF,
+	0x25, 0x20,
+	0x00, 0xE0,
+
+	0xA4, 0x16, 0x4F, 0xE9,
+	0x0F, 0xC0, 0x21, 0xC2,
+
+	0xA6, 0x80, 0x4F, 0xE9,
+	0x1F, 0x62, 0x57, 0x9F,
+
+	0x0D, 0x20,
+	0x05, 0x20,
+	0x2F, 0xC0, 0x21, 0xC6,
+
+	0x2D, 0x44, 0x4C, 0xB6,
+	0x25, 0x44, 0x54, 0xB6,
+
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x0F, 0x20,
+
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x07, 0xC0, 0x44, 0xC6,
+
+	0x17, 0x50, 0x56, 0x9F,
+	0xA5, 0x37, 0x4F, 0xE9,
+
+	0x06, 0xC0, 0x21, 0xC4,
+	0x0F, 0x17, 0x0F, 0xAF,
+
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x1E, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x3E, 0x3D, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x07, 0x20,
+
+	0x2F, 0x20,
+	0x00, 0xE0,
+	0xA3, 0x0F, 0x4F, 0xE9,
+
+	0x06, 0x20,
+	0x00, 0xE0,
+	0x1F, 0x26, 0x1F, 0xDF,
+
+	0x17, 0x26, 0x17, 0xDF,
+	0xA1, 0x1F, 0x4F, 0xE9,
+
+	0x1E, 0x26, 0x1E, 0xDF,
+	0x9D, 0x1E, 0x4F, 0xE9,
+
+	0x35, 0x17, 0x4F, 0xE9,
+	0xA2, 0x3F, 0x4F, 0xE9,
+
+	0x06, 0x06, 0x1F, 0xAF,
+	0x39, 0x37, 0x4F, 0xE9,
+
+	0x2F, 0x2F, 0x17, 0xAF,
+	0x07, 0x07, 0x1E, 0xAF,
+
+	0xA0, 0x80, 0x4F, 0xE9,
+	0x9E, 0x3E, 0x4F, 0xE9,
+
+	0x31, 0x80, 0x4F, 0xE9,
+	0x9C, 0x80, 0x4F, 0xE9,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
+
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
+
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
+
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
+
+	0x63, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
+
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x62, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
+
+	0x60, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x5D, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+};
+
+static unsigned char warp_g200_tgzsf[] = {
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x98, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x81, 0x04,
+	0x89, 0x04,
+	0x01, 0x04,
+	0x09, 0x04,
+
+	0xC9, 0x41, 0xC0, 0xEC,
+	0x11, 0x04,
+	0x00, 0xE0,
+
+	0x41, 0xCC, 0x41, 0xCD,
+	0x49, 0xCC, 0x49, 0xCD,
+
+	0xD1, 0x41, 0xC0, 0xEC,
+	0x51, 0xCC, 0x51, 0xCD,
+
+	0x80, 0x04,
+	0x10, 0x04,
+	0x08, 0x04,
+	0x00, 0xE0,
+
+	0x00, 0xCC, 0xC0, 0xCD,
+	0xD1, 0x49, 0xC0, 0xEC,
+
+	0x8A, 0x1F, 0x20, 0xE9,
+	0x8B, 0x3F, 0x20, 0xE9,
+
+	0x41, 0x3C, 0x41, 0xAD,
+	0x49, 0x3C, 0x49, 0xAD,
+
+	0x10, 0xCC, 0x10, 0xCD,
+	0x08, 0xCC, 0x08, 0xCD,
+
+	0xB9, 0x41, 0x49, 0xBB,
+	0x1F, 0xF0, 0x41, 0xCD,
+
+	0x51, 0x3C, 0x51, 0xAD,
+	0x00, 0x98, 0x80, 0xE9,
+
+	0x8F, 0x80, 0x07, 0xEA,
+	0x24, 0x1F, 0x20, 0xE9,
+
+	0x21, 0x45, 0x80, 0xE8,
+	0x1A, 0x4D, 0x80, 0xE8,
+
+	0x31, 0x55, 0x80, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0x41, 0x49, 0xBD,
+	0x1D, 0x41, 0x51, 0xBD,
+
+	0x2E, 0x41, 0x2A, 0xB8,
+	0x34, 0x53, 0xA0, 0xE8,
+
+	0x15, 0x30,
+	0x1D, 0x30,
+	0x58, 0xE3,
+	0x00, 0xE0,
+
+	0xB5, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x24, 0x43, 0xA0, 0xE8,
+	0x2C, 0x4B, 0xA0, 0xE8,
+
+	0x15, 0x72,
+	0x09, 0xE3,
+	0x00, 0xE0,
+	0x1D, 0x72,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0x97, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x6C, 0x64, 0xC8, 0xEC,
+	0x98, 0xE1,
+	0xB5, 0x05,
+
+	0xBD, 0x05,
+	0x2E, 0x30,
+	0x32, 0xC0, 0xA0, 0xE8,
+
+	0x33, 0xC0, 0xA0, 0xE8,
+	0x74, 0x64, 0xC8, 0xEC,
+
+	0x40, 0x3C, 0x40, 0xAD,
+	0x32, 0x6A,
+	0x2A, 0x30,
+
+	0x20, 0x73,
+	0x33, 0x6A,
+	0x00, 0xE0,
+	0x28, 0x73,
+
+	0x1C, 0x72,
+	0x83, 0xE2,
+	0x7B, 0x80, 0x15, 0xEA,
+
+	0xB8, 0x3D, 0x28, 0xDF,
+	0x30, 0x35, 0x20, 0xDF,
+
+	0x40, 0x30,
+	0x00, 0xE0,
+	0xCC, 0xE2,
+	0x64, 0x72,
+
+	0x25, 0x42, 0x52, 0xBF,
+	0x2D, 0x42, 0x4A, 0xBF,
+
+	0x30, 0x2E, 0x30, 0xDF,
+	0x38, 0x2E, 0x38, 0xDF,
+
+	0x18, 0x1D, 0x45, 0xE9,
+	0x1E, 0x15, 0x45, 0xE9,
+
+	0x2B, 0x49, 0x51, 0xBD,
+	0x00, 0xE0,
+	0x1F, 0x73,
+
+	0x38, 0x38, 0x40, 0xAF,
+	0x30, 0x30, 0x40, 0xAF,
+
+	0x24, 0x1F, 0x24, 0xDF,
+	0x1D, 0x32, 0x20, 0xE9,
+
+	0x2C, 0x1F, 0x2C, 0xDF,
+	0x1A, 0x33, 0x20, 0xE9,
+
+	0xB0, 0x10,
+	0x08, 0xE3,
+	0x40, 0x10,
+	0xB8, 0x10,
+
+	0x26, 0xF0, 0x30, 0xCD,
+	0x2F, 0xF0, 0x38, 0xCD,
+
+	0x2B, 0x80, 0x20, 0xE9,
+	0x2A, 0x80, 0x20, 0xE9,
+
+	0xA6, 0x20,
+	0x88, 0xE2,
+	0x00, 0xE0,
+	0xAF, 0x20,
+
+	0x28, 0x2A, 0x26, 0xAF,
+	0x20, 0x2A, 0xC0, 0xAF,
+
+	0x34, 0x1F, 0x34, 0xDF,
+	0x46, 0x24, 0x46, 0xDF,
+
+	0x28, 0x30, 0x80, 0xBF,
+	0x20, 0x38, 0x80, 0xBF,
+
+	0x47, 0x24, 0x47, 0xDF,
+	0x4E, 0x2C, 0x4E, 0xDF,
+
+	0x4F, 0x2C, 0x4F, 0xDF,
+	0x56, 0x34, 0x56, 0xDF,
+
+	0x28, 0x15, 0x28, 0xDF,
+	0x20, 0x1D, 0x20, 0xDF,
+
+	0x57, 0x34, 0x57, 0xDF,
+	0x00, 0xE0,
+	0x1D, 0x05,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x89, 0xE2,
+	0x2B, 0x30,
+
+	0x3F, 0xC1, 0x1D, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA0, 0x68,
+	0xBF, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x20, 0xC0, 0x20, 0xAF,
+	0x28, 0x05,
+	0x97, 0x74,
+
+	0x00, 0xE0,
+	0x2A, 0x10,
+	0x16, 0xC0, 0x20, 0xE9,
+
+	0x04, 0x80, 0x10, 0xEA,
+	0x8C, 0xE2,
+	0x95, 0x05,
+
+	0x28, 0xC1, 0x28, 0xAD,
+	0x1F, 0xC1, 0x15, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA8, 0x67,
+	0x9F, 0x6B,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x28, 0xC0, 0x28, 0xAD,
+	0x1D, 0x25,
+	0x20, 0x05,
+
+	0x28, 0x32, 0x80, 0xAD,
+	0x40, 0x2A, 0x40, 0xBD,
+
+	0x1C, 0x80, 0x20, 0xE9,
+	0x20, 0x33, 0x20, 0xAD,
+
+	0x20, 0x73,
+	0x00, 0xE0,
+	0xB6, 0x49, 0x51, 0xBB,
+
+	0x26, 0x2F, 0xB0, 0xE8,
+	0x19, 0x20, 0x20, 0xE9,
+
+	0x35, 0x20, 0x35, 0xDF,
+	0x3D, 0x20, 0x3D, 0xDF,
+
+	0x15, 0x20, 0x15, 0xDF,
+	0x1D, 0x20, 0x1D, 0xDF,
+
+	0x26, 0xD0, 0x26, 0xCD,
+	0x29, 0x49, 0x2A, 0xB8,
+
+	0x26, 0x40, 0x80, 0xBD,
+	0x3B, 0x48, 0x50, 0xBD,
+
+	0x3E, 0x54, 0x57, 0x9F,
+	0x00, 0xE0,
+	0x82, 0xE1,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x26, 0x30,
+	0x29, 0x30,
+	0x48, 0x3C, 0x48, 0xAD,
+
+	0x2B, 0x72,
+	0xC2, 0xE1,
+	0x2C, 0xC0, 0x44, 0xC2,
+
+	0x05, 0x24, 0x34, 0xBF,
+	0x0D, 0x24, 0x2C, 0xBF,
+
+	0x2D, 0x46, 0x4E, 0xBF,
+	0x25, 0x46, 0x56, 0xBF,
+
+	0x20, 0x1D, 0x6F, 0x8F,
+	0x32, 0x3E, 0x5F, 0xE9,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x30,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x33, 0x1E, 0x5F, 0xE9,
+
+	0x05, 0x44, 0x54, 0xB2,
+	0x0D, 0x44, 0x4C, 0xB2,
+
+	0x19, 0xC0, 0xB0, 0xE8,
+	0x34, 0xC0, 0x44, 0xC4,
+
+	0x33, 0x73,
+	0x00, 0xE0,
+	0x3E, 0x62, 0x57, 0x9F,
+
+	0x1E, 0xAF, 0x59, 0x9F,
+	0x00, 0xE0,
+	0x0D, 0x20,
+
+	0x84, 0x3E, 0x58, 0xE9,
+	0x28, 0x1D, 0x6F, 0x8F,
+
+	0x05, 0x20,
+	0x00, 0xE0,
+	0x85, 0x1E, 0x58, 0xE9,
+
+	0x9B, 0x3B, 0x33, 0xDF,
+	0x20, 0x20, 0x42, 0xAF,
+
+	0x30, 0x42, 0x56, 0x9F,
+	0x80, 0x3E, 0x57, 0xE9,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x30, 0x80, 0x5F, 0xE9,
+
+	0x28, 0x28, 0x24, 0xAF,
+	0x81, 0x1E, 0x57, 0xE9,
+
+	0x05, 0x47, 0x57, 0xBF,
+	0x0D, 0x47, 0x4F, 0xBF,
+
+	0x88, 0x80, 0x58, 0xE9,
+	0x1B, 0x29, 0x1B, 0xDF,
+
+	0x30, 0x1D, 0x6F, 0x8F,
+	0x3A, 0x30, 0x4F, 0xE9,
+
+	0x1C, 0x30, 0x26, 0xDF,
+	0x09, 0xE3,
+	0x3B, 0x05,
+
+	0x3E, 0x50, 0x56, 0x9F,
+	0x3B, 0x3F, 0x4F, 0xE9,
+
+	0x1E, 0x8F, 0x51, 0x9F,
+	0x00, 0xE0,
+	0xAC, 0x20,
+
+	0x2D, 0x44, 0x4C, 0xB4,
+	0x2C, 0x1C, 0xC0, 0xAF,
+
+	0x25, 0x44, 0x54, 0xB4,
+	0x00, 0xE0,
+	0xC8, 0x30,
+
+	0x30, 0x46, 0x30, 0xAF,
+	0x1B, 0x1B, 0x48, 0xAF,
+
+	0x00, 0xE0,
+	0x25, 0x20,
+	0x38, 0x2C, 0x4F, 0xE9,
+
+	0x86, 0x80, 0x57, 0xE9,
+	0x38, 0x1D, 0x6F, 0x8F,
+
+	0x28, 0x74,
+	0x00, 0xE0,
+	0x0D, 0x44, 0x4C, 0xB0,
+
+	0x05, 0x44, 0x54, 0xB0,
+	0x2D, 0x20,
+	0x9B, 0x10,
+
+	0x82, 0x3E, 0x57, 0xE9,
+	0x32, 0xF0, 0x1B, 0xCD,
+
+	0x1E, 0xBD, 0x59, 0x9F,
+	0x83, 0x1E, 0x57, 0xE9,
+
+	0x38, 0x47, 0x38, 0xAF,
+	0x34, 0x20,
+	0x2A, 0x30,
+
+	0x00, 0xE0,
+	0x0D, 0x20,
+	0x32, 0x20,
+	0x05, 0x20,
+
+	0x87, 0x80, 0x57, 0xE9,
+	0x1F, 0x54, 0x57, 0x9F,
+
+	0x17, 0x42, 0x56, 0x9F,
+	0x00, 0xE0,
+	0x3B, 0x6A,
+
+	0x3F, 0x8F, 0x51, 0x9F,
+	0x37, 0x1E, 0x4F, 0xE9,
+
+	0x37, 0x32, 0x2A, 0xAF,
+	0x00, 0xE0,
+	0x32, 0x00,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x27, 0xC0, 0x44, 0xC0,
+
+	0x36, 0x1F, 0x4F, 0xE9,
+	0x1F, 0x1F, 0x26, 0xDF,
+
+	0x37, 0x1B, 0x37, 0xBF,
+	0x17, 0x26, 0x17, 0xDF,
+
+	0x3E, 0x17, 0x4F, 0xE9,
+	0x3F, 0x3F, 0x4F, 0xE9,
+
+	0x34, 0x1F, 0x34, 0xAF,
+	0x2B, 0x05,
+	0xA7, 0x20,
+
+	0x33, 0x2B, 0x37, 0xDF,
+	0x27, 0x17, 0xC0, 0xAF,
+
+	0x34, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x2D, 0x21, 0x1A, 0xB0,
+	0x25, 0x21, 0x31, 0xB0,
+
+	0x0D, 0x21, 0x1A, 0xB2,
+	0x05, 0x21, 0x31, 0xB2,
+
+	0x03, 0x80, 0x2A, 0xEA,
+	0x17, 0xC1, 0x2B, 0xBD,
+
+	0x2D, 0x20,
+	0x25, 0x20,
+	0x05, 0x20,
+	0x0D, 0x20,
+
+	0xB3, 0x68,
+	0x97, 0x25,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0xC0, 0x33, 0xAF,
+	0x2F, 0xC0, 0x21, 0xC0,
+
+	0x16, 0x42, 0x56, 0x9F,
+	0x3C, 0x27, 0x4F, 0xE9,
+
+	0x1E, 0x62, 0x57, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x21, 0x31, 0xB4,
+	0x2D, 0x21, 0x1A, 0xB4,
+
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x33, 0x05,
+	0x00, 0xE0,
+	0x28, 0x19, 0x60, 0xEC,
+
+	0x0D, 0x21, 0x1A, 0xB6,
+	0x05, 0x21, 0x31, 0xB6,
+
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0xE0,
+	0x2F, 0x20,
+
+	0x23, 0x3B, 0x33, 0xAD,
+	0x1E, 0x26, 0x1E, 0xDF,
+
+	0xA7, 0x1E, 0x4F, 0xE9,
+	0x17, 0x26, 0x16, 0xDF,
+
+	0x2D, 0x20,
+	0x00, 0xE0,
+	0xA8, 0x3F, 0x4F, 0xE9,
+
+	0x2F, 0x2F, 0x1E, 0xAF,
+	0x25, 0x20,
+	0x00, 0xE0,
+
+	0xA4, 0x16, 0x4F, 0xE9,
+	0x0F, 0xC0, 0x21, 0xC2,
+
+	0xA6, 0x80, 0x4F, 0xE9,
+	0x1F, 0x62, 0x57, 0x9F,
+
+	0x0D, 0x20,
+	0x05, 0x20,
+	0x2F, 0xC0, 0x21, 0xC6,
+
+	0x3F, 0x2F, 0x5D, 0x9F,
+	0x00, 0xE0,
+	0x0F, 0x20,
+
+	0x17, 0x50, 0x56, 0x9F,
+	0xA5, 0x37, 0x4F, 0xE9,
+
+	0x06, 0xC0, 0x21, 0xC4,
+	0x0F, 0x17, 0x0F, 0xAF,
+
+	0x37, 0x0F, 0x5C, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x2F, 0x20,
+	0x00, 0xE0,
+	0xA3, 0x80, 0x4F, 0xE9,
+
+	0x06, 0x20,
+	0x00, 0xE0,
+	0x1F, 0x26, 0x1F, 0xDF,
+
+	0x17, 0x26, 0x17, 0xDF,
+	0x35, 0x17, 0x4F, 0xE9,
+
+	0xA1, 0x1F, 0x4F, 0xE9,
+	0xA2, 0x3F, 0x4F, 0xE9,
+
+	0x06, 0x06, 0x1F, 0xAF,
+	0x39, 0x37, 0x4F, 0xE9,
+
+	0x2F, 0x2F, 0x17, 0xAF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xA0, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x31, 0x80, 0x4F, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x57, 0x39, 0x20, 0xE9,
+
+	0x16, 0x28, 0x20, 0xE9,
+	0x1D, 0x3B, 0x20, 0xE9,
+
+	0x1E, 0x2B, 0x20, 0xE9,
+	0x2B, 0x32, 0x20, 0xE9,
+
+	0x1C, 0x23, 0x20, 0xE9,
+	0x57, 0x36, 0x20, 0xE9,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x40, 0x40, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x90, 0xE2,
+	0x00, 0xE0,
+
+	0x68, 0xFF, 0x20, 0xEA,
+	0x19, 0xC8, 0xC1, 0xCD,
+
+	0x1F, 0xD7, 0x18, 0xBD,
+	0x3F, 0xD7, 0x22, 0xBD,
+
+	0x9F, 0x41, 0x49, 0xBD,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x25, 0x41, 0x49, 0xBD,
+	0x2D, 0x41, 0x51, 0xBD,
+
+	0x0D, 0x80, 0x07, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x35, 0x40, 0x48, 0xBD,
+	0x3D, 0x40, 0x50, 0xBD,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x25, 0x30,
+	0x2D, 0x30,
+
+	0x35, 0x30,
+	0xB5, 0x30,
+	0xBD, 0x30,
+	0x3D, 0x30,
+
+	0x9C, 0xA7, 0x5B, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x67, 0xFF, 0x0A, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC9, 0x41, 0xC8, 0xEC,
+	0x42, 0xE1,
+	0x00, 0xE0,
+
+	0x65, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xC8, 0x40, 0xC0, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x62, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+};
+
+static unsigned char warp_g400_t2gz[] = {
+
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
+
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
+
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
+
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
+
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x78, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
+
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
+
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
+
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
+
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
+
+	0x69, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
+
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
+
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
+
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
+
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
+
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
+
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
+
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
+
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
+
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
+
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
+
+	0x25, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x2A, 0x44, 0x54, 0xB4,
+	0x1A, 0x44, 0x64, 0xB4,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
+
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
+
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
+
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
+
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
+
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
+
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
+
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
+
+	0x24, 0x51, 0x20, 0xE9,
+	0x9F, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
+
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
+
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
+
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
+
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
+
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
+
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
+
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
+
+	0xBE, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
+
+	0x7D, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_t2gza[] = {
+
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
+
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
+
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
+
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
+
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x7C, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
+
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
+
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
+
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
+
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
+
+	0x6D, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
+
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
+
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
+
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
+
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
+
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
+
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
+
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
+
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
+
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
+
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
+
+	0x29, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x0F, 0xCF, 0x74, 0xC6,
+	0x3D, 0xCF, 0x74, 0xC2,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x0F, 0x20, 0xE9,
+
+	0x0A, 0x44, 0x54, 0xB4,
+	0x02, 0x44, 0x64, 0xB4,
+
+	0x2A, 0x44, 0x54, 0xB6,
+	0x1A, 0x44, 0x64, 0xB6,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
+
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
+
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
+
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
+
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
+
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
+
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
+
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
+
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
+
+	0x24, 0x51, 0x20, 0xE9,
+	0x9B, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
+
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
+
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
+
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
+
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
+
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
+
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
+
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
+
+	0xBA, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
+
+	0x79, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_t2gzaf[] = {
+
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
+
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
+
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
+
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
+
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x81, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
+
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
+
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
+
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
+
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
+
+	0x72, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
+
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
+
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
+
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
+
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
+
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
+
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
+
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
+
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
+
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x37, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
+
+	0x2E, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x0F, 0xCF, 0x74, 0xC6,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x0F, 0x20, 0xE9,
+
+	0x0A, 0x44, 0x54, 0xB4,
+	0x02, 0x44, 0x64, 0xB4,
+
+	0x2A, 0x44, 0x54, 0xB6,
+	0x1A, 0x44, 0x64, 0xB6,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
+
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x3D, 0xCF, 0x75, 0xC6,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x0A, 0x45, 0x55, 0xB6,
+	0x02, 0x45, 0x65, 0xB6,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x3D, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
+
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x38, 0x4F, 0xE9,
+
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
+
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
+
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
+
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
+
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
+
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
+
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
+
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
+
+	0x24, 0x51, 0x20, 0xE9,
+	0x96, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
+
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
+
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
+
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
+
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
+
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
+
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
+
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
+
+	0xB5, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
+
+	0x74, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_t2gzf[] = {
+
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
+
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
+
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
+
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
+
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x7D, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
+
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
+
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
+
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
+
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
+
+	0x6E, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
+
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
+
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
+
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
+
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
+
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
+
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
+
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
+
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
+
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x0F, 0xCF, 0x75, 0xC6,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
+
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
+
+	0x28, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x31, 0x0F, 0x20, 0xE9,
+
+	0x0A, 0x44, 0x54, 0xB4,
+	0x02, 0x44, 0x64, 0xB4,
+
+	0x2A, 0x45, 0x55, 0xB6,
+	0x1A, 0x45, 0x65, 0xB6,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
+
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
+
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
+
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
+
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
+
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
+
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
+
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
+
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
+
+	0x24, 0x51, 0x20, 0xE9,
+	0x9A, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
+
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
+
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
+
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
+
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
+
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
+
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
+
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
+
+	0xBB, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
+
+	0x78, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_t2gzs[] = {
+
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
+
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
+
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
+
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
+
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x85, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
+
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
+
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
+
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
+
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
+
+	0x76, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
+
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
+
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
+
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
+
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
+
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
+
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
+
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
+
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
+
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
+
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x0F, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x0F, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
+
+	0x31, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x0F, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x0F, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x54, 0xB4,
+	0x1A, 0x44, 0x64, 0xB4,
+
+	0x0A, 0x45, 0x55, 0xB0,
+	0x02, 0x45, 0x65, 0xB0,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x2A, 0x45, 0x55, 0xB2,
+	0x1A, 0x45, 0x65, 0xB2,
+
+	0x0A, 0x45, 0x55, 0xB4,
+	0x02, 0x45, 0x65, 0xB4,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x20,
+	0x1A, 0x20,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA7, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
+
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
+
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
+
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
+
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
+
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
+
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
+
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
+
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
+
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
+
+	0x24, 0x51, 0x20, 0xE9,
+	0x92, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
+
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
+
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
+
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
+
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
+
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
+
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
+
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
+
+	0xB2, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
+
+	0x70, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_t2gzsa[] = {
+
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
+
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
+
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
+
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
+
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x8A, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
+
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
+
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
+
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
+
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
+
+	0x7B, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
+
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
+
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
+
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
+
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
+
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
+
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
+
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
+
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
+
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
+
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x0F, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x0F, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
+
+	0x36, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x0F, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x0F, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x54, 0xB4,
+	0x1A, 0x44, 0x64, 0xB4,
+
+	0x0A, 0x45, 0x55, 0xB0,
+	0x02, 0x45, 0x65, 0xB0,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x45, 0x55, 0xB2,
+	0x1A, 0x45, 0x65, 0xB2,
+
+	0x0A, 0x45, 0x55, 0xB4,
+	0x02, 0x45, 0x65, 0xB4,
+
+	0x0F, 0xCF, 0x74, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x0F, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x44, 0x54, 0xB6,
+	0x1A, 0x44, 0x64, 0xB6,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
+
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
+
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
+
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
+
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
+
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
+
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
+
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
+
+	0x24, 0x51, 0x20, 0xE9,
+	0x8D, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
+
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
+
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
+
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
+
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
+
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
+
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
+
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
+
+	0xAD, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
+
+	0x6B, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_t2gzsaf[] = {
+
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
+
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
+
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
+
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
+
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x8E, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
+
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
+
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
+
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
+
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
+
+	0x7F, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
+
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
+
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
+
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
+
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
+
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
+
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
+
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
+
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
+
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
+
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x0F, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x0F, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
+
+	0x3A, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x0F, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x0F, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x54, 0xB4,
+	0x1A, 0x44, 0x64, 0xB4,
+
+	0x0A, 0x45, 0x55, 0xB0,
+	0x02, 0x45, 0x65, 0xB0,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x45, 0x55, 0xB2,
+	0x1A, 0x45, 0x65, 0xB2,
+
+	0x0A, 0x45, 0x55, 0xB4,
+	0x02, 0x45, 0x65, 0xB4,
+
+	0x0F, 0xCF, 0x74, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x0F, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x44, 0x54, 0xB6,
+	0x1A, 0x44, 0x64, 0xB6,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x45, 0x55, 0xB6,
+	0x02, 0x45, 0x65, 0xB6,
+
+	0x3D, 0xCF, 0x75, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x3D, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x38, 0x4F, 0xE9,
+
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
+
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
+
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
+
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
+
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
+
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
+
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
+
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
+
+	0x24, 0x51, 0x20, 0xE9,
+	0x89, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
+
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
+
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
+
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
+
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
+
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
+
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
+
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
+
+	0xA9, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
+
+	0x67, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_t2gzsf[] = {
+
+	0x00, 0x8A, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x0A, 0x40, 0x50, 0xBF,
+	0x2A, 0x40, 0x60, 0xBF,
+
+	0x32, 0x41, 0x51, 0xBF,
+	0x3A, 0x41, 0x61, 0xBF,
+
+	0xC3, 0x6B,
+	0xD3, 0x6B,
+	0x00, 0x8A, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x23, 0x9F,
+	0x00, 0xE0,
+	0x51, 0x04,
+
+	0x90, 0xE2,
+	0x61, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x51, 0x41, 0xE0, 0xEC,
+	0x39, 0x67, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x63, 0xA0, 0xE8,
+
+	0x61, 0x41, 0xE0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x8A, 0x80, 0x15, 0xEA,
+	0x10, 0x04,
+	0x20, 0x04,
+
+	0x61, 0x51, 0xE0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x52, 0xBF,
+	0x0F, 0x52, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x62, 0xBF,
+	0x1E, 0x51, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x0E, 0x61, 0x60, 0xEA,
+
+	0x32, 0x40, 0x50, 0xBD,
+	0x22, 0x40, 0x60, 0xBD,
+
+	0x12, 0x41, 0x51, 0xBD,
+	0x3A, 0x41, 0x61, 0xBD,
+
+	0xBF, 0x2F, 0x0E, 0xBD,
+	0x97, 0xE2,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x35, 0x48, 0xB1, 0xE8,
+	0x3D, 0x59, 0xB1, 0xE8,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x56, 0x31, 0x56, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x66, 0x31, 0x66, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x57, 0x39, 0x57, 0xBF,
+	0x67, 0x39, 0x67, 0xBF,
+
+	0x7B, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x35, 0x00,
+	0x3D, 0x00,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0x8D, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x75, 0xF8, 0xEC,
+	0x35, 0x20,
+	0x3D, 0x20,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x53, 0x53, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x0E, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x48, 0x35, 0x48, 0xBF,
+	0x58, 0x35, 0x58, 0xBF,
+
+	0x68, 0x35, 0x68, 0xBF,
+	0x49, 0x3D, 0x49, 0xBF,
+
+	0x59, 0x3D, 0x59, 0xBF,
+	0x69, 0x3D, 0x69, 0xBF,
+
+	0x63, 0x63, 0x2D, 0xDF,
+	0x4D, 0x7D, 0xF8, 0xEC,
+
+	0x59, 0xE3,
+	0x00, 0xE0,
+	0xB8, 0x38, 0x33, 0xBF,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x18, 0x3A, 0x41, 0xE9,
+
+	0x3F, 0x53, 0xA0, 0xE8,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x63, 0xA0, 0xE8,
+
+	0x50, 0x70, 0xF8, 0xEC,
+	0x2B, 0x50, 0x3C, 0xE9,
+
+	0x1F, 0x0F, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x59, 0x78, 0xF8, 0xEC,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x56, 0x3F, 0x56, 0xDF,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x66, 0x3D, 0x66, 0xDF,
+
+	0x1D, 0x32, 0x41, 0xE9,
+	0x67, 0x3D, 0x67, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3F, 0x57, 0xDF,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x59, 0x3F, 0x59, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x69, 0x3D, 0x69, 0xDF,
+
+	0x48, 0x37, 0x48, 0xDF,
+	0x58, 0x3F, 0x58, 0xDF,
+
+	0x68, 0x3D, 0x68, 0xDF,
+	0x49, 0x37, 0x49, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x0F, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x0A, 0x44, 0x54, 0xB0,
+	0x02, 0x44, 0x64, 0xB0,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x0F, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x54, 0xB2,
+	0x1A, 0x44, 0x64, 0xB2,
+
+	0x36, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x0F, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x0F, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x54, 0xB4,
+	0x1A, 0x44, 0x64, 0xB4,
+
+	0x0A, 0x45, 0x55, 0xB0,
+	0x02, 0x45, 0x65, 0xB0,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x45, 0x55, 0xB2,
+	0x1A, 0x45, 0x65, 0xB2,
+
+	0x0A, 0x45, 0x55, 0xB4,
+	0x02, 0x45, 0x65, 0xB4,
+
+	0x0F, 0xCF, 0x75, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x31, 0x0F, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x45, 0x55, 0xB6,
+	0x1A, 0x45, 0x65, 0xB6,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x2A, 0x46, 0x56, 0xBF,
+	0x1A, 0x46, 0x66, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x47, 0x57, 0xBF,
+	0x02, 0x47, 0x67, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x53, 0xBF,
+	0x1A, 0x43, 0x63, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x48, 0x58, 0xBF,
+	0x02, 0x48, 0x68, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x2A, 0x49, 0x59, 0xBF,
+	0x1A, 0x49, 0x69, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x82, 0x30, 0x57, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x83, 0x38, 0x57, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x84, 0x31, 0x5E, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x85, 0x39, 0x5E, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x87, 0x77, 0x57, 0xE9,
+	0x8B, 0x3E, 0xBF, 0xEA,
+
+	0x80, 0x30, 0x57, 0xE9,
+	0x81, 0x38, 0x57, 0xE9,
+
+	0x82, 0x31, 0x57, 0xE9,
+	0x86, 0x78, 0x57, 0xE9,
+
+	0x83, 0x39, 0x57, 0xE9,
+	0x87, 0x79, 0x57, 0xE9,
+
+	0x30, 0x1F, 0x5F, 0xE9,
+	0x8A, 0x34, 0x20, 0xE9,
+
+	0x8B, 0x3C, 0x20, 0xE9,
+	0x37, 0x50, 0x60, 0xBD,
+
+	0x57, 0x0D, 0x20, 0xE9,
+	0x35, 0x51, 0x61, 0xBD,
+
+	0x2B, 0x50, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x0E, 0x77,
+
+	0x24, 0x51, 0x20, 0xE9,
+	0x8D, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x0E, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x0B, 0x46, 0xA0, 0xE8,
+	0x1B, 0x56, 0xA0, 0xE8,
+
+	0x2B, 0x66, 0xA0, 0xE8,
+	0x0C, 0x47, 0xA0, 0xE8,
+
+	0x1C, 0x57, 0xA0, 0xE8,
+	0x2C, 0x67, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x57, 0x80, 0x57, 0xCF,
+
+	0x66, 0x33, 0x66, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x67, 0x3B, 0x67, 0xCF,
+
+	0x0B, 0x48, 0xA0, 0xE8,
+	0x1B, 0x58, 0xA0, 0xE8,
+
+	0x2B, 0x68, 0xA0, 0xE8,
+	0x0C, 0x49, 0xA0, 0xE8,
+
+	0x1C, 0x59, 0xA0, 0xE8,
+	0x2C, 0x69, 0xA0, 0xE8,
+
+	0x0B, 0x00,
+	0x1B, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x0C, 0x00,
+	0x1C, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x0B, 0x65,
+	0x1B, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x0C, 0x65,
+	0x1C, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x0B, 0x1B, 0x60, 0xEC,
+	0x34, 0xD7, 0x34, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x0C, 0x1C, 0x60, 0xEC,
+
+	0x3C, 0xD7, 0x3C, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x0B, 0x2B, 0xDE, 0xE8,
+	0x1B, 0x80, 0xDE, 0xE8,
+
+	0x34, 0x80, 0x34, 0xBD,
+	0x3C, 0x80, 0x3C, 0xBD,
+
+	0x33, 0xD7, 0x0B, 0xBD,
+	0x3B, 0xD7, 0x1B, 0xBD,
+
+	0x48, 0x80, 0x48, 0xCF,
+	0x59, 0x80, 0x59, 0xCF,
+
+	0x68, 0x33, 0x68, 0xCF,
+	0x49, 0x3B, 0x49, 0xCF,
+
+	0xAD, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x58, 0x33, 0x58, 0xCF,
+	0x69, 0x3B, 0x69, 0xCF,
+
+	0x6B, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_tgz[] = {
+
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
+
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
+
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
+
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x58, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
+
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
+
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
+
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
+
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+
+	0x4A, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
+
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
+
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
+
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
+
+	0x1D, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x2A, 0x44, 0x4C, 0xB4,
+	0x1A, 0x44, 0x54, 0xB4,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
+
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
+
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
+
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
+
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
+
+	0x24, 0x49, 0x20, 0xE9,
+	0xAF, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
+
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
+
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
+
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0xD6, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
+
+	0x9D, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_tgza[] = {
+
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
+
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
+
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
+
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x5C, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
+
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
+
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
+
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
+
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+
+	0x4E, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
+
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
+
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x27, 0xCF, 0x74, 0xC6,
+	0x3D, 0xCF, 0x74, 0xC2,
+
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
+
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
+
+	0x20, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x27, 0x20, 0xE9,
+
+	0x0A, 0x44, 0x4C, 0xB4,
+	0x02, 0x44, 0x54, 0xB4,
+
+	0x2A, 0x44, 0x4C, 0xB6,
+	0x1A, 0x44, 0x54, 0xB6,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
+
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
+
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
+
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
+
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
+
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
+
+	0x24, 0x49, 0x20, 0xE9,
+	0xAB, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
+
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
+
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
+
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0xD3, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
+
+	0x99, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_tgzaf[] = {
+
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
+
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
+
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
+
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x61, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
+
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
+
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
+
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
+
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+
+	0x53, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
+
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
+
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x34, 0x37, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
+
+	0x26, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x27, 0xCF, 0x74, 0xC6,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x27, 0x20, 0xE9,
+
+	0x0A, 0x44, 0x4C, 0xB4,
+	0x02, 0x44, 0x54, 0xB4,
+
+	0x2A, 0x44, 0x4C, 0xB6,
+	0x1A, 0x44, 0x54, 0xB6,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
+
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x3D, 0xCF, 0x75, 0xC6,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x0A, 0x45, 0x4D, 0xB6,
+	0x02, 0x45, 0x55, 0xB6,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x3D, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
+
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x38, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
+
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
+
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
+
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
+
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
+
+	0x24, 0x49, 0x20, 0xE9,
+	0xA6, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
+
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
+
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
+
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0xCD, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
+
+	0x94, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_tgzf[] = {
+
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
+
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
+
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
+
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x5D, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
+
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
+
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
+
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
+
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+
+	0x4F, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
+
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
+
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x34, 0x80, 0x20, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x27, 0xCF, 0x75, 0xC6,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
+
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
+
+	0x20, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x3D, 0xCF, 0x74, 0xC2,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x31, 0x27, 0x20, 0xE9,
+
+	0x0A, 0x44, 0x4C, 0xB4,
+	0x02, 0x44, 0x54, 0xB4,
+
+	0x2A, 0x45, 0x4D, 0xB6,
+	0x1A, 0x45, 0x55, 0xB6,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x38, 0x3D, 0x20, 0xE9,
+
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
+
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
+
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
+
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
+
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
+
+	0x24, 0x49, 0x20, 0xE9,
+	0xAA, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
+
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
+
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
+
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0xD3, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
+
+	0x98, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_tgzs[] = {
+
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
+
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
+
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
+
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x65, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
+
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
+
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
+
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
+
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+
+	0x57, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
+
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
+
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x27, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x27, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
+
+	0x29, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x27, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x27, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x4C, 0xB4,
+	0x1A, 0x44, 0x54, 0xB4,
+
+	0x0A, 0x45, 0x4D, 0xB0,
+	0x02, 0x45, 0x55, 0xB0,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x2A, 0x45, 0x4D, 0xB2,
+	0x1A, 0x45, 0x55, 0xB2,
+
+	0x0A, 0x45, 0x4D, 0xB4,
+	0x02, 0x45, 0x55, 0xB4,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x20,
+	0x02, 0x20,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA7, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
+
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
+
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
+
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
+
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
+
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
+
+	0x24, 0x49, 0x20, 0xE9,
+	0xA2, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
+
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
+
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
+
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0xCA, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
+
+	0x90, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_tgzsa[] = {
+
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
+
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
+
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
+
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x6A, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
+
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
+
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
+
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
+
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+
+	0x5C, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
+
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
+
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x27, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x27, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
+
+	0x2E, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x27, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x27, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x4C, 0xB4,
+	0x1A, 0x44, 0x54, 0xB4,
+
+	0x0A, 0x45, 0x4D, 0xB0,
+	0x02, 0x45, 0x55, 0xB0,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x45, 0x4D, 0xB2,
+	0x1A, 0x45, 0x55, 0xB2,
+
+	0x0A, 0x45, 0x4D, 0xB4,
+	0x02, 0x45, 0x55, 0xB4,
+
+	0x27, 0xCF, 0x74, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x27, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x44, 0x4C, 0xB6,
+	0x1A, 0x44, 0x54, 0xB6,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
+
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
+
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
+
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
+
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
+
+	0x24, 0x49, 0x20, 0xE9,
+	0x9D, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
+
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
+
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
+
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0xC5, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
+
+	0x8B, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_tgzsaf[] = {
+
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
+
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
+
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
+
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x6E, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
+
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
+
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
+
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
+
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+
+	0x60, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
+
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
+
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x27, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x27, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
+
+	0x32, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x27, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x27, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x4C, 0xB4,
+	0x1A, 0x44, 0x54, 0xB4,
+
+	0x0A, 0x45, 0x4D, 0xB0,
+	0x02, 0x45, 0x55, 0xB0,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x45, 0x4D, 0xB2,
+	0x1A, 0x45, 0x55, 0xB2,
+
+	0x0A, 0x45, 0x4D, 0xB4,
+	0x02, 0x45, 0x55, 0xB4,
+
+	0x27, 0xCF, 0x74, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9C, 0x27, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x44, 0x4C, 0xB6,
+	0x1A, 0x44, 0x54, 0xB6,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x45, 0x4D, 0xB6,
+	0x02, 0x45, 0x55, 0xB6,
+
+	0x3D, 0xCF, 0x75, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x3D, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x9D, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x9E, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x30, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x38, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
+
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
+
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
+
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
+
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
+
+	0x24, 0x49, 0x20, 0xE9,
+	0x99, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
+
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
+
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
+
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0xC1, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
+
+	0x87, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
+
+static unsigned char warp_g400_tgzsf[] = {
+
+	0x00, 0x88, 0x98, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+	0xFF, 0x80, 0xC0, 0xE9,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x22, 0x40, 0x48, 0xBF,
+	0x2A, 0x40, 0x50, 0xBF,
+
+	0x32, 0x41, 0x49, 0xBF,
+	0x3A, 0x41, 0x51, 0xBF,
+
+	0xC3, 0x6B,
+	0xCB, 0x6B,
+	0x00, 0x88, 0x98, 0xE9,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x96, 0xE2,
+	0x41, 0x04,
+
+	0x7B, 0x43, 0xA0, 0xE8,
+	0x73, 0x4B, 0xA0, 0xE8,
+
+	0xAD, 0xEE, 0x29, 0x9F,
+	0x00, 0xE0,
+	0x49, 0x04,
+
+	0x90, 0xE2,
+	0x51, 0x04,
+	0x31, 0x46, 0xB1, 0xE8,
+
+	0x49, 0x41, 0xC0, 0xEC,
+	0x39, 0x57, 0xB1, 0xE8,
+
+	0x00, 0x04,
+	0x46, 0xE2,
+	0x73, 0x53, 0xA0, 0xE8,
+
+	0x51, 0x41, 0xC0, 0xEC,
+	0x31, 0x00,
+	0x39, 0x00,
+
+	0x6A, 0x80, 0x15, 0xEA,
+	0x08, 0x04,
+	0x10, 0x04,
+
+	0x51, 0x49, 0xC0, 0xEC,
+	0x2F, 0x41, 0x60, 0xEA,
+
+	0x31, 0x20,
+	0x39, 0x20,
+	0x1F, 0x42, 0xA0, 0xE8,
+
+	0x2A, 0x42, 0x4A, 0xBF,
+	0x27, 0x4A, 0xA0, 0xE8,
+
+	0x1A, 0x42, 0x52, 0xBF,
+	0x1E, 0x49, 0x60, 0xEA,
+
+	0x73, 0x7B, 0xC8, 0xEC,
+	0x26, 0x51, 0x60, 0xEA,
+
+	0x32, 0x40, 0x48, 0xBD,
+	0x22, 0x40, 0x50, 0xBD,
+
+	0x12, 0x41, 0x49, 0xBD,
+	0x3A, 0x41, 0x51, 0xBD,
+
+	0xBF, 0x2F, 0x26, 0xBD,
+	0x00, 0xE0,
+	0x7B, 0x72,
+
+	0x32, 0x20,
+	0x22, 0x20,
+	0x12, 0x20,
+	0x3A, 0x20,
+
+	0x46, 0x31, 0x46, 0xBF,
+	0x4E, 0x31, 0x4E, 0xBF,
+
+	0xB3, 0xE2, 0x2D, 0x9F,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x56, 0x31, 0x56, 0xBF,
+	0x47, 0x39, 0x47, 0xBF,
+
+	0x4F, 0x39, 0x4F, 0xBF,
+	0x57, 0x39, 0x57, 0xBF,
+
+	0x5C, 0x80, 0x07, 0xEA,
+	0x24, 0x41, 0x20, 0xE9,
+
+	0x42, 0x73, 0xF8, 0xEC,
+	0x00, 0xE0,
+	0x2D, 0x73,
+
+	0x33, 0x72,
+	0x0C, 0xE3,
+	0xA5, 0x2F, 0x1E, 0xBD,
+
+	0x43, 0x43, 0x2D, 0xDF,
+	0x4B, 0x4B, 0x2D, 0xDF,
+
+	0xAE, 0x1E, 0x26, 0xBD,
+	0x58, 0xE3,
+	0x33, 0x66,
+
+	0x53, 0x53, 0x2D, 0xDF,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0xB8, 0x38, 0x33, 0xBF,
+	0x00, 0xE0,
+	0x59, 0xE3,
+
+	0x1E, 0x12, 0x41, 0xE9,
+	0x1A, 0x22, 0x41, 0xE9,
+
+	0x2B, 0x40, 0x3D, 0xE9,
+	0x3F, 0x4B, 0xA0, 0xE8,
+
+	0x2D, 0x73,
+	0x30, 0x76,
+	0x05, 0x80, 0x3D, 0xEA,
+
+	0x37, 0x43, 0xA0, 0xE8,
+	0x3D, 0x53, 0xA0, 0xE8,
+
+	0x48, 0x70, 0xF8, 0xEC,
+	0x2B, 0x48, 0x3C, 0xE9,
+
+	0x1F, 0x27, 0xBC, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x15, 0xC0, 0x20, 0xE9,
+	0x15, 0xC0, 0x20, 0xE9,
+
+	0x18, 0x3A, 0x41, 0xE9,
+	0x1D, 0x32, 0x41, 0xE9,
+
+	0x2A, 0x40, 0x20, 0xE9,
+	0x56, 0x3D, 0x56, 0xDF,
+
+	0x46, 0x37, 0x46, 0xDF,
+	0x4E, 0x3F, 0x4E, 0xDF,
+
+	0x16, 0x30, 0x20, 0xE9,
+	0x4F, 0x3F, 0x4F, 0xDF,
+
+	0x47, 0x37, 0x47, 0xDF,
+	0x57, 0x3D, 0x57, 0xDF,
+
+	0x32, 0x32, 0x2D, 0xDF,
+	0x22, 0x22, 0x2D, 0xDF,
+
+	0x12, 0x12, 0x2D, 0xDF,
+	0x3A, 0x3A, 0x2D, 0xDF,
+
+	0x27, 0xCF, 0x74, 0xC2,
+	0x37, 0xCF, 0x74, 0xC4,
+
+	0x0A, 0x44, 0x4C, 0xB0,
+	0x02, 0x44, 0x54, 0xB0,
+
+	0x3D, 0xCF, 0x74, 0xC0,
+	0x34, 0x37, 0x20, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x38, 0x27, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3C, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x4C, 0xB2,
+	0x1A, 0x44, 0x54, 0xB2,
+
+	0x2E, 0x80, 0x3A, 0xEA,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x27, 0xCF, 0x75, 0xC0,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x32, 0x31, 0x5F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x33, 0x39, 0x5F, 0xE9,
+
+	0x3D, 0xCF, 0x75, 0xC2,
+	0x37, 0xCF, 0x75, 0xC4,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA6, 0x27, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA3, 0x3D, 0x20, 0xE9,
+
+	0x2A, 0x44, 0x4C, 0xB4,
+	0x1A, 0x44, 0x54, 0xB4,
+
+	0x0A, 0x45, 0x4D, 0xB0,
+	0x02, 0x45, 0x55, 0xB0,
+
+	0x88, 0x73, 0x5E, 0xE9,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA0, 0x37, 0x20, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x3E, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x3F, 0x38, 0x4F, 0xE9,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x3A, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x3B, 0x39, 0x4F, 0xE9,
+
+	0x2A, 0x45, 0x4D, 0xB2,
+	0x1A, 0x45, 0x55, 0xB2,
+
+	0x0A, 0x45, 0x4D, 0xB4,
+	0x02, 0x45, 0x55, 0xB4,
+
+	0x27, 0xCF, 0x75, 0xC6,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0xA7, 0x30, 0x4F, 0xE9,
+	0x0A, 0x20,
+	0x02, 0x20,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x31, 0x27, 0x20, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA8, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x45, 0x4D, 0xB6,
+	0x1A, 0x45, 0x55, 0xB6,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x36, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x37, 0x39, 0x4F, 0xE9,
+
+	0x00, 0x80, 0x00, 0xE8,
+	0x2A, 0x20,
+	0x1A, 0x20,
+
+	0x2A, 0x46, 0x4E, 0xBF,
+	0x1A, 0x46, 0x56, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA4, 0x31, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA5, 0x39, 0x4F, 0xE9,
+
+	0x0A, 0x47, 0x4F, 0xBF,
+	0x02, 0x47, 0x57, 0xBF,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0xA1, 0x30, 0x4F, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0xA2, 0x38, 0x4F, 0xE9,
+
+	0x2A, 0x43, 0x4B, 0xBF,
+	0x1A, 0x43, 0x53, 0xBF,
+
+	0x30, 0x50, 0x2E, 0x9F,
+	0x35, 0x31, 0x4F, 0xE9,
+
+	0x38, 0x21, 0x2C, 0x9F,
+	0x39, 0x39, 0x4F, 0xE9,
+
+	0x31, 0x53, 0x2F, 0x9F,
+	0x80, 0x31, 0x57, 0xE9,
+
+	0x39, 0xE5, 0x2C, 0x9F,
+	0x81, 0x39, 0x57, 0xE9,
+
+	0x37, 0x48, 0x50, 0xBD,
+	0x8A, 0x36, 0x20, 0xE9,
+
+	0x86, 0x76, 0x57, 0xE9,
+	0x8B, 0x3E, 0x20, 0xE9,
+
+	0x82, 0x30, 0x57, 0xE9,
+	0x87, 0x77, 0x57, 0xE9,
+
+	0x83, 0x38, 0x57, 0xE9,
+	0x35, 0x49, 0x51, 0xBD,
+
+	0x84, 0x31, 0x5E, 0xE9,
+	0x30, 0x1F, 0x5F, 0xE9,
+
+	0x85, 0x39, 0x5E, 0xE9,
+	0x57, 0x25, 0x20, 0xE9,
+
+	0x2B, 0x48, 0x20, 0xE9,
+	0x1D, 0x37, 0xE1, 0xEA,
+
+	0x1E, 0x35, 0xE1, 0xEA,
+	0x00, 0xE0,
+	0x26, 0x77,
+
+	0x24, 0x49, 0x20, 0xE9,
+	0x9D, 0xFF, 0x20, 0xEA,
+
+	0x16, 0x26, 0x20, 0xE9,
+	0x57, 0x2E, 0xBF, 0xEA,
+
+	0x1C, 0x46, 0xA0, 0xE8,
+	0x23, 0x4E, 0xA0, 0xE8,
+
+	0x2B, 0x56, 0xA0, 0xE8,
+	0x1D, 0x47, 0xA0, 0xE8,
+
+	0x24, 0x4F, 0xA0, 0xE8,
+	0x2C, 0x57, 0xA0, 0xE8,
+
+	0x1C, 0x00,
+	0x23, 0x00,
+	0x2B, 0x00,
+	0x00, 0xE0,
+
+	0x1D, 0x00,
+	0x24, 0x00,
+	0x2C, 0x00,
+	0x00, 0xE0,
+
+	0x1C, 0x65,
+	0x23, 0x65,
+	0x2B, 0x65,
+	0x00, 0xE0,
+
+	0x1D, 0x65,
+	0x24, 0x65,
+	0x2C, 0x65,
+	0x00, 0xE0,
+
+	0x1C, 0x23, 0x60, 0xEC,
+	0x36, 0xD7, 0x36, 0xAD,
+
+	0x2B, 0x80, 0x60, 0xEC,
+	0x1D, 0x24, 0x60, 0xEC,
+
+	0x3E, 0xD7, 0x3E, 0xAD,
+	0x2C, 0x80, 0x60, 0xEC,
+
+	0x1C, 0x2B, 0xDE, 0xE8,
+	0x23, 0x80, 0xDE, 0xE8,
+
+	0x36, 0x80, 0x36, 0xBD,
+	0x3E, 0x80, 0x3E, 0xBD,
+
+	0x33, 0xD7, 0x1C, 0xBD,
+	0x3B, 0xD7, 0x23, 0xBD,
+
+	0x46, 0x80, 0x46, 0xCF,
+	0x4F, 0x80, 0x4F, 0xCF,
+
+	0x56, 0x33, 0x56, 0xCF,
+	0x47, 0x3B, 0x47, 0xCF,
+
+	0xC5, 0xFF, 0x20, 0xEA,
+	0x00, 0x80, 0x00, 0xE8,
+
+	0x4E, 0x33, 0x4E, 0xCF,
+	0x57, 0x3B, 0x57, 0xCF,
+
+	0x8B, 0xFF, 0x20, 0xEA,
+	0x57, 0xC0, 0xBF, 0xEA,
+
+	0x00, 0x80, 0xA0, 0xE9,
+	0x00, 0x00, 0xD8, 0xEC,
+
+};
Index: git/shared-core/mga_warp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/mga_warp.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,198 @@
+/* mga_warp.c -- Matrox G200/G400 WARP engine management -*- linux-c -*-
+ * Created: Thu Jan 11 21:29:32 2001 by gareth@valinux.com
+ */
+/*
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "mga_drm.h"
+#include "mga_drv.h"
+#include "mga_ucode.h"
+
+#define MGA_WARP_CODE_ALIGN		256	/* in bytes */
+
+#define WARP_UCODE_SIZE( which )					\
+	((sizeof(which) / MGA_WARP_CODE_ALIGN + 1) * MGA_WARP_CODE_ALIGN)
+
+#define WARP_UCODE_INSTALL( which, where )				\
+do {									\
+	DRM_DEBUG( " pcbase = 0x%08lx  vcbase = %p\n", pcbase, vcbase );\
+	dev_priv->warp_pipe_phys[where] = pcbase;			\
+	memcpy( vcbase, which, sizeof(which) );				\
+	pcbase += WARP_UCODE_SIZE( which );				\
+	vcbase += WARP_UCODE_SIZE( which );				\
+} while (0)
+
+static const unsigned int mga_warp_g400_microcode_size =
+	       (WARP_UCODE_SIZE(warp_g400_tgz) +
+		WARP_UCODE_SIZE(warp_g400_tgza) +
+		WARP_UCODE_SIZE(warp_g400_tgzaf) +
+		WARP_UCODE_SIZE(warp_g400_tgzf) +
+		WARP_UCODE_SIZE(warp_g400_tgzs) +
+		WARP_UCODE_SIZE(warp_g400_tgzsa) +
+		WARP_UCODE_SIZE(warp_g400_tgzsaf) +
+		WARP_UCODE_SIZE(warp_g400_tgzsf) +
+		WARP_UCODE_SIZE(warp_g400_t2gz) +
+		WARP_UCODE_SIZE(warp_g400_t2gza) +
+		WARP_UCODE_SIZE(warp_g400_t2gzaf) +
+		WARP_UCODE_SIZE(warp_g400_t2gzf) +
+		WARP_UCODE_SIZE(warp_g400_t2gzs) +
+		WARP_UCODE_SIZE(warp_g400_t2gzsa) +
+		WARP_UCODE_SIZE(warp_g400_t2gzsaf) +
+		WARP_UCODE_SIZE(warp_g400_t2gzsf));
+
+static const unsigned int mga_warp_g200_microcode_size =
+	       (WARP_UCODE_SIZE(warp_g200_tgz) +
+		WARP_UCODE_SIZE(warp_g200_tgza) +
+		WARP_UCODE_SIZE(warp_g200_tgzaf) +
+		WARP_UCODE_SIZE(warp_g200_tgzf) +
+		WARP_UCODE_SIZE(warp_g200_tgzs) +
+		WARP_UCODE_SIZE(warp_g200_tgzsa) +
+		WARP_UCODE_SIZE(warp_g200_tgzsaf) +
+		WARP_UCODE_SIZE(warp_g200_tgzsf));
+
+
+unsigned int mga_warp_microcode_size(const drm_mga_private_t * dev_priv)
+{
+	switch (dev_priv->chipset) {
+	case MGA_CARD_TYPE_G400:
+	case MGA_CARD_TYPE_G550:
+		return PAGE_ALIGN(mga_warp_g400_microcode_size);
+	case MGA_CARD_TYPE_G200:
+		return PAGE_ALIGN(mga_warp_g200_microcode_size);
+	default:
+		DRM_ERROR("Unknown chipset value: 0x%x\n", dev_priv->chipset);
+		return 0;
+	}
+}
+
+static int mga_warp_install_g400_microcode(drm_mga_private_t * dev_priv)
+{
+	unsigned char *vcbase = dev_priv->warp->handle;
+	unsigned long pcbase = dev_priv->warp->offset;
+
+	memset(dev_priv->warp_pipe_phys, 0, sizeof(dev_priv->warp_pipe_phys));
+
+	WARP_UCODE_INSTALL(warp_g400_tgz, MGA_WARP_TGZ);
+	WARP_UCODE_INSTALL(warp_g400_tgzf, MGA_WARP_TGZF);
+	WARP_UCODE_INSTALL(warp_g400_tgza, MGA_WARP_TGZA);
+	WARP_UCODE_INSTALL(warp_g400_tgzaf, MGA_WARP_TGZAF);
+	WARP_UCODE_INSTALL(warp_g400_tgzs, MGA_WARP_TGZS);
+	WARP_UCODE_INSTALL(warp_g400_tgzsf, MGA_WARP_TGZSF);
+	WARP_UCODE_INSTALL(warp_g400_tgzsa, MGA_WARP_TGZSA);
+	WARP_UCODE_INSTALL(warp_g400_tgzsaf, MGA_WARP_TGZSAF);
+
+	WARP_UCODE_INSTALL(warp_g400_t2gz, MGA_WARP_T2GZ);
+	WARP_UCODE_INSTALL(warp_g400_t2gzf, MGA_WARP_T2GZF);
+	WARP_UCODE_INSTALL(warp_g400_t2gza, MGA_WARP_T2GZA);
+	WARP_UCODE_INSTALL(warp_g400_t2gzaf, MGA_WARP_T2GZAF);
+	WARP_UCODE_INSTALL(warp_g400_t2gzs, MGA_WARP_T2GZS);
+	WARP_UCODE_INSTALL(warp_g400_t2gzsf, MGA_WARP_T2GZSF);
+	WARP_UCODE_INSTALL(warp_g400_t2gzsa, MGA_WARP_T2GZSA);
+	WARP_UCODE_INSTALL(warp_g400_t2gzsaf, MGA_WARP_T2GZSAF);
+
+	return 0;
+}
+
+static int mga_warp_install_g200_microcode(drm_mga_private_t * dev_priv)
+{
+	unsigned char *vcbase = dev_priv->warp->handle;
+	unsigned long pcbase = dev_priv->warp->offset;
+
+	memset(dev_priv->warp_pipe_phys, 0, sizeof(dev_priv->warp_pipe_phys));
+
+	WARP_UCODE_INSTALL(warp_g200_tgz, MGA_WARP_TGZ);
+	WARP_UCODE_INSTALL(warp_g200_tgzf, MGA_WARP_TGZF);
+	WARP_UCODE_INSTALL(warp_g200_tgza, MGA_WARP_TGZA);
+	WARP_UCODE_INSTALL(warp_g200_tgzaf, MGA_WARP_TGZAF);
+	WARP_UCODE_INSTALL(warp_g200_tgzs, MGA_WARP_TGZS);
+	WARP_UCODE_INSTALL(warp_g200_tgzsf, MGA_WARP_TGZSF);
+	WARP_UCODE_INSTALL(warp_g200_tgzsa, MGA_WARP_TGZSA);
+	WARP_UCODE_INSTALL(warp_g200_tgzsaf, MGA_WARP_TGZSAF);
+
+	return 0;
+}
+
+int mga_warp_install_microcode(drm_mga_private_t * dev_priv)
+{
+	const unsigned int size = mga_warp_microcode_size(dev_priv);
+
+	DRM_DEBUG("MGA ucode size = %d bytes\n", size);
+	if (size > dev_priv->warp->size) {
+		DRM_ERROR("microcode too large! (%u > %lu)\n",
+			  size, dev_priv->warp->size);
+		return -ENOMEM;
+	}
+
+	switch (dev_priv->chipset) {
+	case MGA_CARD_TYPE_G400:
+	case MGA_CARD_TYPE_G550:
+		return mga_warp_install_g400_microcode(dev_priv);
+	case MGA_CARD_TYPE_G200:
+		return mga_warp_install_g200_microcode(dev_priv);
+	default:
+		return -EINVAL;
+	}
+}
+
+#define WMISC_EXPECTED		(MGA_WUCODECACHE_ENABLE | MGA_WMASTER_ENABLE)
+
+int mga_warp_init(drm_mga_private_t * dev_priv)
+{
+	u32 wmisc;
+
+	/* FIXME: Get rid of these damned magic numbers...
+	 */
+	switch (dev_priv->chipset) {
+	case MGA_CARD_TYPE_G400:
+	case MGA_CARD_TYPE_G550:
+		MGA_WRITE(MGA_WIADDR2, MGA_WMODE_SUSPEND);
+		MGA_WRITE(MGA_WGETMSB, 0x00000E00);
+		MGA_WRITE(MGA_WVRTXSZ, 0x00001807);
+		MGA_WRITE(MGA_WACCEPTSEQ, 0x18000000);
+		break;
+	case MGA_CARD_TYPE_G200:
+		MGA_WRITE(MGA_WIADDR, MGA_WMODE_SUSPEND);
+		MGA_WRITE(MGA_WGETMSB, 0x1606);
+		MGA_WRITE(MGA_WVRTXSZ, 7);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	MGA_WRITE(MGA_WMISC, (MGA_WUCODECACHE_ENABLE |
+			      MGA_WMASTER_ENABLE | MGA_WCACHEFLUSH_ENABLE));
+	wmisc = MGA_READ(MGA_WMISC);
+	if (wmisc != WMISC_EXPECTED) {
+		DRM_ERROR("WARP engine config failed! 0x%x != 0x%x\n",
+			  wmisc, WMISC_EXPECTED);
+		return -EINVAL;
+	}
+
+	return 0;
+}
Index: git/shared-core/nouveau_drm.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nouveau_drm.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2005 Stephane Marchesin.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __NOUVEAU_DRM_H__
+#define __NOUVEAU_DRM_H__
+
+#define NOUVEAU_DRM_HEADER_PATCHLEVEL 10
+
+struct drm_nouveau_channel_alloc {
+	uint32_t     fb_ctxdma_handle;
+	uint32_t     tt_ctxdma_handle;
+
+	int          channel;
+	uint32_t     put_base;
+	/* FIFO control regs */
+	drm_handle_t ctrl;
+	int          ctrl_size;
+	/* DMA command buffer */
+	drm_handle_t cmdbuf;
+	int          cmdbuf_size;
+	/* Notifier memory */
+	drm_handle_t notifier;
+	int          notifier_size;
+};
+
+struct drm_nouveau_channel_free {
+	int channel;
+};
+
+struct drm_nouveau_grobj_alloc {
+	int      channel;
+	uint32_t handle;
+	int      class;
+};
+
+#define NOUVEAU_MEM_ACCESS_RO	1
+#define NOUVEAU_MEM_ACCESS_WO	2
+#define NOUVEAU_MEM_ACCESS_RW	3
+struct drm_nouveau_notifierobj_alloc {
+	int      channel;
+	uint32_t handle;
+	int      count;
+
+	uint32_t offset;
+};
+
+struct drm_nouveau_gpuobj_free {
+	int      channel;
+	uint32_t handle;
+};
+
+#define NOUVEAU_MEM_FB			0x00000001
+#define NOUVEAU_MEM_AGP			0x00000002
+#define NOUVEAU_MEM_FB_ACCEPTABLE	0x00000004
+#define NOUVEAU_MEM_AGP_ACCEPTABLE	0x00000008
+#define NOUVEAU_MEM_PCI			0x00000010
+#define NOUVEAU_MEM_PCI_ACCEPTABLE	0x00000020
+#define NOUVEAU_MEM_PINNED		0x00000040
+#define NOUVEAU_MEM_USER_BACKED		0x00000080
+#define NOUVEAU_MEM_MAPPED		0x00000100
+#define NOUVEAU_MEM_INSTANCE		0x00000200 /* internal */
+#define NOUVEAU_MEM_NOTIFIER            0x00000400 /* internal */
+
+struct drm_nouveau_mem_alloc {
+	int flags;
+	int alignment;
+	uint64_t size;	// in bytes
+	uint64_t offset;
+	drm_handle_t map_handle;
+};
+
+struct drm_nouveau_mem_free {
+	uint64_t offset;
+	int flags;
+};
+
+/* FIXME : maybe unify {GET,SET}PARAMs */
+#define NOUVEAU_GETPARAM_PCI_VENDOR      3
+#define NOUVEAU_GETPARAM_PCI_DEVICE      4
+#define NOUVEAU_GETPARAM_BUS_TYPE        5
+#define NOUVEAU_GETPARAM_FB_PHYSICAL     6
+#define NOUVEAU_GETPARAM_AGP_PHYSICAL    7
+#define NOUVEAU_GETPARAM_FB_SIZE         8
+#define NOUVEAU_GETPARAM_AGP_SIZE        9
+#define NOUVEAU_GETPARAM_PCI_PHYSICAL    10
+#define NOUVEAU_GETPARAM_CHIPSET_ID      11
+struct drm_nouveau_getparam {
+	uint64_t param;
+	uint64_t value;
+};
+
+#define NOUVEAU_SETPARAM_CMDBUF_LOCATION 1
+#define NOUVEAU_SETPARAM_CMDBUF_SIZE     2
+struct drm_nouveau_setparam {
+	uint64_t param;
+	uint64_t value;
+};
+
+enum nouveau_card_type {
+	NV_UNKNOWN =0,
+	NV_04      =4,
+	NV_05      =5,
+	NV_10      =10,
+	NV_11      =11,
+	NV_15      =11,
+	NV_17      =17,
+	NV_20      =20,
+	NV_25      =20,
+	NV_30      =30,
+	NV_34      =30,
+	NV_40      =40,
+	NV_44      =44,
+	NV_50      =50,
+	NV_LAST    =0xffff,
+};
+
+enum nouveau_bus_type {
+	NV_AGP     =0,
+	NV_PCI     =1,
+	NV_PCIE    =2,
+};
+
+#define NOUVEAU_MAX_SAREA_CLIPRECTS 16
+
+struct drm_nouveau_sarea {
+	/* the cliprects */
+	struct drm_clip_rect boxes[NOUVEAU_MAX_SAREA_CLIPRECTS];
+	unsigned int nbox;
+};
+
+#define DRM_NOUVEAU_CARD_INIT          0x00
+#define DRM_NOUVEAU_GETPARAM           0x01
+#define DRM_NOUVEAU_SETPARAM           0x02
+#define DRM_NOUVEAU_CHANNEL_ALLOC      0x03
+#define DRM_NOUVEAU_CHANNEL_FREE       0x04
+#define DRM_NOUVEAU_GROBJ_ALLOC        0x05
+#define DRM_NOUVEAU_NOTIFIEROBJ_ALLOC  0x06
+#define DRM_NOUVEAU_GPUOBJ_FREE        0x07
+#define DRM_NOUVEAU_MEM_ALLOC          0x08
+#define DRM_NOUVEAU_MEM_FREE           0x09
+
+#endif /* __NOUVEAU_DRM_H__ */
+
Index: git/shared-core/nouveau_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nouveau_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,584 @@
+/*
+ * Copyright 2005 Stephane Marchesin.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __NOUVEAU_DRV_H__
+#define __NOUVEAU_DRV_H__
+
+#define DRIVER_AUTHOR		"Stephane Marchesin"
+#define DRIVER_EMAIL		"dri-devel@lists.sourceforge.net"
+
+#define DRIVER_NAME		"nouveau"
+#define DRIVER_DESC		"nVidia Riva/TNT/GeForce"
+#define DRIVER_DATE		"20060213"
+
+#define DRIVER_MAJOR		0
+#define DRIVER_MINOR		0
+#define DRIVER_PATCHLEVEL	10
+
+#define NOUVEAU_FAMILY   0x0000FFFF
+#define NOUVEAU_FLAGS    0xFFFF0000
+
+#include "nouveau_drm.h"
+#include "nouveau_reg.h"
+
+struct mem_block {
+	struct mem_block *next;
+	struct mem_block *prev;
+	uint64_t start;
+	uint64_t size;
+	struct drm_file *file_priv; /* NULL: free, -1: heap, other: real files */
+	int flags;
+	drm_local_map_t *map;
+	drm_handle_t map_handle;
+};
+
+enum nouveau_flags {
+	NV_NFORCE   =0x10000000,
+	NV_NFORCE2  =0x20000000
+};
+
+#define NVOBJ_ENGINE_SW		0
+#define NVOBJ_ENGINE_GR  	1
+#define NVOBJ_ENGINE_INT	0xdeadbeef
+
+#define NVOBJ_FLAG_ALLOW_NO_REFS	(1 << 0)
+#define NVOBJ_FLAG_ZERO_ALLOC		(1 << 1)
+#define NVOBJ_FLAG_ZERO_FREE		(1 << 2)
+#define NVOBJ_FLAG_FAKE			(1 << 3)
+struct nouveau_gpuobj {
+	struct list_head list;
+
+	int im_channel;
+	struct mem_block *im_pramin;
+	struct mem_block *im_backing;
+	int im_bound;
+
+	uint32_t flags;
+	int refcount;
+
+	uint32_t engine;
+	uint32_t class;
+
+	void (*dtor)(struct drm_device *, struct nouveau_gpuobj *);
+	void *priv;
+};
+
+struct nouveau_gpuobj_ref {
+	struct list_head list;
+
+	struct nouveau_gpuobj *gpuobj;
+	uint32_t instance;
+
+	int channel;
+	int handle;
+};
+
+struct nouveau_channel
+{
+	struct drm_device *dev;
+	int id;
+
+	/* owner of this fifo */
+	struct drm_file *file_priv;
+	/* mapping of the fifo itself */
+	drm_local_map_t *map;
+	/* mapping of the regs controling the fifo */
+	drm_local_map_t *regs;
+
+	/* DMA push buffer */
+	struct nouveau_gpuobj_ref *pushbuf;
+	struct mem_block          *pushbuf_mem;
+	uint32_t                   pushbuf_base;
+
+	/* Notifier memory */
+	struct mem_block *notifier_block;
+	struct mem_block *notifier_heap;
+	drm_local_map_t  *notifier_map;
+
+	/* PFIFO context */
+	struct nouveau_gpuobj_ref *ramfc;
+
+	/* PGRAPH context */
+	struct nouveau_gpuobj_ref *ramin_grctx;
+	uint32_t pgraph_ctx [340]; /* XXX dynamic alloc ? */
+
+	/* NV50 VM */
+	struct nouveau_gpuobj     *vm_pd;
+	struct nouveau_gpuobj_ref *vm_gart_pt;
+
+	/* Objects */
+	struct nouveau_gpuobj_ref *ramin; /* Private instmem */
+	struct mem_block          *ramin_heap; /* Private PRAMIN heap */
+	struct nouveau_gpuobj_ref *ramht; /* Hash table */
+	struct list_head           ramht_refs; /* Objects referenced by RAMHT */
+};
+
+struct nouveau_drm_channel {
+	struct nouveau_channel *chan;
+
+	/* DMA state */
+	int max, put, cur, free;
+	int push_free;
+	volatile uint32_t *pushbuf;
+
+	/* Notifiers */
+	uint32_t notify0_offset;
+
+	/* Buffer moves */
+	uint32_t m2mf_dma_source;
+	uint32_t m2mf_dma_destin;
+};
+
+struct nouveau_config {
+	struct {
+		int location;
+		int size;
+	} cmdbuf;
+};
+
+struct nouveau_instmem_engine {
+	void	*priv;
+
+	int	(*init)(struct drm_device *dev);
+	void	(*takedown)(struct drm_device *dev);
+
+	int	(*populate)(struct drm_device *, struct nouveau_gpuobj *,
+			    uint32_t *size);
+	void	(*clear)(struct drm_device *, struct nouveau_gpuobj *);
+	int	(*bind)(struct drm_device *, struct nouveau_gpuobj *);
+	int	(*unbind)(struct drm_device *, struct nouveau_gpuobj *);
+};
+
+struct nouveau_mc_engine {
+	int  (*init)(struct drm_device *dev);
+	void (*takedown)(struct drm_device *dev);
+};
+
+struct nouveau_timer_engine {
+	int      (*init)(struct drm_device *dev);
+	void     (*takedown)(struct drm_device *dev);
+	uint64_t (*read)(struct drm_device *dev);
+};
+
+struct nouveau_fb_engine {
+	int  (*init)(struct drm_device *dev);
+	void (*takedown)(struct drm_device *dev);
+};
+
+struct nouveau_fifo_engine {
+	void *priv;
+
+	int  (*init)(struct drm_device *);
+	void (*takedown)(struct drm_device *);
+
+	int  (*create_context)(struct nouveau_channel *);
+	void (*destroy_context)(struct nouveau_channel *);
+	int  (*load_context)(struct nouveau_channel *);
+	int  (*save_context)(struct nouveau_channel *);
+};
+
+struct nouveau_pgraph_engine {
+	int  (*init)(struct drm_device *);
+	void (*takedown)(struct drm_device *);
+
+	int  (*create_context)(struct nouveau_channel *);
+	void (*destroy_context)(struct nouveau_channel *);
+	int  (*load_context)(struct nouveau_channel *);
+	int  (*save_context)(struct nouveau_channel *);
+};
+
+struct nouveau_engine {
+	struct nouveau_instmem_engine instmem;
+	struct nouveau_mc_engine      mc;
+	struct nouveau_timer_engine   timer;
+	struct nouveau_fb_engine      fb;
+	struct nouveau_pgraph_engine  graph;
+	struct nouveau_fifo_engine    fifo;
+};
+
+struct drm_nouveau_private {
+	enum {
+		NOUVEAU_CARD_INIT_DOWN,
+		NOUVEAU_CARD_INIT_DONE,
+		NOUVEAU_CARD_INIT_FAILED
+	} init_state;
+
+	/* the card type, takes NV_* as values */
+	int card_type;
+	/* exact chipset, derived from NV_PMC_BOOT_0 */
+	int chipset;
+	int flags;
+
+	drm_local_map_t *mmio;
+	drm_local_map_t *fb;
+	drm_local_map_t *ramin; /* NV40 onwards */
+
+	int fifo_alloc_count;
+	struct nouveau_channel *fifos[NV_MAX_FIFO_NUMBER];
+
+	struct nouveau_engine Engine;
+	struct nouveau_drm_channel channel;
+
+	/* RAMIN configuration, RAMFC, RAMHT and RAMRO offsets */
+	struct nouveau_gpuobj *ramht;
+	uint32_t ramin_rsvd_vram;
+	uint32_t ramht_offset;
+	uint32_t ramht_size;
+	uint32_t ramht_bits;
+	uint32_t ramfc_offset;
+	uint32_t ramfc_size;
+	uint32_t ramro_offset;
+	uint32_t ramro_size;
+
+	/* base physical adresses */
+	uint64_t fb_phys;
+	uint64_t fb_available_size;
+
+	struct {
+		enum {
+			NOUVEAU_GART_NONE = 0,
+			NOUVEAU_GART_AGP,
+			NOUVEAU_GART_SGDMA
+		} type;
+		uint64_t aper_base;
+		uint64_t aper_size;
+
+		struct nouveau_gpuobj *sg_ctxdma;
+		struct page *sg_dummy_page;
+		dma_addr_t sg_dummy_bus;
+
+		/* nottm hack */
+		struct drm_ttm_backend *sg_be;
+		unsigned long sg_handle;
+	} gart_info;
+
+	/* the mtrr covering the FB */
+	int fb_mtrr;
+
+	struct mem_block *agp_heap;
+	struct mem_block *fb_heap;
+	struct mem_block *fb_nomap_heap;
+	struct mem_block *ramin_heap;
+	struct mem_block *pci_heap;
+
+        /* context table pointed to be NV_PGRAPH_CHANNEL_CTX_TABLE (0x400780) */
+        uint32_t ctx_table_size;
+	struct nouveau_gpuobj_ref *ctx_table;
+
+	struct nouveau_config config;
+
+	struct list_head gpuobj_list;
+};
+
+#define NOUVEAU_CHECK_INITIALISED_WITH_RETURN do {         \
+	struct drm_nouveau_private *nv = dev->dev_private; \
+	if (nv->init_state != NOUVEAU_CARD_INIT_DONE) {    \
+		DRM_ERROR("called without init\n");        \
+		return -EINVAL;                            \
+	}                                                  \
+} while(0)
+
+#define NOUVEAU_GET_USER_CHANNEL_WITH_RETURN(id,cl,ch) do {  \
+	struct drm_nouveau_private *nv = dev->dev_private;   \
+	if (!nouveau_fifo_owner(dev, (cl), (id))) {          \
+		DRM_ERROR("pid %d doesn't own channel %d\n", \
+			  DRM_CURRENTPID, (id));             \
+		return -EPERM;                               \
+	}                                                    \
+	(ch) = nv->fifos[(id)];                              \
+} while(0)
+
+/* nouveau_state.c */
+extern void nouveau_preclose(struct drm_device *dev, struct drm_file *);
+extern int  nouveau_load(struct drm_device *, unsigned long flags);
+extern int  nouveau_firstopen(struct drm_device *);
+extern void nouveau_lastclose(struct drm_device *);
+extern int  nouveau_unload(struct drm_device *);
+extern int  nouveau_ioctl_getparam(struct drm_device *, void *data,
+				   struct drm_file *);
+extern int  nouveau_ioctl_setparam(struct drm_device *, void *data,
+				   struct drm_file *);
+extern void nouveau_wait_for_idle(struct drm_device *);
+extern int  nouveau_card_init(struct drm_device *);
+extern int  nouveau_ioctl_card_init(struct drm_device *, void *data,
+				    struct drm_file *);
+
+/* nouveau_mem.c */
+extern int  nouveau_mem_init_heap(struct mem_block **, uint64_t start,
+				 uint64_t size);
+extern struct mem_block *nouveau_mem_alloc_block(struct mem_block *,
+						 uint64_t size, int align2,
+						 struct drm_file *);
+extern void nouveau_mem_takedown(struct mem_block **heap);
+extern void nouveau_mem_free_block(struct mem_block *);
+extern uint64_t nouveau_mem_fb_amount(struct drm_device *);
+extern void nouveau_mem_release(struct drm_file *, struct mem_block *heap);
+extern int  nouveau_ioctl_mem_alloc(struct drm_device *, void *data,
+				    struct drm_file *);
+extern int  nouveau_ioctl_mem_free(struct drm_device *, void *data,
+				   struct drm_file *);
+extern struct mem_block* nouveau_mem_alloc(struct drm_device *,
+					   int alignment, uint64_t size,
+					   int flags, struct drm_file *);
+extern void nouveau_mem_free(struct drm_device *dev, struct mem_block*);
+extern int  nouveau_mem_init(struct drm_device *);
+extern void nouveau_mem_close(struct drm_device *);
+
+/* nouveau_notifier.c */
+extern int  nouveau_notifier_init_channel(struct nouveau_channel *);
+extern void nouveau_notifier_takedown_channel(struct nouveau_channel *);
+extern int  nouveau_notifier_alloc(struct nouveau_channel *, uint32_t handle,
+				   int cout, uint32_t *offset);
+extern int  nouveau_ioctl_notifier_alloc(struct drm_device *, void *data,
+					 struct drm_file *);
+extern int  nouveau_ioctl_notifier_free(struct drm_device *, void *data,
+					struct drm_file *);
+
+/* nouveau_fifo.c */
+extern int  nouveau_fifo_init(struct drm_device *);
+extern int  nouveau_fifo_number(struct drm_device *);
+extern int  nouveau_fifo_ctx_size(struct drm_device *);
+extern void nouveau_fifo_cleanup(struct drm_device *, struct drm_file *);
+extern int  nouveau_fifo_owner(struct drm_device *, struct drm_file *,
+			       int channel);
+extern int  nouveau_fifo_alloc(struct drm_device *dev,
+			       struct nouveau_channel **chan,
+			       struct drm_file *file_priv,
+			       struct mem_block *pushbuf,
+			       uint32_t fb_ctxdma, uint32_t tt_ctxdma);
+extern void nouveau_fifo_free(struct nouveau_channel *);
+
+/* nouveau_object.c */
+extern int  nouveau_gpuobj_early_init(struct drm_device *);
+extern int  nouveau_gpuobj_init(struct drm_device *);
+extern void nouveau_gpuobj_takedown(struct drm_device *);
+extern void nouveau_gpuobj_late_takedown(struct drm_device *);
+extern int nouveau_gpuobj_channel_init(struct nouveau_channel *,
+				       uint32_t vram_h, uint32_t tt_h);
+extern void nouveau_gpuobj_channel_takedown(struct nouveau_channel *);
+extern int nouveau_gpuobj_new(struct drm_device *, struct nouveau_channel *,
+			      int size, int align, uint32_t flags,
+			      struct nouveau_gpuobj **);
+extern int nouveau_gpuobj_del(struct drm_device *, struct nouveau_gpuobj **);
+extern int nouveau_gpuobj_ref_add(struct drm_device *, struct nouveau_channel *,
+				  uint32_t handle, struct nouveau_gpuobj *,
+				  struct nouveau_gpuobj_ref **);
+extern int nouveau_gpuobj_ref_del(struct drm_device *,
+				  struct nouveau_gpuobj_ref **);
+extern int nouveau_gpuobj_ref_find(struct nouveau_channel *, uint32_t handle,
+				   struct nouveau_gpuobj_ref **ref_ret);
+extern int nouveau_gpuobj_new_ref(struct drm_device *,
+				  struct nouveau_channel *alloc_chan,
+				  struct nouveau_channel *ref_chan,
+				  uint32_t handle, int size, int align,
+				  uint32_t flags, struct nouveau_gpuobj_ref **);
+extern int nouveau_gpuobj_new_fake(struct drm_device *,
+				   uint32_t p_offset, uint32_t b_offset,
+				   uint32_t size, uint32_t flags,
+				   struct nouveau_gpuobj **,
+				   struct nouveau_gpuobj_ref**);
+extern int nouveau_gpuobj_dma_new(struct nouveau_channel *, int class,
+				  uint64_t offset, uint64_t size, int access,
+				  int target, struct nouveau_gpuobj **);
+extern int nouveau_gpuobj_gart_dma_new(struct nouveau_channel *,
+				       uint64_t offset, uint64_t size,
+				       int access, struct nouveau_gpuobj **,
+				       uint32_t *o_ret);
+extern int nouveau_gpuobj_gr_new(struct nouveau_channel *, int class,
+				 struct nouveau_gpuobj **);
+extern int nouveau_ioctl_grobj_alloc(struct drm_device *, void *data,
+				     struct drm_file *);
+extern int nouveau_ioctl_gpuobj_free(struct drm_device *, void *data,
+				     struct drm_file *);
+
+/* nouveau_irq.c */
+extern irqreturn_t nouveau_irq_handler(DRM_IRQ_ARGS);
+extern void        nouveau_irq_preinstall(struct drm_device *);
+extern void        nouveau_irq_postinstall(struct drm_device *);
+extern void        nouveau_irq_uninstall(struct drm_device *);
+
+/* nouveau_sgdma.c */
+extern int nouveau_sgdma_init(struct drm_device *);
+extern void nouveau_sgdma_takedown(struct drm_device *);
+extern int nouveau_sgdma_get_page(struct drm_device *, uint32_t offset,
+				  uint32_t *page);
+extern struct drm_ttm_backend *nouveau_sgdma_init_ttm(struct drm_device *);
+extern int nouveau_sgdma_nottm_hack_init(struct drm_device *);
+extern void nouveau_sgdma_nottm_hack_takedown(struct drm_device *);
+
+/* nouveau_dma.c */
+extern int  nouveau_dma_channel_init(struct drm_device *);
+extern void nouveau_dma_channel_takedown(struct drm_device *);
+extern int  nouveau_dma_wait(struct drm_device *, int size);
+
+/* nv04_fb.c */
+extern int  nv04_fb_init(struct drm_device *);
+extern void nv04_fb_takedown(struct drm_device *);
+
+/* nv10_fb.c */
+extern int  nv10_fb_init(struct drm_device *);
+extern void nv10_fb_takedown(struct drm_device *);
+
+/* nv40_fb.c */
+extern int  nv40_fb_init(struct drm_device *);
+extern void nv40_fb_takedown(struct drm_device *);
+
+/* nv04_fifo.c */
+extern int  nv04_fifo_create_context(struct nouveau_channel *);
+extern void nv04_fifo_destroy_context(struct nouveau_channel *);
+extern int  nv04_fifo_load_context(struct nouveau_channel *);
+extern int  nv04_fifo_save_context(struct nouveau_channel *);
+
+/* nv10_fifo.c */
+extern int  nv10_fifo_create_context(struct nouveau_channel *);
+extern void nv10_fifo_destroy_context(struct nouveau_channel *);
+extern int  nv10_fifo_load_context(struct nouveau_channel *);
+extern int  nv10_fifo_save_context(struct nouveau_channel *);
+
+/* nv40_fifo.c */
+extern int  nv40_fifo_init(struct drm_device *);
+extern int  nv40_fifo_create_context(struct nouveau_channel *);
+extern void nv40_fifo_destroy_context(struct nouveau_channel *);
+extern int  nv40_fifo_load_context(struct nouveau_channel *);
+extern int  nv40_fifo_save_context(struct nouveau_channel *);
+
+/* nv50_fifo.c */
+extern int  nv50_fifo_init(struct drm_device *);
+extern void nv50_fifo_takedown(struct drm_device *);
+extern int  nv50_fifo_create_context(struct nouveau_channel *);
+extern void nv50_fifo_destroy_context(struct nouveau_channel *);
+extern int  nv50_fifo_load_context(struct nouveau_channel *);
+extern int  nv50_fifo_save_context(struct nouveau_channel *);
+
+/* nv04_graph.c */
+extern void nouveau_nv04_context_switch(struct drm_device *);
+extern int  nv04_graph_init(struct drm_device *);
+extern void nv04_graph_takedown(struct drm_device *);
+extern int  nv04_graph_create_context(struct nouveau_channel *);
+extern void nv04_graph_destroy_context(struct nouveau_channel *);
+extern int  nv04_graph_load_context(struct nouveau_channel *);
+extern int  nv04_graph_save_context(struct nouveau_channel *);
+
+/* nv10_graph.c */
+extern void nouveau_nv10_context_switch(struct drm_device *);
+extern int  nv10_graph_init(struct drm_device *);
+extern void nv10_graph_takedown(struct drm_device *);
+extern int  nv10_graph_create_context(struct nouveau_channel *);
+extern void nv10_graph_destroy_context(struct nouveau_channel *);
+extern int  nv10_graph_load_context(struct nouveau_channel *);
+extern int  nv10_graph_save_context(struct nouveau_channel *);
+
+/* nv20_graph.c */
+extern void nouveau_nv20_context_switch(struct drm_device *);
+extern int  nv20_graph_init(struct drm_device *);
+extern void nv20_graph_takedown(struct drm_device *);
+extern int  nv20_graph_create_context(struct nouveau_channel *);
+extern void nv20_graph_destroy_context(struct nouveau_channel *);
+extern int  nv20_graph_load_context(struct nouveau_channel *);
+extern int  nv20_graph_save_context(struct nouveau_channel *);
+
+/* nv30_graph.c */
+extern int  nv30_graph_init(struct drm_device *);
+extern void nv30_graph_takedown(struct drm_device *);
+extern int  nv30_graph_create_context(struct nouveau_channel *);
+extern void nv30_graph_destroy_context(struct nouveau_channel *);
+extern int  nv30_graph_load_context(struct nouveau_channel *);
+extern int  nv30_graph_save_context(struct nouveau_channel *);
+
+/* nv40_graph.c */
+extern int  nv40_graph_init(struct drm_device *);
+extern void nv40_graph_takedown(struct drm_device *);
+extern int  nv40_graph_create_context(struct nouveau_channel *);
+extern void nv40_graph_destroy_context(struct nouveau_channel *);
+extern int  nv40_graph_load_context(struct nouveau_channel *);
+extern int  nv40_graph_save_context(struct nouveau_channel *);
+
+/* nv50_graph.c */
+extern int  nv50_graph_init(struct drm_device *);
+extern void nv50_graph_takedown(struct drm_device *);
+extern int  nv50_graph_create_context(struct nouveau_channel *);
+extern void nv50_graph_destroy_context(struct nouveau_channel *);
+extern int  nv50_graph_load_context(struct nouveau_channel *);
+extern int  nv50_graph_save_context(struct nouveau_channel *);
+
+/* nv04_instmem.c */
+extern int  nv04_instmem_init(struct drm_device *);
+extern void nv04_instmem_takedown(struct drm_device *);
+extern int  nv04_instmem_populate(struct drm_device *, struct nouveau_gpuobj *,
+				  uint32_t *size);
+extern void nv04_instmem_clear(struct drm_device *, struct nouveau_gpuobj *);
+extern int  nv04_instmem_bind(struct drm_device *, struct nouveau_gpuobj *);
+extern int  nv04_instmem_unbind(struct drm_device *, struct nouveau_gpuobj *);
+
+/* nv50_instmem.c */
+extern int  nv50_instmem_init(struct drm_device *);
+extern void nv50_instmem_takedown(struct drm_device *);
+extern int  nv50_instmem_populate(struct drm_device *, struct nouveau_gpuobj *,
+				  uint32_t *size);
+extern void nv50_instmem_clear(struct drm_device *, struct nouveau_gpuobj *);
+extern int  nv50_instmem_bind(struct drm_device *, struct nouveau_gpuobj *);
+extern int  nv50_instmem_unbind(struct drm_device *, struct nouveau_gpuobj *);
+
+/* nv04_mc.c */
+extern int  nv04_mc_init(struct drm_device *);
+extern void nv04_mc_takedown(struct drm_device *);
+
+/* nv40_mc.c */
+extern int  nv40_mc_init(struct drm_device *);
+extern void nv40_mc_takedown(struct drm_device *);
+
+/* nv50_mc.c */
+extern int  nv50_mc_init(struct drm_device *);
+extern void nv50_mc_takedown(struct drm_device *);
+
+/* nv04_timer.c */
+extern int  nv04_timer_init(struct drm_device *);
+extern uint64_t nv04_timer_read(struct drm_device *);
+extern void nv04_timer_takedown(struct drm_device *);
+
+extern long nouveau_compat_ioctl(struct file *file, unsigned int cmd,
+				 unsigned long arg);
+
+#if defined(__powerpc__)
+#define NV_READ(reg)        in_be32((void __iomem *)(dev_priv->mmio)->handle + (reg) )
+#define NV_WRITE(reg,val)   out_be32((void __iomem *)(dev_priv->mmio)->handle + (reg) , (val) )
+#else
+#define NV_READ(reg)        DRM_READ32(  dev_priv->mmio, (reg) )
+#define NV_WRITE(reg,val)   DRM_WRITE32( dev_priv->mmio, (reg), (val) )
+#endif
+
+/* PRAMIN access */
+#if defined(__powerpc__)
+#define NV_RI32(o) in_be32((void __iomem *)(dev_priv->ramin)->handle+(o))
+#define NV_WI32(o,v) out_be32((void __iomem*)(dev_priv->ramin)->handle+(o), (v))
+#else
+#define NV_RI32(o) DRM_READ32(dev_priv->ramin, (o))
+#define NV_WI32(o,v) DRM_WRITE32(dev_priv->ramin, (o), (v))
+#endif
+
+#define INSTANCE_RD(o,i) NV_RI32((o)->im_pramin->start + ((i)<<2))
+#define INSTANCE_WR(o,i,v) NV_WI32((o)->im_pramin->start + ((i)<<2), (v))
+
+#endif /* __NOUVEAU_DRV_H__ */
+
Index: git/shared-core/nouveau_fifo.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nouveau_fifo.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,554 @@
+/* 
+ * Copyright 2005-2006 Stephane Marchesin
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+
+/* returns the number of hw fifos */
+int nouveau_fifo_number(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv=dev->dev_private;
+	switch(dev_priv->card_type)
+	{
+		case NV_04:
+		case NV_05:
+			return 16;
+		case NV_50:
+			return 128;
+		default:
+			return 32;
+	}
+}
+
+/* returns the size of fifo context */
+int nouveau_fifo_ctx_size(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv=dev->dev_private;
+
+	if (dev_priv->card_type >= NV_40)
+		return 128;
+	else if (dev_priv->card_type >= NV_17)
+		return 64;
+	else
+		return 32;
+}
+
+/***********************************
+ * functions doing the actual work
+ ***********************************/
+
+/* voir nv_xaa.c : NVResetGraphics
+ * mmoire mappe par nv_driver.c : NVMapMem
+ * voir nv_driver.c : NVPreInit 
+ */
+
+static int nouveau_fifo_instmem_configure(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	NV_WRITE(NV03_PFIFO_RAMHT,
+			(0x03 << 24) /* search 128 */ | 
+			((dev_priv->ramht_bits - 9) << 16) |
+			(dev_priv->ramht_offset >> 8)
+			);
+
+	NV_WRITE(NV03_PFIFO_RAMRO, dev_priv->ramro_offset>>8);
+
+	switch(dev_priv->card_type)
+	{
+		case NV_50:
+		case NV_40:
+			switch (dev_priv->chipset) {
+			case 0x47:
+			case 0x49:
+			case 0x4b:
+				NV_WRITE(0x2230, 1);
+				break;
+			default:
+				break;
+			}
+			NV_WRITE(NV40_PFIFO_RAMFC, 0x30002);
+			break;
+		case NV_44:
+			NV_WRITE(NV40_PFIFO_RAMFC, ((nouveau_mem_fb_amount(dev)-512*1024+dev_priv->ramfc_offset)>>16) |
+					(2 << 16));
+			break;
+		case NV_30:
+		case NV_20:
+		case NV_17:
+			NV_WRITE(NV03_PFIFO_RAMFC, (dev_priv->ramfc_offset>>8) |
+					(1 << 16) /* 64 Bytes entry*/);
+			/* XXX nvidia blob set bit 18, 21,23 for nv20 & nv30 */
+			break;
+		case NV_11:
+		case NV_10:
+		case NV_04:
+			NV_WRITE(NV03_PFIFO_RAMFC, dev_priv->ramfc_offset>>8);
+			break;
+	}
+
+	return 0;
+}
+
+int nouveau_fifo_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int ret;
+
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) &
+			~NV_PMC_ENABLE_PFIFO);
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) |
+			 NV_PMC_ENABLE_PFIFO);
+
+	/* Enable PFIFO error reporting */
+	NV_WRITE(NV03_PFIFO_INTR_0, 0xFFFFFFFF);
+	NV_WRITE(NV03_PFIFO_INTR_EN_0, 0xFFFFFFFF);
+
+	NV_WRITE(NV03_PFIFO_CACHES, 0x00000000);
+
+	ret = nouveau_fifo_instmem_configure(dev);
+	if (ret) {
+		DRM_ERROR("Failed to configure instance memory\n");
+		return ret;
+	}
+
+	/* FIXME remove all the stuff that's done in nouveau_fifo_alloc */
+
+	DRM_DEBUG("Setting defaults for remaining PFIFO regs\n");
+
+	/* All channels into PIO mode */
+	NV_WRITE(NV04_PFIFO_MODE, 0x00000000);
+
+	NV_WRITE(NV03_PFIFO_CACHE1_PUSH0, 0x00000000);
+	NV_WRITE(NV04_PFIFO_CACHE1_PULL0, 0x00000000);
+	/* Channel 0 active, PIO mode */
+	NV_WRITE(NV03_PFIFO_CACHE1_PUSH1, 0x00000000);
+	/* PUT and GET to 0 */
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_PUT, 0x00000000);
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_GET, 0x00000000);
+	/* No cmdbuf object */
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_INSTANCE, 0x00000000);
+	NV_WRITE(NV03_PFIFO_CACHE0_PUSH0, 0x00000000);
+	NV_WRITE(NV03_PFIFO_CACHE0_PULL0, 0x00000000);
+	NV_WRITE(NV04_PFIFO_SIZE, 0x0000FFFF);
+	NV_WRITE(NV04_PFIFO_CACHE1_HASH, 0x0000FFFF);
+	NV_WRITE(NV04_PFIFO_CACHE0_PULL1, 0x00000001);
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_CTL, 0x00000000);
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_STATE, 0x00000000);
+	NV_WRITE(NV04_PFIFO_CACHE1_ENGINE, 0x00000000);
+
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_FETCH, NV_PFIFO_CACHE1_DMA_FETCH_TRIG_112_BYTES |
+				      NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
+				      NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_4 |
+#ifdef __BIG_ENDIAN
+				      NV_PFIFO_CACHE1_BIG_ENDIAN |
+#endif				      
+				      0x00000000);
+
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_PUSH, 0x00000001);
+	NV_WRITE(NV03_PFIFO_CACHE1_PUSH0, 0x00000001);
+	NV_WRITE(NV04_PFIFO_CACHE1_PULL0, 0x00000001);
+	NV_WRITE(NV04_PFIFO_CACHE1_PULL1, 0x00000001);
+
+	/* FIXME on NV04 */
+	if (dev_priv->card_type >= NV_10) {
+		NV_WRITE(NV10_PGRAPH_CTX_USER, 0x0);
+		NV_WRITE(NV04_PFIFO_DELAY_0, 0xff /* retrycount*/ );
+		if (dev_priv->card_type >= NV_40)
+			NV_WRITE(NV10_PGRAPH_CTX_CONTROL, 0x00002001);
+		else
+			NV_WRITE(NV10_PGRAPH_CTX_CONTROL, 0x10110000);
+	} else {
+		NV_WRITE(NV04_PGRAPH_CTX_USER, 0x0);
+		NV_WRITE(NV04_PFIFO_DELAY_0, 0xff /* retrycount*/ );
+		NV_WRITE(NV04_PGRAPH_CTX_CONTROL, 0x10110000);
+	}
+
+	NV_WRITE(NV04_PFIFO_DMA_TIMESLICE, 0x001fffff);
+	NV_WRITE(NV03_PFIFO_CACHES, 0x00000001);
+	return 0;
+}
+
+static int
+nouveau_fifo_pushbuf_ctxdma_init(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct mem_block *pb = chan->pushbuf_mem;
+	struct nouveau_gpuobj *pushbuf = NULL;
+	int ret;
+
+	if (pb->flags & NOUVEAU_MEM_AGP) {
+		ret = nouveau_gpuobj_gart_dma_new(chan, pb->start, pb->size,
+						  NV_DMA_ACCESS_RO,
+						  &pushbuf,
+						  &chan->pushbuf_base);
+	} else
+	if (pb->flags & NOUVEAU_MEM_PCI) {
+		ret = nouveau_gpuobj_dma_new(chan, NV_CLASS_DMA_IN_MEMORY,
+					     pb->start, pb->size,
+					     NV_DMA_ACCESS_RO,
+					     NV_DMA_TARGET_PCI_NONLINEAR,
+					     &pushbuf);
+		chan->pushbuf_base = 0;
+	} else if (dev_priv->card_type != NV_04) {
+		ret = nouveau_gpuobj_dma_new(chan, NV_CLASS_DMA_IN_MEMORY,
+					     pb->start, pb->size,
+					     NV_DMA_ACCESS_RO,
+					     NV_DMA_TARGET_VIDMEM, &pushbuf);
+		chan->pushbuf_base = 0;
+	} else {
+		/* NV04 cmdbuf hack, from original ddx.. not sure of it's
+		 * exact reason for existing :)  PCI access to cmdbuf in
+		 * VRAM.
+		 */
+		ret = nouveau_gpuobj_dma_new(chan, NV_CLASS_DMA_IN_MEMORY,
+					     pb->start +
+					       drm_get_resource_start(dev, 1),
+					     pb->size, NV_DMA_ACCESS_RO,
+					     NV_DMA_TARGET_PCI, &pushbuf);
+		chan->pushbuf_base = 0;
+	}
+
+	if ((ret = nouveau_gpuobj_ref_add(dev, chan, 0, pushbuf,
+					  &chan->pushbuf))) {
+		DRM_ERROR("Error referencing push buffer ctxdma: %d\n", ret);
+		if (pushbuf != dev_priv->gart_info.sg_ctxdma)
+			nouveau_gpuobj_del(dev, &pushbuf);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct mem_block *
+nouveau_fifo_user_pushbuf_alloc(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_config *config = &dev_priv->config;
+	struct mem_block *pb;
+	int pb_min_size = max(NV03_FIFO_SIZE,PAGE_SIZE);
+
+	/* Defaults for unconfigured values */
+	if (!config->cmdbuf.location)
+		config->cmdbuf.location = NOUVEAU_MEM_FB;
+	if (!config->cmdbuf.size || config->cmdbuf.size < pb_min_size)
+		config->cmdbuf.size = pb_min_size;
+
+	pb = nouveau_mem_alloc(dev, 0, config->cmdbuf.size,
+			       config->cmdbuf.location | NOUVEAU_MEM_MAPPED,
+			       (struct drm_file *)-2);
+	if (!pb)
+		DRM_ERROR("Couldn't allocate DMA push buffer.\n");
+
+	return pb;
+}
+
+/* allocates and initializes a fifo for user space consumption */
+int
+nouveau_fifo_alloc(struct drm_device *dev, struct nouveau_channel **chan_ret,
+		   struct drm_file *file_priv, struct mem_block *pushbuf,
+		   uint32_t vram_handle, uint32_t tt_handle)
+{
+	int ret;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_engine *engine = &dev_priv->Engine;
+	struct nouveau_channel *chan;
+	int channel;
+
+	/*
+	 * Alright, here is the full story
+	 * Nvidia cards have multiple hw fifo contexts (praise them for that, 
+	 * no complicated crash-prone context switches)
+	 * We allocate a new context for each app and let it write to it directly 
+	 * (woo, full userspace command submission !)
+	 * When there are no more contexts, you lost
+	 */
+	for(channel=0; channel<nouveau_fifo_number(dev); channel++) {
+		if (dev_priv->fifos[channel] == NULL)
+			break;
+	}
+	/* no more fifos. you lost. */
+	if (channel==nouveau_fifo_number(dev))
+		return -EINVAL;
+
+	dev_priv->fifos[channel] = drm_calloc(1, sizeof(struct nouveau_channel),
+					      DRM_MEM_DRIVER);
+	if (!dev_priv->fifos[channel])
+		return -ENOMEM;
+	dev_priv->fifo_alloc_count++;
+	chan = dev_priv->fifos[channel];
+	chan->dev = dev;
+	chan->id = channel;
+	chan->file_priv = file_priv;
+	chan->pushbuf_mem = pushbuf;
+
+	DRM_INFO("Allocating FIFO number %d\n", channel);
+
+	/* Allocate space for per-channel fixed notifier memory */
+	ret = nouveau_notifier_init_channel(chan);
+	if (ret) {
+		nouveau_fifo_free(chan);
+		return ret;
+	}
+
+	/* Setup channel's default objects */
+	ret = nouveau_gpuobj_channel_init(chan, vram_handle, tt_handle);
+	if (ret) {
+		nouveau_fifo_free(chan);
+		return ret;
+	}
+
+	/* Create a dma object for the push buffer */
+	ret = nouveau_fifo_pushbuf_ctxdma_init(chan);
+	if (ret) {
+		nouveau_fifo_free(chan);
+		return ret;
+	}
+
+	nouveau_wait_for_idle(dev);
+
+	/* disable the fifo caches */
+	NV_WRITE(NV03_PFIFO_CACHES, 0x00000000);
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_PUSH, NV_READ(NV04_PFIFO_CACHE1_DMA_PUSH)&(~0x1));
+	NV_WRITE(NV03_PFIFO_CACHE1_PUSH0, 0x00000000);
+	NV_WRITE(NV04_PFIFO_CACHE1_PULL0, 0x00000000);
+
+	/* Create a graphics context for new channel */
+	ret = engine->graph.create_context(chan);
+	if (ret) {
+		nouveau_fifo_free(chan);
+		return ret;
+	}
+
+	/* Construct inital RAMFC for new channel */
+	ret = engine->fifo.create_context(chan);
+	if (ret) {
+		nouveau_fifo_free(chan);
+		return ret;
+	}
+
+	/* setup channel's default get/put values */
+	if (dev_priv->card_type < NV_50) {
+		NV_WRITE(NV03_FIFO_REGS_DMAPUT(channel), chan->pushbuf_base);
+		NV_WRITE(NV03_FIFO_REGS_DMAGET(channel), chan->pushbuf_base);
+	} else {
+		NV_WRITE(NV50_FIFO_REGS_DMAPUT(channel), chan->pushbuf_base);
+		NV_WRITE(NV50_FIFO_REGS_DMAGET(channel), chan->pushbuf_base);
+	}
+
+	/* If this is the first channel, setup PFIFO ourselves.  For any
+	 * other case, the GPU will handle this when it switches contexts.
+	 */
+	if (dev_priv->fifo_alloc_count == 1) {
+		ret = engine->fifo.load_context(chan);
+		if (ret) {
+			nouveau_fifo_free(chan);
+			return ret;
+		}
+
+		ret = engine->graph.load_context(chan);
+		if (ret) {
+			nouveau_fifo_free(chan);
+			return ret;
+		}
+	}
+
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_PUSH,
+		 NV_READ(NV04_PFIFO_CACHE1_DMA_PUSH) | 1);
+	NV_WRITE(NV03_PFIFO_CACHE1_PUSH0, 0x00000001);
+	NV_WRITE(NV04_PFIFO_CACHE1_PULL0, 0x00000001);
+	NV_WRITE(NV04_PFIFO_CACHE1_PULL1, 0x00000001);
+
+	/* reenable the fifo caches */
+	NV_WRITE(NV03_PFIFO_CACHES, 1);
+
+	DRM_INFO("%s: initialised FIFO %d\n", __func__, channel);
+	*chan_ret = chan;
+	return 0;
+}
+
+/* stops a fifo */
+void nouveau_fifo_free(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_engine *engine = &dev_priv->Engine;
+
+	DRM_INFO("%s: freeing fifo %d\n", __func__, chan->id);
+
+	/* disable the fifo caches */
+	NV_WRITE(NV03_PFIFO_CACHES, 0x00000000);
+
+	// FIXME XXX needs more code
+
+	engine->fifo.destroy_context(chan);
+
+	/* Cleanup PGRAPH state */
+	engine->graph.destroy_context(chan);
+
+	/* reenable the fifo caches */
+	NV_WRITE(NV03_PFIFO_CACHES, 0x00000001);
+
+	/* Deallocate push buffer */
+	nouveau_gpuobj_ref_del(dev, &chan->pushbuf);
+	if (chan->pushbuf_mem) {
+		nouveau_mem_free(dev, chan->pushbuf_mem);
+		chan->pushbuf_mem = NULL;
+	}
+
+	/* Destroy objects belonging to the channel */
+	nouveau_gpuobj_channel_takedown(chan);
+
+	nouveau_notifier_takedown_channel(chan);
+
+	dev_priv->fifos[chan->id] = NULL;
+	dev_priv->fifo_alloc_count--;
+	drm_free(chan, sizeof(*chan), DRM_MEM_DRIVER);
+}
+
+/* cleanups all the fifos from file_priv */
+void nouveau_fifo_cleanup(struct drm_device *dev, struct drm_file *file_priv)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	DRM_DEBUG("clearing FIFO enables from file_priv\n");
+	for(i = 0; i < nouveau_fifo_number(dev); i++) {
+		struct nouveau_channel *chan = dev_priv->fifos[i];
+
+		if (chan && chan->file_priv == file_priv)
+			nouveau_fifo_free(chan);
+	}
+}
+
+int
+nouveau_fifo_owner(struct drm_device *dev, struct drm_file *file_priv,
+		   int channel)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	if (channel >= nouveau_fifo_number(dev))
+		return 0;
+	if (dev_priv->fifos[channel] == NULL)
+		return 0;
+	return (dev_priv->fifos[channel]->file_priv == file_priv);
+}
+
+/***********************************
+ * ioctls wrapping the functions
+ ***********************************/
+
+static int nouveau_ioctl_fifo_alloc(struct drm_device *dev, void *data,
+				    struct drm_file *file_priv)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct drm_nouveau_channel_alloc *init = data;
+	struct drm_map_list *entry;
+	struct nouveau_channel *chan;
+	struct mem_block *pushbuf;
+	int res;
+
+	NOUVEAU_CHECK_INITIALISED_WITH_RETURN;
+
+	if (init->fb_ctxdma_handle == ~0 || init->tt_ctxdma_handle == ~0)
+		return -EINVAL;
+
+	pushbuf = nouveau_fifo_user_pushbuf_alloc(dev);
+	if (!pushbuf)
+		return -ENOMEM;
+
+	res = nouveau_fifo_alloc(dev, &chan, file_priv, pushbuf,
+				 init->fb_ctxdma_handle,
+				 init->tt_ctxdma_handle);
+	if (res)
+		return res;
+	init->channel  = chan->id;
+	init->put_base = chan->pushbuf_base;
+
+	/* make the fifo available to user space */
+	/* first, the fifo control regs */
+	init->ctrl = dev_priv->mmio->offset;
+	if (dev_priv->card_type < NV_50) {
+		init->ctrl      += NV03_FIFO_REGS(init->channel);
+		init->ctrl_size  = NV03_FIFO_REGS_SIZE;
+	} else {
+		init->ctrl      += NV50_FIFO_REGS(init->channel);
+		init->ctrl_size  = NV50_FIFO_REGS_SIZE;
+	}
+	res = drm_addmap(dev, init->ctrl, init->ctrl_size, _DRM_REGISTERS,
+			 0, &chan->regs);
+	if (res != 0)
+		return res;
+
+	entry = drm_find_matching_map(dev, chan->regs);
+	if (!entry)
+		return -EINVAL;
+	init->ctrl = entry->user_token;
+
+	/* pass back FIFO map info to the caller */
+	init->cmdbuf      = chan->pushbuf_mem->map_handle;
+	init->cmdbuf_size = chan->pushbuf_mem->size;
+
+	/* and the notifier block */
+	init->notifier      = chan->notifier_block->map_handle;
+	init->notifier_size = chan->notifier_block->size;
+
+	return 0;
+}
+
+static int nouveau_ioctl_fifo_free(struct drm_device *dev, void *data,
+				   struct drm_file *file_priv)
+{
+	struct drm_nouveau_channel_free *cfree = data;
+	struct nouveau_channel *chan;
+
+	NOUVEAU_CHECK_INITIALISED_WITH_RETURN;
+	NOUVEAU_GET_USER_CHANNEL_WITH_RETURN(cfree->channel, file_priv, chan);
+
+	nouveau_fifo_free(chan);
+	return 0;
+}
+
+/***********************************
+ * finally, the ioctl table
+ ***********************************/
+
+struct drm_ioctl_desc nouveau_ioctls[] = {
+	DRM_IOCTL_DEF(DRM_NOUVEAU_CARD_INIT, nouveau_ioctl_card_init, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_NOUVEAU_GETPARAM, nouveau_ioctl_getparam, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_NOUVEAU_SETPARAM, nouveau_ioctl_setparam, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_NOUVEAU_CHANNEL_ALLOC, nouveau_ioctl_fifo_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_NOUVEAU_CHANNEL_FREE, nouveau_ioctl_fifo_free, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_NOUVEAU_GROBJ_ALLOC, nouveau_ioctl_grobj_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_NOUVEAU_NOTIFIEROBJ_ALLOC, nouveau_ioctl_notifier_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_NOUVEAU_GPUOBJ_FREE, nouveau_ioctl_gpuobj_free, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_NOUVEAU_MEM_ALLOC, nouveau_ioctl_mem_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_NOUVEAU_MEM_FREE, nouveau_ioctl_mem_free, DRM_AUTH),
+};
+
+int nouveau_max_ioctl = DRM_ARRAY_SIZE(nouveau_ioctls);
Index: git/shared-core/nouveau_irq.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nouveau_irq.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,430 @@
+/*
+ * Copyright (C) 2006 Ben Skeggs.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/*
+ * Authors:
+ *   Ben Skeggs <darktama@iinet.net.au>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drm.h"
+#include "nouveau_drv.h"
+#include "nouveau_reg.h"
+
+void nouveau_irq_preinstall(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	/* Master disable */
+	NV_WRITE(NV03_PMC_INTR_EN_0, 0);
+}
+
+void nouveau_irq_postinstall(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	/* Master enable */
+	NV_WRITE(NV03_PMC_INTR_EN_0, NV_PMC_INTR_EN_0_MASTER_ENABLE);
+}
+
+void nouveau_irq_uninstall(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	/* Master disable */
+	NV_WRITE(NV03_PMC_INTR_EN_0, 0);
+}
+
+static void nouveau_fifo_irq_handler(struct drm_device *dev)
+{
+	uint32_t status, chmode, chstat, channel;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	status = NV_READ(NV03_PFIFO_INTR_0);
+	if (!status)
+		return;
+	chmode = NV_READ(NV04_PFIFO_MODE);
+	chstat = NV_READ(NV04_PFIFO_DMA);
+	channel=NV_READ(NV03_PFIFO_CACHE1_PUSH1)&(nouveau_fifo_number(dev)-1);
+
+	if (status & NV_PFIFO_INTR_CACHE_ERROR) {
+		uint32_t c1get, c1method, c1data;
+
+		DRM_ERROR("PFIFO error interrupt\n");
+
+		c1get = NV_READ(NV03_PFIFO_CACHE1_GET) >> 2;
+		if (dev_priv->card_type < NV_40) {
+			/* Untested, so it may not work.. */
+			c1method = NV_READ(NV04_PFIFO_CACHE1_METHOD(c1get));
+			c1data   = NV_READ(NV04_PFIFO_CACHE1_DATA(c1get));
+		} else {
+			c1method = NV_READ(NV40_PFIFO_CACHE1_METHOD(c1get));
+			c1data   = NV_READ(NV40_PFIFO_CACHE1_DATA(c1get));
+		}
+
+		DRM_ERROR("Channel %d/%d - Method 0x%04x, Data 0x%08x\n",
+			  channel, (c1method >> 13) & 7, c1method & 0x1ffc,
+			  c1data);
+
+		status &= ~NV_PFIFO_INTR_CACHE_ERROR;
+		NV_WRITE(NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);
+	}
+
+	if (status & NV_PFIFO_INTR_DMA_PUSHER) {
+		DRM_ERROR("PFIFO DMA pusher interrupt: ch%d, 0x%08x\n",
+			  channel, NV_READ(NV04_PFIFO_CACHE1_DMA_GET));
+
+		status &= ~NV_PFIFO_INTR_DMA_PUSHER;
+		NV_WRITE(NV03_PFIFO_INTR_0, NV_PFIFO_INTR_DMA_PUSHER);
+
+		NV_WRITE(NV04_PFIFO_CACHE1_DMA_STATE, 0x00000000);
+		if (NV_READ(NV04_PFIFO_CACHE1_DMA_PUT)!=NV_READ(NV04_PFIFO_CACHE1_DMA_GET))
+		{
+			uint32_t getval=NV_READ(NV04_PFIFO_CACHE1_DMA_GET)+4;
+			NV_WRITE(NV04_PFIFO_CACHE1_DMA_GET,getval);
+		}
+	}
+
+	if (status) {
+		DRM_ERROR("Unhandled PFIFO interrupt: status=0x%08x\n", status);
+
+		NV_WRITE(NV03_PFIFO_INTR_0, status);
+	}
+
+	NV_WRITE(NV03_PMC_INTR_0, NV_PMC_INTR_0_PFIFO_PENDING);
+}
+
+#if 0
+static void nouveau_nv04_context_switch(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t channel,i;
+	uint32_t max=0;
+	NV_WRITE(NV04_PGRAPH_FIFO,0x0);
+	channel=NV_READ(NV03_PFIFO_CACHE1_PUSH1)&(nouveau_fifo_number(dev)-1);
+	//DRM_INFO("raw PFIFO_CACH1_PHS1 reg is %x\n",NV_READ(NV03_PFIFO_CACHE1_PUSH1));
+	//DRM_INFO("currently on channel %d\n",channel);
+	for (i=0;i<nouveau_fifo_number(dev);i++)
+		if ((dev_priv->fifos[i].used)&&(i!=channel)) {
+			uint32_t put,get,pending;
+			//put=NV_READ(dev_priv->ramfc_offset+i*32);
+			//get=NV_READ(dev_priv->ramfc_offset+4+i*32);
+			put=NV_READ(NV03_FIFO_REGS_DMAPUT(i));
+			get=NV_READ(NV03_FIFO_REGS_DMAGET(i));
+			pending=NV_READ(NV04_PFIFO_DMA);
+			//DRM_INFO("Channel %d (put/get %x/%x)\n",i,put,get);
+			/* mark all pending channels as such */
+			if ((put!=get)&!(pending&(1<<i)))
+			{
+				pending|=(1<<i);
+				NV_WRITE(NV04_PFIFO_DMA,pending);
+			}
+			max++;
+		}
+	nouveau_wait_for_idle(dev);
+
+#if 1
+	/* 2-channel commute */
+	//		NV_WRITE(NV03_PFIFO_CACHE1_PUSH1,channel|0x100);
+	if (channel==0)
+		channel=1;
+	else
+		channel=0;
+	//		dev_priv->cur_fifo=channel;
+	NV_WRITE(NV04_PFIFO_NEXT_CHANNEL,channel|0x100);
+#endif
+	//NV_WRITE(NV03_PFIFO_CACHE1_PUSH1,max|0x100);
+	//NV_WRITE(0x2050,max|0x100);
+
+	NV_WRITE(NV04_PGRAPH_FIFO,0x1);
+	
+}
+#endif
+
+
+struct nouveau_bitfield_names
+{
+	uint32_t mask;
+	const char * name;
+};
+
+static struct nouveau_bitfield_names nouveau_nstatus_names[] =
+{
+	{ NV03_PGRAPH_NSTATUS_STATE_IN_USE,       "STATE_IN_USE" },
+	{ NV03_PGRAPH_NSTATUS_INVALID_STATE,      "INVALID_STATE" },
+	{ NV03_PGRAPH_NSTATUS_BAD_ARGUMENT,       "BAD_ARGUMENT" },
+	{ NV03_PGRAPH_NSTATUS_PROTECTION_FAULT,   "PROTECTION_FAULT" }
+};
+
+static struct nouveau_bitfield_names nouveau_nsource_names[] =
+{
+	{ NV03_PGRAPH_NSOURCE_NOTIFICATION,       "NOTIFICATION" },
+	{ NV03_PGRAPH_NSOURCE_DATA_ERROR,         "DATA_ERROR" },
+	{ NV03_PGRAPH_NSOURCE_PROTECTION_ERROR,   "PROTECTION_ERROR" },
+	{ NV03_PGRAPH_NSOURCE_RANGE_EXCEPTION,    "RANGE_EXCEPTION" },
+	{ NV03_PGRAPH_NSOURCE_LIMIT_COLOR,        "LIMIT_COLOR" },
+	{ NV03_PGRAPH_NSOURCE_LIMIT_ZETA,         "LIMIT_ZETA" },
+	{ NV03_PGRAPH_NSOURCE_ILLEGAL_MTHD,       "ILLEGAL_MTHD" },
+	{ NV03_PGRAPH_NSOURCE_DMA_R_PROTECTION,   "DMA_R_PROTECTION" },
+	{ NV03_PGRAPH_NSOURCE_DMA_W_PROTECTION,   "DMA_W_PROTECTION" },
+	{ NV03_PGRAPH_NSOURCE_FORMAT_EXCEPTION,   "FORMAT_EXCEPTION" },
+	{ NV03_PGRAPH_NSOURCE_PATCH_EXCEPTION,    "PATCH_EXCEPTION" },
+	{ NV03_PGRAPH_NSOURCE_STATE_INVALID,      "STATE_INVALID" },
+	{ NV03_PGRAPH_NSOURCE_DOUBLE_NOTIFY,      "DOUBLE_NOTIFY" },
+	{ NV03_PGRAPH_NSOURCE_NOTIFY_IN_USE,      "NOTIFY_IN_USE" },
+	{ NV03_PGRAPH_NSOURCE_METHOD_CNT,         "METHOD_CNT" },
+	{ NV03_PGRAPH_NSOURCE_BFR_NOTIFICATION,   "BFR_NOTIFICATION" },
+	{ NV03_PGRAPH_NSOURCE_DMA_VTX_PROTECTION, "DMA_VTX_PROTECTION" },
+	{ NV03_PGRAPH_NSOURCE_DMA_WIDTH_A,        "DMA_WIDTH_A" },
+	{ NV03_PGRAPH_NSOURCE_DMA_WIDTH_B,        "DMA_WIDTH_B" },
+};
+
+static void
+nouveau_print_bitfield_names(uint32_t value,
+                             const struct nouveau_bitfield_names *namelist,
+                             const int namelist_len)
+{
+	int i;
+	for(i=0; i<namelist_len; ++i) {
+		uint32_t mask = namelist[i].mask;
+		if(value & mask) {
+			printk(" %s", namelist[i].name);
+			value &= ~mask;
+		}
+	}
+	if(value)
+		printk(" (unknown bits 0x%08x)", value);
+}
+
+static int
+nouveau_graph_trapped_channel(struct drm_device *dev, int *channel_ret)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int channel;
+
+	if (dev_priv->card_type < NV_10) {
+		channel = (NV_READ(NV04_PGRAPH_TRAPPED_ADDR) >> 24) & 0xf;
+	} else if (dev_priv->card_type < NV_40) {
+		channel = (NV_READ(NV04_PGRAPH_TRAPPED_ADDR) >> 20) & 0x1f;
+	} else
+	if (dev_priv->card_type < NV_50) {
+		uint32_t cur_grctx = (NV_READ(0x40032C) & 0xfffff) << 4;
+
+		/* 0x400704 *sometimes* contains a sensible channel ID, but
+		 * mostly not.. for now lookup which channel owns the active
+		 * PGRAPH context.  Probably a better way, but this'll do
+		 * for now.
+		 */
+		for (channel = 0; channel < 32; channel++) {
+			if (dev_priv->fifos[channel] == NULL)
+				continue;
+			if (cur_grctx ==
+			    dev_priv->fifos[channel]->ramin_grctx->instance)
+				break;
+		}
+		if (channel == 32) {
+			DRM_ERROR("AIII, unable to determine active channel "
+				  "from PGRAPH context 0x%08x\n", cur_grctx);
+			return -EINVAL;
+		}
+	} else {
+		uint32_t cur_grctx = (NV_READ(0x40032C) & 0xfffff) << 12;
+
+		for (channel = 0; channel < 128; channel++) {
+			if (dev_priv->fifos[channel] == NULL)
+				continue;
+			if (cur_grctx ==
+			    dev_priv->fifos[channel]->ramin_grctx->instance)
+				break;
+		}
+		if (channel == 128) {
+			DRM_ERROR("AIII, unable to determine active channel "
+				  "from PGRAPH context 0x%08x\n", cur_grctx);
+			return -EINVAL;
+		}
+	}
+
+	if (channel > nouveau_fifo_number(dev) ||
+	    dev_priv->fifos[channel] == NULL) {
+		DRM_ERROR("AIII, invalid/inactive channel id %d\n", channel);
+		return -EINVAL;
+	}
+
+	*channel_ret = channel;
+	return 0;
+}
+
+static void
+nouveau_graph_dump_trap_info(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t address;
+	uint32_t channel, class;
+	uint32_t method, subc, data, data2;
+	uint32_t nsource, nstatus;
+
+	if (nouveau_graph_trapped_channel(dev, &channel))
+		channel = -1;
+
+	data    = NV_READ(NV04_PGRAPH_TRAPPED_DATA);
+	address = NV_READ(NV04_PGRAPH_TRAPPED_ADDR);
+	method  = address & 0x1FFC;
+	if (dev_priv->card_type < NV_10) {
+		subc = (address >> 13) & 0x7;
+		data2= 0;
+	} else {
+		subc = (address >> 16) & 0x7;
+		data2= NV_READ(NV10_PGRAPH_TRAPPED_DATA_HIGH);
+	}
+	nsource = NV_READ(NV03_PGRAPH_NSOURCE);
+	nstatus = NV_READ(NV03_PGRAPH_NSTATUS);
+	if (dev_priv->card_type < NV_50) {
+		class = NV_READ(0x400160 + subc*4) & 0xFFFF;
+	} else {
+		class = NV_READ(0x400814);
+	}
+
+	DRM_ERROR("nSource:");
+	nouveau_print_bitfield_names(nsource, nouveau_nsource_names,
+	                             ARRAY_SIZE(nouveau_nsource_names));
+	printk(", nStatus:");
+	nouveau_print_bitfield_names(nstatus, nouveau_nstatus_names,
+	                             ARRAY_SIZE(nouveau_nstatus_names));
+	printk("\n");
+
+	DRM_ERROR("Channel %d/%d (class 0x%04x) - Method 0x%04x, Data 0x%08x:0x%08x\n",
+		  channel, subc, class, method, data2, data);
+}
+
+static void nouveau_pgraph_irq_handler(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t status, nsource;
+
+	status = NV_READ(NV03_PGRAPH_INTR);
+	if (!status)
+		return;
+	nsource = NV_READ(NV03_PGRAPH_NSOURCE);
+
+	if (status & NV_PGRAPH_INTR_NOTIFY) {
+		DRM_DEBUG("PGRAPH notify interrupt\n");
+
+		nouveau_graph_dump_trap_info(dev);
+
+		status &= ~NV_PGRAPH_INTR_NOTIFY;
+		NV_WRITE(NV03_PGRAPH_INTR, NV_PGRAPH_INTR_NOTIFY);
+	}
+
+	if (status & NV_PGRAPH_INTR_ERROR) {
+		DRM_ERROR("PGRAPH error interrupt\n");
+
+		nouveau_graph_dump_trap_info(dev);
+
+		status &= ~NV_PGRAPH_INTR_ERROR;
+		NV_WRITE(NV03_PGRAPH_INTR, NV_PGRAPH_INTR_ERROR);
+	}
+
+	if (status & NV_PGRAPH_INTR_CONTEXT_SWITCH) {
+		uint32_t channel=NV_READ(NV03_PFIFO_CACHE1_PUSH1)&(nouveau_fifo_number(dev)-1);
+		DRM_DEBUG("PGRAPH context switch interrupt channel %x\n",channel);
+		switch(dev_priv->card_type)
+		{
+			case NV_04:
+			case NV_05:
+				nouveau_nv04_context_switch(dev);
+				break;
+			case NV_10:
+			case NV_11:
+			case NV_17:
+				nouveau_nv10_context_switch(dev);
+				break;
+			case NV_20:
+			case NV_30:
+				nouveau_nv20_context_switch(dev);
+				break;
+			default:
+				DRM_ERROR("Context switch not implemented\n");
+				break;
+		}
+
+		status &= ~NV_PGRAPH_INTR_CONTEXT_SWITCH;
+		NV_WRITE(NV03_PGRAPH_INTR, NV_PGRAPH_INTR_CONTEXT_SWITCH);
+	}
+
+	if (status) {
+		DRM_ERROR("Unhandled PGRAPH interrupt: STAT=0x%08x\n", status);
+		NV_WRITE(NV03_PGRAPH_INTR, status);
+	}
+
+	NV_WRITE(NV03_PMC_INTR_0, NV_PMC_INTR_0_PGRAPH_PENDING);
+}
+
+static void nouveau_crtc_irq_handler(struct drm_device *dev, int crtc)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	if (crtc&1) {
+		NV_WRITE(NV_CRTC0_INTSTAT, NV_CRTC_INTR_VBLANK);
+	}
+
+	if (crtc&2) {
+		NV_WRITE(NV_CRTC1_INTSTAT, NV_CRTC_INTR_VBLANK);
+	}
+}
+
+irqreturn_t nouveau_irq_handler(DRM_IRQ_ARGS)
+{
+	struct drm_device *dev = (struct drm_device*)arg;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t status;
+
+	status = NV_READ(NV03_PMC_INTR_0);
+	if (!status)
+		return IRQ_NONE;
+
+	if (status & NV_PMC_INTR_0_PFIFO_PENDING) {
+		nouveau_fifo_irq_handler(dev);
+		status &= ~NV_PMC_INTR_0_PFIFO_PENDING;
+	}
+
+	if (status & NV_PMC_INTR_0_PGRAPH_PENDING) {
+		nouveau_pgraph_irq_handler(dev);
+		status &= ~NV_PMC_INTR_0_PGRAPH_PENDING;
+	}
+
+	if (status & NV_PMC_INTR_0_CRTCn_PENDING) {
+		nouveau_crtc_irq_handler(dev, (status>>24)&3);
+		status &= ~NV_PMC_INTR_0_CRTCn_PENDING;
+	}
+
+	if (status)
+		DRM_ERROR("Unhandled PMC INTR status bits 0x%08x\n", status);
+
+	return IRQ_HANDLED;
+}
+
Index: git/shared-core/nouveau_mem.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nouveau_mem.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,608 @@
+/*
+ * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
+ * Copyright 2005 Stephane Marchesin
+ *
+ * The Weather Channel (TM) funded Tungsten Graphics to develop the
+ * initial release of the Radeon 8500 driver under the XFree86 license.
+ * This notice must be preserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ */
+
+
+#include "drmP.h"
+#include "drm.h"
+#include "drm_sarea.h"
+#include "nouveau_drv.h"
+
+static struct mem_block *split_block(struct mem_block *p, uint64_t start, uint64_t size,
+		struct drm_file *file_priv)
+{
+	/* Maybe cut off the start of an existing block */
+	if (start > p->start) {
+		struct mem_block *newblock =
+			drm_alloc(sizeof(*newblock), DRM_MEM_BUFS);
+		if (!newblock)
+			goto out;
+		newblock->start = start;
+		newblock->size = p->size - (start - p->start);
+		newblock->file_priv = NULL;
+		newblock->next = p->next;
+		newblock->prev = p;
+		p->next->prev = newblock;
+		p->next = newblock;
+		p->size -= newblock->size;
+		p = newblock;
+	}
+
+	/* Maybe cut off the end of an existing block */
+	if (size < p->size) {
+		struct mem_block *newblock =
+			drm_alloc(sizeof(*newblock), DRM_MEM_BUFS);
+		if (!newblock)
+			goto out;
+		newblock->start = start + size;
+		newblock->size = p->size - size;
+		newblock->file_priv = NULL;
+		newblock->next = p->next;
+		newblock->prev = p;
+		p->next->prev = newblock;
+		p->next = newblock;
+		p->size = size;
+	}
+
+out:
+	/* Our block is in the middle */
+	p->file_priv = file_priv;
+	return p;
+}
+
+struct mem_block *nouveau_mem_alloc_block(struct mem_block *heap,
+					  uint64_t size,
+					  int align2,
+					  struct drm_file *file_priv)
+{
+	struct mem_block *p;
+	uint64_t mask = (1 << align2) - 1;
+
+	if (!heap)
+		return NULL;
+
+	list_for_each(p, heap) {
+		uint64_t start = (p->start + mask) & ~mask;
+		if (p->file_priv == 0 && start + size <= p->start + p->size)
+			return split_block(p, start, size, file_priv);
+	}
+
+	return NULL;
+}
+
+static struct mem_block *find_block(struct mem_block *heap, uint64_t start)
+{
+	struct mem_block *p;
+
+	list_for_each(p, heap)
+		if (p->start == start)
+			return p;
+
+	return NULL;
+}
+
+void nouveau_mem_free_block(struct mem_block *p)
+{
+	p->file_priv = NULL;
+
+	/* Assumes a single contiguous range.  Needs a special file_priv in
+	 * 'heap' to stop it being subsumed.
+	 */
+	if (p->next->file_priv == 0) {
+		struct mem_block *q = p->next;
+		p->size += q->size;
+		p->next = q->next;
+		p->next->prev = p;
+		drm_free(q, sizeof(*q), DRM_MEM_BUFS);
+	}
+
+	if (p->prev->file_priv == 0) {
+		struct mem_block *q = p->prev;
+		q->size += p->size;
+		q->next = p->next;
+		q->next->prev = q;
+		drm_free(p, sizeof(*q), DRM_MEM_BUFS);
+	}
+}
+
+/* Initialize.  How to check for an uninitialized heap?
+ */
+int nouveau_mem_init_heap(struct mem_block **heap, uint64_t start,
+			  uint64_t size)
+{
+	struct mem_block *blocks = drm_alloc(sizeof(*blocks), DRM_MEM_BUFS);
+
+	if (!blocks)
+		return -ENOMEM;
+
+	*heap = drm_alloc(sizeof(**heap), DRM_MEM_BUFS);
+	if (!*heap) {
+		drm_free(blocks, sizeof(*blocks), DRM_MEM_BUFS);
+		return -ENOMEM;
+	}
+
+	blocks->start = start;
+	blocks->size = size;
+	blocks->file_priv = NULL;
+	blocks->next = blocks->prev = *heap;
+
+	memset(*heap, 0, sizeof(**heap));
+	(*heap)->file_priv = (struct drm_file *) - 1;
+	(*heap)->next = (*heap)->prev = blocks;
+	return 0;
+}
+
+/* 
+ * Free all blocks associated with the releasing file_priv
+ */
+void nouveau_mem_release(struct drm_file *file_priv, struct mem_block *heap)
+{
+	struct mem_block *p;
+
+	if (!heap || !heap->next)
+		return;
+
+	list_for_each(p, heap) {
+		if (p->file_priv == file_priv)
+			p->file_priv = NULL;
+	}
+
+	/* Assumes a single contiguous range.  Needs a special file_priv in
+	 * 'heap' to stop it being subsumed.
+	 */
+	list_for_each(p, heap) {
+		while ((p->file_priv == 0) && (p->next->file_priv == 0) &&
+		       (p->next!=heap)) {
+			struct mem_block *q = p->next;
+			p->size += q->size;
+			p->next = q->next;
+			p->next->prev = p;
+			drm_free(q, sizeof(*q), DRM_MEM_DRIVER);
+		}
+	}
+}
+
+/* 
+ * Cleanup everything
+ */
+void nouveau_mem_takedown(struct mem_block **heap)
+{
+	struct mem_block *p;
+
+	if (!*heap)
+		return;
+
+	for (p = (*heap)->next; p != *heap;) {
+		struct mem_block *q = p;
+		p = p->next;
+		drm_free(q, sizeof(*q), DRM_MEM_DRIVER);
+	}
+
+	drm_free(*heap, sizeof(**heap), DRM_MEM_DRIVER);
+	*heap = NULL;
+}
+
+void nouveau_mem_close(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	nouveau_mem_takedown(&dev_priv->agp_heap);
+	nouveau_mem_takedown(&dev_priv->fb_heap);
+	if (dev_priv->pci_heap)
+		nouveau_mem_takedown(&dev_priv->pci_heap);
+}
+
+/*XXX won't work on BSD because of pci_read_config_dword */
+static uint32_t
+nouveau_mem_fb_amount_igp(struct drm_device *dev)
+{
+#if defined(LINUX) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19))
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct pci_dev *bridge;
+	uint32_t mem;
+
+	bridge = pci_get_bus_and_slot(0, PCI_DEVFN(0,1));
+	if (!bridge) {
+		DRM_ERROR("no bridge device\n");
+		return 0;
+	}
+
+	if (dev_priv->flags&NV_NFORCE) {
+		pci_read_config_dword(bridge, 0x7C, &mem);
+		return (uint64_t)(((mem >> 6) & 31) + 1)*1024*1024;
+	} else
+	if(dev_priv->flags&NV_NFORCE2) {
+		pci_read_config_dword(bridge, 0x84, &mem);
+		return (uint64_t)(((mem >> 4) & 127) + 1)*1024*1024;
+	}
+
+	DRM_ERROR("impossible!\n");
+#else
+	DRM_ERROR("Linux kernel >= 2.6.19 required to check for igp memory amount\n");
+#endif
+
+	return 0;
+}
+
+/* returns the amount of FB ram in bytes */
+uint64_t nouveau_mem_fb_amount(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv=dev->dev_private;
+	switch(dev_priv->card_type)
+	{
+		case NV_04:
+		case NV_05:
+			if (NV_READ(NV03_BOOT_0) & 0x00000100) {
+				return (((NV_READ(NV03_BOOT_0) >> 12) & 0xf)*2+2)*1024*1024;
+			} else
+			switch(NV_READ(NV03_BOOT_0)&NV03_BOOT_0_RAM_AMOUNT)
+			{
+				case NV04_BOOT_0_RAM_AMOUNT_32MB:
+					return 32*1024*1024;
+				case NV04_BOOT_0_RAM_AMOUNT_16MB:
+					return 16*1024*1024;
+				case NV04_BOOT_0_RAM_AMOUNT_8MB:
+					return 8*1024*1024;
+				case NV04_BOOT_0_RAM_AMOUNT_4MB:
+					return 4*1024*1024;
+			}
+			break;
+		case NV_10:
+		case NV_11:
+		case NV_17:
+		case NV_20:
+		case NV_30:
+		case NV_40:
+		case NV_44:
+		case NV_50:
+		default:
+			if (dev_priv->flags & (NV_NFORCE | NV_NFORCE2)) {
+				return nouveau_mem_fb_amount_igp(dev);
+			} else {
+				uint64_t mem;
+
+				mem = (NV_READ(NV04_FIFO_DATA) & 
+				       NV10_FIFO_DATA_RAM_AMOUNT_MB_MASK) >>
+				      NV10_FIFO_DATA_RAM_AMOUNT_MB_SHIFT;
+				return mem*1024*1024;
+			}
+			break;
+	}
+
+	DRM_ERROR("Unable to detect video ram size. Please report your setup to " DRIVER_EMAIL "\n");
+	return 0;
+}
+
+static int
+nouveau_mem_init_agp(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct drm_agp_info info;
+	struct drm_agp_mode mode;
+	struct drm_agp_buffer agp_req;
+	struct drm_agp_binding bind_req;
+	int ret;
+
+	ret = drm_agp_acquire(dev);
+	if (ret) {
+		DRM_ERROR("Unable to acquire AGP: %d\n", ret);
+		return ret;
+	}
+
+	ret = drm_agp_info(dev, &info);
+	if (ret) {
+		DRM_ERROR("Unable to get AGP info: %d\n", ret);
+		return ret;
+	}
+
+	/* see agp.h for the AGPSTAT_* modes available */
+	mode.mode = info.mode;
+	ret = drm_agp_enable(dev, mode);
+	if (ret) {
+		DRM_ERROR("Unable to enable AGP: %d\n", ret);
+		return ret;
+	}
+
+	agp_req.size = info.aperture_size;
+	agp_req.type = 0;
+	ret = drm_agp_alloc(dev, &agp_req);
+	if (ret) {
+		DRM_ERROR("Unable to alloc AGP: %d\n", ret);
+		return ret;
+	}
+
+	bind_req.handle = agp_req.handle;
+	bind_req.offset = 0;
+	ret = drm_agp_bind(dev, &bind_req);
+	if (ret) {
+		DRM_ERROR("Unable to bind AGP: %d\n", ret);
+		return ret;
+	}
+
+	dev_priv->gart_info.type	= NOUVEAU_GART_AGP;
+	dev_priv->gart_info.aper_base	= info.aperture_base;
+	dev_priv->gart_info.aper_size	= info.aperture_size;
+	return 0;
+}
+
+int nouveau_mem_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t fb_size;
+	int ret = 0;
+
+	dev_priv->agp_heap = dev_priv->pci_heap = dev_priv->fb_heap = NULL;
+	dev_priv->fb_phys = 0;
+	dev_priv->gart_info.type = NOUVEAU_GART_NONE;
+
+	/* setup a mtrr over the FB */
+	dev_priv->fb_mtrr = drm_mtrr_add(drm_get_resource_start(dev, 1),
+					 nouveau_mem_fb_amount(dev),
+					 DRM_MTRR_WC);
+
+	/* Init FB */
+	dev_priv->fb_phys=drm_get_resource_start(dev,1);
+	fb_size = nouveau_mem_fb_amount(dev);
+	/* On at least NV40, RAMIN is actually at the end of vram.
+	 * We don't want to allocate this... */
+	if (dev_priv->card_type >= NV_40)
+		fb_size -= dev_priv->ramin_rsvd_vram;
+	dev_priv->fb_available_size = fb_size;
+	DRM_DEBUG("Available VRAM: %dKiB\n", fb_size>>10);
+
+	if (fb_size>256*1024*1024) {
+		/* On cards with > 256Mb, you can't map everything. 
+		 * So we create a second FB heap for that type of memory */
+		if (nouveau_mem_init_heap(&dev_priv->fb_heap,
+					  0, 256*1024*1024))
+			return -ENOMEM;
+		if (nouveau_mem_init_heap(&dev_priv->fb_nomap_heap,
+					  256*1024*1024, fb_size-256*1024*1024))
+			return -ENOMEM;
+	} else {
+		if (nouveau_mem_init_heap(&dev_priv->fb_heap, 0, fb_size))
+			return -ENOMEM;
+		dev_priv->fb_nomap_heap=NULL;
+	}
+
+	/* Init AGP / NV50 PCIEGART */
+	if (drm_device_is_agp(dev) && dev->agp) {
+		if ((ret = nouveau_mem_init_agp(dev)))
+			DRM_ERROR("Error initialising AGP: %d\n", ret);
+	}
+
+	/*Note: this is *not* just NV50 code, but only used on NV50 for now */
+	if (dev_priv->gart_info.type == NOUVEAU_GART_NONE &&
+	    dev_priv->card_type >= NV_50) {
+		ret = nouveau_sgdma_init(dev);
+		if (!ret) {
+			ret = nouveau_sgdma_nottm_hack_init(dev);
+			if (ret)
+				nouveau_sgdma_takedown(dev); 
+		}
+
+		if (ret)
+			DRM_ERROR("Error initialising SG DMA: %d\n", ret);
+	}
+
+	if (dev_priv->gart_info.type != NOUVEAU_GART_NONE) {
+		if (nouveau_mem_init_heap(&dev_priv->agp_heap,
+					  0, dev_priv->gart_info.aper_size)) {
+			if (dev_priv->gart_info.type == NOUVEAU_GART_SGDMA) {
+				nouveau_sgdma_nottm_hack_takedown(dev);
+				nouveau_sgdma_takedown(dev); 
+			}
+		}
+	}
+
+	/* NV04-NV40 PCIEGART */
+	if (!dev_priv->agp_heap && dev_priv->card_type < NV_50) {
+		struct drm_scatter_gather sgreq;
+
+		DRM_DEBUG("Allocating sg memory for PCI DMA\n");
+		sgreq.size = 16 << 20; //16MB of PCI scatter-gather zone
+
+		if (drm_sg_alloc(dev, &sgreq)) {
+			DRM_ERROR("Unable to allocate %dMB of scatter-gather"
+				  " pages for PCI DMA!",sgreq.size>>20);
+		} else {
+			if (nouveau_mem_init_heap(&dev_priv->pci_heap, 0,
+						  dev->sg->pages * PAGE_SIZE)) {
+				DRM_ERROR("Unable to initialize pci_heap!");	
+			}
+		}
+	}
+
+	return 0;
+}
+
+struct mem_block* nouveau_mem_alloc(struct drm_device *dev, int alignment,
+				    uint64_t size, int flags,
+				    struct drm_file *file_priv)
+{
+	struct mem_block *block;
+	int type;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	/* 
+	 * Make things easier on ourselves: all allocations are page-aligned. 
+	 * We need that to map allocated regions into the user space
+	 */
+	if (alignment < PAGE_SHIFT)
+		alignment = PAGE_SHIFT;
+
+	/*
+	 * Warn about 0 sized allocations, but let it go through. It'll return 1 page
+	 */
+	if (size == 0)
+		DRM_INFO("warning : 0 byte allocation\n");
+
+	/*
+	 * Keep alloc size a multiple of the page size to keep drm_addmap() happy
+	 */
+	if (size & (~PAGE_MASK))
+		size = ((size/PAGE_SIZE) + 1) * PAGE_SIZE;
+
+
+#define NOUVEAU_MEM_ALLOC_AGP {\
+		type=NOUVEAU_MEM_AGP;\
+                block = nouveau_mem_alloc_block(dev_priv->agp_heap, size,\
+                                                alignment, file_priv); \
+                if (block) goto alloc_ok;\
+	        }
+
+#define NOUVEAU_MEM_ALLOC_PCI {\
+                type = NOUVEAU_MEM_PCI;\
+                block = nouveau_mem_alloc_block(dev_priv->pci_heap, size, \
+						alignment, file_priv); \
+                if ( block ) goto alloc_ok;\
+	        }
+
+#define NOUVEAU_MEM_ALLOC_FB {\
+                type=NOUVEAU_MEM_FB;\
+                if (!(flags&NOUVEAU_MEM_MAPPED)) {\
+                        block = nouveau_mem_alloc_block(dev_priv->fb_nomap_heap,\
+                                                        size, alignment, \
+							file_priv); \
+                        if (block) goto alloc_ok;\
+                }\
+                block = nouveau_mem_alloc_block(dev_priv->fb_heap, size,\
+                                                alignment, file_priv);\
+                if (block) goto alloc_ok;\
+	        }
+
+
+	if (flags&NOUVEAU_MEM_FB) NOUVEAU_MEM_ALLOC_FB
+	if (flags&NOUVEAU_MEM_AGP) NOUVEAU_MEM_ALLOC_AGP
+	if (flags&NOUVEAU_MEM_PCI) NOUVEAU_MEM_ALLOC_PCI
+	if (flags&NOUVEAU_MEM_FB_ACCEPTABLE) NOUVEAU_MEM_ALLOC_FB
+	if (flags&NOUVEAU_MEM_AGP_ACCEPTABLE) NOUVEAU_MEM_ALLOC_AGP
+	if (flags&NOUVEAU_MEM_PCI_ACCEPTABLE) NOUVEAU_MEM_ALLOC_PCI
+
+
+	return NULL;
+
+alloc_ok:
+	block->flags=type;
+
+	if (flags&NOUVEAU_MEM_MAPPED)
+	{
+		struct drm_map_list *entry;
+		int ret = 0;
+		block->flags|=NOUVEAU_MEM_MAPPED;
+
+		if (type == NOUVEAU_MEM_AGP) {
+			if (dev_priv->gart_info.type != NOUVEAU_GART_SGDMA)
+			ret = drm_addmap(dev, block->start, block->size,
+					 _DRM_AGP, 0, &block->map);
+			else
+			ret = drm_addmap(dev, block->start, block->size,
+					 _DRM_SCATTER_GATHER, 0, &block->map);
+		}
+		else if (type == NOUVEAU_MEM_FB)
+			ret = drm_addmap(dev, block->start + dev_priv->fb_phys,
+					 block->size, _DRM_FRAME_BUFFER,
+					 0, &block->map);
+		else if (type == NOUVEAU_MEM_PCI)
+			ret = drm_addmap(dev, block->start, block->size,
+					 _DRM_SCATTER_GATHER, 0, &block->map);
+
+		if (ret) { 
+			nouveau_mem_free_block(block);
+			return NULL;
+		}
+
+		entry = drm_find_matching_map(dev, block->map);
+		if (!entry) {
+			nouveau_mem_free_block(block);
+			return NULL;
+		}
+		block->map_handle = entry->user_token;
+	}
+
+	DRM_DEBUG("allocated 0x%llx type=0x%08x\n", block->start, block->flags);
+	return block;
+}
+
+void nouveau_mem_free(struct drm_device* dev, struct mem_block* block)
+{
+	DRM_DEBUG("freeing 0x%llx type=0x%08x\n", block->start, block->flags);
+	if (block->flags&NOUVEAU_MEM_MAPPED)
+		drm_rmmap(dev, block->map);
+	nouveau_mem_free_block(block);
+}
+
+/*
+ * Ioctls
+ */
+
+int nouveau_ioctl_mem_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	struct drm_nouveau_mem_alloc *alloc = data;
+	struct mem_block *block;
+
+	NOUVEAU_CHECK_INITIALISED_WITH_RETURN;
+
+	block=nouveau_mem_alloc(dev, alloc->alignment, alloc->size,
+				alloc->flags, file_priv);
+	if (!block)
+		return -ENOMEM;
+	alloc->map_handle=block->map_handle;
+	alloc->offset=block->start;
+	alloc->flags=block->flags;
+
+	return 0;
+}
+
+int nouveau_ioctl_mem_free(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct drm_nouveau_mem_free *memfree = data;
+	struct mem_block *block;
+
+	NOUVEAU_CHECK_INITIALISED_WITH_RETURN;
+
+	block=NULL;
+	if (memfree->flags & NOUVEAU_MEM_FB)
+		block = find_block(dev_priv->fb_heap, memfree->offset);
+	else if (memfree->flags & NOUVEAU_MEM_AGP)
+		block = find_block(dev_priv->agp_heap, memfree->offset);
+	else if (memfree->flags & NOUVEAU_MEM_PCI)
+		block = find_block(dev_priv->pci_heap, memfree->offset);
+	if (!block)
+		return -EFAULT;
+	if (block->file_priv != file_priv)
+		return -EPERM;
+
+	nouveau_mem_free(dev, block);
+	return 0;
+}
+
+
Index: git/shared-core/nouveau_notifier.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nouveau_notifier.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2007 Ben Skeggs.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+
+int
+nouveau_notifier_init_channel(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int flags, ret;
+
+	/*TODO: PCI notifier blocks */
+	if (dev_priv->agp_heap)
+		flags = NOUVEAU_MEM_AGP;
+	else if (dev_priv->pci_heap)
+		flags = NOUVEAU_MEM_PCI;
+	else
+		flags = NOUVEAU_MEM_FB;
+	flags |= (NOUVEAU_MEM_MAPPED | NOUVEAU_MEM_FB_ACCEPTABLE);
+
+	chan->notifier_block = nouveau_mem_alloc(dev, 0, PAGE_SIZE, flags,
+						 (struct drm_file *)-2);
+	if (!chan->notifier_block)
+		return -ENOMEM;
+	DRM_DEBUG("Allocated notifier block in 0x%08x\n",
+		  chan->notifier_block->flags);
+
+	ret = nouveau_mem_init_heap(&chan->notifier_heap,
+				    0, chan->notifier_block->size);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+void
+nouveau_notifier_takedown_channel(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+
+	if (chan->notifier_block) {
+		nouveau_mem_free(dev, chan->notifier_block);
+		chan->notifier_block = NULL;
+	}
+
+	nouveau_mem_takedown(&chan->notifier_heap);
+}
+
+static void
+nouveau_notifier_gpuobj_dtor(struct drm_device *dev,
+			     struct nouveau_gpuobj *gpuobj)
+{
+	DRM_DEBUG("\n");
+
+	if (gpuobj->priv)
+		nouveau_mem_free_block(gpuobj->priv);
+}
+
+int
+nouveau_notifier_alloc(struct nouveau_channel *chan, uint32_t handle,
+		       int count, uint32_t *b_offset)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_gpuobj *nobj = NULL;
+	struct mem_block *mem;
+	uint32_t offset;
+	int target, ret;
+
+	if (!chan->notifier_heap) {
+		DRM_ERROR("Channel %d doesn't have a notifier heap!\n",
+			  chan->id);
+		return -EINVAL;
+	}
+
+	mem = nouveau_mem_alloc_block(chan->notifier_heap, count*32, 0,
+				      (struct drm_file *)-2);
+	if (!mem) {
+		DRM_ERROR("Channel %d notifier block full\n", chan->id);
+		return -ENOMEM;
+	}
+	mem->flags = NOUVEAU_MEM_NOTIFIER;
+
+	offset = chan->notifier_block->start;
+	if (chan->notifier_block->flags & NOUVEAU_MEM_FB) {
+		target = NV_DMA_TARGET_VIDMEM;
+	} else
+	if (chan->notifier_block->flags & NOUVEAU_MEM_AGP) {
+		if (dev_priv->gart_info.type == NOUVEAU_GART_SGDMA &&
+		    dev_priv->card_type < NV_50) {
+			ret = nouveau_sgdma_get_page(dev, offset, &offset);
+			if (ret)
+				return ret;
+			target = NV_DMA_TARGET_PCI;
+		} else {
+			target = NV_DMA_TARGET_AGP;
+		}
+	} else 
+	if (chan->notifier_block->flags & NOUVEAU_MEM_PCI) {
+		target = NV_DMA_TARGET_PCI_NONLINEAR;
+	} else {
+		DRM_ERROR("Bad DMA target, flags 0x%08x!\n",
+			  chan->notifier_block->flags);
+		return -EINVAL;
+	}
+	offset += mem->start;
+
+	if ((ret = nouveau_gpuobj_dma_new(chan, NV_CLASS_DMA_IN_MEMORY,
+					  offset, mem->size,
+					  NV_DMA_ACCESS_RW, target, &nobj))) {
+		nouveau_mem_free_block(mem);
+		DRM_ERROR("Error creating notifier ctxdma: %d\n", ret);
+		return ret;
+	}
+	nobj->dtor   = nouveau_notifier_gpuobj_dtor;
+	nobj->priv   = mem;
+
+	if ((ret = nouveau_gpuobj_ref_add(dev, chan, handle, nobj, NULL))) {
+		nouveau_gpuobj_del(dev, &nobj);
+		nouveau_mem_free_block(mem);
+		DRM_ERROR("Error referencing notifier ctxdma: %d\n", ret);
+		return ret;
+	}
+
+	*b_offset = mem->start;
+	return 0;
+}
+
+int
+nouveau_ioctl_notifier_alloc(struct drm_device *dev, void *data,
+			     struct drm_file *file_priv)
+{
+	struct drm_nouveau_notifierobj_alloc *na = data;
+	struct nouveau_channel *chan;
+	int ret;
+
+	NOUVEAU_CHECK_INITIALISED_WITH_RETURN;
+	NOUVEAU_GET_USER_CHANNEL_WITH_RETURN(na->channel, file_priv, chan);
+
+	ret = nouveau_notifier_alloc(chan, na->handle, na->count, &na->offset);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
Index: git/shared-core/nouveau_object.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nouveau_object.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,1148 @@
+/*
+ * Copyright (C) 2006 Ben Skeggs.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/*
+ * Authors:
+ *   Ben Skeggs <darktama@iinet.net.au>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+/* NVidia uses context objects to drive drawing operations.
+
+   Context objects can be selected into 8 subchannels in the FIFO,
+   and then used via DMA command buffers.
+
+   A context object is referenced by a user defined handle (CARD32). The HW
+   looks up graphics objects in a hash table in the instance RAM.
+
+   An entry in the hash table consists of 2 CARD32. The first CARD32 contains
+   the handle, the second one a bitfield, that contains the address of the
+   object in instance RAM.
+
+   The format of the second CARD32 seems to be:
+
+   NV4 to NV30:
+
+   15: 0  instance_addr >> 4
+   17:16  engine (here uses 1 = graphics)
+   28:24  channel id (here uses 0)
+   31	  valid (use 1)
+
+   NV40:
+
+   15: 0  instance_addr >> 4   (maybe 19-0)
+   21:20  engine (here uses 1 = graphics)
+   I'm unsure about the other bits, but using 0 seems to work.
+
+   The key into the hash table depends on the object handle and channel id and
+   is given as:
+*/
+static uint32_t
+nouveau_ramht_hash_handle(struct drm_device *dev, int channel, uint32_t handle)
+{
+	struct drm_nouveau_private *dev_priv=dev->dev_private;
+	uint32_t hash = 0;
+	int i;
+
+	DRM_DEBUG("ch%d handle=0x%08x\n", channel, handle);
+
+	for (i=32;i>0;i-=dev_priv->ramht_bits) {
+		hash ^= (handle & ((1 << dev_priv->ramht_bits) - 1));
+		handle >>= dev_priv->ramht_bits;
+	}
+	if (dev_priv->card_type < NV_50)
+		hash ^= channel << (dev_priv->ramht_bits - 4);
+	hash <<= 3;
+
+	DRM_DEBUG("hash=0x%08x\n", hash);
+	return hash;
+}
+
+static int
+nouveau_ramht_entry_valid(struct drm_device *dev, struct nouveau_gpuobj *ramht,
+			  uint32_t offset)
+{
+	struct drm_nouveau_private *dev_priv=dev->dev_private;
+	uint32_t ctx = INSTANCE_RD(ramht, (offset + 4)/4);
+
+	if (dev_priv->card_type < NV_40)
+		return ((ctx & NV_RAMHT_CONTEXT_VALID) != 0);
+	return (ctx != 0);
+}
+
+static int
+nouveau_ramht_insert(struct drm_device *dev, struct nouveau_gpuobj_ref *ref)
+{
+	struct drm_nouveau_private *dev_priv=dev->dev_private;
+	struct nouveau_channel *chan = dev_priv->fifos[ref->channel];
+	struct nouveau_gpuobj *ramht = chan->ramht ? chan->ramht->gpuobj : NULL;
+	struct nouveau_gpuobj *gpuobj = ref->gpuobj;
+	uint32_t ctx, co, ho;
+
+	if (!ramht) {
+		DRM_ERROR("No hash table!\n");
+		return -EINVAL;
+	}
+
+	if (dev_priv->card_type < NV_40) {
+		ctx = NV_RAMHT_CONTEXT_VALID | (ref->instance >> 4) |
+		      (ref->channel   << NV_RAMHT_CONTEXT_CHANNEL_SHIFT) |
+		      (gpuobj->engine << NV_RAMHT_CONTEXT_ENGINE_SHIFT);
+	} else
+	if (dev_priv->card_type < NV_50) {
+		ctx = (ref->instance >> 4) |
+		      (ref->channel   << NV40_RAMHT_CONTEXT_CHANNEL_SHIFT) |
+		      (gpuobj->engine << NV40_RAMHT_CONTEXT_ENGINE_SHIFT);
+	} else {
+		ctx = (ref->instance  >> 4) |
+		      (gpuobj->engine << NV40_RAMHT_CONTEXT_ENGINE_SHIFT);
+	}
+
+	co = ho = nouveau_ramht_hash_handle(dev, ref->channel, ref->handle);
+	do {
+		if (!nouveau_ramht_entry_valid(dev, ramht, co)) {
+			DRM_DEBUG("insert ch%d 0x%08x: h=0x%08x, c=0x%08x\n",
+				  ref->channel, co, ref->handle, ctx);
+			INSTANCE_WR(ramht, (co + 0)/4, ref->handle);
+			INSTANCE_WR(ramht, (co + 4)/4, ctx);
+
+			list_add_tail(&ref->list, &chan->ramht_refs);
+			return 0;
+		}
+		DRM_DEBUG("collision ch%d 0x%08x: h=0x%08x\n",
+			  ref->channel, co, INSTANCE_RD(ramht, co/4));
+
+		co += 8;
+		if (co >= dev_priv->ramht_size) {
+			DRM_INFO("no space left after collision\n");
+			co = 0;
+			/* exit as it seems to cause crash with nouveau_demo and
+			 * 0xdead0001 object */
+			break;
+		}
+	} while (co != ho);
+
+	DRM_ERROR("RAMHT space exhausted. ch=%d\n", ref->channel);
+	return -ENOMEM;
+}
+
+static void
+nouveau_ramht_remove(struct drm_device *dev, struct nouveau_gpuobj_ref *ref)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_channel *chan = dev_priv->fifos[ref->channel];
+	struct nouveau_gpuobj *ramht = chan->ramht ? chan->ramht->gpuobj : NULL;
+	uint32_t co, ho;
+
+	if (!ramht) {
+		DRM_ERROR("No hash table!\n");
+		return;
+	}
+
+	co = ho = nouveau_ramht_hash_handle(dev, ref->channel, ref->handle);
+	do {
+		if (nouveau_ramht_entry_valid(dev, ramht, co) &&
+		    (ref->handle == INSTANCE_RD(ramht, (co/4)))) {
+			DRM_DEBUG("remove ch%d 0x%08x: h=0x%08x, c=0x%08x\n",
+				  ref->channel, co, ref->handle,
+				  INSTANCE_RD(ramht, (co + 4)));
+			INSTANCE_WR(ramht, (co + 0)/4, 0x00000000);
+			INSTANCE_WR(ramht, (co + 4)/4, 0x00000000);
+
+			list_del(&ref->list);
+			return;
+		}
+
+		co += 8;
+		if (co >= dev_priv->ramht_size)
+			co = 0;
+	} while (co != ho);
+
+	DRM_ERROR("RAMHT entry not found. ch=%d, handle=0x%08x\n",
+		  ref->channel, ref->handle);
+}
+
+int
+nouveau_gpuobj_new(struct drm_device *dev, struct nouveau_channel *chan,
+		   int size, int align, uint32_t flags,
+		   struct nouveau_gpuobj **gpuobj_ret)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_engine *engine = &dev_priv->Engine;
+	struct nouveau_gpuobj *gpuobj;
+	struct mem_block *pramin = NULL;
+	int ret;
+
+	DRM_DEBUG("ch%d size=%d align=%d flags=0x%08x\n",
+		  chan ? chan->id : -1, size, align, flags);
+
+	if (!dev_priv || !gpuobj_ret || *gpuobj_ret != NULL)
+		return -EINVAL;
+
+	gpuobj = drm_calloc(1, sizeof(*gpuobj), DRM_MEM_DRIVER);
+	if (!gpuobj)
+		return -ENOMEM;
+	DRM_DEBUG("gpuobj %p\n", gpuobj);
+	gpuobj->flags = flags;
+	gpuobj->im_channel = chan ? chan->id : -1;
+
+	list_add_tail(&gpuobj->list, &dev_priv->gpuobj_list);
+
+	/* Choose between global instmem heap, and per-channel private
+	 * instmem heap.  On <NV50 allow requests for private instmem
+	 * to be satisfied from global heap if no per-channel area
+	 * available.
+	 */
+	if (chan) {
+		if (chan->ramin_heap) {
+			DRM_DEBUG("private heap\n");
+			pramin = chan->ramin_heap;
+		} else
+		if (dev_priv->card_type < NV_50) {
+			DRM_DEBUG("global heap fallback\n");
+			pramin = dev_priv->ramin_heap;
+		}
+	} else {
+		DRM_DEBUG("global heap\n");
+		pramin = dev_priv->ramin_heap;
+	}
+
+	if (!pramin) {
+		DRM_ERROR("No PRAMIN heap!\n");
+		return -EINVAL;
+	}
+
+	if (!chan && (ret = engine->instmem.populate(dev, gpuobj, &size))) {
+		nouveau_gpuobj_del(dev, &gpuobj);
+		return ret;
+	}
+
+	/* Allocate a chunk of the PRAMIN aperture */
+	gpuobj->im_pramin = nouveau_mem_alloc_block(pramin, size,
+						    drm_order(align),
+						    (struct drm_file *)-2);
+	if (!gpuobj->im_pramin) {
+		nouveau_gpuobj_del(dev, &gpuobj);
+		return -ENOMEM;
+	}
+	gpuobj->im_pramin->flags = NOUVEAU_MEM_INSTANCE;
+
+	if (!chan && (ret = engine->instmem.bind(dev, gpuobj))) {
+		nouveau_gpuobj_del(dev, &gpuobj);
+		return ret;
+	}
+
+	if (gpuobj->flags & NVOBJ_FLAG_ZERO_ALLOC) {
+		int i;
+
+		for (i = 0; i < gpuobj->im_pramin->size; i += 4)
+			INSTANCE_WR(gpuobj, i/4, 0);
+	}
+
+	*gpuobj_ret = gpuobj;
+	return 0;
+}
+
+int
+nouveau_gpuobj_early_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("\n");
+
+	INIT_LIST_HEAD(&dev_priv->gpuobj_list);
+
+	return 0;
+}
+
+int
+nouveau_gpuobj_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int ret;
+
+	DRM_DEBUG("\n");
+
+	if (dev_priv->card_type < NV_50) {
+		if ((ret = nouveau_gpuobj_new_fake(dev, dev_priv->ramht_offset,
+						   ~0, dev_priv->ramht_size,
+						   NVOBJ_FLAG_ZERO_ALLOC |
+						   NVOBJ_FLAG_ALLOW_NO_REFS,
+						   &dev_priv->ramht, NULL)))
+			return ret;
+	}
+
+	return 0;
+}
+
+void
+nouveau_gpuobj_takedown(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("\n");
+
+	nouveau_gpuobj_del(dev, &dev_priv->ramht);
+}
+
+void
+nouveau_gpuobj_late_takedown(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_gpuobj *gpuobj = NULL;
+	struct list_head *entry, *tmp;
+
+	DRM_DEBUG("\n");
+
+	list_for_each_safe(entry, tmp, &dev_priv->gpuobj_list) {
+		gpuobj = list_entry(entry, struct nouveau_gpuobj, list);
+
+		DRM_ERROR("gpuobj %p still exists at takedown, refs=%d\n",
+			  gpuobj, gpuobj->refcount);
+		gpuobj->refcount = 0;
+		nouveau_gpuobj_del(dev, &gpuobj);
+	}
+}
+
+int
+nouveau_gpuobj_del(struct drm_device *dev, struct nouveau_gpuobj **pgpuobj)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_engine *engine = &dev_priv->Engine;
+	struct nouveau_gpuobj *gpuobj;
+
+	DRM_DEBUG("gpuobj %p\n", pgpuobj ? *pgpuobj : NULL);
+
+	if (!dev_priv || !pgpuobj || !(*pgpuobj))
+		return -EINVAL;
+	gpuobj = *pgpuobj;
+
+	if (gpuobj->refcount != 0) {
+		DRM_ERROR("gpuobj refcount is %d\n", gpuobj->refcount);
+		return -EINVAL;
+	}
+
+	if (gpuobj->dtor)
+		gpuobj->dtor(dev, gpuobj);
+
+	if (gpuobj->im_backing) {
+		if (gpuobj->flags & NVOBJ_FLAG_FAKE)
+			drm_free(gpuobj->im_backing,
+				 sizeof(*gpuobj->im_backing), DRM_MEM_DRIVER);
+		else
+			engine->instmem.clear(dev, gpuobj);
+	}
+
+	if (gpuobj->im_pramin) {
+		if (gpuobj->flags & NVOBJ_FLAG_FAKE)
+			drm_free(gpuobj->im_pramin, sizeof(*gpuobj->im_pramin),
+				 DRM_MEM_DRIVER);
+		else
+			nouveau_mem_free_block(gpuobj->im_pramin);
+	}
+
+	list_del(&gpuobj->list);
+
+	*pgpuobj = NULL;
+	drm_free(gpuobj, sizeof(*gpuobj), DRM_MEM_DRIVER);
+	return 0;
+}
+
+static int
+nouveau_gpuobj_instance_get(struct drm_device *dev,
+			    struct nouveau_channel *chan,
+			    struct nouveau_gpuobj *gpuobj, uint32_t *inst)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_gpuobj *cpramin;
+
+	/* <NV50 use PRAMIN address everywhere */
+	if (dev_priv->card_type < NV_50) {
+		*inst = gpuobj->im_pramin->start;
+		return 0;
+	}
+
+	if (chan && gpuobj->im_channel != chan->id) {
+		DRM_ERROR("Channel mismatch: obj %d, ref %d\n",
+			  gpuobj->im_channel, chan->id);
+		return -EINVAL;
+	}
+
+	/* NV50 channel-local instance */
+	if (chan > 0) {
+		cpramin = chan->ramin->gpuobj;
+		*inst = gpuobj->im_pramin->start - cpramin->im_pramin->start;
+		return 0;
+	}
+
+	/* NV50 global (VRAM) instance */
+	if (gpuobj->im_channel < 0) {
+		/* ...from global heap */
+		if (!gpuobj->im_backing) {
+			DRM_ERROR("AII, no VRAM backing gpuobj\n");
+			return -EINVAL;
+		}
+		*inst = gpuobj->im_backing->start;
+		return 0;
+	} else {
+		/* ...from local heap */
+		cpramin = dev_priv->fifos[gpuobj->im_channel]->ramin->gpuobj;
+		*inst = cpramin->im_backing->start +
+			(gpuobj->im_pramin->start - cpramin->im_pramin->start);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+int
+nouveau_gpuobj_ref_add(struct drm_device *dev, struct nouveau_channel *chan,
+		       uint32_t handle, struct nouveau_gpuobj *gpuobj,
+		       struct nouveau_gpuobj_ref **ref_ret)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_gpuobj_ref *ref;
+	uint32_t instance;
+	int ret;
+
+	DRM_DEBUG("ch%d h=0x%08x gpuobj=%p\n",
+		  chan ? chan->id : -1, handle, gpuobj);
+
+	if (!dev_priv || !gpuobj || (ref_ret && *ref_ret != NULL))
+		return -EINVAL;
+
+	if (!chan && !ref_ret)
+		return -EINVAL;
+
+	ret = nouveau_gpuobj_instance_get(dev, chan, gpuobj, &instance);
+	if (ret)
+		return ret;
+
+	ref = drm_calloc(1, sizeof(*ref), DRM_MEM_DRIVER);
+	if (!ref)
+		return -ENOMEM;
+	ref->gpuobj   = gpuobj;
+	ref->channel  = chan ? chan->id : -1;
+	ref->instance = instance;
+
+	if (!ref_ret) {
+		ref->handle = handle;
+
+		ret = nouveau_ramht_insert(dev, ref);
+		if (ret) {
+			drm_free(ref, sizeof(*ref), DRM_MEM_DRIVER);
+			return ret;
+		}
+	} else {
+		ref->handle = ~0;
+		*ref_ret = ref;
+	}
+
+	ref->gpuobj->refcount++;
+	return 0;
+}
+
+int nouveau_gpuobj_ref_del(struct drm_device *dev, struct nouveau_gpuobj_ref **pref)
+{
+	struct nouveau_gpuobj_ref *ref;
+
+	DRM_DEBUG("ref %p\n", pref ? *pref : NULL);
+
+	if (!dev || !pref || *pref == NULL)
+		return -EINVAL;
+	ref = *pref;
+
+	if (ref->handle != ~0)
+		nouveau_ramht_remove(dev, ref);
+
+	if (ref->gpuobj) {
+		ref->gpuobj->refcount--;
+
+		if (ref->gpuobj->refcount == 0) {
+			if (!(ref->gpuobj->flags & NVOBJ_FLAG_ALLOW_NO_REFS))
+				nouveau_gpuobj_del(dev, &ref->gpuobj);
+		}
+	}
+
+	*pref = NULL;
+	drm_free(ref, sizeof(ref), DRM_MEM_DRIVER);
+	return 0;
+}
+
+int
+nouveau_gpuobj_new_ref(struct drm_device *dev,
+		       struct nouveau_channel *oc, struct nouveau_channel *rc,
+		       uint32_t handle, int size, int align, uint32_t flags,
+		       struct nouveau_gpuobj_ref **ref)
+{
+	struct nouveau_gpuobj *gpuobj = NULL;
+	int ret;
+
+	if ((ret = nouveau_gpuobj_new(dev, oc, size, align, flags, &gpuobj)))
+		return ret;
+
+	if ((ret = nouveau_gpuobj_ref_add(dev, rc, handle, gpuobj, ref))) {
+		nouveau_gpuobj_del(dev, &gpuobj);
+		return ret;
+	}
+
+	return 0;
+}
+
+int
+nouveau_gpuobj_ref_find(struct nouveau_channel *chan, uint32_t handle,
+			struct nouveau_gpuobj_ref **ref_ret)
+{
+	struct nouveau_gpuobj_ref *ref;
+	struct list_head *entry, *tmp;
+
+	list_for_each_safe(entry, tmp, &chan->ramht_refs) {		
+		ref = list_entry(entry, struct nouveau_gpuobj_ref, list);
+
+		if (ref->handle == handle) {
+			if (ref_ret)
+				*ref_ret = ref;
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+int
+nouveau_gpuobj_new_fake(struct drm_device *dev, uint32_t p_offset,
+			uint32_t b_offset, uint32_t size,
+			uint32_t flags, struct nouveau_gpuobj **pgpuobj,
+			struct nouveau_gpuobj_ref **pref)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_gpuobj *gpuobj = NULL;
+	int i;
+
+	DRM_DEBUG("p_offset=0x%08x b_offset=0x%08x size=0x%08x flags=0x%08x\n",
+		  p_offset, b_offset, size, flags);
+
+	gpuobj = drm_calloc(1, sizeof(*gpuobj), DRM_MEM_DRIVER);
+	if (!gpuobj)
+		return -ENOMEM;
+	DRM_DEBUG("gpuobj %p\n", gpuobj);
+	gpuobj->im_channel = -1;
+	gpuobj->flags      = flags | NVOBJ_FLAG_FAKE;
+
+	list_add_tail(&gpuobj->list, &dev_priv->gpuobj_list);
+
+	if (p_offset != ~0) {
+		gpuobj->im_pramin = drm_calloc(1, sizeof(struct mem_block),
+					       DRM_MEM_DRIVER);
+		if (!gpuobj->im_pramin) {
+			nouveau_gpuobj_del(dev, &gpuobj);
+			return -ENOMEM;
+		}
+		gpuobj->im_pramin->start = p_offset;
+		gpuobj->im_pramin->size  = size;
+	}
+
+	if (b_offset != ~0) {
+		gpuobj->im_backing = drm_calloc(1, sizeof(struct mem_block),
+					       DRM_MEM_DRIVER);
+		if (!gpuobj->im_backing) {
+			nouveau_gpuobj_del(dev, &gpuobj);
+			return -ENOMEM;
+		}
+		gpuobj->im_backing->start = b_offset;
+		gpuobj->im_backing->size  = size;
+	}
+
+	if (gpuobj->flags & NVOBJ_FLAG_ZERO_ALLOC) {
+		for (i = 0; i < gpuobj->im_pramin->size; i += 4)
+			INSTANCE_WR(gpuobj, i/4, 0);
+	}
+
+	if (pref) {
+		if ((i = nouveau_gpuobj_ref_add(dev, NULL, 0, gpuobj, pref))) {
+			nouveau_gpuobj_del(dev, &gpuobj);
+			return i;
+		}
+	}
+
+	if (pgpuobj)
+		*pgpuobj = gpuobj;
+	return 0;
+}
+
+
+static int
+nouveau_gpuobj_class_instmem_size(struct drm_device *dev, int class)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	/*XXX: dodgy hack for now */
+	if (dev_priv->card_type >= NV_50)
+		return 24;
+	if (dev_priv->card_type >= NV_40)
+		return 32;
+	return 16;
+}
+
+/*
+   DMA objects are used to reference a piece of memory in the
+   framebuffer, PCI or AGP address space. Each object is 16 bytes big
+   and looks as follows:
+   
+   entry[0]
+   11:0  class (seems like I can always use 0 here)
+   12    page table present?
+   13    page entry linear?
+   15:14 access: 0 rw, 1 ro, 2 wo
+   17:16 target: 0 NV memory, 1 NV memory tiled, 2 PCI, 3 AGP
+   31:20 dma adjust (bits 0-11 of the address)
+   entry[1]
+   dma limit (size of transfer)
+   entry[X]
+   1     0 readonly, 1 readwrite
+   31:12 dma frame address of the page (bits 12-31 of the address)
+   entry[N]
+   page table terminator, same value as the first pte, as does nvidia
+   rivatv uses 0xffffffff
+
+   Non linear page tables need a list of frame addresses afterwards,
+   the rivatv project has some info on this.
+
+   The method below creates a DMA object in instance RAM and returns a handle
+   to it that can be used to set up context objects.
+*/
+int
+nouveau_gpuobj_dma_new(struct nouveau_channel *chan, int class,
+		       uint64_t offset, uint64_t size, int access,
+		       int target, struct nouveau_gpuobj **gpuobj)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int ret;
+	uint32_t is_scatter_gather = 0;
+	
+	/* Total number of pages covered by the request.
+	 */
+	const unsigned int page_count = (size + PAGE_SIZE - 1) / PAGE_SIZE;
+
+
+	DRM_DEBUG("ch%d class=0x%04x offset=0x%llx size=0x%llx\n",
+		  chan->id, class, offset, size);
+	DRM_DEBUG("access=%d target=%d\n", access, target);
+
+	switch (target) {
+        case NV_DMA_TARGET_AGP:
+                 offset += dev_priv->gart_info.aper_base;
+                 break;
+        case NV_DMA_TARGET_PCI_NONLINEAR:
+                /*assume the "offset" is a virtual memory address*/
+                is_scatter_gather = 1;
+                /*put back the right value*/
+                target = NV_DMA_TARGET_PCI;
+                break;
+        default:
+                break;
+        }
+	
+	ret = nouveau_gpuobj_new(dev, chan,
+				 is_scatter_gather ? ((page_count << 2) + 12) : nouveau_gpuobj_class_instmem_size(dev, class),
+				 16,
+				 NVOBJ_FLAG_ZERO_ALLOC | NVOBJ_FLAG_ZERO_FREE,
+				 gpuobj);
+	if (ret) {
+		DRM_ERROR("Error creating gpuobj: %d\n", ret);
+		return ret;
+	}
+
+	if (dev_priv->card_type < NV_50) {
+		uint32_t frame, adjust, pte_flags = 0;
+		adjust = offset &  0x00000fff;
+		if (access != NV_DMA_ACCESS_RO)
+				pte_flags |= (1<<1);
+		
+		if ( ! is_scatter_gather ) 
+			{
+			frame  = offset & ~0x00000fff;
+			
+			INSTANCE_WR(*gpuobj, 0, ((1<<12) | (1<<13) |
+					(adjust << 20) |
+					 (access << 14) |
+					 (target << 16) |
+					  class));
+			INSTANCE_WR(*gpuobj, 1, size - 1);
+			INSTANCE_WR(*gpuobj, 2, frame | pte_flags);
+			INSTANCE_WR(*gpuobj, 3, frame | pte_flags);
+			}
+		else 
+			{
+			/* Intial page entry in the scatter-gather area that
+			 * corresponds to the base offset
+			 */
+			unsigned int idx = offset / PAGE_SIZE;
+
+			uint32_t instance_offset;
+			unsigned int i;
+
+			if ((idx + page_count) > dev->sg->pages) {
+				DRM_ERROR("Requested page range exceedes "
+					  "allocated scatter-gather range!");
+				return -E2BIG;
+			}
+
+			DRM_DEBUG("Creating PCI DMA object using virtual zone starting at %#llx, size %d\n", offset, (uint32_t)size);
+	                INSTANCE_WR(*gpuobj, 0, ((1<<12) | (0<<13) |
+                                (adjust << 20) |
+                                (access << 14) |
+                                (target << 16) |
+                                class));
+			INSTANCE_WR(*gpuobj, 1, (uint32_t) size-1);
+
+
+			/*write starting at the third dword*/
+			instance_offset = 2;
+ 
+			/*for each PAGE, get its bus address, fill in the page table entry, and advance*/
+			for (i = 0; i < page_count; i++) {
+				if (dev->sg->busaddr[idx] == 0) {
+					dev->sg->busaddr[idx] =
+						pci_map_page(dev->pdev,
+							     dev->sg->pagelist[idx],
+							     0,
+							     PAGE_SIZE,
+							     DMA_BIDIRECTIONAL);
+
+					if (dma_mapping_error(dev->sg->busaddr[idx])) {
+						return -ENOMEM;
+					}
+				}
+
+				frame = (uint32_t) dev->sg->busaddr[idx];
+				INSTANCE_WR(*gpuobj, instance_offset, 
+					    frame | pte_flags);
+ 
+				idx++;
+				instance_offset ++;
+ 			}
+			}
+	} else {
+		uint32_t flags0, flags5;
+
+		if (target == NV_DMA_TARGET_VIDMEM) {
+			flags0 = 0x00190000;
+			flags5 = 0x00010000;
+		} else {
+			flags0 = 0x7fc00000;
+			flags5 = 0x00080000;
+		}
+
+		INSTANCE_WR(*gpuobj, 0, flags0 | class);
+		INSTANCE_WR(*gpuobj, 1, offset + size - 1);
+		INSTANCE_WR(*gpuobj, 2, offset);
+		INSTANCE_WR(*gpuobj, 5, flags5);
+	}
+
+	(*gpuobj)->engine = NVOBJ_ENGINE_SW;
+	(*gpuobj)->class  = class;
+	return 0;
+}
+
+int
+nouveau_gpuobj_gart_dma_new(struct nouveau_channel *chan,
+			    uint64_t offset, uint64_t size, int access,
+			    struct nouveau_gpuobj **gpuobj,
+			    uint32_t *o_ret)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int ret;
+
+	if (dev_priv->gart_info.type == NOUVEAU_GART_AGP ||
+	    (dev_priv->card_type >= NV_50 &&
+	     dev_priv->gart_info.type == NOUVEAU_GART_SGDMA)) {
+		ret = nouveau_gpuobj_dma_new(chan, NV_CLASS_DMA_IN_MEMORY,
+					     offset, size, access,
+					     NV_DMA_TARGET_AGP, gpuobj);
+		if (o_ret)
+			*o_ret = 0;
+	} else
+	if (dev_priv->gart_info.type == NOUVEAU_GART_SGDMA) {
+		*gpuobj = dev_priv->gart_info.sg_ctxdma;
+		if (offset & ~0xffffffffULL) {
+			DRM_ERROR("obj offset exceeds 32-bits\n");
+			return -EINVAL;
+		}
+		if (o_ret)
+			*o_ret = (uint32_t)offset;
+		ret = (*gpuobj != NULL) ? 0 : -EINVAL;
+	} else {
+		DRM_ERROR("Invalid GART type %d\n", dev_priv->gart_info.type);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+/* Context objects in the instance RAM have the following structure.
+ * On NV40 they are 32 byte long, on NV30 and smaller 16 bytes.
+
+   NV4 - NV30:
+
+   entry[0]
+   11:0 class
+   12   chroma key enable
+   13   user clip enable
+   14   swizzle enable
+   17:15 patch config:
+       scrcopy_and, rop_and, blend_and, scrcopy, srccopy_pre, blend_pre
+   18   synchronize enable
+   19   endian: 1 big, 0 little
+   21:20 dither mode
+   23    single step enable
+   24    patch status: 0 invalid, 1 valid
+   25    context_surface 0: 1 valid
+   26    context surface 1: 1 valid
+   27    context pattern: 1 valid
+   28    context rop: 1 valid
+   29,30 context beta, beta4
+   entry[1]
+   7:0   mono format
+   15:8  color format
+   31:16 notify instance address
+   entry[2]
+   15:0  dma 0 instance address
+   31:16 dma 1 instance address
+   entry[3]
+   dma method traps
+
+   NV40:
+   No idea what the exact format is. Here's what can be deducted:
+
+   entry[0]:
+   11:0  class  (maybe uses more bits here?)
+   17    user clip enable
+   21:19 patch config 
+   25    patch status valid ?
+   entry[1]:
+   15:0  DMA notifier  (maybe 20:0)
+   entry[2]:
+   15:0  DMA 0 instance (maybe 20:0)
+   24    big endian
+   entry[3]:
+   15:0  DMA 1 instance (maybe 20:0)
+   entry[4]:
+   entry[5]:
+   set to 0?
+*/
+int
+nouveau_gpuobj_gr_new(struct nouveau_channel *chan, int class,
+		      struct nouveau_gpuobj **gpuobj)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int ret;
+
+	DRM_DEBUG("ch%d class=0x%04x\n", chan->id, class);
+
+	ret = nouveau_gpuobj_new(dev, chan,
+				 nouveau_gpuobj_class_instmem_size(dev, class),
+				 16,
+				 NVOBJ_FLAG_ZERO_ALLOC | NVOBJ_FLAG_ZERO_FREE,
+				 gpuobj);
+	if (ret) {
+		DRM_ERROR("Error creating gpuobj: %d\n", ret);
+		return ret;
+	}
+
+	if (dev_priv->card_type >= NV_50) {
+		INSTANCE_WR(*gpuobj, 0, class);
+		INSTANCE_WR(*gpuobj, 5, 0x00010000);
+	} else {
+	switch (class) {
+	case NV_CLASS_NULL:
+		INSTANCE_WR(*gpuobj, 0, 0x00001030);
+		INSTANCE_WR(*gpuobj, 1, 0xFFFFFFFF);
+		break;
+	default:
+		if (dev_priv->card_type >= NV_40) {
+			INSTANCE_WR(*gpuobj, 0, class);
+#ifdef __BIG_ENDIAN
+			INSTANCE_WR(*gpuobj, 2, 0x01000000);
+#endif
+		} else {
+#ifdef __BIG_ENDIAN
+			INSTANCE_WR(*gpuobj, 0, class | 0x00080000);
+#else
+			INSTANCE_WR(*gpuobj, 0, class);
+#endif
+		}
+	}
+	}
+
+	(*gpuobj)->engine = NVOBJ_ENGINE_GR;
+	(*gpuobj)->class  = class;
+	return 0;
+}
+
+static int
+nouveau_gpuobj_channel_init_pramin(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_gpuobj *pramin = NULL;
+	int size, base, ret;
+
+	DRM_DEBUG("ch%d\n", chan->id);
+
+	/* Base amount for object storage (4KiB enough?) */
+	size = 0x1000;
+	base = 0;
+
+	/* PGRAPH context */
+
+	if (dev_priv->card_type == NV_50) {
+		/* Various fixed table thingos */
+		size += 0x1400; /* mostly unknown stuff */
+		size += 0x4000; /* vm pd */
+		base  = 0x6000;
+		/* RAMHT, not sure about setting size yet, 32KiB to be safe */
+		size += 0x8000;
+		/* RAMFC */
+		size += 0x1000;
+		/* PGRAPH context */
+		size += 0x60000;
+	}
+
+	DRM_DEBUG("ch%d PRAMIN size: 0x%08x bytes, base alloc=0x%08x\n",
+		  chan->id, size, base);
+	ret = nouveau_gpuobj_new_ref(dev, NULL, NULL, 0, size, 0x1000, 0,
+				     &chan->ramin);
+	if (ret) {
+		DRM_ERROR("Error allocating channel PRAMIN: %d\n", ret);
+		return ret;
+	}
+	pramin = chan->ramin->gpuobj;
+
+	ret = nouveau_mem_init_heap(&chan->ramin_heap,
+				    pramin->im_pramin->start + base, size);
+	if (ret) {
+		DRM_ERROR("Error creating PRAMIN heap: %d\n", ret);
+		nouveau_gpuobj_ref_del(dev, &chan->ramin);
+		return ret;
+	}
+
+	return 0;
+}
+
+int
+nouveau_gpuobj_channel_init(struct nouveau_channel *chan,
+			    uint32_t vram_h, uint32_t tt_h)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_gpuobj *vram = NULL, *tt = NULL;
+	int ret, i;
+
+	INIT_LIST_HEAD(&chan->ramht_refs);
+
+	DRM_DEBUG("ch%d vram=0x%08x tt=0x%08x\n", chan->id, vram_h, tt_h);
+
+	/* Reserve a block of PRAMIN for the channel
+	 *XXX: maybe on <NV50 too at some point
+	 */
+	if (0 || dev_priv->card_type == NV_50) {
+		ret = nouveau_gpuobj_channel_init_pramin(chan);
+		if (ret)
+			return ret;
+	}
+
+	/* NV50 VM, point offset 0-512MiB at shared PCIEGART table  */
+	if (dev_priv->card_type >= NV_50) {
+		uint32_t vm_offset;
+		
+		vm_offset = (dev_priv->chipset & 0xf0) == 0x50 ? 0x1400 : 0x200;
+		vm_offset += chan->ramin->gpuobj->im_pramin->start;
+		if ((ret = nouveau_gpuobj_new_fake(dev, vm_offset, ~0, 0x4000,
+						   0, &chan->vm_pd, NULL)))
+			return ret;
+		for (i=0; i<0x4000; i+=8) {
+			INSTANCE_WR(chan->vm_pd, (i+0)/4, 0x00000000);
+			INSTANCE_WR(chan->vm_pd, (i+4)/4, 0xdeadcafe);
+		}
+
+		if ((ret = nouveau_gpuobj_ref_add(dev, NULL, 0,
+						  dev_priv->gart_info.sg_ctxdma,
+						  &chan->vm_gart_pt)))
+			return ret;
+		INSTANCE_WR(chan->vm_pd, (0+0)/4,
+			    chan->vm_gart_pt->instance | 0x03);
+		INSTANCE_WR(chan->vm_pd, (0+4)/4, 0x00000000);
+	}
+
+	/* RAMHT */
+	if (dev_priv->card_type < NV_50) {
+		ret = nouveau_gpuobj_ref_add(dev, NULL, 0, dev_priv->ramht,
+					     &chan->ramht);
+		if (ret)
+			return ret;
+	} else {
+		ret = nouveau_gpuobj_new_ref(dev, chan, chan, 0,
+					     0x8000, 16,
+					     NVOBJ_FLAG_ZERO_ALLOC,
+					     &chan->ramht);
+		if (ret)
+			return ret;
+	}
+
+	/* VRAM ctxdma */
+	if ((ret = nouveau_gpuobj_dma_new(chan, NV_CLASS_DMA_IN_MEMORY,
+					  0, dev_priv->fb_available_size,
+					  NV_DMA_ACCESS_RW,
+					  NV_DMA_TARGET_VIDMEM, &vram))) {
+		DRM_ERROR("Error creating VRAM ctxdma: %d\n", ret);
+		return ret;
+	}
+
+	if ((ret = nouveau_gpuobj_ref_add(dev, chan, vram_h, vram, NULL))) {
+		DRM_ERROR("Error referencing VRAM ctxdma: %d\n", ret);
+		return ret;
+	}
+
+	/* TT memory ctxdma */
+	if (dev_priv->gart_info.type != NOUVEAU_GART_NONE) {
+		ret = nouveau_gpuobj_gart_dma_new(chan, 0,
+						  dev_priv->gart_info.aper_size,
+						  NV_DMA_ACCESS_RW, &tt, NULL);
+	} else
+	if (dev_priv->pci_heap) {
+		ret = nouveau_gpuobj_dma_new(chan, NV_CLASS_DMA_IN_MEMORY,
+					     0, dev->sg->pages * PAGE_SIZE,
+					     NV_DMA_ACCESS_RW,
+					     NV_DMA_TARGET_PCI_NONLINEAR, &tt);
+	} else {
+		DRM_ERROR("Invalid GART type %d\n", dev_priv->gart_info.type);
+		ret = -EINVAL;
+	}
+
+	if (ret) {
+		DRM_ERROR("Error creating TT ctxdma: %d\n", ret);
+		return ret;
+	}
+
+	ret = nouveau_gpuobj_ref_add(dev, chan, tt_h, tt, NULL);
+	if (ret) {
+		DRM_ERROR("Error referencing TT ctxdma: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+void
+nouveau_gpuobj_channel_takedown(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct list_head *entry, *tmp;
+	struct nouveau_gpuobj_ref *ref;
+
+	DRM_DEBUG("ch%d\n", chan->id);
+
+	list_for_each_safe(entry, tmp, &chan->ramht_refs) {		
+		ref = list_entry(entry, struct nouveau_gpuobj_ref, list);
+
+		nouveau_gpuobj_ref_del(dev, &ref);
+	}
+
+	nouveau_gpuobj_ref_del(dev, &chan->ramht);
+
+	nouveau_gpuobj_del(dev, &chan->vm_pd);
+	nouveau_gpuobj_ref_del(dev, &chan->vm_gart_pt);
+
+	if (chan->ramin_heap)
+		nouveau_mem_takedown(&chan->ramin_heap);
+	if (chan->ramin)
+		nouveau_gpuobj_ref_del(dev, &chan->ramin);
+
+}
+
+int nouveau_ioctl_grobj_alloc(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv)
+{
+	struct nouveau_channel *chan;
+	struct drm_nouveau_grobj_alloc *init = data;
+	struct nouveau_gpuobj *gr = NULL;
+	int ret;
+
+	NOUVEAU_CHECK_INITIALISED_WITH_RETURN;
+	NOUVEAU_GET_USER_CHANNEL_WITH_RETURN(init->channel, file_priv, chan);
+
+	//FIXME: check args, only allow trusted objects to be created
+	
+	if (init->handle == ~0)
+		return -EINVAL;
+
+	if (nouveau_gpuobj_ref_find(chan, init->handle, NULL) == 0)
+		return -EEXIST;
+
+	ret = nouveau_gpuobj_gr_new(chan, init->class, &gr);
+	if (ret) {
+		DRM_ERROR("Error creating gr object: %d (%d/0x%08x)\n",
+			  ret, init->channel, init->handle);
+		return ret;
+	}
+
+	if ((ret = nouveau_gpuobj_ref_add(dev, chan, init->handle, gr, NULL))) {
+		DRM_ERROR("Error referencing gr object: %d (%d/0x%08x\n)",
+			  ret, init->channel, init->handle);
+		nouveau_gpuobj_del(dev, &gr);
+		return ret;
+	}
+
+	return 0;
+}
+
+int nouveau_ioctl_gpuobj_free(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv)
+{
+	struct drm_nouveau_gpuobj_free *objfree = data;
+	struct nouveau_gpuobj_ref *ref;
+	struct nouveau_channel *chan;
+	int ret;
+
+	NOUVEAU_CHECK_INITIALISED_WITH_RETURN;
+	NOUVEAU_GET_USER_CHANNEL_WITH_RETURN(objfree->channel, file_priv, chan);
+
+	if ((ret = nouveau_gpuobj_ref_find(chan, objfree->handle, &ref)))
+		return ret;
+	nouveau_gpuobj_ref_del(dev, &ref);
+
+	return 0;
+}
+
Index: git/shared-core/nouveau_reg.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nouveau_reg.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,550 @@
+
+
+#define NV03_BOOT_0                                        0x00100000
+#    define NV03_BOOT_0_RAM_AMOUNT                         0x00000003
+#    define NV03_BOOT_0_RAM_AMOUNT_8MB                     0x00000000
+#    define NV03_BOOT_0_RAM_AMOUNT_2MB                     0x00000001
+#    define NV03_BOOT_0_RAM_AMOUNT_4MB                     0x00000002
+#    define NV03_BOOT_0_RAM_AMOUNT_8MB_SDRAM               0x00000003
+#    define NV04_BOOT_0_RAM_AMOUNT_32MB                    0x00000000
+#    define NV04_BOOT_0_RAM_AMOUNT_4MB                     0x00000001
+#    define NV04_BOOT_0_RAM_AMOUNT_8MB                     0x00000002
+#    define NV04_BOOT_0_RAM_AMOUNT_16MB                    0x00000003
+
+#define NV04_FIFO_DATA                                     0x0010020c
+#    define NV10_FIFO_DATA_RAM_AMOUNT_MB_MASK              0xfff00000
+#    define NV10_FIFO_DATA_RAM_AMOUNT_MB_SHIFT             20
+
+#define NV_RAMIN                                           0x00700000
+
+#define NV_RAMHT_HANDLE_OFFSET                             0
+#define NV_RAMHT_CONTEXT_OFFSET                            4
+#    define NV_RAMHT_CONTEXT_VALID                         (1<<31)
+#    define NV_RAMHT_CONTEXT_CHANNEL_SHIFT                 24
+#    define NV_RAMHT_CONTEXT_ENGINE_SHIFT                  16
+#        define NV_RAMHT_CONTEXT_ENGINE_SOFTWARE           0
+#        define NV_RAMHT_CONTEXT_ENGINE_GRAPHICS           1
+#    define NV_RAMHT_CONTEXT_INSTANCE_SHIFT                0
+#    define NV40_RAMHT_CONTEXT_CHANNEL_SHIFT               23
+#    define NV40_RAMHT_CONTEXT_ENGINE_SHIFT                20
+#    define NV40_RAMHT_CONTEXT_INSTANCE_SHIFT              0
+
+/* DMA object defines */
+#define NV_DMA_ACCESS_RW 0
+#define NV_DMA_ACCESS_RO 1
+#define NV_DMA_ACCESS_WO 2
+#define NV_DMA_TARGET_VIDMEM 0
+#define NV_DMA_TARGET_PCI    2
+#define NV_DMA_TARGET_AGP    3
+/*The following is not a real value used by nvidia cards, it's changed by nouveau_object_dma_create*/
+#define NV_DMA_TARGET_PCI_NONLINEAR   8
+
+/* Some object classes we care about in the drm */
+#define NV_CLASS_DMA_FROM_MEMORY                           0x00000002
+#define NV_CLASS_DMA_TO_MEMORY                             0x00000003
+#define NV_CLASS_NULL                                      0x00000030
+#define NV_CLASS_DMA_IN_MEMORY                             0x0000003D
+
+#define NV03_FIFO_SIZE                                     0x8000UL
+#define NV_MAX_FIFO_NUMBER                                 128
+#define NV03_FIFO_REGS_SIZE                                0x10000
+#define NV03_FIFO_REGS(i)                                  (0x00800000+i*NV03_FIFO_REGS_SIZE)
+#    define NV03_FIFO_REGS_DMAPUT(i)                       (NV03_FIFO_REGS(i)+0x40)
+#    define NV03_FIFO_REGS_DMAGET(i)                       (NV03_FIFO_REGS(i)+0x44)
+#define NV50_FIFO_REGS_SIZE                                0x2000
+#define NV50_FIFO_REGS(i)                                  (0x00c00000+i*NV50_FIFO_REGS_SIZE)
+#    define NV50_FIFO_REGS_DMAPUT(i)                       (NV50_FIFO_REGS(i)+0x40)
+#    define NV50_FIFO_REGS_DMAGET(i)                       (NV50_FIFO_REGS(i)+0x44)
+
+#define NV03_PMC_BOOT_0                                    0x00000000
+#define NV03_PMC_INTR_0                                    0x00000100
+#    define NV_PMC_INTR_0_PFIFO_PENDING                       (1<< 8)
+#    define NV_PMC_INTR_0_PGRAPH_PENDING                      (1<<12)
+#    define NV_PMC_INTR_0_CRTC0_PENDING                       (1<<24)
+#    define NV_PMC_INTR_0_CRTC1_PENDING                       (1<<25)
+#    define NV_PMC_INTR_0_CRTCn_PENDING                       (3<<24)
+#define NV03_PMC_INTR_EN_0                                 0x00000140
+#    define NV_PMC_INTR_EN_0_MASTER_ENABLE                    (1<< 0)
+#define NV03_PMC_ENABLE                                    0x00000200
+#    define NV_PMC_ENABLE_PFIFO                               (1<< 8)
+#    define NV_PMC_ENABLE_PGRAPH                              (1<<12)
+/* Disabling the below bit breaks newer (G7X only?) mobile chipsets,
+ * the card will hang early on in the X init process.
+ */
+#    define NV_PMC_ENABLE_UNK13                               (1<<13)
+#define NV40_PMC_1700                                      0x00001700
+#define NV40_PMC_1704                                      0x00001704
+#define NV40_PMC_1708                                      0x00001708
+#define NV40_PMC_170C                                      0x0000170C
+
+/* probably PMC ? */
+#define NV50_PUNK_BAR0_PRAMIN                              0x00001700
+#define NV50_PUNK_BAR_CFG_BASE                             0x00001704
+#define NV50_PUNK_BAR_CFG_BASE_VALID                          (1<<30)
+#define NV50_PUNK_BAR1_CTXDMA                              0x00001708
+#define NV50_PUNK_BAR1_CTXDMA_VALID                           (1<<31)
+#define NV50_PUNK_BAR3_CTXDMA                              0x0000170C
+#define NV50_PUNK_BAR3_CTXDMA_VALID                           (1<<31)
+#define NV50_PUNK_UNK1710                                  0x00001710
+
+#define NV04_PTIMER_INTR_0                                 0x00009100
+#define NV04_PTIMER_INTR_EN_0                              0x00009140
+#define NV04_PTIMER_NUMERATOR                              0x00009200
+#define NV04_PTIMER_DENOMINATOR                            0x00009210
+#define NV04_PTIMER_TIME_0                                 0x00009400
+#define NV04_PTIMER_TIME_1                                 0x00009410
+#define NV04_PTIMER_ALARM_0                                0x00009420
+
+#define NV04_PFB_CFG0                                      0x00100200
+#define NV04_PFB_CFG1                                      0x00100204
+#define NV40_PFB_020C                                      0x0010020C
+#define NV10_PFB_TILE(i)                                   (0x00100240 + (i*16))
+#define NV10_PFB_TILE__SIZE                                8
+#define NV10_PFB_TLIMIT(i)                                 (0x00100244 + (i*16))
+#define NV10_PFB_TSIZE(i)                                  (0x00100248 + (i*16))
+#define NV10_PFB_TSTATUS(i)                                (0x0010024C + (i*16))
+#define NV10_PFB_CLOSE_PAGE2                               0x0010033C
+#define NV40_PFB_TILE(i)                                   (0x00100600 + (i*16))
+#define NV40_PFB_TILE__SIZE_0                              12
+#define NV40_PFB_TILE__SIZE_1                              15
+#define NV40_PFB_TLIMIT(i)                                 (0x00100604 + (i*16))
+#define NV40_PFB_TSIZE(i)                                  (0x00100608 + (i*16))
+#define NV40_PFB_TSTATUS(i)                                (0x0010060C + (i*16))
+
+#define NV04_PGRAPH_DEBUG_0                                0x00400080
+#define NV04_PGRAPH_DEBUG_1                                0x00400084
+#define NV04_PGRAPH_DEBUG_2                                0x00400088
+#define NV04_PGRAPH_DEBUG_3                                0x0040008c
+#define NV10_PGRAPH_DEBUG_4                                0x00400090
+#define NV03_PGRAPH_INTR                                   0x00400100
+#define NV03_PGRAPH_NSTATUS                                0x00400104
+#    define NV03_PGRAPH_NSTATUS_STATE_IN_USE                  (1<<23)
+#    define NV03_PGRAPH_NSTATUS_INVALID_STATE                 (1<<24)
+#    define NV03_PGRAPH_NSTATUS_BAD_ARGUMENT                  (1<<25)
+#    define NV03_PGRAPH_NSTATUS_PROTECTION_FAULT              (1<<26)
+#define NV03_PGRAPH_NSOURCE                                0x00400108
+#    define NV03_PGRAPH_NSOURCE_NOTIFICATION                  (1<< 0)
+#    define NV03_PGRAPH_NSOURCE_DATA_ERROR                    (1<< 1)
+#    define NV03_PGRAPH_NSOURCE_PROTECTION_ERROR              (1<< 2)
+#    define NV03_PGRAPH_NSOURCE_RANGE_EXCEPTION               (1<< 3)
+#    define NV03_PGRAPH_NSOURCE_LIMIT_COLOR                   (1<< 4)
+#    define NV03_PGRAPH_NSOURCE_LIMIT_ZETA                    (1<< 5)
+#    define NV03_PGRAPH_NSOURCE_ILLEGAL_MTHD                  (1<< 6)
+#    define NV03_PGRAPH_NSOURCE_DMA_R_PROTECTION              (1<< 7)
+#    define NV03_PGRAPH_NSOURCE_DMA_W_PROTECTION              (1<< 8)
+#    define NV03_PGRAPH_NSOURCE_FORMAT_EXCEPTION              (1<< 9)
+#    define NV03_PGRAPH_NSOURCE_PATCH_EXCEPTION               (1<<10)
+#    define NV03_PGRAPH_NSOURCE_STATE_INVALID                 (1<<11)
+#    define NV03_PGRAPH_NSOURCE_DOUBLE_NOTIFY                 (1<<12)
+#    define NV03_PGRAPH_NSOURCE_NOTIFY_IN_USE                 (1<<13)
+#    define NV03_PGRAPH_NSOURCE_METHOD_CNT                    (1<<14)
+#    define NV03_PGRAPH_NSOURCE_BFR_NOTIFICATION              (1<<15)
+#    define NV03_PGRAPH_NSOURCE_DMA_VTX_PROTECTION            (1<<16)
+#    define NV03_PGRAPH_NSOURCE_DMA_WIDTH_A                   (1<<17)
+#    define NV03_PGRAPH_NSOURCE_DMA_WIDTH_B                   (1<<18)
+#define NV03_PGRAPH_INTR_EN                                0x00400140
+#define NV40_PGRAPH_INTR_EN                                0x0040013C
+#    define NV_PGRAPH_INTR_NOTIFY                             (1<< 0)
+#    define NV_PGRAPH_INTR_MISSING_HW                         (1<< 4)
+#    define NV_PGRAPH_INTR_CONTEXT_SWITCH                     (1<<12)
+#    define NV_PGRAPH_INTR_BUFFER_NOTIFY                      (1<<16)
+#    define NV_PGRAPH_INTR_ERROR                              (1<<20)
+#define NV10_PGRAPH_CTX_CONTROL                            0x00400144
+#define NV10_PGRAPH_CTX_USER                               0x00400148
+#define NV10_PGRAPH_CTX_SWITCH1                            0x0040014C
+#define NV10_PGRAPH_CTX_SWITCH2                            0x00400150
+#define NV10_PGRAPH_CTX_SWITCH3                            0x00400154
+#define NV10_PGRAPH_CTX_SWITCH4                            0x00400158
+#define NV10_PGRAPH_CTX_SWITCH5                            0x0040015C
+#define NV04_PGRAPH_CTX_SWITCH1                            0x00400160
+#define NV10_PGRAPH_CTX_CACHE1                             0x00400160
+#define NV04_PGRAPH_CTX_SWITCH2                            0x00400164
+#define NV04_PGRAPH_CTX_SWITCH3                            0x00400168
+#define NV04_PGRAPH_CTX_SWITCH4                            0x0040016C
+#define NV04_PGRAPH_CTX_CONTROL                            0x00400170
+#define NV04_PGRAPH_CTX_USER                               0x00400174
+#define NV04_PGRAPH_CTX_CACHE1                             0x00400180
+#define NV10_PGRAPH_CTX_CACHE2                             0x00400180
+#define NV03_PGRAPH_CTX_CONTROL                            0x00400190
+#define NV03_PGRAPH_CTX_USER                               0x00400194
+#define NV04_PGRAPH_CTX_CACHE2                             0x004001A0
+#define NV10_PGRAPH_CTX_CACHE3                             0x004001A0
+#define NV04_PGRAPH_CTX_CACHE3                             0x004001C0
+#define NV10_PGRAPH_CTX_CACHE4                             0x004001C0
+#define NV04_PGRAPH_CTX_CACHE4                             0x004001E0
+#define NV10_PGRAPH_CTX_CACHE5                             0x004001E0
+#define NV40_PGRAPH_CTXCTL_0304                            0x00400304
+#define NV40_PGRAPH_CTXCTL_0304_XFER_CTX                   0x00000001
+#define NV40_PGRAPH_CTXCTL_UCODE_STAT                      0x00400308
+#define NV40_PGRAPH_CTXCTL_UCODE_STAT_IP_MASK              0xff000000
+#define NV40_PGRAPH_CTXCTL_UCODE_STAT_IP_SHIFT                     24
+#define NV40_PGRAPH_CTXCTL_UCODE_STAT_OP_MASK              0x00ffffff
+#define NV40_PGRAPH_CTXCTL_0310                            0x00400310
+#define NV40_PGRAPH_CTXCTL_0310_XFER_SAVE                  0x00000020
+#define NV40_PGRAPH_CTXCTL_0310_XFER_LOAD                  0x00000040
+#define NV40_PGRAPH_CTXCTL_030C                            0x0040030c
+#define NV40_PGRAPH_CTXCTL_UCODE_INDEX                     0x00400324
+#define NV40_PGRAPH_CTXCTL_UCODE_DATA                      0x00400328
+#define NV40_PGRAPH_CTXCTL_CUR                             0x0040032c
+#define NV40_PGRAPH_CTXCTL_CUR_LOADED                      0x01000000
+#define NV40_PGRAPH_CTXCTL_CUR_INST_MASK                   0x000FFFFF
+#define NV03_PGRAPH_ABS_X_RAM                              0x00400400
+#define NV03_PGRAPH_ABS_Y_RAM                              0x00400480
+#define NV03_PGRAPH_X_MISC                                 0x00400500
+#define NV03_PGRAPH_Y_MISC                                 0x00400504
+#define NV04_PGRAPH_VALID1                                 0x00400508
+#define NV04_PGRAPH_SOURCE_COLOR                           0x0040050C
+#define NV04_PGRAPH_MISC24_0                               0x00400510
+#define NV03_PGRAPH_XY_LOGIC_MISC0                         0x00400514
+#define NV03_PGRAPH_XY_LOGIC_MISC1                         0x00400518
+#define NV03_PGRAPH_XY_LOGIC_MISC2                         0x0040051C
+#define NV03_PGRAPH_XY_LOGIC_MISC3                         0x00400520
+#define NV03_PGRAPH_CLIPX_0                                0x00400524
+#define NV03_PGRAPH_CLIPX_1                                0x00400528
+#define NV03_PGRAPH_CLIPY_0                                0x0040052C
+#define NV03_PGRAPH_CLIPY_1                                0x00400530
+#define NV03_PGRAPH_ABS_ICLIP_XMAX                         0x00400534
+#define NV03_PGRAPH_ABS_ICLIP_YMAX                         0x00400538
+#define NV03_PGRAPH_ABS_UCLIP_XMIN                         0x0040053C
+#define NV03_PGRAPH_ABS_UCLIP_YMIN                         0x00400540
+#define NV03_PGRAPH_ABS_UCLIP_XMAX                         0x00400544
+#define NV03_PGRAPH_ABS_UCLIP_YMAX                         0x00400548
+#define NV03_PGRAPH_ABS_UCLIPA_XMIN                        0x00400560
+#define NV03_PGRAPH_ABS_UCLIPA_YMIN                        0x00400564
+#define NV03_PGRAPH_ABS_UCLIPA_XMAX                        0x00400568
+#define NV03_PGRAPH_ABS_UCLIPA_YMAX                        0x0040056C
+#define NV04_PGRAPH_MISC24_1                               0x00400570
+#define NV04_PGRAPH_MISC24_2                               0x00400574
+#define NV04_PGRAPH_VALID2                                 0x00400578
+#define NV04_PGRAPH_PASSTHRU_0                             0x0040057C
+#define NV04_PGRAPH_PASSTHRU_1                             0x00400580
+#define NV04_PGRAPH_PASSTHRU_2                             0x00400584
+#define NV10_PGRAPH_DIMX_TEXTURE                           0x00400588
+#define NV10_PGRAPH_WDIMX_TEXTURE                          0x0040058C
+#define NV04_PGRAPH_COMBINE_0_ALPHA                        0x00400590
+#define NV04_PGRAPH_COMBINE_0_COLOR                        0x00400594
+#define NV04_PGRAPH_COMBINE_1_ALPHA                        0x00400598
+#define NV04_PGRAPH_COMBINE_1_COLOR                        0x0040059C
+#define NV04_PGRAPH_FORMAT_0                               0x004005A8
+#define NV04_PGRAPH_FORMAT_1                               0x004005AC
+#define NV04_PGRAPH_FILTER_0                               0x004005B0
+#define NV04_PGRAPH_FILTER_1                               0x004005B4
+#define NV03_PGRAPH_MONO_COLOR0                            0x00400600
+#define NV04_PGRAPH_ROP3                                   0x00400604
+#define NV04_PGRAPH_BETA_AND                               0x00400608
+#define NV04_PGRAPH_BETA_PREMULT                           0x0040060C
+#define NV04_PGRAPH_LIMIT_VIOL_PIX                         0x00400610
+#define NV04_PGRAPH_FORMATS                                0x00400618
+#define NV10_PGRAPH_DEBUG_2                                0x00400620
+#define NV04_PGRAPH_BOFFSET0                               0x00400640
+#define NV04_PGRAPH_BOFFSET1                               0x00400644
+#define NV04_PGRAPH_BOFFSET2                               0x00400648
+#define NV04_PGRAPH_BOFFSET3                               0x0040064C
+#define NV04_PGRAPH_BOFFSET4                               0x00400650
+#define NV04_PGRAPH_BOFFSET5                               0x00400654
+#define NV04_PGRAPH_BBASE0                                 0x00400658
+#define NV04_PGRAPH_BBASE1                                 0x0040065C
+#define NV04_PGRAPH_BBASE2                                 0x00400660
+#define NV04_PGRAPH_BBASE3                                 0x00400664
+#define NV04_PGRAPH_BBASE4                                 0x00400668
+#define NV04_PGRAPH_BBASE5                                 0x0040066C
+#define NV04_PGRAPH_BPITCH0                                0x00400670
+#define NV04_PGRAPH_BPITCH1                                0x00400674
+#define NV04_PGRAPH_BPITCH2                                0x00400678
+#define NV04_PGRAPH_BPITCH3                                0x0040067C
+#define NV04_PGRAPH_BPITCH4                                0x00400680
+#define NV04_PGRAPH_BLIMIT0                                0x00400684
+#define NV04_PGRAPH_BLIMIT1                                0x00400688
+#define NV04_PGRAPH_BLIMIT2                                0x0040068C
+#define NV04_PGRAPH_BLIMIT3                                0x00400690
+#define NV04_PGRAPH_BLIMIT4                                0x00400694
+#define NV04_PGRAPH_BLIMIT5                                0x00400698
+#define NV04_PGRAPH_BSWIZZLE2                              0x0040069C
+#define NV04_PGRAPH_BSWIZZLE5                              0x004006A0
+#define NV03_PGRAPH_STATUS                                 0x004006B0
+#define NV04_PGRAPH_STATUS                                 0x00400700
+#define NV04_PGRAPH_TRAPPED_ADDR                           0x00400704
+#define NV04_PGRAPH_TRAPPED_DATA                           0x00400708
+#define NV04_PGRAPH_SURFACE                                0x0040070C
+#define NV10_PGRAPH_TRAPPED_DATA_HIGH                      0x0040070C
+#define NV04_PGRAPH_STATE                                  0x00400710
+#define NV10_PGRAPH_SURFACE                                0x00400710
+#define NV04_PGRAPH_NOTIFY                                 0x00400714
+#define NV10_PGRAPH_STATE                                  0x00400714
+#define NV10_PGRAPH_NOTIFY                                 0x00400718
+
+#define NV04_PGRAPH_FIFO                                   0x00400720
+
+#define NV04_PGRAPH_BPIXEL                                 0x00400724
+#define NV10_PGRAPH_RDI_INDEX                              0x00400750
+#define NV04_PGRAPH_FFINTFC_ST2                            0x00400754
+#define NV10_PGRAPH_RDI_DATA                               0x00400754
+#define NV04_PGRAPH_DMA_PITCH                              0x00400760
+#define NV10_PGRAPH_FFINTFC_ST2                            0x00400764
+#define NV04_PGRAPH_DVD_COLORFMT                           0x00400764
+#define NV04_PGRAPH_SCALED_FORMAT                          0x00400768
+#define NV10_PGRAPH_DMA_PITCH                              0x00400770
+#define NV10_PGRAPH_DVD_COLORFMT                           0x00400774
+#define NV10_PGRAPH_SCALED_FORMAT                          0x00400778
+#define NV10_PGRAPH_CHANNEL_CTX_TABLE                      0x00400780
+#define NV10_PGRAPH_CHANNEL_CTX_SIZE                       0x00400784
+#define NV20_PGRAPH_CHANNEL_CTX_POINTER                    0x00400784
+#define NV10_PGRAPH_CHANNEL_CTX_POINTER                    0x00400788
+#define NV20_PGRAPH_CHANNEL_CTX_XFER                       0x00400788
+#define NV20_PGRAPH_CHANNEL_CTX_XFER_LOAD                  0x00000001
+#define NV20_PGRAPH_CHANNEL_CTX_XFER_SAVE                  0x00000002
+#define NV04_PGRAPH_PATT_COLOR0                            0x00400800
+#define NV04_PGRAPH_PATT_COLOR1                            0x00400804
+#define NV04_PGRAPH_PATTERN                                0x00400808
+#define NV04_PGRAPH_PATTERN_SHAPE                          0x00400810
+#define NV04_PGRAPH_CHROMA                                 0x00400814
+#define NV04_PGRAPH_CONTROL0                               0x00400818
+#define NV04_PGRAPH_CONTROL1                               0x0040081C
+#define NV04_PGRAPH_CONTROL2                               0x00400820
+#define NV04_PGRAPH_BLEND                                  0x00400824
+#define NV04_PGRAPH_STORED_FMT                             0x00400830
+#define NV04_PGRAPH_PATT_COLORRAM                          0x00400900
+#define NV40_PGRAPH_TILE0(i)                               0x00400900
+#define NV40_PGRAPH_TLIMIT0(i)                             0x00400904
+#define NV40_PGRAPH_TSIZE0(i)                              0x00400908
+#define NV40_PGRAPH_TSTATUS0(i)                            0x0040090C
+#define NV10_PGRAPH_TILE(i)                                (0x00400B00 + (i*16))
+#define NV10_PGRAPH_TLIMIT(i)                              (0x00400B04 + (i*16))
+#define NV10_PGRAPH_TSIZE(i)                               (0x00400B08 + (i*16))
+#define NV10_PGRAPH_TSTATUS(i)                             (0x00400B0C + (i*16))
+#define NV04_PGRAPH_U_RAM                                  0x00400D00
+#define NV47_PGRAPH_TILE0(i)                               0x00400D00
+#define NV47_PGRAPH_TLIMIT0(i)                             0x00400D04
+#define NV47_PGRAPH_TSIZE0(i)                              0x00400D08
+#define NV47_PGRAPH_TSTATUS0(i)                            0x00400D0C
+#define NV04_PGRAPH_V_RAM                                  0x00400D40
+#define NV04_PGRAPH_W_RAM                                  0x00400D80
+#define NV10_PGRAPH_COMBINER0_IN_ALPHA                     0x00400E40
+#define NV10_PGRAPH_COMBINER1_IN_ALPHA                     0x00400E44
+#define NV10_PGRAPH_COMBINER0_IN_RGB                       0x00400E48
+#define NV10_PGRAPH_COMBINER1_IN_RGB                       0x00400E4C
+#define NV10_PGRAPH_COMBINER_COLOR0                        0x00400E50
+#define NV10_PGRAPH_COMBINER_COLOR1                        0x00400E54
+#define NV10_PGRAPH_COMBINER0_OUT_ALPHA                    0x00400E58
+#define NV10_PGRAPH_COMBINER1_OUT_ALPHA                    0x00400E5C
+#define NV10_PGRAPH_COMBINER0_OUT_RGB                      0x00400E60
+#define NV10_PGRAPH_COMBINER1_OUT_RGB                      0x00400E64
+#define NV10_PGRAPH_COMBINER_FINAL0                        0x00400E68
+#define NV10_PGRAPH_COMBINER_FINAL1                        0x00400E6C
+#define NV10_PGRAPH_WINDOWCLIP_HORIZONTAL                  0x00400F00
+#define NV10_PGRAPH_WINDOWCLIP_VERTICAL                    0x00400F20
+#define NV10_PGRAPH_XFMODE0                                0x00400F40
+#define NV10_PGRAPH_XFMODE1                                0x00400F44
+#define NV10_PGRAPH_GLOBALSTATE0                           0x00400F48
+#define NV10_PGRAPH_GLOBALSTATE1                           0x00400F4C
+#define NV10_PGRAPH_PIPE_ADDRESS                           0x00400F50
+#define NV10_PGRAPH_PIPE_DATA                              0x00400F54
+#define NV04_PGRAPH_DMA_START_0                            0x00401000
+#define NV04_PGRAPH_DMA_START_1                            0x00401004
+#define NV04_PGRAPH_DMA_LENGTH                             0x00401008
+#define NV04_PGRAPH_DMA_MISC                               0x0040100C
+#define NV04_PGRAPH_DMA_DATA_0                             0x00401020
+#define NV04_PGRAPH_DMA_DATA_1                             0x00401024
+#define NV04_PGRAPH_DMA_RM                                 0x00401030
+#define NV04_PGRAPH_DMA_A_XLATE_INST                       0x00401040
+#define NV04_PGRAPH_DMA_A_CONTROL                          0x00401044
+#define NV04_PGRAPH_DMA_A_LIMIT                            0x00401048
+#define NV04_PGRAPH_DMA_A_TLB_PTE                          0x0040104C
+#define NV04_PGRAPH_DMA_A_TLB_TAG                          0x00401050
+#define NV04_PGRAPH_DMA_A_ADJ_OFFSET                       0x00401054
+#define NV04_PGRAPH_DMA_A_OFFSET                           0x00401058
+#define NV04_PGRAPH_DMA_A_SIZE                             0x0040105C
+#define NV04_PGRAPH_DMA_A_Y_SIZE                           0x00401060
+#define NV04_PGRAPH_DMA_B_XLATE_INST                       0x00401080
+#define NV04_PGRAPH_DMA_B_CONTROL                          0x00401084
+#define NV04_PGRAPH_DMA_B_LIMIT                            0x00401088
+#define NV04_PGRAPH_DMA_B_TLB_PTE                          0x0040108C
+#define NV04_PGRAPH_DMA_B_TLB_TAG                          0x00401090
+#define NV04_PGRAPH_DMA_B_ADJ_OFFSET                       0x00401094
+#define NV04_PGRAPH_DMA_B_OFFSET                           0x00401098
+#define NV04_PGRAPH_DMA_B_SIZE                             0x0040109C
+#define NV04_PGRAPH_DMA_B_Y_SIZE                           0x004010A0
+#define NV40_PGRAPH_TILE1(i)                               0x00406900
+#define NV40_PGRAPH_TLIMIT1(i)                             0x00406904
+#define NV40_PGRAPH_TSIZE1(i)                              0x00406908
+#define NV40_PGRAPH_TSTATUS1(i)                            0x0040690C
+
+
+/* It's a guess that this works on NV03. Confirmed on NV04, though */
+#define NV04_PFIFO_DELAY_0                                 0x00002040
+#define NV04_PFIFO_DMA_TIMESLICE                           0x00002044
+#define NV04_PFIFO_NEXT_CHANNEL                            0x00002050
+#define NV03_PFIFO_INTR_0                                  0x00002100
+#define NV03_PFIFO_INTR_EN_0                               0x00002140
+#    define NV_PFIFO_INTR_CACHE_ERROR                         (1<< 0)
+#    define NV_PFIFO_INTR_RUNOUT                              (1<< 4)
+#    define NV_PFIFO_INTR_RUNOUT_OVERFLOW                     (1<< 8)
+#    define NV_PFIFO_INTR_DMA_PUSHER                          (1<<12)
+#    define NV_PFIFO_INTR_DMA_PT                              (1<<16)
+#    define NV_PFIFO_INTR_SEMAPHORE                           (1<<20)
+#    define NV_PFIFO_INTR_ACQUIRE_TIMEOUT                     (1<<24)
+#define NV03_PFIFO_RAMHT                                   0x00002210
+#define NV03_PFIFO_RAMFC                                   0x00002214
+#define NV03_PFIFO_RAMRO                                   0x00002218
+#define NV40_PFIFO_RAMFC                                   0x00002220
+#define NV03_PFIFO_CACHES                                  0x00002500
+#define NV04_PFIFO_MODE                                    0x00002504
+#define NV04_PFIFO_DMA                                     0x00002508
+#define NV04_PFIFO_SIZE                                    0x0000250c
+#define NV50_PFIFO_CTX_TABLE(c)                        (0x2600+(c)*4)
+#define NV50_PFIFO_CTX_TABLE__SIZE                                128
+#define NV50_PFIFO_CTX_TABLE_CHANNEL_ENABLED                  (1<<31)
+#define NV50_PFIFO_CTX_TABLE_UNK30_BAD                        (1<<30)
+#define NV50_PFIFO_CTX_TABLE_INSTANCE_MASK_G80             0x0FFFFFFF
+#define NV50_PFIFO_CTX_TABLE_INSTANCE_MASK_G84             0x00FFFFFF
+#define NV03_PFIFO_CACHE0_PUSH0                            0x00003000
+#define NV03_PFIFO_CACHE0_PULL0                            0x00003040
+#define NV04_PFIFO_CACHE0_PULL0                            0x00003050
+#define NV04_PFIFO_CACHE0_PULL1                            0x00003054
+#define NV03_PFIFO_CACHE1_PUSH0                            0x00003200
+#define NV03_PFIFO_CACHE1_PUSH1                            0x00003204
+#define NV04_PFIFO_CACHE1_DMA_PUSH                         0x00003220
+#define NV04_PFIFO_CACHE1_DMA_FETCH                        0x00003224
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_8_BYTES         0x00000000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_16_BYTES        0x00000008
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_24_BYTES        0x00000010
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_32_BYTES        0x00000018
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_40_BYTES        0x00000020
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_48_BYTES        0x00000028
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_56_BYTES        0x00000030
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_64_BYTES        0x00000038
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_72_BYTES        0x00000040
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_80_BYTES        0x00000048
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_88_BYTES        0x00000050
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_96_BYTES        0x00000058
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_104_BYTES       0x00000060
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_112_BYTES       0x00000068
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_120_BYTES       0x00000070
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES       0x00000078
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_136_BYTES       0x00000080
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_144_BYTES       0x00000088
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_152_BYTES       0x00000090
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_160_BYTES       0x00000098
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_168_BYTES       0x000000A0
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_176_BYTES       0x000000A8
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_184_BYTES       0x000000B0
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_192_BYTES       0x000000B8
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_200_BYTES       0x000000C0
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_208_BYTES       0x000000C8
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_216_BYTES       0x000000D0
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_224_BYTES       0x000000D8
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_232_BYTES       0x000000E0
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_240_BYTES       0x000000E8
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_248_BYTES       0x000000F0
+#    define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_256_BYTES       0x000000F8
+#    define NV_PFIFO_CACHE1_DMA_FETCH_SIZE                 0x0000E000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_32_BYTES        0x00000000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_64_BYTES        0x00002000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_96_BYTES        0x00004000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES       0x00006000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_160_BYTES       0x00008000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_192_BYTES       0x0000A000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_224_BYTES       0x0000C000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_256_BYTES       0x0000E000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS             0x001F0000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_0           0x00000000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_1           0x00010000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_2           0x00020000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_3           0x00030000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_4           0x00040000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_5           0x00050000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_6           0x00060000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_7           0x00070000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8           0x00080000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_9           0x00090000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_10          0x000A0000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_11          0x000B0000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_12          0x000C0000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_13          0x000D0000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_14          0x000E0000
+#    define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_15          0x000F0000
+#    define NV_PFIFO_CACHE1_ENDIAN                         0x80000000
+#    define NV_PFIFO_CACHE1_LITTLE_ENDIAN                  0x7FFFFFFF
+#    define NV_PFIFO_CACHE1_BIG_ENDIAN                     0x80000000
+#define NV04_PFIFO_CACHE1_DMA_STATE                        0x00003228
+#define NV04_PFIFO_CACHE1_DMA_INSTANCE                     0x0000322c
+#define NV04_PFIFO_CACHE1_DMA_CTL                          0x00003230
+#define NV04_PFIFO_CACHE1_DMA_PUT                          0x00003240
+#define NV04_PFIFO_CACHE1_DMA_GET                          0x00003244
+#define NV10_PFIFO_CACHE1_REF_CNT                          0x00003248
+#define NV10_PFIFO_CACHE1_DMA_SUBROUTINE                   0x0000324C
+#define NV03_PFIFO_CACHE1_PULL0                            0x00003240
+#define NV04_PFIFO_CACHE1_PULL0                            0x00003250
+#define NV03_PFIFO_CACHE1_PULL1                            0x00003250
+#define NV04_PFIFO_CACHE1_PULL1                            0x00003254
+#define NV04_PFIFO_CACHE1_HASH                             0x00003258
+#define NV10_PFIFO_CACHE1_ACQUIRE_TIMEOUT                  0x00003260
+#define NV10_PFIFO_CACHE1_ACQUIRE_TIMESTAMP                0x00003264
+#define NV10_PFIFO_CACHE1_ACQUIRE_VALUE                    0x00003268
+#define NV10_PFIFO_CACHE1_SEMAPHORE                        0x0000326C
+#define NV03_PFIFO_CACHE1_GET                              0x00003270
+#define NV04_PFIFO_CACHE1_ENGINE                           0x00003280
+#define NV04_PFIFO_CACHE1_DMA_DCOUNT                       0x000032A0
+#define NV40_PFIFO_GRCTX_INSTANCE                          0x000032E0
+#define NV40_PFIFO_UNK32E4                                 0x000032E4
+#define NV04_PFIFO_CACHE1_METHOD(i)                (0x00003800+(i*8))
+#define NV04_PFIFO_CACHE1_DATA(i)                  (0x00003804+(i*8))
+#define NV40_PFIFO_CACHE1_METHOD(i)                (0x00090000+(i*8))
+#define NV40_PFIFO_CACHE1_DATA(i)                  (0x00090004+(i*8))
+
+#define NV_CRTC0_INTSTAT                                   0x00600100
+#define NV_CRTC0_INTEN                                     0x00600140
+#define NV_CRTC1_INTSTAT                                   0x00602100
+#define NV_CRTC1_INTEN                                     0x00602140
+#    define NV_CRTC_INTR_VBLANK                                (1<<0)
+
+/* Fifo commands. These are not regs, neither masks */
+#define NV03_FIFO_CMD_JUMP                                 0x20000000
+#define NV03_FIFO_CMD_JUMP_OFFSET_MASK                     0x1ffffffc
+#define NV03_FIFO_CMD_REWIND                               (NV03_FIFO_CMD_JUMP | (0 & NV03_FIFO_CMD_JUMP_OFFSET_MASK))
+
+/* RAMFC offsets */
+#define NV04_RAMFC_DMA_PUT                                       0x00
+#define NV04_RAMFC_DMA_GET                                       0x04
+#define NV04_RAMFC_DMA_INSTANCE                                  0x08
+#define NV04_RAMFC_DMA_STATE                                     0x0C
+#define NV04_RAMFC_DMA_FETCH                                     0x10
+#define NV04_RAMFC_ENGINE                                        0x14
+#define NV04_RAMFC_PULL1_ENGINE                                  0x18
+
+#define NV10_RAMFC_DMA_PUT                                       0x00
+#define NV10_RAMFC_DMA_GET                                       0x04
+#define NV10_RAMFC_REF_CNT                                       0x08
+#define NV10_RAMFC_DMA_INSTANCE                                  0x0C
+#define NV10_RAMFC_DMA_STATE                                     0x10
+#define NV10_RAMFC_DMA_FETCH                                     0x14
+#define NV10_RAMFC_ENGINE                                        0x18
+#define NV10_RAMFC_PULL1_ENGINE                                  0x1C
+#define NV10_RAMFC_ACQUIRE_VALUE                                 0x20
+#define NV10_RAMFC_ACQUIRE_TIMESTAMP                             0x24
+#define NV10_RAMFC_ACQUIRE_TIMEOUT                               0x28
+#define NV10_RAMFC_SEMAPHORE                                     0x2C
+#define NV10_RAMFC_DMA_SUBROUTINE                                0x30
+
+#define NV40_RAMFC_DMA_PUT                                       0x00
+#define NV40_RAMFC_DMA_GET                                       0x04
+#define NV40_RAMFC_REF_CNT                                       0x08
+#define NV40_RAMFC_DMA_INSTANCE                                  0x0C
+#define NV40_RAMFC_DMA_DCOUNT /* ? */                            0x10
+#define NV40_RAMFC_DMA_STATE                                     0x14
+#define NV40_RAMFC_DMA_FETCH                                     0x18
+#define NV40_RAMFC_ENGINE                                        0x1C
+#define NV40_RAMFC_PULL1_ENGINE                                  0x20
+#define NV40_RAMFC_ACQUIRE_VALUE                                 0x24
+#define NV40_RAMFC_ACQUIRE_TIMESTAMP                             0x28
+#define NV40_RAMFC_ACQUIRE_TIMEOUT                               0x2C
+#define NV40_RAMFC_SEMAPHORE                                     0x30
+#define NV40_RAMFC_DMA_SUBROUTINE                                0x34
+#define NV40_RAMFC_GRCTX_INSTANCE /* guess */                    0x38
+#define NV40_RAMFC_DMA_TIMESLICE                                 0x3C
+#define NV40_RAMFC_UNK_40                                        0x40
+#define NV40_RAMFC_UNK_44                                        0x44
+#define NV40_RAMFC_UNK_48                                        0x48
+#define NV40_RAMFC_UNK_4C                                        0x4C
+#define NV40_RAMFC_UNK_50                                        0x50
+
Index: git/shared-core/nouveau_state.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nouveau_state.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,566 @@
+/* 
+ * Copyright 2005 Stephane Marchesin
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "drm_sarea.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+static int nouveau_init_card_mappings(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int ret;
+
+	/* resource 0 is mmio regs */
+	/* resource 1 is linear FB */
+	/* resource 2 is RAMIN (mmio regs + 0x1000000) */
+	/* resource 6 is bios */
+
+	/* map the mmio regs */
+	ret = drm_addmap(dev, drm_get_resource_start(dev, 0),
+			      drm_get_resource_len(dev, 0), 
+			      _DRM_REGISTERS, _DRM_READ_ONLY, &dev_priv->mmio);
+	if (ret) {
+		DRM_ERROR("Unable to initialize the mmio mapping (%d). "
+			  "Please report your setup to " DRIVER_EMAIL "\n",
+			  ret);
+		return 1;
+	}
+	DRM_DEBUG("regs mapped ok at 0x%lx\n", dev_priv->mmio->offset);
+
+	/* map larger RAMIN aperture on NV40 cards */
+	dev_priv->ramin = NULL;
+	if (dev_priv->card_type >= NV_40) {
+		int ramin_resource = 2;
+		if (drm_get_resource_len(dev, ramin_resource) == 0)
+			ramin_resource = 3;
+
+		ret = drm_addmap(dev,
+				 drm_get_resource_start(dev, ramin_resource),
+				 drm_get_resource_len(dev, ramin_resource),
+				 _DRM_REGISTERS, _DRM_READ_ONLY,
+				 &dev_priv->ramin);
+		if (ret) {
+			DRM_ERROR("Failed to init RAMIN mapping, "
+				  "limited instance memory available\n");
+			dev_priv->ramin = NULL;
+		}
+	}
+
+	/* On older cards (or if the above failed), create a map covering
+	 * the BAR0 PRAMIN aperture */
+	if (!dev_priv->ramin) {
+		ret = drm_addmap(dev,
+				 drm_get_resource_start(dev, 0) + NV_RAMIN,
+				 (1*1024*1024),
+				 _DRM_REGISTERS, _DRM_READ_ONLY,
+				 &dev_priv->ramin);
+		if (ret) {
+			DRM_ERROR("Failed to map BAR0 PRAMIN: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int nouveau_stub_init(struct drm_device *dev) { return 0; }
+static void nouveau_stub_takedown(struct drm_device *dev) {}
+static uint64_t nouveau_stub_timer_read(struct drm_device *dev) { return 0; }
+
+static int nouveau_init_engine_ptrs(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_engine *engine = &dev_priv->Engine;
+
+	switch (dev_priv->chipset & 0xf0) {
+	case 0x00:
+		engine->instmem.init	= nv04_instmem_init;
+		engine->instmem.takedown= nv04_instmem_takedown;
+		engine->instmem.populate	= nv04_instmem_populate;
+		engine->instmem.clear		= nv04_instmem_clear;
+		engine->instmem.bind		= nv04_instmem_bind;
+		engine->instmem.unbind		= nv04_instmem_unbind;
+		engine->mc.init		= nv04_mc_init;
+		engine->mc.takedown	= nv04_mc_takedown;
+		engine->timer.init	= nv04_timer_init;
+		engine->timer.read	= nv04_timer_read;
+		engine->timer.takedown	= nv04_timer_takedown;
+		engine->fb.init		= nv04_fb_init;
+		engine->fb.takedown	= nv04_fb_takedown;
+		engine->graph.init	= nv04_graph_init;
+		engine->graph.takedown	= nv04_graph_takedown;
+		engine->graph.create_context	= nv04_graph_create_context;
+		engine->graph.destroy_context	= nv04_graph_destroy_context;
+		engine->graph.load_context	= nv04_graph_load_context;
+		engine->graph.save_context	= nv04_graph_save_context;
+		engine->fifo.init	= nouveau_fifo_init;
+		engine->fifo.takedown	= nouveau_stub_takedown;
+		engine->fifo.create_context	= nv04_fifo_create_context;
+		engine->fifo.destroy_context	= nv04_fifo_destroy_context;
+		engine->fifo.load_context	= nv04_fifo_load_context;
+		engine->fifo.save_context	= nv04_fifo_save_context;
+		break;
+	case 0x10:
+		engine->instmem.init	= nv04_instmem_init;
+		engine->instmem.takedown= nv04_instmem_takedown;
+		engine->instmem.populate	= nv04_instmem_populate;
+		engine->instmem.clear		= nv04_instmem_clear;
+		engine->instmem.bind		= nv04_instmem_bind;
+		engine->instmem.unbind		= nv04_instmem_unbind;
+		engine->mc.init		= nv04_mc_init;
+		engine->mc.takedown	= nv04_mc_takedown;
+		engine->timer.init	= nv04_timer_init;
+		engine->timer.read	= nv04_timer_read;
+		engine->timer.takedown	= nv04_timer_takedown;
+		engine->fb.init		= nv10_fb_init;
+		engine->fb.takedown	= nv10_fb_takedown;
+		engine->graph.init	= nv10_graph_init;
+		engine->graph.takedown	= nv10_graph_takedown;
+		engine->graph.create_context	= nv10_graph_create_context;
+		engine->graph.destroy_context	= nv10_graph_destroy_context;
+		engine->graph.load_context	= nv10_graph_load_context;
+		engine->graph.save_context	= nv10_graph_save_context;
+		engine->fifo.init	= nouveau_fifo_init;
+		engine->fifo.takedown	= nouveau_stub_takedown;
+		engine->fifo.create_context	= nv10_fifo_create_context;
+		engine->fifo.destroy_context	= nv10_fifo_destroy_context;
+		engine->fifo.load_context	= nv10_fifo_load_context;
+		engine->fifo.save_context	= nv10_fifo_save_context;
+		break;
+	case 0x20:
+		engine->instmem.init	= nv04_instmem_init;
+		engine->instmem.takedown= nv04_instmem_takedown;
+		engine->instmem.populate	= nv04_instmem_populate;
+		engine->instmem.clear		= nv04_instmem_clear;
+		engine->instmem.bind		= nv04_instmem_bind;
+		engine->instmem.unbind		= nv04_instmem_unbind;
+		engine->mc.init		= nv04_mc_init;
+		engine->mc.takedown	= nv04_mc_takedown;
+		engine->timer.init	= nv04_timer_init;
+		engine->timer.read	= nv04_timer_read;
+		engine->timer.takedown	= nv04_timer_takedown;
+		engine->fb.init		= nv10_fb_init;
+		engine->fb.takedown	= nv10_fb_takedown;
+		engine->graph.init	= nv20_graph_init;
+		engine->graph.takedown	= nv20_graph_takedown;
+		engine->graph.create_context	= nv20_graph_create_context;
+		engine->graph.destroy_context	= nv20_graph_destroy_context;
+		engine->graph.load_context	= nv20_graph_load_context;
+		engine->graph.save_context	= nv20_graph_save_context;
+		engine->fifo.init	= nouveau_fifo_init;
+		engine->fifo.takedown	= nouveau_stub_takedown;
+		engine->fifo.create_context	= nv10_fifo_create_context;
+		engine->fifo.destroy_context	= nv10_fifo_destroy_context;
+		engine->fifo.load_context	= nv10_fifo_load_context;
+		engine->fifo.save_context	= nv10_fifo_save_context;
+		break;
+	case 0x30:
+		engine->instmem.init	= nv04_instmem_init;
+		engine->instmem.takedown= nv04_instmem_takedown;
+		engine->instmem.populate	= nv04_instmem_populate;
+		engine->instmem.clear		= nv04_instmem_clear;
+		engine->instmem.bind		= nv04_instmem_bind;
+		engine->instmem.unbind		= nv04_instmem_unbind;
+		engine->mc.init		= nv04_mc_init;
+		engine->mc.takedown	= nv04_mc_takedown;
+		engine->timer.init	= nv04_timer_init;
+		engine->timer.read	= nv04_timer_read;
+		engine->timer.takedown	= nv04_timer_takedown;
+		engine->fb.init		= nv10_fb_init;
+		engine->fb.takedown	= nv10_fb_takedown;
+		engine->graph.init	= nv30_graph_init;
+		engine->graph.takedown	= nv30_graph_takedown;
+		engine->graph.create_context	= nv30_graph_create_context;
+		engine->graph.destroy_context	= nv30_graph_destroy_context;
+		engine->graph.load_context	= nv30_graph_load_context;
+		engine->graph.save_context	= nv30_graph_save_context;
+		engine->fifo.init	= nouveau_fifo_init;
+		engine->fifo.takedown	= nouveau_stub_takedown;
+		engine->fifo.create_context	= nv10_fifo_create_context;
+		engine->fifo.destroy_context	= nv10_fifo_destroy_context;
+		engine->fifo.load_context	= nv10_fifo_load_context;
+		engine->fifo.save_context	= nv10_fifo_save_context;
+		break;
+	case 0x40:
+		engine->instmem.init	= nv04_instmem_init;
+		engine->instmem.takedown= nv04_instmem_takedown;
+		engine->instmem.populate	= nv04_instmem_populate;
+		engine->instmem.clear		= nv04_instmem_clear;
+		engine->instmem.bind		= nv04_instmem_bind;
+		engine->instmem.unbind		= nv04_instmem_unbind;
+		engine->mc.init		= nv40_mc_init;
+		engine->mc.takedown	= nv40_mc_takedown;
+		engine->timer.init	= nv04_timer_init;
+		engine->timer.read	= nv04_timer_read;
+		engine->timer.takedown	= nv04_timer_takedown;
+		engine->fb.init		= nv40_fb_init;
+		engine->fb.takedown	= nv40_fb_takedown;
+		engine->graph.init	= nv40_graph_init;
+		engine->graph.takedown	= nv40_graph_takedown;
+		engine->graph.create_context	= nv40_graph_create_context;
+		engine->graph.destroy_context	= nv40_graph_destroy_context;
+		engine->graph.load_context	= nv40_graph_load_context;
+		engine->graph.save_context	= nv40_graph_save_context;
+		engine->fifo.init	= nv40_fifo_init;
+		engine->fifo.takedown	= nouveau_stub_takedown;
+		engine->fifo.create_context	= nv40_fifo_create_context;
+		engine->fifo.destroy_context	= nv40_fifo_destroy_context;
+		engine->fifo.load_context	= nv40_fifo_load_context;
+		engine->fifo.save_context	= nv40_fifo_save_context;
+		break;
+	case 0x50:
+	case 0x80: /* gotta love NVIDIA's consistency.. */
+		engine->instmem.init	= nv50_instmem_init;
+		engine->instmem.takedown= nv50_instmem_takedown;
+		engine->instmem.populate	= nv50_instmem_populate;
+		engine->instmem.clear		= nv50_instmem_clear;
+		engine->instmem.bind		= nv50_instmem_bind;
+		engine->instmem.unbind		= nv50_instmem_unbind;
+		engine->mc.init		= nv50_mc_init;
+		engine->mc.takedown	= nv50_mc_takedown;
+		engine->timer.init	= nouveau_stub_init;
+		engine->timer.read	= nouveau_stub_timer_read;
+		engine->timer.takedown	= nouveau_stub_takedown;
+		engine->fb.init		= nouveau_stub_init;
+		engine->fb.takedown	= nouveau_stub_takedown;
+		engine->graph.init	= nv50_graph_init;
+		engine->graph.takedown	= nv50_graph_takedown;
+		engine->graph.create_context	= nv50_graph_create_context;
+		engine->graph.destroy_context	= nv50_graph_destroy_context;
+		engine->graph.load_context	= nv50_graph_load_context;
+		engine->graph.save_context	= nv50_graph_save_context;
+		engine->fifo.init	= nv50_fifo_init;
+		engine->fifo.takedown	= nv50_fifo_takedown;
+		engine->fifo.create_context	= nv50_fifo_create_context;
+		engine->fifo.destroy_context	= nv50_fifo_destroy_context;
+		engine->fifo.load_context	= nv50_fifo_load_context;
+		engine->fifo.save_context	= nv50_fifo_save_context;
+		break;
+	default:
+		DRM_ERROR("NV%02x unsupported\n", dev_priv->chipset);
+		return 1;
+	}
+
+	return 0;
+}
+
+int
+nouveau_card_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_engine *engine;
+	int ret;
+
+	DRM_DEBUG("prev state = %d\n", dev_priv->init_state);
+
+	if (dev_priv->init_state == NOUVEAU_CARD_INIT_DONE)
+		return 0;
+
+	/* Map any PCI resources we need on the card */
+	ret = nouveau_init_card_mappings(dev);
+	if (ret) return ret;
+
+	/* Determine exact chipset we're running on */
+	if (dev_priv->card_type < NV_10)
+		dev_priv->chipset = dev_priv->card_type;
+	else
+		dev_priv->chipset =
+			(NV_READ(NV03_PMC_BOOT_0) & 0x0ff00000) >> 20;
+
+	/* Initialise internal driver API hooks */
+	ret = nouveau_init_engine_ptrs(dev);
+	if (ret) return ret;
+	engine = &dev_priv->Engine;
+	dev_priv->init_state = NOUVEAU_CARD_INIT_FAILED;
+
+	ret = nouveau_gpuobj_early_init(dev);
+	if (ret) return ret;
+
+	/* Initialise instance memory, must happen before mem_init so we
+	 * know exactly how much VRAM we're able to use for "normal"
+	 * purposes.
+	 */
+	ret = engine->instmem.init(dev);
+	if (ret) return ret;
+
+	/* Setup the memory manager */
+	ret = nouveau_mem_init(dev);
+	if (ret) return ret;
+
+	ret = nouveau_gpuobj_init(dev);
+	if (ret) return ret;
+
+	/* Parse BIOS tables / Run init tables? */
+
+	/* PMC */
+	ret = engine->mc.init(dev);
+	if (ret) return ret;
+
+	/* PTIMER */
+	ret = engine->timer.init(dev);
+	if (ret) return ret;
+
+	/* PFB */
+	ret = engine->fb.init(dev);
+	if (ret) return ret;
+
+	/* PGRAPH */
+	ret = engine->graph.init(dev);
+	if (ret) return ret;
+
+	/* PFIFO */
+	ret = engine->fifo.init(dev);
+	if (ret) return ret;
+
+	/* this call irq_preinstall, register irq handler and
+	 * call irq_postinstall
+	 */
+	ret = drm_irq_install(dev);
+	if (ret) return ret;
+
+	/* what about PVIDEO/PCRTC/PRAMDAC etc? */
+
+	ret = nouveau_dma_channel_init(dev);
+	if (ret) return ret;
+
+	dev_priv->init_state = NOUVEAU_CARD_INIT_DONE;
+	return 0;
+}
+
+static void nouveau_card_takedown(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_engine *engine = &dev_priv->Engine;
+
+	DRM_DEBUG("prev state = %d\n", dev_priv->init_state);
+
+	if (dev_priv->init_state != NOUVEAU_CARD_INIT_DOWN) {
+		nouveau_dma_channel_takedown(dev);
+
+		engine->fifo.takedown(dev);
+		engine->graph.takedown(dev);
+		engine->fb.takedown(dev);
+		engine->timer.takedown(dev);
+		engine->mc.takedown(dev);
+
+		nouveau_sgdma_nottm_hack_takedown(dev);
+		nouveau_sgdma_takedown(dev);
+
+		nouveau_gpuobj_takedown(dev);
+
+		nouveau_mem_close(dev);
+		engine->instmem.takedown(dev);
+
+		drm_irq_uninstall(dev);
+
+		nouveau_gpuobj_late_takedown(dev);
+
+		dev_priv->init_state = NOUVEAU_CARD_INIT_DOWN;
+	}
+}
+
+/* here a client dies, release the stuff that was allocated for its
+ * file_priv */
+void nouveau_preclose(struct drm_device *dev, struct drm_file *file_priv)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	nouveau_fifo_cleanup(dev, file_priv);
+	nouveau_mem_release(file_priv,dev_priv->fb_heap);
+	nouveau_mem_release(file_priv,dev_priv->agp_heap);
+	nouveau_mem_release(file_priv,dev_priv->pci_heap);
+}
+
+/* first module load, setup the mmio/fb mapping */
+int nouveau_firstopen(struct drm_device *dev)
+{
+	return 0;
+}
+
+int nouveau_load(struct drm_device *dev, unsigned long flags)
+{
+	struct drm_nouveau_private *dev_priv;
+
+	if (flags==NV_UNKNOWN)
+		return -EINVAL;
+
+	dev_priv = drm_calloc(1, sizeof(*dev_priv), DRM_MEM_DRIVER);
+	if (!dev_priv)                   
+		return -ENOMEM;
+
+	dev_priv->card_type=flags&NOUVEAU_FAMILY;
+	dev_priv->flags=flags&NOUVEAU_FLAGS;
+	dev_priv->init_state = NOUVEAU_CARD_INIT_DOWN;
+
+	dev->dev_private = (void *)dev_priv;
+	return 0;
+}
+
+void nouveau_lastclose(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	nouveau_card_takedown(dev);
+
+	if(dev_priv->fb_mtrr>0)
+	{
+		drm_mtrr_del(dev_priv->fb_mtrr, drm_get_resource_start(dev, 1),nouveau_mem_fb_amount(dev), DRM_MTRR_WC);
+		dev_priv->fb_mtrr=0;
+	}
+}
+
+int nouveau_unload(struct drm_device *dev)
+{
+	drm_free(dev->dev_private, sizeof(*dev->dev_private), DRM_MEM_DRIVER);
+	dev->dev_private = NULL;
+	return 0;
+}
+
+int
+nouveau_ioctl_card_init(struct drm_device *dev, void *data,
+			struct drm_file *file_priv)
+{
+	return nouveau_card_init(dev);
+}
+
+int nouveau_ioctl_getparam(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct drm_nouveau_getparam *getparam = data;
+
+	NOUVEAU_CHECK_INITIALISED_WITH_RETURN;
+
+	switch (getparam->param) {
+	case NOUVEAU_GETPARAM_CHIPSET_ID:
+		getparam->value = dev_priv->chipset;
+		break;
+	case NOUVEAU_GETPARAM_PCI_VENDOR:
+		getparam->value=dev->pci_vendor;
+		break;
+	case NOUVEAU_GETPARAM_PCI_DEVICE:
+		getparam->value=dev->pci_device;
+		break;
+	case NOUVEAU_GETPARAM_BUS_TYPE:
+		if (drm_device_is_agp(dev))
+			getparam->value=NV_AGP;
+		else if (drm_device_is_pcie(dev))
+			getparam->value=NV_PCIE;
+		else
+			getparam->value=NV_PCI;
+		break;
+	case NOUVEAU_GETPARAM_FB_PHYSICAL:
+		getparam->value=dev_priv->fb_phys;
+		break;
+	case NOUVEAU_GETPARAM_AGP_PHYSICAL:
+		getparam->value=dev_priv->gart_info.aper_base;
+		break;
+	case NOUVEAU_GETPARAM_PCI_PHYSICAL:
+		if ( dev -> sg )
+			getparam->value=(uint64_t) dev->sg->virtual;
+		else 
+		     {
+		     DRM_ERROR("Requested PCIGART address, while no PCIGART was created\n");
+		     return -EINVAL;
+		     }
+		break;
+	case NOUVEAU_GETPARAM_FB_SIZE:
+		getparam->value=dev_priv->fb_available_size;
+		break;
+	case NOUVEAU_GETPARAM_AGP_SIZE:
+		getparam->value=dev_priv->gart_info.aper_size;
+		break;
+	default:
+		DRM_ERROR("unknown parameter %lld\n", getparam->param);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int nouveau_ioctl_setparam(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct drm_nouveau_setparam *setparam = data;
+
+	NOUVEAU_CHECK_INITIALISED_WITH_RETURN;
+
+	switch (setparam->param) {
+	case NOUVEAU_SETPARAM_CMDBUF_LOCATION:
+		switch (setparam->value) {
+		case NOUVEAU_MEM_AGP:
+		case NOUVEAU_MEM_FB:
+		case NOUVEAU_MEM_PCI:
+		case NOUVEAU_MEM_AGP | NOUVEAU_MEM_PCI_ACCEPTABLE:
+			break;
+		default:
+			DRM_ERROR("invalid CMDBUF_LOCATION value=%lld\n",
+					setparam->value);
+			return -EINVAL;
+		}
+		dev_priv->config.cmdbuf.location = setparam->value;
+		break;
+	case NOUVEAU_SETPARAM_CMDBUF_SIZE:
+		dev_priv->config.cmdbuf.size = setparam->value;
+		break;
+	default:
+		DRM_ERROR("unknown parameter %lld\n", setparam->param);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* waits for idle */
+void nouveau_wait_for_idle(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv=dev->dev_private;
+	switch(dev_priv->card_type) {
+	case NV_50:
+		break;
+	default: {
+		/* This stuff is more or less a copy of what is seen
+		 * in nv28 kmmio dump.
+		 */
+		uint64_t started = dev_priv->Engine.timer.read(dev);
+		uint64_t stopped = started;
+		uint32_t status;
+		do {
+			uint32_t pmc_e = NV_READ(NV03_PMC_ENABLE);
+			(void)pmc_e;
+			status = NV_READ(NV04_PGRAPH_STATUS);
+			if (!status)
+				break;
+			stopped = dev_priv->Engine.timer.read(dev);
+		/* It'll never wrap anyway... */
+		} while (stopped - started < 1000000000ULL);
+		if (status)
+			DRM_ERROR("timed out with status 0x%08x\n",
+			          status);
+	}
+	}
+}
+
+
Index: git/shared-core/nv04_fb.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv04_fb.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,24 @@
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+int
+nv04_fb_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	/* This is what the DDX did for NV_ARCH_04, but a mmio-trace shows
+	 * nvidia reading PFB_CFG_0, then writing back its original value.
+	 * (which was 0x701114 in this case)
+	 */
+	NV_WRITE(NV04_PFB_CFG0, 0x1114);
+
+	return 0;
+}
+
+void
+nv04_fb_takedown(struct drm_device *dev)
+{
+}
+
Index: git/shared-core/nv04_fifo.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv04_fifo.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2007 Ben Skeggs.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+
+#define RAMFC_WR(offset,val) INSTANCE_WR(chan->ramfc->gpuobj, \
+					 NV04_RAMFC_##offset/4, (val))
+#define RAMFC_RD(offset)     INSTANCE_RD(chan->ramfc->gpuobj, \
+					 NV04_RAMFC_##offset/4)
+#define NV04_RAMFC(c) (dev_priv->ramfc_offset + ((c) * NV04_RAMFC__SIZE))
+#define NV04_RAMFC__SIZE 32
+
+int
+nv04_fifo_create_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int ret;
+
+	if ((ret = nouveau_gpuobj_new_fake(dev, NV04_RAMFC(chan->id), ~0,
+						NV04_RAMFC__SIZE,
+						NVOBJ_FLAG_ZERO_ALLOC |
+						NVOBJ_FLAG_ZERO_FREE,
+						NULL, &chan->ramfc)))
+		return ret;
+
+	/* Setup initial state */
+	RAMFC_WR(DMA_PUT, chan->pushbuf_base);
+	RAMFC_WR(DMA_GET, chan->pushbuf_base);
+	RAMFC_WR(DMA_INSTANCE, chan->pushbuf->instance >> 4);
+	RAMFC_WR(DMA_FETCH, (NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
+			     NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
+			     NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8 |
+#ifdef __BIG_ENDIAN
+			     NV_PFIFO_CACHE1_BIG_ENDIAN |
+#endif
+			     0));
+
+	/* enable the fifo dma operation */
+	NV_WRITE(NV04_PFIFO_MODE,NV_READ(NV04_PFIFO_MODE) | (1<<chan->id));
+	return 0;
+}
+
+void
+nv04_fifo_destroy_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	
+	NV_WRITE(NV04_PFIFO_MODE, NV_READ(NV04_PFIFO_MODE)&~(1<<chan->id));
+
+	nouveau_gpuobj_ref_del(dev, &chan->ramfc);
+}
+
+int
+nv04_fifo_load_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t tmp;
+
+	NV_WRITE(NV03_PFIFO_CACHE1_PUSH1, (1<<8) | chan->id);
+
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_GET, RAMFC_RD(DMA_GET));
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_PUT, RAMFC_RD(DMA_PUT));
+	
+	tmp = RAMFC_RD(DMA_INSTANCE);
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_INSTANCE, tmp & 0xFFFF);
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_DCOUNT, tmp >> 16);
+	
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_STATE, RAMFC_RD(DMA_STATE));
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_FETCH, RAMFC_RD(DMA_FETCH));
+	NV_WRITE(NV04_PFIFO_CACHE1_ENGINE, RAMFC_RD(ENGINE));
+	NV_WRITE(NV04_PFIFO_CACHE1_PULL1, RAMFC_RD(PULL1_ENGINE));
+
+	/* Reset NV04_PFIFO_CACHE1_DMA_CTL_AT_INFO to INVALID */
+	tmp = NV_READ(NV04_PFIFO_CACHE1_DMA_CTL) & ~(1<<31);
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_CTL, tmp);
+
+	return 0;
+}
+
+int
+nv04_fifo_save_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t tmp;
+
+	RAMFC_WR(DMA_PUT, NV04_PFIFO_CACHE1_DMA_PUT);
+	RAMFC_WR(DMA_GET, NV04_PFIFO_CACHE1_DMA_GET);
+
+	tmp  = NV_READ(NV04_PFIFO_CACHE1_DMA_DCOUNT) << 16;
+	tmp |= NV_READ(NV04_PFIFO_CACHE1_DMA_INSTANCE);
+	RAMFC_WR(DMA_INSTANCE, tmp);
+
+	RAMFC_WR(DMA_STATE, NV_READ(NV04_PFIFO_CACHE1_DMA_STATE));
+	RAMFC_WR(DMA_FETCH, NV_READ(NV04_PFIFO_CACHE1_DMA_FETCH));
+	RAMFC_WR(ENGINE, NV_READ(NV04_PFIFO_CACHE1_ENGINE));
+	RAMFC_WR(PULL1_ENGINE, NV_READ(NV04_PFIFO_CACHE1_PULL1));
+	
+	return 0;
+}
+
Index: git/shared-core/nv04_graph.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv04_graph.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,474 @@
+/* 
+ * Copyright 2007 Stephane Marchesin
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drm.h"
+#include "nouveau_drv.h"
+
+static uint32_t nv04_graph_ctx_regs [] = {
+	NV04_PGRAPH_CTX_SWITCH1,
+	NV04_PGRAPH_CTX_SWITCH2,
+	NV04_PGRAPH_CTX_SWITCH3,
+	NV04_PGRAPH_CTX_SWITCH4,
+	NV04_PGRAPH_CTX_CACHE1,
+	NV04_PGRAPH_CTX_CACHE2,
+	NV04_PGRAPH_CTX_CACHE3,
+	NV04_PGRAPH_CTX_CACHE4,
+	0x00400184,
+	0x004001a4,
+	0x004001c4,
+	0x004001e4,
+	0x00400188,
+	0x004001a8,
+	0x004001c8,
+	0x004001e8,
+	0x0040018c,
+	0x004001ac,
+	0x004001cc,
+	0x004001ec,
+	0x00400190,
+	0x004001b0,
+	0x004001d0,
+	0x004001f0,
+	0x00400194,
+	0x004001b4,
+	0x004001d4,
+	0x004001f4,
+	0x00400198,
+	0x004001b8,
+	0x004001d8,
+	0x004001f8,
+	0x0040019c,
+	0x004001bc,
+	0x004001dc,
+	0x004001fc,
+	0x00400174,
+	NV04_PGRAPH_DMA_START_0,
+	NV04_PGRAPH_DMA_START_1,
+	NV04_PGRAPH_DMA_LENGTH,
+	NV04_PGRAPH_DMA_MISC,
+	NV04_PGRAPH_DMA_PITCH,
+	NV04_PGRAPH_BOFFSET0,
+	NV04_PGRAPH_BBASE0,
+	NV04_PGRAPH_BLIMIT0,
+	NV04_PGRAPH_BOFFSET1,
+	NV04_PGRAPH_BBASE1,
+	NV04_PGRAPH_BLIMIT1,
+	NV04_PGRAPH_BOFFSET2,
+	NV04_PGRAPH_BBASE2,
+	NV04_PGRAPH_BLIMIT2,
+	NV04_PGRAPH_BOFFSET3,
+	NV04_PGRAPH_BBASE3,
+	NV04_PGRAPH_BLIMIT3,
+	NV04_PGRAPH_BOFFSET4,
+	NV04_PGRAPH_BBASE4,
+	NV04_PGRAPH_BLIMIT4,
+	NV04_PGRAPH_BOFFSET5,
+	NV04_PGRAPH_BBASE5,
+	NV04_PGRAPH_BLIMIT5,
+	NV04_PGRAPH_BPITCH0,
+	NV04_PGRAPH_BPITCH1,
+	NV04_PGRAPH_BPITCH2,
+	NV04_PGRAPH_BPITCH3,
+	NV04_PGRAPH_BPITCH4,
+	NV04_PGRAPH_SURFACE,
+	NV04_PGRAPH_STATE,
+	NV04_PGRAPH_BSWIZZLE2,
+	NV04_PGRAPH_BSWIZZLE5,
+	NV04_PGRAPH_BPIXEL,
+	NV04_PGRAPH_NOTIFY,
+	NV04_PGRAPH_PATT_COLOR0,
+	NV04_PGRAPH_PATT_COLOR1,
+	NV04_PGRAPH_PATT_COLORRAM+0x00,
+	NV04_PGRAPH_PATT_COLORRAM+0x01,
+	NV04_PGRAPH_PATT_COLORRAM+0x02,
+	NV04_PGRAPH_PATT_COLORRAM+0x03,
+	NV04_PGRAPH_PATT_COLORRAM+0x04,
+	NV04_PGRAPH_PATT_COLORRAM+0x05,
+	NV04_PGRAPH_PATT_COLORRAM+0x06,
+	NV04_PGRAPH_PATT_COLORRAM+0x07,
+	NV04_PGRAPH_PATT_COLORRAM+0x08,
+	NV04_PGRAPH_PATT_COLORRAM+0x09,
+	NV04_PGRAPH_PATT_COLORRAM+0x0A,
+	NV04_PGRAPH_PATT_COLORRAM+0x0B,
+	NV04_PGRAPH_PATT_COLORRAM+0x0C,
+	NV04_PGRAPH_PATT_COLORRAM+0x0D,
+	NV04_PGRAPH_PATT_COLORRAM+0x0E,
+	NV04_PGRAPH_PATT_COLORRAM+0x0F,
+	NV04_PGRAPH_PATT_COLORRAM+0x10,
+	NV04_PGRAPH_PATT_COLORRAM+0x11,
+	NV04_PGRAPH_PATT_COLORRAM+0x12,
+	NV04_PGRAPH_PATT_COLORRAM+0x13,
+	NV04_PGRAPH_PATT_COLORRAM+0x14,
+	NV04_PGRAPH_PATT_COLORRAM+0x15,
+	NV04_PGRAPH_PATT_COLORRAM+0x16,
+	NV04_PGRAPH_PATT_COLORRAM+0x17,
+	NV04_PGRAPH_PATT_COLORRAM+0x18,
+	NV04_PGRAPH_PATT_COLORRAM+0x19,
+	NV04_PGRAPH_PATT_COLORRAM+0x1A,
+	NV04_PGRAPH_PATT_COLORRAM+0x1B,
+	NV04_PGRAPH_PATT_COLORRAM+0x1C,
+	NV04_PGRAPH_PATT_COLORRAM+0x1D,
+	NV04_PGRAPH_PATT_COLORRAM+0x1E,
+	NV04_PGRAPH_PATT_COLORRAM+0x1F,
+	NV04_PGRAPH_PATT_COLORRAM+0x20,
+	NV04_PGRAPH_PATT_COLORRAM+0x21,
+	NV04_PGRAPH_PATT_COLORRAM+0x22,
+	NV04_PGRAPH_PATT_COLORRAM+0x23,
+	NV04_PGRAPH_PATT_COLORRAM+0x24,
+	NV04_PGRAPH_PATT_COLORRAM+0x25,
+	NV04_PGRAPH_PATT_COLORRAM+0x26,
+	NV04_PGRAPH_PATT_COLORRAM+0x27,
+	NV04_PGRAPH_PATT_COLORRAM+0x28,
+	NV04_PGRAPH_PATT_COLORRAM+0x29,
+	NV04_PGRAPH_PATT_COLORRAM+0x2A,
+	NV04_PGRAPH_PATT_COLORRAM+0x2B,
+	NV04_PGRAPH_PATT_COLORRAM+0x2C,
+	NV04_PGRAPH_PATT_COLORRAM+0x2D,
+	NV04_PGRAPH_PATT_COLORRAM+0x2E,
+	NV04_PGRAPH_PATT_COLORRAM+0x2F,
+	NV04_PGRAPH_PATT_COLORRAM+0x30,
+	NV04_PGRAPH_PATT_COLORRAM+0x31,
+	NV04_PGRAPH_PATT_COLORRAM+0x32,
+	NV04_PGRAPH_PATT_COLORRAM+0x33,
+	NV04_PGRAPH_PATT_COLORRAM+0x34,
+	NV04_PGRAPH_PATT_COLORRAM+0x35,
+	NV04_PGRAPH_PATT_COLORRAM+0x36,
+	NV04_PGRAPH_PATT_COLORRAM+0x37,
+	NV04_PGRAPH_PATT_COLORRAM+0x38,
+	NV04_PGRAPH_PATT_COLORRAM+0x39,
+	NV04_PGRAPH_PATT_COLORRAM+0x3A,
+	NV04_PGRAPH_PATT_COLORRAM+0x3B,
+	NV04_PGRAPH_PATT_COLORRAM+0x3C,
+	NV04_PGRAPH_PATT_COLORRAM+0x3D,
+	NV04_PGRAPH_PATT_COLORRAM+0x3E,
+	NV04_PGRAPH_PATT_COLORRAM+0x3F,
+	NV04_PGRAPH_PATTERN,
+	0x0040080c,
+	NV04_PGRAPH_PATTERN_SHAPE,
+	0x00400600,
+	NV04_PGRAPH_ROP3,
+	NV04_PGRAPH_CHROMA,
+	NV04_PGRAPH_BETA_AND,
+	NV04_PGRAPH_BETA_PREMULT,
+	NV04_PGRAPH_CONTROL0,
+	NV04_PGRAPH_CONTROL1,
+	NV04_PGRAPH_CONTROL2,
+	NV04_PGRAPH_BLEND,
+	NV04_PGRAPH_STORED_FMT,
+	NV04_PGRAPH_SOURCE_COLOR,
+	0x00400560,
+	0x00400568,
+	0x00400564,
+	0x0040056c,
+	0x00400400,
+	0x00400480,
+	0x00400404,
+	0x00400484,
+	0x00400408,
+	0x00400488,
+	0x0040040c,
+	0x0040048c,
+	0x00400410,
+	0x00400490,
+	0x00400414,
+	0x00400494,
+	0x00400418,
+	0x00400498,
+	0x0040041c,
+	0x0040049c,
+	0x00400420,
+	0x004004a0,
+	0x00400424,
+	0x004004a4,
+	0x00400428,
+	0x004004a8,
+	0x0040042c,
+	0x004004ac,
+	0x00400430,
+	0x004004b0,
+	0x00400434,
+	0x004004b4,
+	0x00400438,
+	0x004004b8,
+	0x0040043c,
+	0x004004bc,
+	0x00400440,
+	0x004004c0,
+	0x00400444,
+	0x004004c4,
+	0x00400448,
+	0x004004c8,
+	0x0040044c,
+	0x004004cc,
+	0x00400450,
+	0x004004d0,
+	0x00400454,
+	0x004004d4,
+	0x00400458,
+	0x004004d8,
+	0x0040045c,
+	0x004004dc,
+	0x00400460,
+	0x004004e0,
+	0x00400464,
+	0x004004e4,
+	0x00400468,
+	0x004004e8,
+	0x0040046c,
+	0x004004ec,
+	0x00400470,
+	0x004004f0,
+	0x00400474,
+	0x004004f4,
+	0x00400478,
+	0x004004f8,
+	0x0040047c,
+	0x004004fc,
+	0x0040053c,
+	0x00400544,
+	0x00400540,
+	0x00400548,
+	0x00400560,
+	0x00400568,
+	0x00400564,
+	0x0040056c,
+	0x00400534,
+	0x00400538,
+	0x00400514,
+	0x00400518,
+	0x0040051c,
+	0x00400520,
+	0x00400524,
+	0x00400528,
+	0x0040052c,
+	0x00400530,
+	0x00400d00,
+	0x00400d40,
+	0x00400d80,
+	0x00400d04,
+	0x00400d44,
+	0x00400d84,
+	0x00400d08,
+	0x00400d48,
+	0x00400d88,
+	0x00400d0c,
+	0x00400d4c,
+	0x00400d8c,
+	0x00400d10,
+	0x00400d50,
+	0x00400d90,
+	0x00400d14,
+	0x00400d54,
+	0x00400d94,
+	0x00400d18,
+	0x00400d58,
+	0x00400d98,
+	0x00400d1c,
+	0x00400d5c,
+	0x00400d9c,
+	0x00400d20,
+	0x00400d60,
+	0x00400da0,
+	0x00400d24,
+	0x00400d64,
+	0x00400da4,
+	0x00400d28,
+	0x00400d68,
+	0x00400da8,
+	0x00400d2c,
+	0x00400d6c,
+	0x00400dac,
+	0x00400d30,
+	0x00400d70,
+	0x00400db0,
+	0x00400d34,
+	0x00400d74,
+	0x00400db4,
+	0x00400d38,
+	0x00400d78,
+	0x00400db8,
+	0x00400d3c,
+	0x00400d7c,
+	0x00400dbc,
+	0x00400590,
+	0x00400594,
+	0x00400598,
+	0x0040059c,
+	0x004005a8,
+	0x004005ac,
+	0x004005b0,
+	0x004005b4,
+	0x004005c0,
+	0x004005c4,
+	0x004005c8,
+	0x004005cc,
+	0x004005d0,
+	0x004005d4,
+	0x004005d8,
+	0x004005dc,
+	0x004005e0,
+	NV04_PGRAPH_PASSTHRU_0,
+	NV04_PGRAPH_PASSTHRU_1,
+	NV04_PGRAPH_PASSTHRU_2,
+	NV04_PGRAPH_DVD_COLORFMT,
+	NV04_PGRAPH_SCALED_FORMAT,
+	NV04_PGRAPH_MISC24_0,
+	NV04_PGRAPH_MISC24_1,
+	NV04_PGRAPH_MISC24_2,
+	0x00400500,
+	0x00400504,
+	NV04_PGRAPH_VALID1,
+	NV04_PGRAPH_VALID2
+
+
+};
+
+void nouveau_nv04_context_switch(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_channel *next, *last;
+	int chid;
+
+	chid = NV_READ(NV03_PFIFO_CACHE1_PUSH1)&(nouveau_fifo_number(dev)-1);
+	next = dev_priv->fifos[chid];
+
+	chid = (NV_READ(NV04_PGRAPH_CTX_USER) >> 24) & (nouveau_fifo_number(dev)-1);
+	last = dev_priv->fifos[chid];
+
+	DRM_INFO("NV: PGRAPH context switch interrupt channel %x -> %x\n",last->id, next->id);
+
+/*	NV_WRITE(NV03_PFIFO_CACHES, 0x0);
+	NV_WRITE(NV04_PFIFO_CACHE0_PULL0, 0x0);
+	NV_WRITE(NV04_PFIFO_CACHE1_PULL0, 0x0);*/
+	NV_WRITE(NV04_PGRAPH_FIFO,0x0);
+
+	if (last)
+		nv04_graph_save_context(last);
+
+	nouveau_wait_for_idle(dev);
+
+	NV_WRITE(NV04_PGRAPH_CTX_CONTROL, 0x10000000);
+	NV_WRITE(NV04_PGRAPH_CTX_USER, (NV_READ(NV04_PGRAPH_CTX_USER) & 0xffffff) | (0x0f << 24));
+
+	nouveau_wait_for_idle(dev);
+
+	nv04_graph_load_context(next);
+
+	NV_WRITE(NV04_PGRAPH_CTX_CONTROL, 0x10010100);
+	NV_WRITE(NV04_PGRAPH_CTX_USER, next->id << 24);
+	NV_WRITE(NV04_PGRAPH_FFINTFC_ST2, NV_READ(NV04_PGRAPH_FFINTFC_ST2)&0x000FFFFF);
+
+/*	NV_WRITE(NV04_PGRAPH_FIFO,0x0);
+	NV_WRITE(NV04_PFIFO_CACHE0_PULL0, 0x0);
+	NV_WRITE(NV04_PFIFO_CACHE1_PULL0, 0x1);
+	NV_WRITE(NV03_PFIFO_CACHES, 0x1);*/
+	NV_WRITE(NV04_PGRAPH_FIFO,0x1);
+}
+
+int nv04_graph_create_context(struct nouveau_channel *chan) {
+	DRM_DEBUG("nv04_graph_context_create %d\n", chan->id);
+
+	memset(chan->pgraph_ctx, 0, sizeof(chan->pgraph_ctx));
+
+	//dev_priv->fifos[channel].pgraph_ctx_user = channel << 24;
+	chan->pgraph_ctx[0] = 0x0001ffff;
+	/* is it really needed ??? */
+	//dev_priv->fifos[channel].pgraph_ctx[1] = NV_READ(NV_PGRAPH_DEBUG_4);
+	//dev_priv->fifos[channel].pgraph_ctx[2] = NV_READ(0x004006b0);
+
+	return 0;
+}
+
+void nv04_graph_destroy_context(struct nouveau_channel *chan)
+{
+}
+
+int nv04_graph_load_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	for (i = 0; i < sizeof(nv04_graph_ctx_regs)/sizeof(nv04_graph_ctx_regs[0]); i++)
+		NV_WRITE(nv04_graph_ctx_regs[i], chan->pgraph_ctx[i]);
+
+	return 0;
+}
+
+int nv04_graph_save_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	for (i = 0; i < sizeof(nv04_graph_ctx_regs)/sizeof(nv04_graph_ctx_regs[0]); i++)
+		chan->pgraph_ctx[i] = NV_READ(nv04_graph_ctx_regs[i]);
+
+	return 0;
+}
+
+int nv04_graph_init(struct drm_device *dev) {
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) &
+			~NV_PMC_ENABLE_PGRAPH);
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) |
+			 NV_PMC_ENABLE_PGRAPH);
+
+	/* Enable PGRAPH interrupts */
+	NV_WRITE(NV03_PGRAPH_INTR, 0xFFFFFFFF);
+	NV_WRITE(NV03_PGRAPH_INTR_EN, 0xFFFFFFFF);
+
+	// check the context is big enough
+	if ( sizeof(nv04_graph_ctx_regs)>sizeof(dev_priv->fifos[0]->pgraph_ctx) )
+		DRM_ERROR("pgraph_ctx too small\n");
+
+	NV_WRITE(NV04_PGRAPH_DEBUG_0, 0x000001FF);
+	NV_WRITE(NV04_PGRAPH_DEBUG_0, 0x1231c000);
+	NV_WRITE(NV04_PGRAPH_DEBUG_1, 0xf2d91100);
+	NV_WRITE(NV04_PGRAPH_DEBUG_2, 0x11d5f870);
+	NV_WRITE(NV04_PGRAPH_DEBUG_3, 0x0004FF31);
+	NV_WRITE(NV04_PGRAPH_DEBUG_3, 0x4004FF31 |
+				    (0x00D00000) |
+				    (1<<29) |
+				    (1<<31));
+	NV_WRITE(NV04_PGRAPH_DEBUG_3, 0xfad4ff31);
+
+	NV_WRITE(NV04_PGRAPH_STATE        , 0xFFFFFFFF);
+	NV_WRITE(NV04_PGRAPH_CTX_CONTROL  , 0x10010100);
+	NV_WRITE(NV04_PGRAPH_FIFO         , 0x00000001);
+
+	/* These don't belong here, they're part of a per-channel context */
+	NV_WRITE(NV04_PGRAPH_PATTERN_SHAPE, 0x00000000);
+	NV_WRITE(NV04_PGRAPH_BETA_AND     , 0xFFFFFFFF);
+
+	return 0;
+}
+
+void nv04_graph_takedown(struct drm_device *dev)
+{
+}
+
Index: git/shared-core/nv04_mc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv04_mc.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,23 @@
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+int
+nv04_mc_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	/* Power up everything, resetting each individual unit will
+	 * be done later if needed.
+	 */
+	NV_WRITE(NV03_PMC_ENABLE, 0xFFFFFFFF);
+
+	return 0;
+}
+
+void
+nv04_mc_takedown(struct drm_device *dev)
+{
+}
+
Index: git/shared-core/nv04_timer.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv04_timer.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,45 @@
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+int
+nv04_timer_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	NV_WRITE(NV04_PTIMER_INTR_EN_0, 0x00000000);
+	NV_WRITE(NV04_PTIMER_INTR_0, 0xFFFFFFFF);
+
+	NV_WRITE(NV04_PTIMER_NUMERATOR, 0x00000008);
+	NV_WRITE(NV04_PTIMER_DENOMINATOR, 0x00000003);
+
+	return 0;
+}
+
+uint64_t
+nv04_timer_read(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t low;
+	/* From kmmio dumps on nv28 this looks like how the blob does this.
+	 * It reads the high dword twice, before and after.
+	 * The only explanation seems to be that the 64-bit timer counter
+	 * advances between high and low dword reads and may corrupt the
+	 * result. Not confirmed.
+	 */
+	uint32_t high2 = NV_READ(NV04_PTIMER_TIME_1);
+	uint32_t high1;
+	do {
+		high1 = high2;
+		low = NV_READ(NV04_PTIMER_TIME_0);
+		high2 = NV_READ(NV04_PTIMER_TIME_1);
+	} while(high1 != high2);
+	return (((uint64_t)high2) << 32) | (uint64_t)low;
+}
+
+void
+nv04_timer_takedown(struct drm_device *dev)
+{
+}
+
Index: git/shared-core/nv10_fb.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv10_fb.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,26 @@
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+int
+nv10_fb_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t fb_bar_size;
+	int i;
+
+	fb_bar_size = drm_get_resource_len(dev, 0) - 1;
+	for (i=0; i<NV10_PFB_TILE__SIZE; i++) {
+		NV_WRITE(NV10_PFB_TILE(i), 0);
+		NV_WRITE(NV10_PFB_TLIMIT(i), fb_bar_size);
+	}
+
+	return 0;
+}
+
+void
+nv10_fb_takedown(struct drm_device *dev)
+{
+}
+
Index: git/shared-core/nv10_fifo.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv10_fifo.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2007 Ben Skeggs.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+
+
+#define RAMFC_WR(offset,val) INSTANCE_WR(chan->ramfc->gpuobj, \
+					 NV10_RAMFC_##offset/4, (val))
+#define RAMFC_RD(offset)     INSTANCE_RD(chan->ramfc->gpuobj, \
+					 NV10_RAMFC_##offset/4)
+#define NV10_RAMFC(c) (dev_priv->ramfc_offset + ((c) * NV10_RAMFC__SIZE))
+#define NV10_RAMFC__SIZE ((dev_priv->chipset) >= 0x17 ? 64 : 32)
+
+int
+nv10_fifo_create_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int ret;
+
+	if ((ret = nouveau_gpuobj_new_fake(dev, NV10_RAMFC(chan->id), ~0,
+						NV10_RAMFC__SIZE,
+						NVOBJ_FLAG_ZERO_ALLOC |
+						NVOBJ_FLAG_ZERO_FREE,
+						NULL, &chan->ramfc)))
+		return ret;
+
+	/* Fill entries that are seen filled in dumps of nvidia driver just
+	 * after channel's is put into DMA mode
+	 */
+	RAMFC_WR(DMA_PUT       , chan->pushbuf_base);
+	RAMFC_WR(DMA_GET       , chan->pushbuf_base);
+	RAMFC_WR(DMA_INSTANCE  , chan->pushbuf->instance >> 4);
+	RAMFC_WR(DMA_FETCH     , NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
+				 NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
+				 NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8 |
+#ifdef __BIG_ENDIAN
+				 NV_PFIFO_CACHE1_BIG_ENDIAN |
+#endif
+				 0);
+
+	/* enable the fifo dma operation */
+	NV_WRITE(NV04_PFIFO_MODE,NV_READ(NV04_PFIFO_MODE)|(1<<chan->id));
+	return 0;
+}
+
+void
+nv10_fifo_destroy_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	NV_WRITE(NV04_PFIFO_MODE, NV_READ(NV04_PFIFO_MODE)&~(1<<chan->id));
+
+	nouveau_gpuobj_ref_del(dev, &chan->ramfc);
+}
+
+int
+nv10_fifo_load_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t tmp;
+
+	NV_WRITE(NV03_PFIFO_CACHE1_PUSH1            , 0x00000100 | chan->id);
+
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_GET          , RAMFC_RD(DMA_GET));
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_PUT          , RAMFC_RD(DMA_PUT));
+	NV_WRITE(NV10_PFIFO_CACHE1_REF_CNT          , RAMFC_RD(REF_CNT));
+
+	tmp = RAMFC_RD(DMA_INSTANCE);
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_INSTANCE     , tmp & 0xFFFF);
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_DCOUNT       , tmp >> 16);
+
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_STATE        , RAMFC_RD(DMA_STATE));
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_FETCH        , RAMFC_RD(DMA_FETCH));
+	NV_WRITE(NV04_PFIFO_CACHE1_ENGINE           , RAMFC_RD(ENGINE));
+	NV_WRITE(NV04_PFIFO_CACHE1_PULL1            , RAMFC_RD(PULL1_ENGINE));
+
+	if (dev_priv->chipset >= 0x17) {
+		NV_WRITE(NV10_PFIFO_CACHE1_ACQUIRE_VALUE,
+			 RAMFC_RD(ACQUIRE_VALUE));
+		NV_WRITE(NV10_PFIFO_CACHE1_ACQUIRE_TIMESTAMP,
+			 RAMFC_RD(ACQUIRE_TIMESTAMP));
+		NV_WRITE(NV10_PFIFO_CACHE1_ACQUIRE_TIMEOUT,
+			 RAMFC_RD(ACQUIRE_TIMEOUT));
+		NV_WRITE(NV10_PFIFO_CACHE1_SEMAPHORE,
+			 RAMFC_RD(SEMAPHORE));
+		NV_WRITE(NV10_PFIFO_CACHE1_DMA_SUBROUTINE,
+			 RAMFC_RD(DMA_SUBROUTINE));
+	}
+
+	/* Reset NV04_PFIFO_CACHE1_DMA_CTL_AT_INFO to INVALID */
+	tmp = NV_READ(NV04_PFIFO_CACHE1_DMA_CTL) & ~(1<<31);
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_CTL, tmp);
+
+	return 0;
+}
+
+int
+nv10_fifo_save_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t tmp;
+
+	RAMFC_WR(DMA_PUT          , NV_READ(NV04_PFIFO_CACHE1_DMA_PUT));
+	RAMFC_WR(DMA_GET          , NV_READ(NV04_PFIFO_CACHE1_DMA_GET));
+	RAMFC_WR(REF_CNT          , NV_READ(NV10_PFIFO_CACHE1_REF_CNT));
+
+	tmp  = NV_READ(NV04_PFIFO_CACHE1_DMA_INSTANCE) & 0xFFFF;
+	tmp |= (NV_READ(NV04_PFIFO_CACHE1_DMA_DCOUNT) << 16);
+	RAMFC_WR(DMA_INSTANCE     , tmp);
+
+	RAMFC_WR(DMA_STATE        , NV_READ(NV04_PFIFO_CACHE1_DMA_STATE));
+	RAMFC_WR(DMA_FETCH	  , NV_READ(NV04_PFIFO_CACHE1_DMA_FETCH));
+	RAMFC_WR(ENGINE           , NV_READ(NV04_PFIFO_CACHE1_ENGINE));
+	RAMFC_WR(PULL1_ENGINE     , NV_READ(NV04_PFIFO_CACHE1_PULL1));
+
+	if (dev_priv->chipset >= 0x17) {
+		RAMFC_WR(ACQUIRE_VALUE,
+			 NV_READ(NV10_PFIFO_CACHE1_ACQUIRE_VALUE));
+		RAMFC_WR(ACQUIRE_TIMESTAMP,
+			 NV_READ(NV10_PFIFO_CACHE1_ACQUIRE_TIMESTAMP));
+		RAMFC_WR(ACQUIRE_TIMEOUT,
+			 NV_READ(NV10_PFIFO_CACHE1_ACQUIRE_TIMEOUT));
+		RAMFC_WR(SEMAPHORE,
+			 NV_READ(NV10_PFIFO_CACHE1_SEMAPHORE));
+		RAMFC_WR(DMA_SUBROUTINE,
+			 NV_READ(NV04_PFIFO_CACHE1_DMA_GET));
+	}
+
+	return 0;
+}
+
Index: git/shared-core/nv10_graph.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv10_graph.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,872 @@
+/* 
+ * Copyright 2007 Matthieu CASTET <castet.matthieu@free.fr>
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drm.h"
+#include "nouveau_drv.h"
+
+#define NV10_FIFO_NUMBER 32
+
+struct pipe_state {
+	uint32_t pipe_0x0000[0x040/4];
+	uint32_t pipe_0x0040[0x010/4];
+	uint32_t pipe_0x0200[0x0c0/4];
+	uint32_t pipe_0x4400[0x080/4];
+	uint32_t pipe_0x6400[0x3b0/4];
+	uint32_t pipe_0x6800[0x2f0/4];
+	uint32_t pipe_0x6c00[0x030/4];
+	uint32_t pipe_0x7000[0x130/4];
+	uint32_t pipe_0x7400[0x0c0/4];
+	uint32_t pipe_0x7800[0x0c0/4];
+};
+
+/* TODO dynamic allocation ??? */
+static struct pipe_state pipe_state[NV10_FIFO_NUMBER];
+
+static void nv10_graph_save_pipe(struct nouveau_channel *chan) {
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct pipe_state *fifo_pipe_state = pipe_state + chan->id;
+	int i;
+#define PIPE_SAVE(addr) \
+	do { \
+		NV_WRITE(NV10_PGRAPH_PIPE_ADDRESS, addr); \
+		for (i=0; i < sizeof(fifo_pipe_state->pipe_##addr)/sizeof(fifo_pipe_state->pipe_##addr[0]); i++) \
+			fifo_pipe_state->pipe_##addr[i] = NV_READ(NV10_PGRAPH_PIPE_DATA); \
+	} while (0)
+
+	PIPE_SAVE(0x4400);
+	PIPE_SAVE(0x0200);
+	PIPE_SAVE(0x6400);
+	PIPE_SAVE(0x6800);
+	PIPE_SAVE(0x6c00);
+	PIPE_SAVE(0x7000);
+	PIPE_SAVE(0x7400);
+	PIPE_SAVE(0x7800);
+	PIPE_SAVE(0x0040);
+	PIPE_SAVE(0x0000);
+
+#undef PIPE_SAVE
+}
+
+static void nv10_graph_load_pipe(struct nouveau_channel *chan) {
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct pipe_state *fifo_pipe_state = pipe_state + chan->id;
+	int i;
+	uint32_t xfmode0, xfmode1;
+#define PIPE_RESTORE(addr) \
+	do { \
+		NV_WRITE(NV10_PGRAPH_PIPE_ADDRESS, addr); \
+		for (i=0; i < sizeof(fifo_pipe_state->pipe_##addr)/sizeof(fifo_pipe_state->pipe_##addr[0]); i++) \
+			NV_WRITE(NV10_PGRAPH_PIPE_DATA, fifo_pipe_state->pipe_##addr[i]); \
+	} while (0)
+
+
+	nouveau_wait_for_idle(dev);
+	/* XXX check haiku comments */
+	xfmode0 = NV_READ(NV10_PGRAPH_XFMODE0);
+	xfmode1 = NV_READ(NV10_PGRAPH_XFMODE1);
+	NV_WRITE(NV10_PGRAPH_XFMODE0, 0x10000000);
+	NV_WRITE(NV10_PGRAPH_XFMODE1, 0x00000000);
+	NV_WRITE(NV10_PGRAPH_PIPE_ADDRESS, 0x000064c0);
+	for (i = 0; i < 4; i++)
+		NV_WRITE(NV10_PGRAPH_PIPE_DATA, 0x3f800000);
+	for (i = 0; i < 4; i++)
+		NV_WRITE(NV10_PGRAPH_PIPE_DATA, 0x00000000);
+
+	NV_WRITE(NV10_PGRAPH_PIPE_ADDRESS, 0x00006ab0);
+	for (i = 0; i < 3; i++)
+		NV_WRITE(NV10_PGRAPH_PIPE_DATA, 0x3f800000);
+
+	NV_WRITE(NV10_PGRAPH_PIPE_ADDRESS, 0x00006a80);
+	for (i = 0; i < 3; i++)
+		NV_WRITE(NV10_PGRAPH_PIPE_DATA, 0x00000000);
+
+	NV_WRITE(NV10_PGRAPH_PIPE_ADDRESS, 0x00000040);
+	NV_WRITE(NV10_PGRAPH_PIPE_DATA, 0x00000008);
+
+
+	PIPE_RESTORE(0x0200);
+	nouveau_wait_for_idle(dev);
+
+	/* restore XFMODE */
+	NV_WRITE(NV10_PGRAPH_XFMODE0, xfmode0);
+	NV_WRITE(NV10_PGRAPH_XFMODE1, xfmode1);
+	PIPE_RESTORE(0x6400);
+	PIPE_RESTORE(0x6800);
+	PIPE_RESTORE(0x6c00);
+	PIPE_RESTORE(0x7000);
+	PIPE_RESTORE(0x7400);
+	PIPE_RESTORE(0x7800);
+	PIPE_RESTORE(0x4400);
+	PIPE_RESTORE(0x0000);
+	PIPE_RESTORE(0x0040);
+	nouveau_wait_for_idle(dev);
+
+#undef PIPE_RESTORE
+}
+
+static void nv10_graph_create_pipe(struct nouveau_channel *chan) {
+	struct pipe_state *fifo_pipe_state = pipe_state + chan->id;
+	uint32_t *fifo_pipe_state_addr;
+	int i;
+#define PIPE_INIT(addr) \
+	do { \
+		fifo_pipe_state_addr = fifo_pipe_state->pipe_##addr; \
+	} while (0)
+#define PIPE_INIT_END(addr) \
+	do { \
+		if (fifo_pipe_state_addr != \
+				sizeof(fifo_pipe_state->pipe_##addr)/sizeof(fifo_pipe_state->pipe_##addr[0]) + fifo_pipe_state->pipe_##addr) \
+			DRM_ERROR("incomplete pipe init for 0x%x :  %p/%p\n", addr, fifo_pipe_state_addr, \
+					sizeof(fifo_pipe_state->pipe_##addr)/sizeof(fifo_pipe_state->pipe_##addr[0]) + fifo_pipe_state->pipe_##addr); \
+	} while (0)
+#define NV_WRITE_PIPE_INIT(value) *(fifo_pipe_state_addr++) = value
+
+	PIPE_INIT(0x0200);
+	for (i = 0; i < 48; i++)
+		NV_WRITE_PIPE_INIT(0x00000000);
+	PIPE_INIT_END(0x0200);
+
+	PIPE_INIT(0x6400);
+	for (i = 0; i < 211; i++)
+		NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x3f800000);
+	NV_WRITE_PIPE_INIT(0x40000000);
+	NV_WRITE_PIPE_INIT(0x40000000);
+	NV_WRITE_PIPE_INIT(0x40000000);
+	NV_WRITE_PIPE_INIT(0x40000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x3f800000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x3f000000);
+	NV_WRITE_PIPE_INIT(0x3f000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x3f800000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x3f800000);
+	NV_WRITE_PIPE_INIT(0x3f800000);
+	NV_WRITE_PIPE_INIT(0x3f800000);
+	NV_WRITE_PIPE_INIT(0x3f800000);
+	PIPE_INIT_END(0x6400);
+
+	PIPE_INIT(0x6800);
+	for (i = 0; i < 162; i++)
+		NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x3f800000);
+	for (i = 0; i < 25; i++)
+		NV_WRITE_PIPE_INIT(0x00000000);
+	PIPE_INIT_END(0x6800);
+
+	PIPE_INIT(0x6c00);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0xbf800000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	PIPE_INIT_END(0x6c00);
+
+	PIPE_INIT(0x7000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x7149f2ca);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x7149f2ca);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x7149f2ca);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x7149f2ca);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x7149f2ca);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x7149f2ca);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x7149f2ca);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x00000000);
+	NV_WRITE_PIPE_INIT(0x7149f2ca);
+	for (i = 0; i < 35; i++)
+		NV_WRITE_PIPE_INIT(0x00000000);
+	PIPE_INIT_END(0x7000);
+
+	PIPE_INIT(0x7400);
+	for (i = 0; i < 48; i++)
+		NV_WRITE_PIPE_INIT(0x00000000);
+	PIPE_INIT_END(0x7400);
+
+	PIPE_INIT(0x7800);
+	for (i = 0; i < 48; i++)
+		NV_WRITE_PIPE_INIT(0x00000000);
+	PIPE_INIT_END(0x7800);
+
+	PIPE_INIT(0x4400);
+	for (i = 0; i < 32; i++)
+		NV_WRITE_PIPE_INIT(0x00000000);
+	PIPE_INIT_END(0x4400);
+
+	PIPE_INIT(0x0000);
+	for (i = 0; i < 16; i++)
+		NV_WRITE_PIPE_INIT(0x00000000);
+	PIPE_INIT_END(0x0000);
+
+	PIPE_INIT(0x0040);
+	for (i = 0; i < 4; i++)
+		NV_WRITE_PIPE_INIT(0x00000000);
+	PIPE_INIT_END(0x0040);
+
+#undef PIPE_INIT
+#undef PIPE_INIT_END
+#undef NV_WRITE_PIPE_INIT
+}
+
+static int nv10_graph_ctx_regs [] = {
+NV10_PGRAPH_CTX_SWITCH1,
+NV10_PGRAPH_CTX_SWITCH2,
+NV10_PGRAPH_CTX_SWITCH3,
+NV10_PGRAPH_CTX_SWITCH4,
+NV10_PGRAPH_CTX_SWITCH5,
+NV10_PGRAPH_CTX_CACHE1,	/* 8 values from 0x400160 to 0x40017c */
+NV10_PGRAPH_CTX_CACHE2,	/* 8 values from 0x400180 to 0x40019c */
+NV10_PGRAPH_CTX_CACHE3,	/* 8 values from 0x4001a0 to 0x4001bc */
+NV10_PGRAPH_CTX_CACHE4,	/* 8 values from 0x4001c0 to 0x4001dc */
+NV10_PGRAPH_CTX_CACHE5,	/* 8 values from 0x4001e0 to 0x4001fc */
+0x00400164,
+0x00400184,
+0x004001a4,
+0x004001c4,
+0x004001e4,
+0x00400168,
+0x00400188,
+0x004001a8,
+0x004001c8,
+0x004001e8,
+0x0040016c,
+0x0040018c,
+0x004001ac,
+0x004001cc,
+0x004001ec,
+0x00400170,
+0x00400190,
+0x004001b0,
+0x004001d0,
+0x004001f0,
+0x00400174,
+0x00400194,
+0x004001b4,
+0x004001d4,
+0x004001f4,
+0x00400178,
+0x00400198,
+0x004001b8,
+0x004001d8,
+0x004001f8,
+0x0040017c,
+0x0040019c,
+0x004001bc,
+0x004001dc,
+0x004001fc,
+NV10_PGRAPH_CTX_USER,
+NV04_PGRAPH_DMA_START_0,
+NV04_PGRAPH_DMA_START_1,
+NV04_PGRAPH_DMA_LENGTH,
+NV04_PGRAPH_DMA_MISC,
+NV10_PGRAPH_DMA_PITCH,
+NV04_PGRAPH_BOFFSET0,
+NV04_PGRAPH_BBASE0,
+NV04_PGRAPH_BLIMIT0,
+NV04_PGRAPH_BOFFSET1,
+NV04_PGRAPH_BBASE1,
+NV04_PGRAPH_BLIMIT1,
+NV04_PGRAPH_BOFFSET2,
+NV04_PGRAPH_BBASE2,
+NV04_PGRAPH_BLIMIT2,
+NV04_PGRAPH_BOFFSET3,
+NV04_PGRAPH_BBASE3,
+NV04_PGRAPH_BLIMIT3,
+NV04_PGRAPH_BOFFSET4,
+NV04_PGRAPH_BBASE4,
+NV04_PGRAPH_BLIMIT4,
+NV04_PGRAPH_BOFFSET5,
+NV04_PGRAPH_BBASE5,
+NV04_PGRAPH_BLIMIT5,
+NV04_PGRAPH_BPITCH0,
+NV04_PGRAPH_BPITCH1,
+NV04_PGRAPH_BPITCH2,
+NV04_PGRAPH_BPITCH3,
+NV04_PGRAPH_BPITCH4,
+NV10_PGRAPH_SURFACE,
+NV10_PGRAPH_STATE,
+NV04_PGRAPH_BSWIZZLE2,
+NV04_PGRAPH_BSWIZZLE5,
+NV04_PGRAPH_BPIXEL,
+NV10_PGRAPH_NOTIFY,
+NV04_PGRAPH_PATT_COLOR0,
+NV04_PGRAPH_PATT_COLOR1,
+NV04_PGRAPH_PATT_COLORRAM, /* 64 values from 0x400900 to 0x4009fc */
+0x00400904,
+0x00400908,
+0x0040090c,
+0x00400910,
+0x00400914,
+0x00400918,
+0x0040091c,
+0x00400920,
+0x00400924,
+0x00400928,
+0x0040092c,
+0x00400930,
+0x00400934,
+0x00400938,
+0x0040093c,
+0x00400940,
+0x00400944,
+0x00400948,
+0x0040094c,
+0x00400950,
+0x00400954,
+0x00400958,
+0x0040095c,
+0x00400960,
+0x00400964,
+0x00400968,
+0x0040096c,
+0x00400970,
+0x00400974,
+0x00400978,
+0x0040097c,
+0x00400980,
+0x00400984,
+0x00400988,
+0x0040098c,
+0x00400990,
+0x00400994,
+0x00400998,
+0x0040099c,
+0x004009a0,
+0x004009a4,
+0x004009a8,
+0x004009ac,
+0x004009b0,
+0x004009b4,
+0x004009b8,
+0x004009bc,
+0x004009c0,
+0x004009c4,
+0x004009c8,
+0x004009cc,
+0x004009d0,
+0x004009d4,
+0x004009d8,
+0x004009dc,
+0x004009e0,
+0x004009e4,
+0x004009e8,
+0x004009ec,
+0x004009f0,
+0x004009f4,
+0x004009f8,
+0x004009fc,
+NV04_PGRAPH_PATTERN,	/* 2 values from 0x400808 to 0x40080c */
+0x0040080c,
+NV04_PGRAPH_PATTERN_SHAPE,
+NV03_PGRAPH_MONO_COLOR0,
+NV04_PGRAPH_ROP3,
+NV04_PGRAPH_CHROMA,
+NV04_PGRAPH_BETA_AND,
+NV04_PGRAPH_BETA_PREMULT,
+0x00400e70,
+0x00400e74,
+0x00400e78,
+0x00400e7c,
+0x00400e80,
+0x00400e84,
+0x00400e88,
+0x00400e8c,
+0x00400ea0,
+0x00400ea4,
+0x00400ea8,
+0x00400e90,
+0x00400e94,
+0x00400e98,
+0x00400e9c,
+NV10_PGRAPH_WINDOWCLIP_HORIZONTAL, /* 8 values from 0x400f00 to 0x400f1c */
+NV10_PGRAPH_WINDOWCLIP_VERTICAL,   /* 8 values from 0x400f20 to 0x400f3c */
+0x00400f04,
+0x00400f24,
+0x00400f08,
+0x00400f28,
+0x00400f0c,
+0x00400f2c,
+0x00400f10,
+0x00400f30,
+0x00400f14,
+0x00400f34,
+0x00400f18,
+0x00400f38,
+0x00400f1c,
+0x00400f3c,
+NV10_PGRAPH_XFMODE0,
+NV10_PGRAPH_XFMODE1,
+NV10_PGRAPH_GLOBALSTATE0,
+NV10_PGRAPH_GLOBALSTATE1,
+NV04_PGRAPH_STORED_FMT,
+NV04_PGRAPH_SOURCE_COLOR,
+NV03_PGRAPH_ABS_X_RAM,	/* 32 values from 0x400400 to 0x40047c */
+NV03_PGRAPH_ABS_Y_RAM,	/* 32 values from 0x400480 to 0x4004fc */
+0x00400404,
+0x00400484,
+0x00400408,
+0x00400488,
+0x0040040c,
+0x0040048c,
+0x00400410,
+0x00400490,
+0x00400414,
+0x00400494,
+0x00400418,
+0x00400498,
+0x0040041c,
+0x0040049c,
+0x00400420,
+0x004004a0,
+0x00400424,
+0x004004a4,
+0x00400428,
+0x004004a8,
+0x0040042c,
+0x004004ac,
+0x00400430,
+0x004004b0,
+0x00400434,
+0x004004b4,
+0x00400438,
+0x004004b8,
+0x0040043c,
+0x004004bc,
+0x00400440,
+0x004004c0,
+0x00400444,
+0x004004c4,
+0x00400448,
+0x004004c8,
+0x0040044c,
+0x004004cc,
+0x00400450,
+0x004004d0,
+0x00400454,
+0x004004d4,
+0x00400458,
+0x004004d8,
+0x0040045c,
+0x004004dc,
+0x00400460,
+0x004004e0,
+0x00400464,
+0x004004e4,
+0x00400468,
+0x004004e8,
+0x0040046c,
+0x004004ec,
+0x00400470,
+0x004004f0,
+0x00400474,
+0x004004f4,
+0x00400478,
+0x004004f8,
+0x0040047c,
+0x004004fc,
+NV03_PGRAPH_ABS_UCLIP_XMIN,
+NV03_PGRAPH_ABS_UCLIP_XMAX,
+NV03_PGRAPH_ABS_UCLIP_YMIN,
+NV03_PGRAPH_ABS_UCLIP_YMAX,
+0x00400550,
+0x00400558,
+0x00400554,
+0x0040055c,
+NV03_PGRAPH_ABS_UCLIPA_XMIN,
+NV03_PGRAPH_ABS_UCLIPA_XMAX,
+NV03_PGRAPH_ABS_UCLIPA_YMIN,
+NV03_PGRAPH_ABS_UCLIPA_YMAX,
+NV03_PGRAPH_ABS_ICLIP_XMAX,
+NV03_PGRAPH_ABS_ICLIP_YMAX,
+NV03_PGRAPH_XY_LOGIC_MISC0,
+NV03_PGRAPH_XY_LOGIC_MISC1,
+NV03_PGRAPH_XY_LOGIC_MISC2,
+NV03_PGRAPH_XY_LOGIC_MISC3,
+NV03_PGRAPH_CLIPX_0,
+NV03_PGRAPH_CLIPX_1,
+NV03_PGRAPH_CLIPY_0,
+NV03_PGRAPH_CLIPY_1,
+NV10_PGRAPH_COMBINER0_IN_ALPHA,
+NV10_PGRAPH_COMBINER1_IN_ALPHA,
+NV10_PGRAPH_COMBINER0_IN_RGB,
+NV10_PGRAPH_COMBINER1_IN_RGB,
+NV10_PGRAPH_COMBINER_COLOR0,
+NV10_PGRAPH_COMBINER_COLOR1,
+NV10_PGRAPH_COMBINER0_OUT_ALPHA,
+NV10_PGRAPH_COMBINER1_OUT_ALPHA,
+NV10_PGRAPH_COMBINER0_OUT_RGB,
+NV10_PGRAPH_COMBINER1_OUT_RGB,
+NV10_PGRAPH_COMBINER_FINAL0,
+NV10_PGRAPH_COMBINER_FINAL1,
+0x00400e00,
+0x00400e04,
+0x00400e08,
+0x00400e0c,
+0x00400e10,
+0x00400e14,
+0x00400e18,
+0x00400e1c,
+0x00400e20,
+0x00400e24,
+0x00400e28,
+0x00400e2c,
+0x00400e30,
+0x00400e34,
+0x00400e38,
+0x00400e3c,
+NV04_PGRAPH_PASSTHRU_0,
+NV04_PGRAPH_PASSTHRU_1,
+NV04_PGRAPH_PASSTHRU_2,
+NV10_PGRAPH_DIMX_TEXTURE,
+NV10_PGRAPH_WDIMX_TEXTURE,
+NV10_PGRAPH_DVD_COLORFMT,
+NV10_PGRAPH_SCALED_FORMAT,
+NV04_PGRAPH_MISC24_0,
+NV04_PGRAPH_MISC24_1,
+NV04_PGRAPH_MISC24_2,
+NV03_PGRAPH_X_MISC,
+NV03_PGRAPH_Y_MISC,
+NV04_PGRAPH_VALID1,
+NV04_PGRAPH_VALID2,
+};
+
+static int nv17_graph_ctx_regs [] = {
+NV10_PGRAPH_DEBUG_4,
+0x004006b0,
+0x00400eac,
+0x00400eb0,
+0x00400eb4,
+0x00400eb8,
+0x00400ebc,
+0x00400ec0,
+0x00400ec4,
+0x00400ec8,
+0x00400ecc,
+0x00400ed0,
+0x00400ed4,
+0x00400ed8,
+0x00400edc,
+0x00400ee0,
+0x00400a00,
+0x00400a04,
+};
+
+static int nv10_graph_ctx_regs_find_offset(struct drm_device *dev, int reg)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i, j;
+	for (i = 0; i < sizeof(nv10_graph_ctx_regs)/sizeof(nv10_graph_ctx_regs[0]); i++) {
+		if (nv10_graph_ctx_regs[i] == reg)
+			return i;
+	}
+	if (dev_priv->chipset>=0x17) {
+		for (j = 0; j < sizeof(nv17_graph_ctx_regs)/sizeof(nv17_graph_ctx_regs[0]); i++,j++) {
+			if (nv17_graph_ctx_regs[j] == reg)
+				return i;
+		}
+	}
+	return -1;
+}
+
+int nv10_graph_load_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i, j;
+
+	for (i = 0; i < sizeof(nv10_graph_ctx_regs)/sizeof(nv10_graph_ctx_regs[0]); i++)
+		NV_WRITE(nv10_graph_ctx_regs[i], chan->pgraph_ctx[i]);
+	if (dev_priv->chipset>=0x17) {
+		for (j = 0; j < sizeof(nv17_graph_ctx_regs)/sizeof(nv17_graph_ctx_regs[0]); i++,j++)
+			NV_WRITE(nv17_graph_ctx_regs[j], chan->pgraph_ctx[i]);
+	}
+
+	nv10_graph_load_pipe(chan);
+
+	return 0;
+}
+
+int nv10_graph_save_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i, j;
+
+	for (i = 0; i < sizeof(nv10_graph_ctx_regs)/sizeof(nv10_graph_ctx_regs[0]); i++)
+		chan->pgraph_ctx[i] = NV_READ(nv10_graph_ctx_regs[i]);
+	if (dev_priv->chipset>=0x17) {
+		for (j = 0; j < sizeof(nv17_graph_ctx_regs)/sizeof(nv17_graph_ctx_regs[0]); i++,j++)
+			chan->pgraph_ctx[i] = NV_READ(nv17_graph_ctx_regs[j]);
+	}
+
+	nv10_graph_save_pipe(chan);
+
+	return 0;
+}
+
+void nouveau_nv10_context_switch(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv;
+	struct nouveau_channel *next, *last;
+	int chid;
+
+	if (!dev) {
+		DRM_DEBUG("Invalid drm_device\n");
+		return;
+	}
+	dev_priv = dev->dev_private;
+	if (!dev_priv) {
+		DRM_DEBUG("Invalid drm_nouveau_private\n");
+		return;
+	}
+	if (!dev_priv->fifos) {
+		DRM_DEBUG("Invalid drm_nouveau_private->fifos\n");
+		return;
+	}
+
+	chid = (NV_READ(NV04_PGRAPH_TRAPPED_ADDR) >> 20)&(nouveau_fifo_number(dev)-1);
+	next = dev_priv->fifos[chid];
+
+	if (!next) {
+		DRM_DEBUG("Invalid next channel\n");
+		return;
+	}
+
+	chid = (NV_READ(NV10_PGRAPH_CTX_USER) >> 24) & (nouveau_fifo_number(dev)-1);
+	last = dev_priv->fifos[chid];
+
+	if (!last) {
+		DRM_DEBUG("WARNING: Invalid last channel, switch to %x\n",
+		          next->id);
+	} else {
+		DRM_DEBUG("NV: PGRAPH context switch interrupt channel %x -> %x\n",
+		         last->id, next->id);
+	}
+
+	NV_WRITE(NV04_PGRAPH_FIFO,0x0);
+	if (last) {
+		nouveau_wait_for_idle(dev);
+		nv10_graph_save_context(last);
+	}	
+
+	nouveau_wait_for_idle(dev);
+
+	NV_WRITE(NV10_PGRAPH_CTX_CONTROL, 0x10000000);
+
+	nouveau_wait_for_idle(dev);
+
+	nv10_graph_load_context(next);
+
+	NV_WRITE(NV10_PGRAPH_CTX_CONTROL, 0x10010100);
+	NV_WRITE(NV10_PGRAPH_FFINTFC_ST2, NV_READ(NV10_PGRAPH_FFINTFC_ST2)&0xCFFFFFFF);
+	NV_WRITE(NV04_PGRAPH_FIFO,0x1);
+}
+
+#define NV_WRITE_CTX(reg, val) do { \
+	int offset = nv10_graph_ctx_regs_find_offset(dev, reg); \
+	if (offset > 0) \
+		chan->pgraph_ctx[offset] = val; \
+	} while (0)
+
+int nv10_graph_create_context(struct nouveau_channel *chan) {
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("nv10_graph_context_create %d\n", chan->id);
+
+	memset(chan->pgraph_ctx, 0, sizeof(chan->pgraph_ctx));
+
+	/* mmio trace suggest that should be done in ddx with methods/objects */
+#if 0
+	uint32_t tmp, vramsz;
+	/* per channel init from ddx */
+	tmp = NV_READ(NV10_PGRAPH_SURFACE) & 0x0007ff00;
+	/*XXX the original ddx code, does this in 2 steps :
+	 * tmp = NV_READ(NV10_PGRAPH_SURFACE) & 0x0007ff00;
+	 * NV_WRITE(NV10_PGRAPH_SURFACE, tmp);
+	 * tmp = NV_READ(NV10_PGRAPH_SURFACE) | 0x00020100;
+	 * NV_WRITE(NV10_PGRAPH_SURFACE, tmp);
+	 */
+	tmp |= 0x00020100;
+	NV_WRITE_CTX(NV10_PGRAPH_SURFACE, tmp);
+
+	vramsz = drm_get_resource_len(dev, 0) - 1;
+	NV_WRITE_CTX(NV04_PGRAPH_BOFFSET0, 0);
+	NV_WRITE_CTX(NV04_PGRAPH_BOFFSET1, 0);
+	NV_WRITE_CTX(NV04_PGRAPH_BLIMIT0 , vramsz);
+	NV_WRITE_CTX(NV04_PGRAPH_BLIMIT1 , vramsz);
+
+	NV_WRITE_CTX(NV04_PGRAPH_PATTERN_SHAPE, 0x00000000);
+	NV_WRITE_CTX(NV04_PGRAPH_BETA_AND     , 0xFFFFFFFF);
+
+	NV_WRITE_CTX(NV03_PGRAPH_ABS_UCLIP_XMIN, 0);
+	NV_WRITE_CTX(NV03_PGRAPH_ABS_UCLIP_YMIN, 0);
+	NV_WRITE_CTX(NV03_PGRAPH_ABS_UCLIP_XMAX, 0x7fff);
+	NV_WRITE_CTX(NV03_PGRAPH_ABS_UCLIP_YMAX, 0x7fff);
+#endif
+
+	NV_WRITE_CTX(0x00400e88, 0x08000000);
+	NV_WRITE_CTX(0x00400e9c, 0x4b7fffff);
+	NV_WRITE_CTX(NV03_PGRAPH_XY_LOGIC_MISC0, 0x0001ffff);
+	NV_WRITE_CTX(0x00400e10, 0x00001000);
+	NV_WRITE_CTX(0x00400e14, 0x00001000);
+	NV_WRITE_CTX(0x00400e30, 0x00080008);
+	NV_WRITE_CTX(0x00400e34, 0x00080008);
+	if (dev_priv->chipset>=0x17) {
+		/* is it really needed ??? */
+		NV_WRITE_CTX(NV10_PGRAPH_DEBUG_4, NV_READ(NV10_PGRAPH_DEBUG_4));
+		NV_WRITE_CTX(0x004006b0, NV_READ(0x004006b0));
+		NV_WRITE_CTX(0x00400eac, 0x0fff0000);
+		NV_WRITE_CTX(0x00400eb0, 0x0fff0000);
+		NV_WRITE_CTX(0x00400ec0, 0x00000080);
+		NV_WRITE_CTX(0x00400ed0, 0x00000080);
+	}
+	NV_WRITE_CTX(NV10_PGRAPH_CTX_USER, chan->id << 24);
+
+	nv10_graph_create_pipe(chan);
+	return 0;
+}
+
+void nv10_graph_destroy_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int chid;
+	chid = (NV_READ(NV10_PGRAPH_CTX_USER) >> 24) & (nouveau_fifo_number(dev)-1);
+
+	/* does this avoid a potential context switch while we are written graph
+	 * reg, or we should mask graph interrupt ???
+	 */
+	NV_WRITE(NV04_PGRAPH_FIFO,0x0);
+	if (chid == chan->id) {
+		DRM_INFO("cleanning a channel with graph in current context\n");
+		nouveau_wait_for_idle(dev);
+		DRM_INFO("reseting current graph context\n");
+		nv10_graph_create_context(chan);
+		nv10_graph_load_context(chan);
+	}
+	NV_WRITE(NV04_PGRAPH_FIFO,0x1);
+}
+
+int nv10_graph_init(struct drm_device *dev) {
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) &
+			~NV_PMC_ENABLE_PGRAPH);
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) |
+			 NV_PMC_ENABLE_PGRAPH);
+
+	NV_WRITE(NV03_PGRAPH_INTR   , 0xFFFFFFFF);
+	NV_WRITE(NV03_PGRAPH_INTR_EN, 0xFFFFFFFF);
+
+	NV_WRITE(NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);
+	NV_WRITE(NV04_PGRAPH_DEBUG_0, 0x00000000);
+	NV_WRITE(NV04_PGRAPH_DEBUG_1, 0x00118700);
+	//NV_WRITE(NV04_PGRAPH_DEBUG_2, 0x24E00810); /* 0x25f92ad9 */
+	NV_WRITE(NV04_PGRAPH_DEBUG_2, 0x25f92ad9);
+	NV_WRITE(NV04_PGRAPH_DEBUG_3, 0x55DE0830 |
+				      (1<<29) |
+				      (1<<31));
+	if (dev_priv->chipset>=0x17) {
+		NV_WRITE(NV10_PGRAPH_DEBUG_4, 0x1f000000);
+		NV_WRITE(0x004006b0, 0x40000020);
+	}
+	else
+		NV_WRITE(NV10_PGRAPH_DEBUG_4, 0x00000000);
+
+	/* copy tile info from PFB */
+	for (i=0; i<NV10_PFB_TILE__SIZE; i++) {
+		NV_WRITE(NV10_PGRAPH_TILE(i), NV_READ(NV10_PFB_TILE(i)));
+		NV_WRITE(NV10_PGRAPH_TLIMIT(i), NV_READ(NV10_PFB_TLIMIT(i)));
+		NV_WRITE(NV10_PGRAPH_TSIZE(i), NV_READ(NV10_PFB_TSIZE(i)));
+		NV_WRITE(NV10_PGRAPH_TSTATUS(i), NV_READ(NV10_PFB_TSTATUS(i)));
+	}
+
+	NV_WRITE(NV10_PGRAPH_CTX_SWITCH1, 0x00000000);
+	NV_WRITE(NV10_PGRAPH_CTX_SWITCH2, 0x00000000);
+	NV_WRITE(NV10_PGRAPH_CTX_SWITCH3, 0x00000000);
+	NV_WRITE(NV10_PGRAPH_CTX_SWITCH4, 0x00000000);
+	NV_WRITE(NV10_PGRAPH_CTX_CONTROL, 0x10010100);
+	NV_WRITE(NV10_PGRAPH_STATE      , 0xFFFFFFFF);
+	NV_WRITE(NV04_PGRAPH_FIFO       , 0x00000001);
+
+	return 0;
+}
+
+void nv10_graph_takedown(struct drm_device *dev)
+{
+}
+
Index: git/shared-core/nv20_graph.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv20_graph.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,249 @@
+/* 
+ * Copyright 2007 Matthieu CASTET <castet.matthieu@free.fr>
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+#define NV20_GRCTX_SIZE (3529*4)
+
+int nv20_graph_create_context(struct nouveau_channel *chan) {
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	unsigned int ctx_size = NV20_GRCTX_SIZE;
+	int ret;
+
+	if ((ret = nouveau_gpuobj_new_ref(dev, chan, NULL, 0, ctx_size, 16,
+					  NVOBJ_FLAG_ZERO_ALLOC,
+					  &chan->ramin_grctx)))
+		return ret;
+
+	/* Initialise default context values */
+	INSTANCE_WR(chan->ramin_grctx->gpuobj, 10, chan->id<<24); /* CTX_USER */
+
+	INSTANCE_WR(dev_priv->ctx_table->gpuobj, chan->id,
+		    chan->ramin_grctx->instance >> 4);
+	return 0;
+}
+
+void nv20_graph_destroy_context(struct nouveau_channel *chan) {
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	nouveau_gpuobj_ref_del(dev, &chan->ramin_grctx);
+
+	INSTANCE_WR(dev_priv->ctx_table->gpuobj, chan->id, 0);
+}
+
+static void nv20_graph_rdi(struct drm_device *dev) {
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	NV_WRITE(NV10_PGRAPH_RDI_INDEX, 0x2c80000);
+	for (i = 0; i < 32; i++)
+		NV_WRITE(NV10_PGRAPH_RDI_DATA, 0);
+
+	nouveau_wait_for_idle(dev);
+}
+
+/* Save current context (from PGRAPH) into the channel's context
+ */
+int nv20_graph_save_context(struct nouveau_channel *chan) {
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t instance;
+
+	instance = INSTANCE_RD(dev_priv->ctx_table->gpuobj, chan->id);
+	if (!instance) {
+		return -EINVAL;
+	}
+	if (instance != (chan->ramin_grctx->instance >> 4))
+		DRM_ERROR("nv20_graph_save_context : bad instance\n");
+
+	NV_WRITE(NV10_PGRAPH_CHANNEL_CTX_SIZE, instance);
+	NV_WRITE(NV10_PGRAPH_CHANNEL_CTX_POINTER, 2 /* save ctx */);
+	return 0;
+}
+
+
+/* Restore the context for a specific channel into PGRAPH
+ */
+int nv20_graph_load_context(struct nouveau_channel *chan) {
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t instance;
+
+	instance = INSTANCE_RD(dev_priv->ctx_table->gpuobj, chan->id);
+	if (!instance) {
+		return -EINVAL;
+	}
+	if (instance != (chan->ramin_grctx->instance >> 4))
+		DRM_ERROR("nv20_graph_load_context_current : bad instance\n");
+
+	NV_WRITE(NV10_PGRAPH_CTX_USER, chan->id << 24);
+	NV_WRITE(NV10_PGRAPH_CHANNEL_CTX_SIZE, instance);
+	NV_WRITE(NV10_PGRAPH_CHANNEL_CTX_POINTER, 1 /* restore ctx */);
+	return 0;
+}
+
+void nouveau_nv20_context_switch(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_channel *next, *last;
+	int chid;
+
+	chid = NV_READ(NV03_PFIFO_CACHE1_PUSH1)&(nouveau_fifo_number(dev)-1);
+	next = dev_priv->fifos[chid];
+
+	chid = (NV_READ(NV10_PGRAPH_CTX_USER) >> 24) & (nouveau_fifo_number(dev)-1);
+	last = dev_priv->fifos[chid];
+
+	DRM_DEBUG("NV: PGRAPH context switch interrupt channel %x -> %x\n",
+		  last->id, next->id);
+
+	NV_WRITE(NV04_PGRAPH_FIFO,0x0);
+
+	nv20_graph_save_context(last);
+	
+	nouveau_wait_for_idle(dev);
+
+	NV_WRITE(NV10_PGRAPH_CTX_CONTROL, 0x10000000);
+
+	nv20_graph_load_context(next);
+
+	nouveau_wait_for_idle(dev);
+	
+	if ((NV_READ(NV10_PGRAPH_CTX_USER) >> 24) != next->id)
+		DRM_ERROR("nouveau_nv20_context_switch : wrong channel restored %x %x!!!\n", next->id, NV_READ(NV10_PGRAPH_CTX_USER) >> 24);
+
+	NV_WRITE(NV10_PGRAPH_CTX_CONTROL, 0x10010100);
+	NV_WRITE(NV10_PGRAPH_FFINTFC_ST2, NV_READ(NV10_PGRAPH_FFINTFC_ST2)&0xCFFFFFFF);
+
+	NV_WRITE(NV04_PGRAPH_FIFO,0x1);
+}
+
+int nv20_graph_init(struct drm_device *dev) {
+	struct drm_nouveau_private *dev_priv =
+		(struct drm_nouveau_private *)dev->dev_private;
+	uint32_t tmp, vramsz;
+	int ret, i;
+
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) &
+			~NV_PMC_ENABLE_PGRAPH);
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) |
+			 NV_PMC_ENABLE_PGRAPH);
+
+	/* Create Context Pointer Table */
+	dev_priv->ctx_table_size = 32 * 4;
+	if ((ret = nouveau_gpuobj_new_ref(dev, NULL, NULL, 0,
+					  dev_priv->ctx_table_size, 16,
+					  NVOBJ_FLAG_ZERO_ALLOC,
+					  &dev_priv->ctx_table)))
+		return ret;
+
+	NV_WRITE(NV10_PGRAPH_CHANNEL_CTX_TABLE,
+		 dev_priv->ctx_table->instance >> 4);
+
+	//XXX need to be done and save/restore for each fifo ???
+	nv20_graph_rdi(dev);
+
+	NV_WRITE(NV03_PGRAPH_INTR   , 0xFFFFFFFF);
+	NV_WRITE(NV03_PGRAPH_INTR_EN, 0xFFFFFFFF);
+
+	NV_WRITE(NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);
+	NV_WRITE(NV04_PGRAPH_DEBUG_0, 0x00000000);
+	NV_WRITE(NV04_PGRAPH_DEBUG_1, 0x00118700);
+	NV_WRITE(NV04_PGRAPH_DEBUG_3, 0xF20E0431);
+	NV_WRITE(NV10_PGRAPH_DEBUG_4, 0x00000000);
+	NV_WRITE(0x40009C           , 0x00000040);
+
+	if (dev_priv->chipset >= 0x25) {
+		NV_WRITE(0x400890, 0x00080000);
+		NV_WRITE(0x400610, 0x304B1FB6);
+		NV_WRITE(0x400B80, 0x18B82880);
+		NV_WRITE(0x400B84, 0x44000000);
+		NV_WRITE(0x400098, 0x40000080);
+		NV_WRITE(0x400B88, 0x000000ff);
+	} else {
+		NV_WRITE(0x400880, 0x00080000);
+		NV_WRITE(0x400094, 0x00000005);
+		NV_WRITE(0x400B80, 0x45CAA208);
+		NV_WRITE(0x400B84, 0x24000000);
+		NV_WRITE(0x400098, 0x00000040);
+		NV_WRITE(NV10_PGRAPH_RDI_INDEX, 0x00E00038);
+		NV_WRITE(NV10_PGRAPH_RDI_DATA , 0x00000030);
+		NV_WRITE(NV10_PGRAPH_RDI_INDEX, 0x00E10038);
+		NV_WRITE(NV10_PGRAPH_RDI_DATA , 0x00000030);
+	}
+
+	/* copy tile info from PFB */
+	for (i=0; i<NV10_PFB_TILE__SIZE; i++) {
+		NV_WRITE(NV10_PGRAPH_TILE(i), NV_READ(NV10_PFB_TILE(i)));
+		NV_WRITE(NV10_PGRAPH_TLIMIT(i), NV_READ(NV10_PFB_TLIMIT(i)));
+		NV_WRITE(NV10_PGRAPH_TSIZE(i), NV_READ(NV10_PFB_TSIZE(i)));
+		NV_WRITE(NV10_PGRAPH_TSTATUS(i), NV_READ(NV10_PFB_TSTATUS(i)));
+	}
+
+	NV_WRITE(NV10_PGRAPH_CTX_CONTROL, 0x10010100);
+	NV_WRITE(NV10_PGRAPH_STATE      , 0xFFFFFFFF);
+	NV_WRITE(NV04_PGRAPH_FIFO       , 0x00000001);
+
+	tmp = NV_READ(NV10_PGRAPH_SURFACE) & 0x0007ff00;
+	NV_WRITE(NV10_PGRAPH_SURFACE, tmp);
+	tmp = NV_READ(NV10_PGRAPH_SURFACE) | 0x00020100;
+	NV_WRITE(NV10_PGRAPH_SURFACE, tmp);
+
+	/* begin RAM config */
+	vramsz = drm_get_resource_len(dev, 0) - 1;
+	NV_WRITE(0x4009A4, NV_READ(NV04_PFB_CFG0));
+	NV_WRITE(0x4009A8, NV_READ(NV04_PFB_CFG1));
+	NV_WRITE(NV10_PGRAPH_RDI_INDEX, 0x00EA0000);
+	NV_WRITE(NV10_PGRAPH_RDI_DATA , NV_READ(NV04_PFB_CFG0));
+	NV_WRITE(NV10_PGRAPH_RDI_INDEX, 0x00EA0004);
+	NV_WRITE(NV10_PGRAPH_RDI_DATA , NV_READ(NV04_PFB_CFG1));
+	NV_WRITE(0x400820, 0);
+	NV_WRITE(0x400824, 0);
+	NV_WRITE(0x400864, vramsz-1);
+	NV_WRITE(0x400868, vramsz-1);
+
+	/* interesting.. the below overwrites some of the tile setup above.. */
+	NV_WRITE(0x400B20, 0x00000000);
+	NV_WRITE(0x400B04, 0xFFFFFFFF);
+
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_XMIN, 0);
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_YMIN, 0);
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_XMAX, 0x7fff);
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_YMAX, 0x7fff);
+
+	return 0;
+}
+
+void nv20_graph_takedown(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	nouveau_gpuobj_ref_del(dev, &dev_priv->ctx_table);
+}
+
Index: git/shared-core/nv30_graph.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv30_graph.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,2912 @@
+/*
+ * Based on nv40_graph.c
+ *  Someday this will all go away...
+ */
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+/*
+ * There are 3 families :
+ * NV30 is 0x10de:0x030*
+ * NV31 is 0x10de:0x031*
+ *
+ * NV34 is 0x10de:0x032*
+ *
+ * NV35 is 0x10de:0x033* (NV35 and NV36 are the same)
+ * NV36 is 0x10de:0x034*
+ *
+ * Not seen in the wild, no dumps (probably NV35) :
+ * NV37 is 0x10de:0x00fc, 0x10de:0x00fd
+ * NV38 is 0x10de:0x0333, 0x10de:0x00fe
+ *
+ */
+
+
+#define NV30_31_GRCTX_SIZE (22392)
+#define NV34_GRCTX_SIZE    (18140)
+#define NV35_36_GRCTX_SIZE (22396)
+
+static void nv30_31_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	INSTANCE_WR(ctx, 0x410/4, 0x00000101);
+	INSTANCE_WR(ctx, 0x424/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x428/4, 0x00000060);
+	INSTANCE_WR(ctx, 0x444/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x448/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x44c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x460/4, 0x44400000);
+	INSTANCE_WR(ctx, 0x48c/4, 0xffff0000);
+	for(i = 0x4e0; i< 0x4e8; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x4ec/4, 0x00011100);
+	for(i = 0x508; i< 0x548; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x550/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x58c/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x590/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x594/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x598/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x59c/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x5b0/4, 0xb0000000);
+	for(i = 0x600; i< 0x640; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00010588);
+	for(i = 0x640; i< 0x680; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00030303);
+	for(i = 0x6c0; i< 0x700; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x0008aae4);
+	for(i = 0x700; i< 0x740; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	for(i = 0x740; i< 0x780; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x85c/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x860/4, 0x00010000);
+	for(i = 0x864; i< 0x874; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00040004);
+	INSTANCE_WR(ctx, 0x1f18/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f1c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f20/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f28/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f2c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f30/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f38/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f3c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f40/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f48/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f4c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f50/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f58/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f5c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f60/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f68/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f6c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f70/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f78/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f7c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f80/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f88/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f8c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f90/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f98/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f9c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fa0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fa8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fb0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fb8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fbc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fc0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fc8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fcc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fd0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fd8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fdc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fe0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fe8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ff0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1ff8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ffc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2000/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2008/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x200c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2010/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2018/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x201c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2020/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2028/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x202c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2030/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2038/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x203c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2040/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2048/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x204c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2050/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2058/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x205c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2060/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2068/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x206c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2070/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2078/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x207c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2080/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2088/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x208c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2090/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2098/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x209c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20a0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20a8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20ac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20b0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20b8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20bc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20c0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20c8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20cc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20d0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20d8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20dc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20e0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20e8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20ec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20f0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20f8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20fc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2100/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2108/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x210c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2110/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2118/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x211c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2120/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2128/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x212c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2130/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2138/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x213c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2140/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2148/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x214c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2150/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2158/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x215c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2160/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2168/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x216c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2170/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2178/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x217c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2180/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2188/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x218c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2190/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2198/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x219c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21a0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21a8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21ac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21b0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21b8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21bc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21c0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21c8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21cc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21d0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21d8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21dc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21e0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21e8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21ec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21f0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21f8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21fc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2200/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2208/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x220c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2210/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2218/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x221c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2220/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2228/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x222c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2230/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2238/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x223c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2240/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2248/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x224c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2250/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2258/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x225c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2260/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2268/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x226c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2270/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2278/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x227c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2280/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2288/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x228c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2290/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2298/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x229c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22a0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22a8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22ac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22b0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22b8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22bc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22c0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22c8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22cc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22d0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22d8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22dc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22e0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22e8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22ec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22f0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22f8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22fc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2300/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2308/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x230c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2310/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2318/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x231c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2320/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2328/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x232c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2330/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2338/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x233c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2340/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2348/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x234c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2350/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2358/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x235c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2360/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2368/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x236c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2370/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2378/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x237c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2380/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2388/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x238c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2390/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2398/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x239c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23a0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23a8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23ac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23b0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23b8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23bc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23c0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23c8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23cc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23d0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23d8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23dc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23e0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23e8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23ec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23f0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23f8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23fc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2400/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2408/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x240c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2410/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2418/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x241c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2420/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2428/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x242c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2430/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2438/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x243c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2440/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2448/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x244c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2450/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2458/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x245c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2460/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2468/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x246c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2470/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2478/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x247c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2480/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2488/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x248c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2490/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2498/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x249c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24a0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24a8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24ac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24b0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24b8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24bc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24c0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24c8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24cc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24d0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24d8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24dc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24e0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24e8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24ec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24f0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24f8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24fc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2500/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2508/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x250c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2510/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2518/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x251c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2520/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2528/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x252c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2530/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2538/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x253c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2540/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2548/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x254c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2550/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2558/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x255c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2560/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2568/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x256c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2570/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2578/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x257c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2580/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2588/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x258c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2590/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2598/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x259c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25a0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25a8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25ac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25b0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25b8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25bc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25c0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25c8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25cc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25d0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25d8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25dc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25e0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25e8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25ec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25f0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25f8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25fc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2600/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2608/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x260c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2610/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2618/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x261c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2620/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2628/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x262c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2630/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2638/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x263c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2640/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2648/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x264c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2650/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2658/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x265c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2660/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2668/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x266c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2670/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2678/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x267c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2680/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2688/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x268c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2690/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2698/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x269c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26a0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26a8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26ac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26b0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26b8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26bc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26c0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26c8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26cc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26d0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26d8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26dc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26e0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26e8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26ec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26f0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26f8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26fc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2700/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2708/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x270c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2710/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2718/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x271c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2720/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2728/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x272c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2730/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2738/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x273c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2740/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2748/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x274c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2750/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2758/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x275c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2760/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2768/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x276c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2770/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2778/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x277c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2780/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2788/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x278c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2790/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2798/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x279c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27a0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27a8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27ac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27b0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27b8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27bc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27c0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27c8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27cc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27d0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27d8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27dc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27e0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27e8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27ec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27f0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27f8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27fc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2800/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2808/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x280c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2810/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2818/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x281c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2820/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2828/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x282c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2830/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2838/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x283c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2840/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2848/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x284c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2850/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2858/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x285c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2860/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2868/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x286c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2870/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2878/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x287c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2880/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2888/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x288c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2890/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2898/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x289c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28a0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28a8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28ac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28b0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28b8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28bc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28c0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28c8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28cc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28d0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28d8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28dc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28e0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28e8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28ec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28f0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28f8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28fc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2900/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2908/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x290c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2910/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2918/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x291c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2920/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2928/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x292c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2930/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2938/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x293c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2940/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2948/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x294c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2950/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2958/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x295c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2960/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2968/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x296c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2970/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2978/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x297c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2980/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2988/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x298c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2990/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2998/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x299c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29a0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29a8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29ac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29b0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29b8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29bc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29c0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29c8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29cc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29d0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29d8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29dc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29e0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29e8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29ec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29f0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29f8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29fc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a00/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a08/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a0c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a10/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a18/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a1c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a20/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a28/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a2c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a30/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a38/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a3c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a40/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a48/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a4c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a50/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a58/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a5c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a60/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a68/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a6c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a70/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a78/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a7c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a80/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a88/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a8c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a90/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a98/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a9c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2aa0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2aa8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2aac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ab0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ab8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2abc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ac0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ac8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2acc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ad0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ad8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2adc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ae0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ae8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2aec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2af0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2af8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2afc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b00/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b08/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b0c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b10/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b18/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b1c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b20/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b28/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b2c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b30/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b38/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b3c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b40/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b48/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b4c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b50/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b58/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b5c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b60/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b68/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b6c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b70/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b78/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b7c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b80/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b88/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b8c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b90/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b98/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b9c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ba0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ba8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2bac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2bb0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2bb8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2bbc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2bc0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2bc8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2bcc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2bd0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2bd8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2bdc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2be0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2be8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2bec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2bf0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2bf8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2bfc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c00/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c08/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c0c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c10/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c18/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c1c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c20/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c28/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c2c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c30/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c38/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c3c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c40/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c48/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c4c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c50/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c58/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c5c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c60/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c68/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c6c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c70/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c78/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c7c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c80/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c88/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c8c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c90/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c98/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c9c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ca0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ca8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2cac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2cb0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2cb8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2cbc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2cc0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2cc8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ccc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2cd0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2cd8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2cdc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ce0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ce8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2cec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2cf0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2cf8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2cfc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d00/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d08/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d0c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d10/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d18/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d1c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d20/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d28/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d2c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d30/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d38/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d3c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d40/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d48/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d4c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d50/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d58/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d5c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d60/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d68/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d6c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d70/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d78/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d7c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d80/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d88/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d8c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d90/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d98/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d9c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2da0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2da8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2dac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2db0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2db8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2dbc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2dc0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2dc8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2dcc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2dd0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2dd8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ddc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2de0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2de8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2dec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2df0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2df8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2dfc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e00/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e08/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e0c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e10/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e18/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e1c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e20/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e28/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e2c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e30/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e38/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e3c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e40/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e48/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e4c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e50/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e58/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e5c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e60/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e68/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e6c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e70/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e78/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e7c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e80/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e88/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e8c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e90/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e98/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e9c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ea0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ea8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2eac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2eb0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2eb8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ebc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ec0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ec8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ecc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ed0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ed8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2edc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ee0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ee8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2eec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ef0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ef8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2efc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f00/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f08/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f0c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f10/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f18/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f1c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f20/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f28/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f2c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f30/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f38/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f3c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f40/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f48/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f4c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f50/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f58/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f5c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f60/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f68/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f6c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f70/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f78/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f7c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f80/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f88/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f8c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f90/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f98/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f9c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2fa0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2fa8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2fac/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2fb0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2fb8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2fbc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2fc0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2fc8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2fcc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2fd0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2fd8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2fdc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2fe0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2fe8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2fec/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ff0/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ff8/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ffc/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3000/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x3008/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x300c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3010/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x3018/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x301c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3020/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x3028/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x302c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3030/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x3038/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x303c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3040/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x3048/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x304c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3050/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x3058/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x305c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3060/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x3068/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x306c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3070/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x3078/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x307c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3080/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x3088/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x308c/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3090/4, 0x000c001b);
+	for(i = 0x30b8; i< 0x30c8; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x344c/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x3808/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x381c/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x3848/4, 0x40000000);
+	INSTANCE_WR(ctx, 0x384c/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x3850/4, 0x3f000000);
+	INSTANCE_WR(ctx, 0x3858/4, 0x40000000);
+	INSTANCE_WR(ctx, 0x385c/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x3864/4, 0xbf800000);
+	INSTANCE_WR(ctx, 0x386c/4, 0xbf800000);
+}
+
+static void nv34_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	INSTANCE_WR(ctx, 0x40c/4, 0x01000101);
+	INSTANCE_WR(ctx, 0x420/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x424/4, 0x00000060);
+	INSTANCE_WR(ctx, 0x440/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x444/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x448/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x45c/4, 0x44400000);
+	INSTANCE_WR(ctx, 0x480/4, 0xffff0000);
+	for(i = 0x4d4; i< 0x4dc; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x4e0/4, 0x00011100);
+	for(i = 0x4fc; i< 0x53c; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x544/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x57c/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x580/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x584/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x588/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x58c/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x5a0/4, 0xb0000000);
+	for(i = 0x5f0; i< 0x630; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00010588);
+	for(i = 0x630; i< 0x670; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00030303);
+	for(i = 0x6b0; i< 0x6f0; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x0008aae4);
+	for(i = 0x6f0; i< 0x730; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	for(i = 0x730; i< 0x770; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x850/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x854/4, 0x00010000);
+	for(i = 0x858; i< 0x868; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00040004);
+	INSTANCE_WR(ctx, 0x15ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x15b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x15b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x15bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x15c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x15c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x15cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x15d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x15d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x15dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x15e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x15e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x15ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x15f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x15f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x15fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1600/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1604/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x160c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1610/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1614/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x161c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1620/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1624/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x162c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1630/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1634/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x163c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1640/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1644/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x164c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1650/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1654/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x165c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1660/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1664/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x166c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1670/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1674/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x167c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1680/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1684/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x168c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1690/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1694/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x169c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x16a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x16a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x16ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x16b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x16b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x16bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x16c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x16c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x16cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x16d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x16d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x16dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x16e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x16e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x16ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x16f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x16f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x16fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1700/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1704/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x170c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1710/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1714/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x171c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1720/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1724/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x172c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1730/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1734/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x173c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1740/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1744/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x174c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1750/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1754/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x175c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1760/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1764/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x176c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1770/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1774/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x177c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1780/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1784/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x178c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1790/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1794/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x179c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x17a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x17a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x17ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x17b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x17b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x17bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x17c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x17c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x17cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x17d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x17d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x17dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x17e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x17e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x17ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x17f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x17f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x17fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1800/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1804/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x180c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1810/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1814/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x181c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1820/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1824/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x182c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1830/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1834/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x183c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1840/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1844/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x184c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1850/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1854/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x185c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1860/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1864/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x186c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1870/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1874/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x187c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1880/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1884/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x188c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1890/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1894/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x189c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x18a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x18a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x18ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x18b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x18b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x18bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x18c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x18c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x18cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x18d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x18d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x18dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x18e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x18e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x18ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x18f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x18f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x18fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1900/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1904/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x190c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1910/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1914/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x191c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1920/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1924/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x192c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1930/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1934/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x193c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1940/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1944/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x194c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1950/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1954/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x195c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1960/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1964/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x196c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1970/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1974/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x197c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1980/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1984/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x198c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1990/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1994/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x199c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x19a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x19a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x19ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x19b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x19b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x19bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x19c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x19c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x19cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x19d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x19d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x19dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x19e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x19e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x19ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x19f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x19f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x19fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1a00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1a04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1a0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1a10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1a14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1a1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1a20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1a24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1a2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1a30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1a34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1a3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1a40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1a44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1a4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1a50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1a54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1a5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1a60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1a64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1a6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1a70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1a74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1a7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1a80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1a84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1a8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1a90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1a94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1a9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1aa0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1aa4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1aac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ab0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ab4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1abc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ac0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ac4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1acc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ad0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ad4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1adc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ae0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ae4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1aec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1af0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1af4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1afc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1b00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1b04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1b0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1b10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1b14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1b1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1b20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1b24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1b2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1b30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1b34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1b3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1b40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1b44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1b4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1b50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1b54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1b5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1b60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1b64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1b6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1b70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1b74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1b7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1b80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1b84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1b8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1b90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1b94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1b9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ba0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ba4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1bac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1bb0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1bb4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1bbc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1bc0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1bc4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1bcc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1bd0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1bd4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1bdc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1be0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1be4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1bec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1bf0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1bf4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1bfc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1c00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1c04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1c0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1c10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1c14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1c1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1c20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1c24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1c2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1c30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1c34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1c3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1c40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1c44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1c4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1c50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1c54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1c5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1c60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1c64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1c6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1c70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1c74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1c7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1c80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1c84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1c8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1c90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1c94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1c9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ca0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ca4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1cac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1cb0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1cb4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1cbc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1cc0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1cc4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1ccc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1cd0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1cd4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1cdc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ce0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ce4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1cec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1cf0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1cf4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1cfc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1d00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1d04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1d0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1d10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1d14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1d1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1d20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1d24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1d2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1d30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1d34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1d3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1d40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1d44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1d4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1d50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1d54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1d5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1d60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1d64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1d6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1d70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1d74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1d7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1d80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1d84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1d8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1d90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1d94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1d9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1da0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1da4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1dac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1db0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1db4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1dbc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1dc0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1dc4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1dcc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1dd0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1dd4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1ddc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1de0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1de4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1dec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1df0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1df4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1dfc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1e00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1e04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1e0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1e10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1e14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1e1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1e20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1e24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1e2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1e30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1e34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1e3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1e40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1e44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1e4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1e50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1e54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1e5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1e60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1e64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1e6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1e70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1e74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1e7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1e80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1e84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1e8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1e90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1e94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1e9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ea0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ea4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1eac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1eb0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1eb4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1ebc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ec0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ec4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1ecc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ed0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ed4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1edc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ee0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ee4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1eec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ef0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ef4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1efc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fa0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fa4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fb0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fb4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fbc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fc0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fc4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fcc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fd0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fd4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fdc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fe0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fe4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ff0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ff4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1ffc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2000/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2004/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x200c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2010/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2014/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x201c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2020/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2024/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x202c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2030/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2034/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x203c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2040/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2044/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x204c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2050/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2054/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x205c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2060/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2064/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x206c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2070/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2074/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x207c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2080/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2084/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x208c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2090/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2094/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x209c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2100/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2104/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x210c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2110/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2114/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x211c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2120/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2124/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x212c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2130/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2134/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x213c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2140/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2144/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x214c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2150/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2154/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x215c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2160/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2164/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x216c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2170/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2174/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x217c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2180/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2184/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x218c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2190/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2194/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x219c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2200/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2204/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x220c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2210/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2214/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x221c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2220/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2224/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x222c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2230/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2234/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x223c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2240/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2244/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x224c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2250/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2254/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x225c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2260/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2264/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x226c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2270/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2274/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x227c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2280/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2284/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x228c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2290/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2294/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x229c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2300/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2304/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x230c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2310/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2314/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x231c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2320/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2324/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x232c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2330/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2334/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x233c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2340/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2344/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x234c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2350/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2354/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x235c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2360/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2364/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x236c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2370/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2374/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x237c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2380/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2384/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x238c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2390/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2394/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x239c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2400/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2404/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x240c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2410/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2414/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x241c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2420/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2424/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x242c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2430/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2434/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x243c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2440/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2444/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x244c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2450/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2454/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x245c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2460/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2464/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x246c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2470/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2474/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x247c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2480/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2484/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x248c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2490/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2494/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x249c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2500/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2504/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x250c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2510/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2514/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x251c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2520/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2524/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x252c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2530/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2534/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x253c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2540/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2544/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x254c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2550/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2554/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x255c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2560/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2564/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x256c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2570/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2574/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x257c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2580/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2584/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x258c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2590/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2594/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x259c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2600/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2604/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x260c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2610/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2614/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x261c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2620/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2624/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x262c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2630/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2634/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x263c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2640/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2644/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x264c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2650/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2654/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x265c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2660/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2664/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x266c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2670/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2674/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x267c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2680/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2684/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x268c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2690/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2694/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x269c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2700/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2704/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x270c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2710/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2714/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x271c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2720/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2724/4, 0x000c001b);
+	for(i = 0x274c; i< 0x275c; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x2ae0/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x2e9c/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x2eb0/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x2edc/4, 0x40000000);
+	INSTANCE_WR(ctx, 0x2ee0/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x2ee4/4, 0x3f000000);
+	INSTANCE_WR(ctx, 0x2eec/4, 0x40000000);
+	INSTANCE_WR(ctx, 0x2ef0/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x2ef8/4, 0xbf800000);
+	INSTANCE_WR(ctx, 0x2f00/4, 0xbf800000);
+}
+
+static void nv35_36_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	INSTANCE_WR(ctx, 0x40c/4, 0x00000101);
+	INSTANCE_WR(ctx, 0x420/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x424/4, 0x00000060);
+	INSTANCE_WR(ctx, 0x440/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x444/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x448/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x45c/4, 0x44400000);
+	INSTANCE_WR(ctx, 0x488/4, 0xffff0000);
+	for(i = 0x4dc; i< 0x4e4; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x4e8/4, 0x00011100);
+	for(i = 0x504; i< 0x544; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x54c/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x588/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x58c/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x590/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x594/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x598/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x5ac/4, 0xb0000000);
+	for(i = 0x604; i< 0x644; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00010588);
+	for(i = 0x644; i< 0x684; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00030303);
+	for(i = 0x6c4; i< 0x704; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x0008aae4);
+	for(i = 0x704; i< 0x744; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	for(i = 0x744; i< 0x784; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x860/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x864/4, 0x00010000);
+	for(i = 0x868; i< 0x878; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00040004);
+	INSTANCE_WR(ctx, 0x1f1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1f90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1f94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1f9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fa0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fa4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fb0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fb4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fbc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fc0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fc4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fcc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fd0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fd4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fdc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1fe0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1fe4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1fec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x1ff0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x1ff4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x1ffc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2000/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2004/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x200c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2010/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2014/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x201c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2020/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2024/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x202c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2030/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2034/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x203c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2040/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2044/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x204c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2050/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2054/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x205c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2060/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2064/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x206c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2070/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2074/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x207c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2080/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2084/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x208c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2090/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2094/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x209c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x20f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x20f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x20fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2100/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2104/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x210c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2110/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2114/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x211c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2120/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2124/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x212c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2130/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2134/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x213c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2140/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2144/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x214c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2150/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2154/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x215c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2160/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2164/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x216c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2170/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2174/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x217c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2180/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2184/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x218c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2190/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2194/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x219c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x21f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x21f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x21fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2200/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2204/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x220c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2210/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2214/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x221c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2220/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2224/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x222c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2230/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2234/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x223c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2240/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2244/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x224c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2250/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2254/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x225c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2260/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2264/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x226c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2270/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2274/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x227c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2280/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2284/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x228c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2290/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2294/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x229c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x22f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x22f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x22fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2300/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2304/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x230c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2310/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2314/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x231c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2320/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2324/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x232c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2330/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2334/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x233c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2340/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2344/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x234c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2350/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2354/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x235c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2360/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2364/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x236c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2370/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2374/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x237c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2380/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2384/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x238c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2390/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2394/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x239c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x23f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x23f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x23fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2400/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2404/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x240c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2410/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2414/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x241c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2420/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2424/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x242c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2430/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2434/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x243c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2440/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2444/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x244c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2450/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2454/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x245c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2460/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2464/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x246c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2470/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2474/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x247c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2480/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2484/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x248c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2490/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2494/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x249c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x24f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x24f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x24fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2500/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2504/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x250c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2510/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2514/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x251c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2520/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2524/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x252c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2530/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2534/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x253c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2540/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2544/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x254c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2550/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2554/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x255c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2560/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2564/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x256c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2570/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2574/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x257c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2580/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2584/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x258c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2590/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2594/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x259c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x25f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x25f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x25fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2600/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2604/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x260c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2610/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2614/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x261c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2620/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2624/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x262c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2630/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2634/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x263c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2640/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2644/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x264c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2650/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2654/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x265c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2660/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2664/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x266c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2670/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2674/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x267c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2680/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2684/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x268c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2690/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2694/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x269c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x26f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x26f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x26fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2700/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2704/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x270c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2710/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2714/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x271c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2720/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2724/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x272c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2730/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2734/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x273c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2740/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2744/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x274c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2750/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2754/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x275c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2760/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2764/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x276c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2770/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2774/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x277c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2780/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2784/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x278c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2790/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2794/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x279c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x27f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x27f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x27fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2800/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2804/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x280c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2810/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2814/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x281c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2820/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2824/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x282c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2830/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2834/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x283c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2840/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2844/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x284c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2850/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2854/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x285c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2860/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2864/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x286c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2870/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2874/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x287c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2880/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2884/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x288c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2890/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2894/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x289c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x28f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x28f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x28fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2900/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2904/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x290c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2910/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2914/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x291c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2920/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2924/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x292c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2930/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2934/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x293c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2940/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2944/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x294c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2950/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2954/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x295c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2960/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2964/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x296c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2970/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2974/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x297c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2980/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2984/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x298c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2990/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2994/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x299c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29a0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29a4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29ac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29b0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29b4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29bc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29c0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29c4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29cc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29d0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29d4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29dc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29e0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29e4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29ec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x29f0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x29f4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x29fc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2a90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2a94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2a9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2aa0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2aa4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2aac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ab0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ab4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2abc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ac0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ac4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2acc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ad0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ad4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2adc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ae0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ae4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2aec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2af0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2af4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2afc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2b90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2b94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2b9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ba0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ba4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2bac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2bb0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2bb4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2bbc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2bc0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2bc4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2bcc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2bd0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2bd4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2bdc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2be0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2be4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2bec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2bf0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2bf4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2bfc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2c90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2c94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2c9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ca0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ca4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2cac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2cb0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2cb4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2cbc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2cc0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2cc4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ccc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2cd0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2cd4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2cdc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ce0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ce4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2cec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2cf0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2cf4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2cfc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2d90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2d94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2d9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2da0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2da4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2dac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2db0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2db4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2dbc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2dc0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2dc4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2dcc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2dd0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2dd4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ddc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2de0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2de4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2dec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2df0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2df4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2dfc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2e90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2e94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2e9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ea0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ea4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2eac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2eb0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2eb4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ebc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ec0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ec4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ecc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ed0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ed4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2edc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ee0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ee4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2eec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ef0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ef4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2efc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f00/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f04/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f0c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f10/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f14/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f1c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f20/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f24/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f2c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f30/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f34/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f3c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f40/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f44/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f4c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f50/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f54/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f5c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f60/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f64/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f6c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f70/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f74/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f7c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f80/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f84/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f8c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2f90/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2f94/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2f9c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2fa0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2fa4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2fac/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2fb0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2fb4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2fbc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2fc0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2fc4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2fcc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2fd0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2fd4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2fdc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2fe0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2fe4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2fec/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x2ff0/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x2ff4/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x2ffc/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x3000/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3004/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x300c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x3010/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3014/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x301c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x3020/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3024/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x302c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x3030/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3034/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x303c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x3040/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3044/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x304c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x3050/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3054/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x305c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x3060/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3064/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x306c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x3070/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3074/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x307c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x3080/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3084/4, 0x000c001b);
+	INSTANCE_WR(ctx, 0x308c/4, 0x10700ff9);
+	INSTANCE_WR(ctx, 0x3090/4, 0x0436086c);
+	INSTANCE_WR(ctx, 0x3094/4, 0x000c001b);
+	for(i = 0x30bc; i< 0x30cc; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x3450/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x380c/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x3820/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x384c/4, 0x40000000);
+	INSTANCE_WR(ctx, 0x3850/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x3854/4, 0x3f000000);
+	INSTANCE_WR(ctx, 0x385c/4, 0x40000000);
+	INSTANCE_WR(ctx, 0x3860/4, 0x3f800000);
+	INSTANCE_WR(ctx, 0x3868/4, 0xbf800000);
+	INSTANCE_WR(ctx, 0x3870/4, 0xbf800000);}
+
+int nv30_graph_create_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	void (*ctx_init)(struct drm_device *, struct nouveau_gpuobj *);
+	unsigned int ctx_size;
+	int ret;
+
+	switch (dev_priv->chipset) {
+	case 0x30:
+	case 0x31:
+		ctx_size = NV30_31_GRCTX_SIZE;
+		ctx_init = nv30_31_graph_context_init;
+		break;
+	case 0x34:
+		ctx_size = NV34_GRCTX_SIZE;
+		ctx_init = nv34_graph_context_init;
+		break;
+	case 0x35:
+	case 0x36:
+		ctx_size = NV35_36_GRCTX_SIZE;
+		ctx_init = nv35_36_graph_context_init;
+		break;
+	default:
+		ctx_size = 0;
+		ctx_init = nv35_36_graph_context_init;
+		DRM_ERROR("Please contact the devs if you want your NV%x card to work\n",dev_priv->chipset);
+		break;
+	}
+
+	if ((ret = nouveau_gpuobj_new_ref(dev, chan, NULL, 0, ctx_size, 16,
+					  NVOBJ_FLAG_ZERO_ALLOC,
+					  &chan->ramin_grctx)))
+		return ret;
+
+	/* Initialise default context values */
+	ctx_init(dev, chan->ramin_grctx->gpuobj);
+
+	INSTANCE_WR(chan->ramin_grctx->gpuobj, 0x28/4, (chan->id<<24)|0x1); /* CTX_USER */
+	INSTANCE_WR(dev_priv->ctx_table->gpuobj, chan->id,
+			chan->ramin_grctx->instance >> 4);
+
+	return 0;
+}
+
+void nv30_graph_destroy_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	if (chan->ramin_grctx)
+		nouveau_gpuobj_ref_del(dev, &chan->ramin_grctx);
+
+	INSTANCE_WR(dev_priv->ctx_table->gpuobj, chan->id, 0);
+}
+
+static int
+nouveau_graph_wait_idle(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int tv = 1000;
+
+	while (tv--) {
+		if (NV_READ(0x400700) == 0)
+			break;
+	}
+
+	if (NV_READ(0x400700)) {
+		DRM_ERROR("timeout!\n");
+		return -EBUSY;
+	}
+	return 0;
+}
+
+int nv30_graph_load_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t inst;
+
+	if (!chan->ramin_grctx)
+		return -EINVAL;
+	inst = chan->ramin_grctx->instance >> 4;
+
+	NV_WRITE(NV20_PGRAPH_CHANNEL_CTX_POINTER, inst);
+	NV_WRITE(NV20_PGRAPH_CHANNEL_CTX_XFER,
+		 NV20_PGRAPH_CHANNEL_CTX_XFER_LOAD);
+
+	return nouveau_graph_wait_idle(dev);
+}
+
+int nv30_graph_save_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t inst;
+
+	if (!chan->ramin_grctx)
+		return -EINVAL;
+	inst = chan->ramin_grctx->instance >> 4;
+
+	NV_WRITE(NV20_PGRAPH_CHANNEL_CTX_POINTER, inst);
+	NV_WRITE(NV20_PGRAPH_CHANNEL_CTX_XFER,
+		 NV20_PGRAPH_CHANNEL_CTX_XFER_SAVE);
+
+	return nouveau_graph_wait_idle(dev);
+}
+
+int nv30_graph_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t vramsz, tmp;
+	int ret, i;
+
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) &
+			~NV_PMC_ENABLE_PGRAPH);
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) |
+			 NV_PMC_ENABLE_PGRAPH);
+
+        /* Create Context Pointer Table */
+        dev_priv->ctx_table_size = 32 * 4;
+	if ((ret = nouveau_gpuobj_new_ref(dev, NULL, NULL, 0,
+					  dev_priv->ctx_table_size, 16,
+					  NVOBJ_FLAG_ZERO_ALLOC,
+					  &dev_priv->ctx_table)))
+		return ret;
+
+        NV_WRITE(NV10_PGRAPH_CHANNEL_CTX_TABLE,
+		 dev_priv->ctx_table->instance >> 4);
+
+	NV_WRITE(NV03_PGRAPH_INTR   , 0xFFFFFFFF);
+	NV_WRITE(NV03_PGRAPH_INTR_EN, 0xFFFFFFFF);
+
+	NV_WRITE(NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);
+	NV_WRITE(NV04_PGRAPH_DEBUG_0, 0x00000000);
+	NV_WRITE(NV04_PGRAPH_DEBUG_1, 0x401287c0);
+	NV_WRITE(0x400890, 0x01b463ff);
+	NV_WRITE(NV04_PGRAPH_DEBUG_3, 0xf3de0471);
+	NV_WRITE(NV10_PGRAPH_DEBUG_4, 0x00008000);
+	NV_WRITE(NV04_PGRAPH_LIMIT_VIOL_PIX, 0xf04bdff6);
+	NV_WRITE(0x400B80, 0x1003d888);
+	NV_WRITE(0x400098, 0x00000000);
+	NV_WRITE(0x40009C, 0x0005ad00);
+	NV_WRITE(0x400B88, 0x62ff00ff); // suspiciously like PGRAPH_DEBUG_2
+	NV_WRITE(0x4000a0, 0x00000000);
+	NV_WRITE(0x4000a4, 0x00000008);
+	NV_WRITE(0x4008a8, 0xb784a400);
+	NV_WRITE(0x400ba0, 0x002f8685);
+	NV_WRITE(0x400ba4, 0x00231f3f);
+	NV_WRITE(0x4008a4, 0x40000020);
+	NV_WRITE(0x400B84, 0x0c000000);
+	NV_WRITE(NV04_PGRAPH_DEBUG_2, 0x62ff0f7f);
+	NV_WRITE(0x4000c0, 0x00000016);
+	NV_WRITE(0x400780, 0x000014e4);
+
+	/* copy tile info from PFB */
+	for (i=0; i<NV10_PFB_TILE__SIZE; i++) {
+		NV_WRITE(NV10_PGRAPH_TILE(i), NV_READ(NV10_PFB_TILE(i)));
+		NV_WRITE(NV10_PGRAPH_TLIMIT(i), NV_READ(NV10_PFB_TLIMIT(i)));
+		NV_WRITE(NV10_PGRAPH_TSIZE(i), NV_READ(NV10_PFB_TSIZE(i)));
+		NV_WRITE(NV10_PGRAPH_TSTATUS(i), NV_READ(NV10_PFB_TSTATUS(i)));
+	}
+
+	NV_WRITE(NV10_PGRAPH_CTX_CONTROL, 0x10010100);
+	NV_WRITE(NV10_PGRAPH_STATE      , 0xFFFFFFFF);
+	NV_WRITE(NV04_PGRAPH_FIFO       , 0x00000001);
+
+	/* begin RAM config */
+	vramsz = drm_get_resource_len(dev, 0) - 1;
+	NV_WRITE(0x4009A4, NV_READ(NV04_PFB_CFG0));
+	NV_WRITE(0x4009A8, NV_READ(NV04_PFB_CFG1));
+	NV_WRITE(0x400750, 0x00EA0000);
+	NV_WRITE(0x400754, NV_READ(NV04_PFB_CFG0));
+	NV_WRITE(0x400750, 0x00EA0004);
+	NV_WRITE(0x400754, NV_READ(NV04_PFB_CFG1));
+	NV_WRITE(0x400820, 0);
+	NV_WRITE(0x400824, 0);
+	NV_WRITE(0x400864, vramsz-1);
+	NV_WRITE(0x400868, vramsz-1);
+
+	NV_WRITE(0x400B20, 0x00000000);
+	NV_WRITE(0x400B04, 0xFFFFFFFF);
+
+	/* per-context state, doesn't belong here */
+	tmp = NV_READ(NV10_PGRAPH_SURFACE) & 0x0007ff00;
+	NV_WRITE(NV10_PGRAPH_SURFACE, tmp);
+	tmp = NV_READ(NV10_PGRAPH_SURFACE) | 0x00020100;
+	NV_WRITE(NV10_PGRAPH_SURFACE, tmp);
+
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_XMIN, 0);
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_YMIN, 0);
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_XMAX, 0x7fff);
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_YMAX, 0x7fff);
+
+	return 0;
+}
+
+void nv30_graph_takedown(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	nouveau_gpuobj_ref_del(dev, &dev_priv->ctx_table);
+}
+
Index: git/shared-core/nv40_fb.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv40_fb.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,56 @@
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+int
+nv40_fb_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t fb_bar_size, tmp;
+	int num_tiles;
+	int i;
+
+	switch (dev_priv->chipset) {
+	case 0x40:
+	case 0x45:
+		tmp = NV_READ(NV10_PFB_CLOSE_PAGE2);
+		NV_WRITE(NV10_PFB_CLOSE_PAGE2, tmp & ~(1<<15));
+		num_tiles = NV10_PFB_TILE__SIZE;
+		break;
+	case 0x46: /* G72 */
+	case 0x47: /* G70 */
+	case 0x49: /* G71 */
+	case 0x4b: /* G73 */
+	case 0x4c: /* C51 (G7X version) */
+		num_tiles = NV40_PFB_TILE__SIZE_1;
+		break;
+	default:
+		num_tiles = NV40_PFB_TILE__SIZE_0;
+		break;
+	}
+
+	fb_bar_size = drm_get_resource_len(dev, 0) - 1;
+	switch (dev_priv->chipset) {
+	case 0x40:
+		for (i=0; i<num_tiles; i++) {
+			NV_WRITE(NV10_PFB_TILE(i), 0);
+			NV_WRITE(NV10_PFB_TLIMIT(i), fb_bar_size);
+		}
+		break;
+	default:
+		for (i=0; i<num_tiles; i++) {
+			NV_WRITE(NV40_PFB_TILE(i), 0);
+			NV_WRITE(NV40_PFB_TLIMIT(i), fb_bar_size);
+		}
+		break;
+	}
+
+	return 0;
+}
+
+void
+nv40_fb_takedown(struct drm_device *dev)
+{
+}
+
Index: git/shared-core/nv40_fifo.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv40_fifo.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2007 Ben Skeggs.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "drmP.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+
+#define RAMFC_WR(offset,val) INSTANCE_WR(chan->ramfc->gpuobj, \
+					 NV40_RAMFC_##offset/4, (val))
+#define RAMFC_RD(offset)     INSTANCE_RD(chan->ramfc->gpuobj, \
+					 NV40_RAMFC_##offset/4)
+#define NV40_RAMFC(c) (dev_priv->ramfc_offset + ((c)*NV40_RAMFC__SIZE))
+#define NV40_RAMFC__SIZE 128
+
+int
+nv40_fifo_create_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int ret;
+
+	if ((ret = nouveau_gpuobj_new_fake(dev, NV40_RAMFC(chan->id), ~0,
+						NV40_RAMFC__SIZE,
+						NVOBJ_FLAG_ZERO_ALLOC |
+						NVOBJ_FLAG_ZERO_FREE,
+						NULL, &chan->ramfc)))
+		return ret;
+
+	/* Fill entries that are seen filled in dumps of nvidia driver just
+	 * after channel's is put into DMA mode
+	 */
+	RAMFC_WR(DMA_PUT       , chan->pushbuf_base);
+	RAMFC_WR(DMA_GET       , chan->pushbuf_base);
+	RAMFC_WR(DMA_INSTANCE  , chan->pushbuf->instance >> 4);
+	RAMFC_WR(DMA_FETCH     , NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
+				 NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
+				 NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8 |
+#ifdef __BIG_ENDIAN
+				 NV_PFIFO_CACHE1_BIG_ENDIAN |
+#endif
+				 0x30000000 /* no idea.. */);
+	RAMFC_WR(DMA_SUBROUTINE, 0);
+	RAMFC_WR(GRCTX_INSTANCE, chan->ramin_grctx->instance >> 4);
+	RAMFC_WR(DMA_TIMESLICE , 0x0001FFFF);
+
+	/* enable the fifo dma operation */
+	NV_WRITE(NV04_PFIFO_MODE,NV_READ(NV04_PFIFO_MODE)|(1<<chan->id));
+	return 0;
+}
+
+void
+nv40_fifo_destroy_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	NV_WRITE(NV04_PFIFO_MODE, NV_READ(NV04_PFIFO_MODE)&~(1<<chan->id));
+
+	if (chan->ramfc)
+		nouveau_gpuobj_ref_del(dev, &chan->ramfc);
+}
+
+int
+nv40_fifo_load_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t tmp, tmp2;
+
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_GET          , RAMFC_RD(DMA_GET));
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_PUT          , RAMFC_RD(DMA_PUT));
+	NV_WRITE(NV10_PFIFO_CACHE1_REF_CNT          , RAMFC_RD(REF_CNT));
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_INSTANCE     , RAMFC_RD(DMA_INSTANCE));
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_DCOUNT       , RAMFC_RD(DMA_DCOUNT));
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_STATE        , RAMFC_RD(DMA_STATE));
+
+	/* No idea what 0x2058 is.. */
+	tmp   = RAMFC_RD(DMA_FETCH);
+	tmp2  = NV_READ(0x2058) & 0xFFF;
+	tmp2 |= (tmp & 0x30000000);
+	NV_WRITE(0x2058, tmp2);
+	tmp  &= ~0x30000000;
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_FETCH        , tmp);
+
+	NV_WRITE(NV04_PFIFO_CACHE1_ENGINE           , RAMFC_RD(ENGINE));
+	NV_WRITE(NV04_PFIFO_CACHE1_PULL1            , RAMFC_RD(PULL1_ENGINE));
+	NV_WRITE(NV10_PFIFO_CACHE1_ACQUIRE_VALUE    , RAMFC_RD(ACQUIRE_VALUE));
+	NV_WRITE(NV10_PFIFO_CACHE1_ACQUIRE_TIMESTAMP, RAMFC_RD(ACQUIRE_TIMESTAMP));
+	NV_WRITE(NV10_PFIFO_CACHE1_ACQUIRE_TIMEOUT  , RAMFC_RD(ACQUIRE_TIMEOUT));
+	NV_WRITE(NV10_PFIFO_CACHE1_SEMAPHORE        , RAMFC_RD(SEMAPHORE));
+	NV_WRITE(NV10_PFIFO_CACHE1_DMA_SUBROUTINE   , RAMFC_RD(DMA_SUBROUTINE));
+	NV_WRITE(NV40_PFIFO_GRCTX_INSTANCE          , RAMFC_RD(GRCTX_INSTANCE));
+	NV_WRITE(0x32e4, RAMFC_RD(UNK_40));
+	/* NVIDIA does this next line twice... */
+	NV_WRITE(0x32e8, RAMFC_RD(UNK_44));
+	NV_WRITE(0x2088, RAMFC_RD(UNK_4C));
+	NV_WRITE(0x3300, RAMFC_RD(UNK_50));
+
+	/* not sure what part is PUT, and which is GET.. never seen a non-zero
+	 * value appear in a mmio-trace yet..
+	 */
+#if 0
+	tmp = NV_READ(UNK_84);
+	NV_WRITE(NV_PFIFO_CACHE1_GET, tmp ???);
+	NV_WRITE(NV_PFIFO_CACHE1_PUT, tmp ???);
+#endif
+
+	/* Don't clobber the TIMEOUT_ENABLED flag when restoring from RAMFC */
+	tmp  = NV_READ(NV04_PFIFO_DMA_TIMESLICE) & ~0x1FFFF;
+	tmp |= RAMFC_RD(DMA_TIMESLICE) & 0x1FFFF;
+	NV_WRITE(NV04_PFIFO_DMA_TIMESLICE, tmp);
+
+	/* Set channel active, and in DMA mode */
+	NV_WRITE(NV03_PFIFO_CACHE1_PUSH1  , 0x00010000 | chan->id);
+	/* Reset DMA_CTL_AT_INFO to INVALID */
+	tmp = NV_READ(NV04_PFIFO_CACHE1_DMA_CTL) & ~(1<<31);
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_CTL, tmp);
+
+	return 0;
+}
+
+int
+nv40_fifo_save_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t tmp;
+
+	RAMFC_WR(DMA_PUT          , NV_READ(NV04_PFIFO_CACHE1_DMA_PUT));
+	RAMFC_WR(DMA_GET          , NV_READ(NV04_PFIFO_CACHE1_DMA_GET));
+	RAMFC_WR(REF_CNT          , NV_READ(NV10_PFIFO_CACHE1_REF_CNT));
+	RAMFC_WR(DMA_INSTANCE     , NV_READ(NV04_PFIFO_CACHE1_DMA_INSTANCE));
+	RAMFC_WR(DMA_DCOUNT       , NV_READ(NV04_PFIFO_CACHE1_DMA_DCOUNT));
+	RAMFC_WR(DMA_STATE        , NV_READ(NV04_PFIFO_CACHE1_DMA_STATE));
+
+	tmp  = NV_READ(NV04_PFIFO_CACHE1_DMA_FETCH);
+	tmp |= NV_READ(0x2058) & 0x30000000;
+	RAMFC_WR(DMA_FETCH	  , tmp);
+
+	RAMFC_WR(ENGINE           , NV_READ(NV04_PFIFO_CACHE1_ENGINE));
+	RAMFC_WR(PULL1_ENGINE     , NV_READ(NV04_PFIFO_CACHE1_PULL1));
+	RAMFC_WR(ACQUIRE_VALUE    , NV_READ(NV10_PFIFO_CACHE1_ACQUIRE_VALUE));
+	tmp = NV_READ(NV10_PFIFO_CACHE1_ACQUIRE_TIMESTAMP);
+	RAMFC_WR(ACQUIRE_TIMESTAMP, tmp);
+	RAMFC_WR(ACQUIRE_TIMEOUT  , NV_READ(NV10_PFIFO_CACHE1_ACQUIRE_TIMEOUT));
+	RAMFC_WR(SEMAPHORE        , NV_READ(NV10_PFIFO_CACHE1_SEMAPHORE));
+
+	/* NVIDIA read 0x3228 first, then write DMA_GET here.. maybe something
+	 * more involved depending on the value of 0x3228?
+	 */
+	RAMFC_WR(DMA_SUBROUTINE   , NV_READ(NV04_PFIFO_CACHE1_DMA_GET));
+
+	RAMFC_WR(GRCTX_INSTANCE   , NV_READ(NV40_PFIFO_GRCTX_INSTANCE));
+
+	/* No idea what the below is for exactly, ripped from a mmio-trace */
+	RAMFC_WR(UNK_40           , NV_READ(NV40_PFIFO_UNK32E4));
+
+	/* NVIDIA do this next line twice.. bug? */
+	RAMFC_WR(UNK_44           , NV_READ(0x32e8));
+	RAMFC_WR(UNK_4C           , NV_READ(0x2088));
+	RAMFC_WR(UNK_50           , NV_READ(0x3300));
+
+#if 0 /* no real idea which is PUT/GET in UNK_48.. */
+	tmp  = NV_READ(NV04_PFIFO_CACHE1_GET);
+	tmp |= (NV_READ(NV04_PFIFO_CACHE1_PUT) << 16);
+	RAMFC_WR(UNK_48           , tmp);
+#endif
+
+	return 0;
+}
+
+int
+nv40_fifo_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int ret;
+
+	if ((ret = nouveau_fifo_init(dev)))
+		return ret;
+
+	NV_WRITE(NV04_PFIFO_DMA_TIMESLICE, 0x2101ffff);
+	return 0;
+}
+
Index: git/shared-core/nv40_graph.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv40_graph.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,2055 @@
+/*
+ * Copyright (C) 2007 Ben Skeggs.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+
+/* The sizes are taken from the difference between the start of two
+ * grctx addresses while running the nvidia driver.  Probably slightly
+ * larger than they actually are, because of other objects being created
+ * between the contexts
+ */
+#define NV40_GRCTX_SIZE (175*1024)
+#define NV41_GRCTX_SIZE (92*1024)
+#define NV43_GRCTX_SIZE (70*1024)
+#define NV46_GRCTX_SIZE (70*1024) /* probably ~64KiB */
+#define NV49_GRCTX_SIZE (164640)
+#define NV4A_GRCTX_SIZE (64*1024)
+#define NV4B_GRCTX_SIZE (164640)
+#define NV4C_GRCTX_SIZE (25*1024)
+#define NV4E_GRCTX_SIZE (25*1024)
+
+/*TODO: deciper what each offset in the context represents. The below
+ *      contexts are taken from dumps just after the 3D object is
+ *      created.
+ */
+static void
+nv40_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	/* Always has the "instance address" of itself at offset 0 */
+	INSTANCE_WR(ctx, 0x00000/4, ctx->im_pramin->start);
+	/* unknown */
+	INSTANCE_WR(ctx, 0x00024/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00028/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00030/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0011c/4, 0x20010001);
+	INSTANCE_WR(ctx, 0x00120/4, 0x0f73ef00);
+	INSTANCE_WR(ctx, 0x00128/4, 0x02008821);
+	INSTANCE_WR(ctx, 0x0016c/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00170/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00174/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x0017c/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00180/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00184/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00188/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x0018c/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x0019c/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x001a0/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x001b0/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x001c0/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x001d0/4, 0x0b0b0b0c);
+	INSTANCE_WR(ctx, 0x00340/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x00350/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00354/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00358/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x0035c/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00388/4, 0x00000008);
+	INSTANCE_WR(ctx, 0x0039c/4, 0x00000010);
+	INSTANCE_WR(ctx, 0x00480/4, 0x00000100);
+	INSTANCE_WR(ctx, 0x00494/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00498/4, 0x00080060);
+	INSTANCE_WR(ctx, 0x004b4/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x004b8/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x004bc/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x004d0/4, 0x46400000);
+	INSTANCE_WR(ctx, 0x004ec/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x004f8/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x004fc/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00504/4, 0x00011100);
+	for (i=0x00520; i<=0x0055c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x00568/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x00594/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x00598/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x0059c/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x005a0/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x005b4/4, 0x40100000);
+	INSTANCE_WR(ctx, 0x005cc/4, 0x00000004);
+	INSTANCE_WR(ctx, 0x005d8/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x0060c/4, 0x435185d6);
+	INSTANCE_WR(ctx, 0x00610/4, 0x2155b699);
+	INSTANCE_WR(ctx, 0x00614/4, 0xfedcba98);
+	INSTANCE_WR(ctx, 0x00618/4, 0x00000098);
+	INSTANCE_WR(ctx, 0x00628/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x0062c/4, 0x00ff7000);
+	INSTANCE_WR(ctx, 0x00630/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00640/4, 0x00ff0000);
+	INSTANCE_WR(ctx, 0x0067c/4, 0x00ffff00);
+	/* 0x680-0x6BC - NV30_TCL_PRIMITIVE_3D_TX_ADDRESS_UNIT(0-15) */
+	/* 0x6C0-0x6FC - NV30_TCL_PRIMITIVE_3D_TX_FORMAT_UNIT(0-15) */
+	for (i=0x006C0; i<=0x006fc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00018488);
+	/* 0x700-0x73C - NV30_TCL_PRIMITIVE_3D_TX_WRAP_UNIT(0-15) */
+	for (i=0x00700; i<=0x0073c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00028202);
+	/* 0x740-0x77C - NV30_TCL_PRIMITIVE_3D_TX_ENABLE_UNIT(0-15) */
+	/* 0x780-0x7BC - NV30_TCL_PRIMITIVE_3D_TX_SWIZZLE_UNIT(0-15) */
+	for (i=0x00780; i<=0x007bc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0000aae4);
+	/* 0x7C0-0x7FC - NV30_TCL_PRIMITIVE_3D_TX_FILTER_UNIT(0-15) */
+	for (i=0x007c0; i<=0x007fc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	/* 0x800-0x83C - NV30_TCL_PRIMITIVE_3D_TX_XY_DIM_UNIT(0-15) */
+	for (i=0x00800; i<=0x0083c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	/* 0x840-0x87C - NV30_TCL_PRIMITIVE_3D_TX_UNK07_UNIT(0-15) */
+	/* 0x880-0x8BC - NV30_TCL_PRIMITIVE_3D_TX_DEPTH_UNIT(0-15) */
+	for (i=0x00880; i<=0x008bc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00100008);
+	/* unknown */
+	for (i=0x00910; i<=0x0091c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0001bc80);
+	for (i=0x00920; i<=0x0092c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000202);
+	for (i=0x00940; i<=0x0094c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000008);
+	for (i=0x00960; i<=0x0096c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x00980/4, 0x00000002);
+	INSTANCE_WR(ctx, 0x009b4/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x009c0/4, 0x3e020200);
+	INSTANCE_WR(ctx, 0x009c4/4, 0x00ffffff);
+	INSTANCE_WR(ctx, 0x009c8/4, 0x60103f00);
+	INSTANCE_WR(ctx, 0x009d4/4, 0x00020000);
+	INSTANCE_WR(ctx, 0x00a08/4, 0x00008100);
+	INSTANCE_WR(ctx, 0x00aac/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00af0/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00af8/4, 0x80800001);
+	INSTANCE_WR(ctx, 0x00bcc/4, 0x00000005);
+	INSTANCE_WR(ctx, 0x00bf8/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00bfc/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c00/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c04/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c08/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c0c/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c44/4, 0x00000001);
+	for (i=0x03008; i<=0x03080; i+=8)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x05288; i<=0x08570; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x08628; i<=0x08e18; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x0bd28; i<=0x0f010; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x0f0c8; i<=0x0f8b8; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x127c8; i<=0x15ab0; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x15b68; i<=0x16358; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x19268; i<=0x1c550; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x1c608; i<=0x1cdf8; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x1fd08; i<=0x22ff0; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x230a8; i<=0x23898; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x267a8; i<=0x29a90; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x29b48; i<=0x2a338; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+}
+
+static void
+nv41_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	INSTANCE_WR(ctx, 0x00000/4, ctx->im_pramin->start);
+	INSTANCE_WR(ctx, 0x00000024/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00000028/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00000030/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0000011c/4, 0x20010001);
+	INSTANCE_WR(ctx, 0x00000120/4, 0x0f73ef00);
+	INSTANCE_WR(ctx, 0x00000128/4, 0x02008821);
+	for (i = 0x00000178; i <= 0x00000180; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00000188/4, 0x00000040);
+	for (i = 0x00000194; i <= 0x000001b0; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x000001d0/4, 0x0b0b0b0c);
+	INSTANCE_WR(ctx, 0x00000340/4, 0x00040000);
+	for (i = 0x00000350; i <= 0x0000035c; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00000388/4, 0x00000008);
+	INSTANCE_WR(ctx, 0x0000039c/4, 0x00001010);
+	INSTANCE_WR(ctx, 0x000003cc/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x000003d0/4, 0x00080060);
+	INSTANCE_WR(ctx, 0x000003ec/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x000003f0/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x000003f4/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00000408/4, 0x46400000);
+	INSTANCE_WR(ctx, 0x00000418/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x00000424/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00000428/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00000430/4, 0x00011100);
+	for (i = 0x0000044c; i <= 0x00000488; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x00000494/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x000004bc/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x000004c0/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x000004c4/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x000004c8/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x000004dc/4, 0x40100000);
+	INSTANCE_WR(ctx, 0x000004f8/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x0000052c/4, 0x435185d6);
+	INSTANCE_WR(ctx, 0x00000530/4, 0x2155b699);
+	INSTANCE_WR(ctx, 0x00000534/4, 0xfedcba98);
+	INSTANCE_WR(ctx, 0x00000538/4, 0x00000098);
+	INSTANCE_WR(ctx, 0x00000548/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x0000054c/4, 0x00ff7000);
+	INSTANCE_WR(ctx, 0x00000550/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00000560/4, 0x00ff0000);
+	INSTANCE_WR(ctx, 0x00000598/4, 0x00ffff00);
+	for (i = 0x000005dc; i <= 0x00000618; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00018488);
+	for (i = 0x0000061c; i <= 0x00000658; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00028202);
+	for (i = 0x0000069c; i <= 0x000006d8; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x0000aae4);
+	for (i = 0x000006dc; i <= 0x00000718; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	for (i = 0x0000071c; i <= 0x00000758; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	for (i = 0x0000079c; i <= 0x000007d8; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00100008);
+	for (i = 0x0000082c; i <= 0x00000838; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x0001bc80);
+	for (i = 0x0000083c; i <= 0x00000848; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00000202);
+	for (i = 0x0000085c; i <= 0x00000868; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00000008);
+	for (i = 0x0000087c; i <= 0x00000888; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x0000089c/4, 0x00000002);
+	INSTANCE_WR(ctx, 0x000008d0/4, 0x00000021);
+	INSTANCE_WR(ctx, 0x000008d4/4, 0x030c30c3);
+	INSTANCE_WR(ctx, 0x000008e0/4, 0x3e020200);
+	INSTANCE_WR(ctx, 0x000008e4/4, 0x00ffffff);
+	INSTANCE_WR(ctx, 0x000008e8/4, 0x20103f00);
+	INSTANCE_WR(ctx, 0x000008f4/4, 0x00020000);
+	INSTANCE_WR(ctx, 0x0000092c/4, 0x00008100);
+	INSTANCE_WR(ctx, 0x000009b8/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x000009fc/4, 0x00001001);
+	INSTANCE_WR(ctx, 0x00000a04/4, 0x00000003);
+	INSTANCE_WR(ctx, 0x00000a08/4, 0x00888001);
+	INSTANCE_WR(ctx, 0x00000aac/4, 0x00000005);
+	INSTANCE_WR(ctx, 0x00000ab8/4, 0x0000ffff);
+	for (i = 0x00000ad4; i <= 0x00000ae4; i += 4)
+		INSTANCE_WR(ctx, i/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00000ae8/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00000b20/4, 0x00000001);
+	for (i = 0x00002ee8; i <= 0x00002f60; i += 8)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i = 0x00005168; i <= 0x00007358; i += 24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i = 0x00007368; i <= 0x00007758; i += 16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i = 0x0000a068; i <= 0x0000c258; i += 24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i = 0x0000c268; i <= 0x0000c658; i += 16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i = 0x0000ef68; i <= 0x00011158; i += 24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i = 0x00011168; i <= 0x00011558; i += 16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i = 0x00013e68; i <= 0x00016058; i += 24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i = 0x00016068; i <= 0x00016458; i += 16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+};
+
+static void
+nv43_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+	
+	INSTANCE_WR(ctx, 0x00000/4, ctx->im_pramin->start);
+	INSTANCE_WR(ctx, 0x00024/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00028/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00030/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0011c/4, 0x20010001);
+	INSTANCE_WR(ctx, 0x00120/4, 0x0f73ef00);
+	INSTANCE_WR(ctx, 0x00128/4, 0x02008821);
+	INSTANCE_WR(ctx, 0x00178/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x0017c/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00180/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00188/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00194/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00198/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x0019c/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x001a0/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x001a4/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x001a8/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x001ac/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x001b0/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x001d0/4, 0x0b0b0b0c);
+	INSTANCE_WR(ctx, 0x00340/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x00350/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00354/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00358/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x0035c/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00388/4, 0x00000008);
+	INSTANCE_WR(ctx, 0x0039c/4, 0x00001010);
+	INSTANCE_WR(ctx, 0x003cc/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003d0/4, 0x00080060);
+	INSTANCE_WR(ctx, 0x003ec/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x003f0/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x003f4/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00408/4, 0x46400000);
+	INSTANCE_WR(ctx, 0x00418/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x00424/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00428/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00430/4, 0x00011100);
+	for (i=0x0044c; i<=0x00488; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x00494/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x004bc/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x004c0/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x004c4/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x004c8/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x004dc/4, 0x40100000);
+	INSTANCE_WR(ctx, 0x004f8/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x0052c/4, 0x435185d6);
+	INSTANCE_WR(ctx, 0x00530/4, 0x2155b699);
+	INSTANCE_WR(ctx, 0x00534/4, 0xfedcba98);
+	INSTANCE_WR(ctx, 0x00538/4, 0x00000098);
+	INSTANCE_WR(ctx, 0x00548/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x0054c/4, 0x00ff7000);
+	INSTANCE_WR(ctx, 0x00550/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00560/4, 0x00ff0000);
+	INSTANCE_WR(ctx, 0x00598/4, 0x00ffff00);
+	for (i=0x005dc; i<=0x00618; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00018488);
+	for (i=0x0061c; i<=0x00658; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00028202);
+	for (i=0x0069c; i<=0x006d8; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0000aae4);
+	for (i=0x006dc; i<=0x00718; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	for (i=0x0071c; i<=0x00758; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	for (i=0x0079c; i<=0x007d8; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00100008);
+	for (i=0x0082c; i<=0x00838; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0001bc80);
+	for (i=0x0083c; i<=0x00848; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000202);
+	for (i=0x0085c; i<=0x00868; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000008);
+	for (i=0x0087c; i<=0x00888; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x0089c/4, 0x00000002);
+	INSTANCE_WR(ctx, 0x008d0/4, 0x00000021);
+	INSTANCE_WR(ctx, 0x008d4/4, 0x030c30c3);
+	INSTANCE_WR(ctx, 0x008e0/4, 0x3e020200);
+	INSTANCE_WR(ctx, 0x008e4/4, 0x00ffffff);
+	INSTANCE_WR(ctx, 0x008e8/4, 0x0c103f00);
+	INSTANCE_WR(ctx, 0x008f4/4, 0x00020000);
+	INSTANCE_WR(ctx, 0x0092c/4, 0x00008100);
+	INSTANCE_WR(ctx, 0x009b8/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x009fc/4, 0x00001001);
+	INSTANCE_WR(ctx, 0x00a04/4, 0x00000003);
+	INSTANCE_WR(ctx, 0x00a08/4, 0x00888001);
+	INSTANCE_WR(ctx, 0x00a8c/4, 0x00000005);
+	INSTANCE_WR(ctx, 0x00a98/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00ab4/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00ab8/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00abc/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00ac0/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00af8/4, 0x00000001);
+	for (i=0x02ec0; i<=0x02f38; i+=8)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x04c80; i<=0x06e70; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x06e80; i<=0x07270; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x096c0; i<=0x0b8b0; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x0b8c0; i<=0x0bcb0; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x0e100; i<=0x102f0; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x10300; i<=0x106f0; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+};
+
+static void
+nv46_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	INSTANCE_WR(ctx, 0x00000/4, ctx->im_pramin->start);
+	INSTANCE_WR(ctx, 0x00040/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00044/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x0004c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00138/4, 0x20010001);
+	INSTANCE_WR(ctx, 0x0013c/4, 0x0f73ef00);
+	INSTANCE_WR(ctx, 0x00144/4, 0x02008821);
+	INSTANCE_WR(ctx, 0x00174/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00178/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0017c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00180/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00184/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00188/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0018c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00190/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00194/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00198/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x0019c/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x001a4/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x001ec/4, 0x0b0b0b0c);
+	INSTANCE_WR(ctx, 0x0035c/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x0036c/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00370/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00374/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00378/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x003a4/4, 0x00000008);
+	INSTANCE_WR(ctx, 0x003b8/4, 0x00003010);
+	INSTANCE_WR(ctx, 0x003dc/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003e0/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003e4/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003e8/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003ec/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003f0/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003f4/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003f8/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003fc/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00400/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00404/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00408/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x0040c/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00410/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00414/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00418/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x004b0/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x004b4/4, 0x00080060);
+	INSTANCE_WR(ctx, 0x004d0/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x004d4/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x004d8/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x004ec/4, 0x46400000);
+	INSTANCE_WR(ctx, 0x004fc/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x00500/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00504/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00508/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0050c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00510/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00514/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00518/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0051c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00520/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00524/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00528/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0052c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00530/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00534/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00538/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0053c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00550/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00554/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x0055c/4, 0x00011100);
+	for (i=0x00578; i<0x005b4; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005c0/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x005e8/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x005ec/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x005f0/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x005f4/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x00608/4, 0x40100000);
+	INSTANCE_WR(ctx, 0x00624/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00658/4, 0x435185d6);
+	INSTANCE_WR(ctx, 0x0065c/4, 0x2155b699);
+	INSTANCE_WR(ctx, 0x00660/4, 0xfedcba98);
+	INSTANCE_WR(ctx, 0x00664/4, 0x00000098);
+	INSTANCE_WR(ctx, 0x00674/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00678/4, 0x00ff7000);
+	INSTANCE_WR(ctx, 0x0067c/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x0068c/4, 0x00ff0000);
+	INSTANCE_WR(ctx, 0x006c8/4, 0x00ffff00);
+	for (i=0x0070c; i<=0x00748; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00018488);
+	for (i=0x0074c; i<=0x00788; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00028202);
+	for (i=0x007cc; i<=0x00808; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0000aae4);
+	for (i=0x0080c; i<=0x00848; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	for (i=0x0084c; i<=0x00888; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	for (i=0x008cc; i<=0x00908; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00100008);
+	for (i=0x0095c; i<=0x00968; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0001bc80);
+	for (i=0x0096c; i<=0x00978; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000202);
+	for (i=0x0098c; i<=0x00998; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000008);
+	for (i=0x009ac; i<=0x009b8; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x009cc/4, 0x00000002);
+	INSTANCE_WR(ctx, 0x00a00/4, 0x00000421);
+	INSTANCE_WR(ctx, 0x00a04/4, 0x030c30c3);
+	INSTANCE_WR(ctx, 0x00a08/4, 0x00011001);
+	INSTANCE_WR(ctx, 0x00a14/4, 0x3e020200);
+	INSTANCE_WR(ctx, 0x00a18/4, 0x00ffffff);
+	INSTANCE_WR(ctx, 0x00a1c/4, 0x0c103f00);
+	INSTANCE_WR(ctx, 0x00a28/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x00a60/4, 0x00008100);
+	INSTANCE_WR(ctx, 0x00aec/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00b30/4, 0x00001001);
+	INSTANCE_WR(ctx, 0x00b38/4, 0x00000003);
+	INSTANCE_WR(ctx, 0x00b3c/4, 0x00888001);
+	INSTANCE_WR(ctx, 0x00bc0/4, 0x00000005);
+	INSTANCE_WR(ctx, 0x00bcc/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00be8/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00bec/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00bf0/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00bf4/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00c2c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00c30/4, 0x08e00001);
+	INSTANCE_WR(ctx, 0x00c34/4, 0x000e3000);
+	for (i=0x017f8; i<=0x01870; i+=8)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x035b8; i<=0x057a8; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x057b8; i<=0x05ba8; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x07f38; i<=0x0a128; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x0a138; i<=0x0a528; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x0c8b8; i<=0x0eaa8; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x0eab8; i<=0x0eea8; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+}
+
+static void
+nv49_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	INSTANCE_WR(ctx, 0x00000/4, ctx->im_pramin->start);
+	INSTANCE_WR(ctx, 0x00004/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x00008/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x0000c/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x00010/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x00014/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x00018/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x0001c/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x00020/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x000c4/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x000c8/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x000d0/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x001bc/4, 0x20010001);
+	INSTANCE_WR(ctx, 0x001c0/4, 0x0f73ef00);
+	INSTANCE_WR(ctx, 0x001c8/4, 0x02008821);
+	INSTANCE_WR(ctx, 0x00218/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x0021c/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00220/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00228/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00234/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00238/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x0023c/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00240/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00244/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00248/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x0024c/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00250/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00270/4, 0x0b0b0b0c);
+	INSTANCE_WR(ctx, 0x003e0/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x003f0/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x003f4/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x003f8/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x003fc/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00428/4, 0x00000008);
+	INSTANCE_WR(ctx, 0x0043c/4, 0x00001010);
+	INSTANCE_WR(ctx, 0x00460/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00464/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00468/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x0046c/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00470/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00474/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00478/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x0047c/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00480/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00484/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00488/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x0048c/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00490/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00494/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00498/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x0049c/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x004f4/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x004f8/4, 0x00080060);
+	INSTANCE_WR(ctx, 0x00514/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x00518/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x0051c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00530/4, 0x46400000);
+	INSTANCE_WR(ctx, 0x00540/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x00544/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00548/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0054c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00550/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00554/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00558/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0055c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00560/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00564/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00568/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0056c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00570/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00574/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00578/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0057c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00580/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00594/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00598/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x005a0/4, 0x00011100);
+	INSTANCE_WR(ctx, 0x005bc/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005c0/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005c4/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005c8/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005cc/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005d0/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005d4/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005d8/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005dc/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005e0/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005e4/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005e8/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005ec/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005f0/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005f4/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005f8/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x00604/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x0062c/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x00630/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x00634/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x00638/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x0064c/4, 0x40100000);
+	INSTANCE_WR(ctx, 0x00668/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x0069c/4, 0x435185d6);
+	INSTANCE_WR(ctx, 0x006a0/4, 0x2155b699);
+	INSTANCE_WR(ctx, 0x006a4/4, 0xfedcba98);
+	INSTANCE_WR(ctx, 0x006a8/4, 0x00000098);
+	INSTANCE_WR(ctx, 0x006b8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x006bc/4, 0x00ff7000);
+	INSTANCE_WR(ctx, 0x006c0/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x006d0/4, 0x00ff0000);
+	INSTANCE_WR(ctx, 0x0070c/4, 0x00ffff00);
+	for (i=0x00750; i<=0x0078c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00018488);
+	for (i=0x00790; i<=0x007cc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00028202);
+	for (i=0x00810; i<=0x0084c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0000aae4);
+	for (i=0x00850; i<=0x0088c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	for (i=0x00890; i<=0x008cc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	for (i=0x00910; i<=0x0094c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00100008);
+	for (i=0x009a0; i<=0x009ac; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0001bc80);
+	for (i=0x009b0; i<=0x009bc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000202);
+	for (i=0x009d0; i<=0x009dc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000008);
+	for (i=0x009f0; i<=0x009fc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x00a10/4, 0x00000002);
+	INSTANCE_WR(ctx, 0x00a44/4, 0x00000421);
+	INSTANCE_WR(ctx, 0x00a48/4, 0x030c30c3);
+	INSTANCE_WR(ctx, 0x00a54/4, 0x3e020200);
+	INSTANCE_WR(ctx, 0x00a58/4, 0x00ffffff);
+	INSTANCE_WR(ctx, 0x00a5c/4, 0x20103f00);
+	INSTANCE_WR(ctx, 0x00a68/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x00aa0/4, 0x00008100);
+	INSTANCE_WR(ctx, 0x00b2c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00b70/4, 0x00001001);
+	INSTANCE_WR(ctx, 0x00b7c/4, 0x00000003);
+	INSTANCE_WR(ctx, 0x00b80/4, 0x00888001);
+	INSTANCE_WR(ctx, 0x00bb0/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bb4/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bb8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bbc/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bc0/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bc4/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bc8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bcc/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bd0/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bd4/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bd8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bdc/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00be0/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00be4/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00be8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bec/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bf0/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bf4/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bf8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bfc/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c00/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c04/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c08/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c0c/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c10/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c14/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c18/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c1c/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c20/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c24/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c28/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c2c/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c54/4, 0x00000005);
+	INSTANCE_WR(ctx, 0x00c60/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00c7c/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c80/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c84/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c88/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c8c/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c90/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c94/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c98/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c9c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00cd4/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00cd8/4, 0x08e00001);
+	INSTANCE_WR(ctx, 0x00cdc/4, 0x000e3000);
+	for(i=0x030a0; i<=0x03118; i+=8)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for(i=0x098a0; i<=0x0ba90; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x0baa0; i<=0x0be90; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for(i=0x0e2e0; i<=0x0fff0; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x10008; i<=0x104d0; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x104e0; i<=0x108d0; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for(i=0x12d20; i<=0x14f10; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x14f20; i<=0x15310; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for(i=0x17760; i<=0x19950; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x19960; i<=0x19d50; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for(i=0x1c1a0; i<=0x1e390; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x1e3a0; i<=0x1e790; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for(i=0x20be0; i<=0x22dd0; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x22de0; i<=0x231d0; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+}
+
+static void
+nv4a_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	INSTANCE_WR(ctx, 0x00000/4, ctx->im_pramin->start);
+	INSTANCE_WR(ctx, 0x00024/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00028/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00030/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0011c/4, 0x20010001);
+	INSTANCE_WR(ctx, 0x00120/4, 0x0f73ef00);
+	INSTANCE_WR(ctx, 0x00128/4, 0x02008821);
+	INSTANCE_WR(ctx, 0x00158/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0015c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00160/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00164/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00168/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0016c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00170/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00174/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00178/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x0017c/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00180/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00188/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x001d0/4, 0x0b0b0b0c);
+	INSTANCE_WR(ctx, 0x00340/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x00350/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00354/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00358/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x0035c/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00388/4, 0x00000008);
+	INSTANCE_WR(ctx, 0x0039c/4, 0x00003010);
+	INSTANCE_WR(ctx, 0x003cc/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003d0/4, 0x00080060);
+	INSTANCE_WR(ctx, 0x003ec/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x003f0/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x003f4/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00408/4, 0x46400000);
+	INSTANCE_WR(ctx, 0x00418/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x00424/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00428/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00430/4, 0x00011100);
+	for (i=0x0044c; i<=0x00488; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x00494/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x004bc/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x004c0/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x004c4/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x004c8/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x004dc/4, 0x40100000);
+	INSTANCE_WR(ctx, 0x004f8/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x0052c/4, 0x435185d6);
+	INSTANCE_WR(ctx, 0x00530/4, 0x2155b699);
+	INSTANCE_WR(ctx, 0x00534/4, 0xfedcba98);
+	INSTANCE_WR(ctx, 0x00538/4, 0x00000098);
+	INSTANCE_WR(ctx, 0x00548/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x0054c/4, 0x00ff7000);
+	INSTANCE_WR(ctx, 0x00550/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x0055c/4, 0x00ff0000);
+	INSTANCE_WR(ctx, 0x00594/4, 0x00ffff00);
+	for (i=0x005d8; i<=0x00614; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00018488);
+	for (i=0x00618; i<=0x00654; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00028202);
+	for (i=0x00698; i<=0x006d4; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0000aae4);
+	for (i=0x006d8; i<=0x00714; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	for (i=0x00718; i<=0x00754; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	for (i=0x00798; i<=0x007d4; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00100008);
+	for (i=0x00828; i<=0x00834; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0001bc80);
+	for (i=0x00838; i<=0x00844; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000202);
+	for (i=0x00858; i<=0x00864; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000008);
+	for (i=0x00878; i<=0x00884; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x00898/4, 0x00000002);
+	INSTANCE_WR(ctx, 0x008cc/4, 0x00000021);
+	INSTANCE_WR(ctx, 0x008d0/4, 0x030c30c3);
+	INSTANCE_WR(ctx, 0x008d4/4, 0x00011001);
+	INSTANCE_WR(ctx, 0x008e0/4, 0x3e020200);
+	INSTANCE_WR(ctx, 0x008e4/4, 0x00ffffff);
+	INSTANCE_WR(ctx, 0x008e8/4, 0x0c103f00);
+	INSTANCE_WR(ctx, 0x008f4/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x0092c/4, 0x00008100);
+	INSTANCE_WR(ctx, 0x009b8/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x009fc/4, 0x00001001);
+	INSTANCE_WR(ctx, 0x00a04/4, 0x00000003);
+	INSTANCE_WR(ctx, 0x00a08/4, 0x00888001);
+	INSTANCE_WR(ctx, 0x00a8c/4, 0x00000005);
+	INSTANCE_WR(ctx, 0x00a98/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00ab4/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00ab8/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00abc/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00ac0/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00af8/4, 0x00000001);
+	for (i=0x016c0; i<=0x01738; i+=8)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x03840; i<=0x05670; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x05680; i<=0x05a70; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x07e00; i<=0x09ff0; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x0a000; i<=0x0a3f0; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x0c780; i<=0x0e970; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x0e980; i<=0x0ed70; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+}
+
+static void
+nv4b_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	INSTANCE_WR(ctx, 0x00000/4, ctx->im_pramin->start);
+	INSTANCE_WR(ctx, 0x00004/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x00008/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x0000c/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x00010/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x00014/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x00018/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x0001c/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x00020/4, 0x0000c040);
+	INSTANCE_WR(ctx, 0x000c4/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x000c8/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x000d0/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x001bc/4, 0x20010001);
+	INSTANCE_WR(ctx, 0x001c0/4, 0x0f73ef00);
+	INSTANCE_WR(ctx, 0x001c8/4, 0x02008821);
+	INSTANCE_WR(ctx, 0x00218/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x0021c/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00220/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00228/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00234/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00238/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x0023c/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00240/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00244/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00248/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x0024c/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00250/4, 0x80000000);
+	INSTANCE_WR(ctx, 0x00270/4, 0x0b0b0b0c);
+	INSTANCE_WR(ctx, 0x003e0/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x003f0/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x003f4/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x003f8/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x003fc/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00428/4, 0x00000008);
+	INSTANCE_WR(ctx, 0x0043c/4, 0x00001010);
+	INSTANCE_WR(ctx, 0x00460/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00464/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00468/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x0046c/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00470/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00474/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00478/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x0047c/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00480/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00484/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00488/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x0048c/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00490/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00494/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x00498/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x0049c/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x004f4/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x004f8/4, 0x00080060);
+	INSTANCE_WR(ctx, 0x00514/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x00518/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x0051c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00530/4, 0x46400000);
+	INSTANCE_WR(ctx, 0x00540/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x00544/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00548/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0054c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00550/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00554/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00558/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0055c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00560/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00564/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00568/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0056c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00570/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00574/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00578/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x0057c/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00580/4, 0x88888888);
+	INSTANCE_WR(ctx, 0x00594/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00598/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x005a0/4, 0x00011100);
+	INSTANCE_WR(ctx, 0x005bc/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005c0/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005c4/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005c8/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005cc/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005d0/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005d4/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005d8/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005dc/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005e0/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005e4/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005e8/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005ec/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005f0/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005f4/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x005f8/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x00604/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x0062c/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x00630/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x00634/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x00638/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x0064c/4, 0x40100000);
+	INSTANCE_WR(ctx, 0x00668/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x0069c/4, 0x435185d6);
+	INSTANCE_WR(ctx, 0x006a0/4, 0x2155b699);
+	INSTANCE_WR(ctx, 0x006a4/4, 0xfedcba98);
+	INSTANCE_WR(ctx, 0x006a8/4, 0x00000098);
+	INSTANCE_WR(ctx, 0x006b8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x006bc/4, 0x00ff7000);
+	INSTANCE_WR(ctx, 0x006c0/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x006d0/4, 0x00ff0000);
+	INSTANCE_WR(ctx, 0x0070c/4, 0x00ffff00);
+	for (i=0x00750; i<=0x0078c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00018488);
+	for (i=0x00790; i<=0x007cc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00028202);
+	for (i=0x00810; i<=0x0084c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0000aae4);
+	for (i=0x00850; i<=0x0088c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	for (i=0x00890; i<=0x008cc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	for (i=0x00910; i<=0x0094c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00100008);
+	for (i=0x009a0; i<=0x009ac; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0001bc80);
+	for (i=0x009b0; i<=0x009bc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000202);
+	for (i=0x009d0; i<=0x009dc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000008);
+	for (i=0x009f0; i<=0x009fc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x00a10/4, 0x00000002);
+	INSTANCE_WR(ctx, 0x00a44/4, 0x00000421);
+	INSTANCE_WR(ctx, 0x00a48/4, 0x030c30c3);
+	INSTANCE_WR(ctx, 0x00a54/4, 0x3e020200);
+	INSTANCE_WR(ctx, 0x00a58/4, 0x00ffffff);
+	INSTANCE_WR(ctx, 0x00a5c/4, 0x20103f00);
+	INSTANCE_WR(ctx, 0x00a68/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x00aa0/4, 0x00008100);
+	INSTANCE_WR(ctx, 0x00b2c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00b70/4, 0x00001001);
+	INSTANCE_WR(ctx, 0x00b7c/4, 0x00000003);
+	INSTANCE_WR(ctx, 0x00b80/4, 0x00888001);
+	INSTANCE_WR(ctx, 0x00bb0/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bb4/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bb8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bbc/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bc0/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bc4/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bc8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bcc/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bd0/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bd4/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bd8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bdc/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00be0/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00be4/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00be8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bec/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bf0/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bf4/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bf8/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00bfc/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c00/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c04/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c08/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c0c/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c10/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c14/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c18/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c1c/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c20/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c24/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c28/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c2c/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00c54/4, 0x00000005);
+	INSTANCE_WR(ctx, 0x00c60/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00c7c/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c80/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c84/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c88/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c8c/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c90/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c94/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c98/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00c9c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00cd4/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00cd8/4, 0x08e00001);
+	INSTANCE_WR(ctx, 0x00cdc/4, 0x000e3000);
+	for(i=0x030a0; i<=0x03118; i+=8)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for(i=0x098a0; i<=0x0ba90; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x0baa0; i<=0x0be90; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for(i=0x0e2e0; i<=0x0fff0; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x10008; i<=0x104d0; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x104e0; i<=0x108d0; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for(i=0x12d20; i<=0x14f10; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x14f20; i<=0x15310; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for(i=0x17760; i<=0x19950; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for(i=0x19960; i<=0x19d50; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+}
+
+static void
+nv4c_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	INSTANCE_WR(ctx, 0x00000/4, ctx->im_pramin->start);
+	INSTANCE_WR(ctx, 0x00024/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00028/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00030/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0011c/4, 0x20010001);
+	INSTANCE_WR(ctx, 0x00120/4, 0x0f73ef00);
+	INSTANCE_WR(ctx, 0x00128/4, 0x02008821);
+	INSTANCE_WR(ctx, 0x00158/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0015c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00160/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00164/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00168/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0016c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00170/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00174/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00178/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x0017c/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00180/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00188/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x001d0/4, 0x0b0b0b0c);
+	INSTANCE_WR(ctx, 0x00340/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x00350/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00354/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00358/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x0035c/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00388/4, 0x00000008);
+	INSTANCE_WR(ctx, 0x0039c/4, 0x00001010);
+	INSTANCE_WR(ctx, 0x003d0/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003d4/4, 0x00080060);
+	INSTANCE_WR(ctx, 0x003f0/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x003f4/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x003f8/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0040c/4, 0x46400000);
+	INSTANCE_WR(ctx, 0x0041c/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x00428/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x0042c/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00434/4, 0x00011100);
+	for (i=0x00450; i<0x0048c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x00498/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x004c0/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x004c4/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x004c8/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x004cc/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x004e0/4, 0x40100000);
+	INSTANCE_WR(ctx, 0x004fc/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00530/4, 0x435185d6);
+	INSTANCE_WR(ctx, 0x00534/4, 0x2155b699);
+	INSTANCE_WR(ctx, 0x00538/4, 0xfedcba98);
+	INSTANCE_WR(ctx, 0x0053c/4, 0x00000098);
+	INSTANCE_WR(ctx, 0x0054c/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x00550/4, 0x00ff7000);
+	INSTANCE_WR(ctx, 0x00554/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00564/4, 0x00ff0000);
+	INSTANCE_WR(ctx, 0x0059c/4, 0x00ffff00);
+	for (i=0x005e0; i<=0x0061c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00018488);
+	for (i=0x00620; i<=0x0065c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00028202);
+	for (i=0x006a0; i<=0x006dc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0000aae4);
+	for (i=0x006e0; i<=0x0071c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	for (i=0x00720; i<=0x0075c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	for (i=0x007a0; i<=0x007dc; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00100008);
+	for (i=0x00830; i<=0x0083c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0001bc80);
+	for (i=0x00840; i<=0x0084c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000202);
+	for (i=0x00860; i<=0x0086c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000008);
+	for (i=0x00880; i<=0x0088c; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x008a0/4, 0x00000002);
+	INSTANCE_WR(ctx, 0x008d4/4, 0x00000020);
+	INSTANCE_WR(ctx, 0x008d8/4, 0x030c30c3);
+	INSTANCE_WR(ctx, 0x008dc/4, 0x00011001);
+	INSTANCE_WR(ctx, 0x008e8/4, 0x3e020200);
+	INSTANCE_WR(ctx, 0x008ec/4, 0x00ffffff);
+	INSTANCE_WR(ctx, 0x008f0/4, 0x0c103f00);
+	INSTANCE_WR(ctx, 0x008fc/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x00934/4, 0x00008100);
+	INSTANCE_WR(ctx, 0x009c0/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00a04/4, 0x00001001);
+	INSTANCE_WR(ctx, 0x00a0c/4, 0x00000003);
+	INSTANCE_WR(ctx, 0x00a10/4, 0x00888001);
+	INSTANCE_WR(ctx, 0x00a74/4, 0x00000005);
+	INSTANCE_WR(ctx, 0x00a80/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00a9c/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00aa0/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00ad8/4, 0x00000001);
+	for (i=0x016a0; i<0x01718; i+=8)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x03460; i<0x05650; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x05660; i<0x05a50; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+}
+
+static void
+nv4e_graph_context_init(struct drm_device *dev, struct nouveau_gpuobj *ctx)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i;
+
+	INSTANCE_WR(ctx, 0x00000/4, ctx->im_pramin->start);
+	INSTANCE_WR(ctx, 0x00024/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00028/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00030/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0011c/4, 0x20010001);
+	INSTANCE_WR(ctx, 0x00120/4, 0x0f73ef00);
+	INSTANCE_WR(ctx, 0x00128/4, 0x02008821);
+	INSTANCE_WR(ctx, 0x00158/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0015c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00160/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00164/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00168/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x0016c/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00170/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00174/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00178/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x0017c/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00180/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x00188/4, 0x00000040);
+	INSTANCE_WR(ctx, 0x001d0/4, 0x0b0b0b0c);
+	INSTANCE_WR(ctx, 0x00340/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x00350/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00354/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00358/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x0035c/4, 0x55555555);
+	INSTANCE_WR(ctx, 0x00388/4, 0x00000008);
+	INSTANCE_WR(ctx, 0x0039c/4, 0x00001010);
+	INSTANCE_WR(ctx, 0x003cc/4, 0x00000111);
+	INSTANCE_WR(ctx, 0x003d0/4, 0x00080060);
+	INSTANCE_WR(ctx, 0x003ec/4, 0x00000080);
+	INSTANCE_WR(ctx, 0x003f0/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x003f4/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00408/4, 0x46400000);
+	INSTANCE_WR(ctx, 0x00418/4, 0xffff0000);
+	INSTANCE_WR(ctx, 0x00424/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00428/4, 0x0fff0000);
+	INSTANCE_WR(ctx, 0x00430/4, 0x00011100);
+	for (i=0x0044c; i<=0x00488; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x07ff0000);
+	INSTANCE_WR(ctx, 0x00494/4, 0x4b7fffff);
+	INSTANCE_WR(ctx, 0x004bc/4, 0x30201000);
+	INSTANCE_WR(ctx, 0x004c0/4, 0x70605040);
+	INSTANCE_WR(ctx, 0x004c4/4, 0xb8a89888);
+	INSTANCE_WR(ctx, 0x004c8/4, 0xf8e8d8c8);
+	INSTANCE_WR(ctx, 0x004dc/4, 0x40100000);
+	INSTANCE_WR(ctx, 0x004f8/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x0052c/4, 0x435185d6);
+	INSTANCE_WR(ctx, 0x00530/4, 0x2155b699);
+	INSTANCE_WR(ctx, 0x00534/4, 0xfedcba98);
+	INSTANCE_WR(ctx, 0x00538/4, 0x00000098);
+	INSTANCE_WR(ctx, 0x00548/4, 0xffffffff);
+	INSTANCE_WR(ctx, 0x0054c/4, 0x00ff7000);
+	INSTANCE_WR(ctx, 0x00550/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x0055c/4, 0x00ff0000);
+	INSTANCE_WR(ctx, 0x00594/4, 0x00ffff00);
+	for (i=0x005d8; i<=0x00614; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00018488);
+	for (i=0x00618; i<=0x00654; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00028202);
+	for (i=0x00698; i<=0x006d4; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0000aae4);
+	for (i=0x006d8; i<=0x00714; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x01012000);
+	for (i=0x00718; i<=0x00754; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	for (i=0x00798; i<=0x007d4; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00100008);
+	for (i=0x00828; i<=0x00834; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x0001bc80);
+	for (i=0x00838; i<=0x00844; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000202);
+	for (i=0x00858; i<=0x00864; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00000008);
+	for (i=0x00878; i<=0x00884; i+=4)
+		INSTANCE_WR(ctx, i/4, 0x00080008);
+	INSTANCE_WR(ctx, 0x00898/4, 0x00000002);
+	INSTANCE_WR(ctx, 0x008cc/4, 0x00000020);
+	INSTANCE_WR(ctx, 0x008d0/4, 0x030c30c3);
+	INSTANCE_WR(ctx, 0x008d4/4, 0x00011001);
+	INSTANCE_WR(ctx, 0x008e0/4, 0x3e020200);
+	INSTANCE_WR(ctx, 0x008e4/4, 0x00ffffff);
+	INSTANCE_WR(ctx, 0x008e8/4, 0x0c103f00);
+	INSTANCE_WR(ctx, 0x008f4/4, 0x00040000);
+	INSTANCE_WR(ctx, 0x0092c/4, 0x00008100);
+	INSTANCE_WR(ctx, 0x009b8/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x009fc/4, 0x00001001);
+	INSTANCE_WR(ctx, 0x00a04/4, 0x00000003);
+	INSTANCE_WR(ctx, 0x00a08/4, 0x00888001);
+	INSTANCE_WR(ctx, 0x00a6c/4, 0x00000005);
+	INSTANCE_WR(ctx, 0x00a78/4, 0x0000ffff);
+	INSTANCE_WR(ctx, 0x00a94/4, 0x00005555);
+	INSTANCE_WR(ctx, 0x00a98/4, 0x00000001);
+	INSTANCE_WR(ctx, 0x00aa4/4, 0x00000001);
+	for (i=0x01668; i<=0x016e0; i+=8)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+	for (i=0x03428; i<=0x05618; i+=24)
+		INSTANCE_WR(ctx, i/4, 0x00000001);
+	for (i=0x05628; i<=0x05a18; i+=16)
+		INSTANCE_WR(ctx, i/4, 0x3f800000);
+}
+
+int
+nv40_graph_create_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	void (*ctx_init)(struct drm_device *, struct nouveau_gpuobj *);
+	unsigned int ctx_size;
+	int ret;
+
+	switch (dev_priv->chipset) {
+	case 0x40:
+		ctx_size = NV40_GRCTX_SIZE;
+		ctx_init = nv40_graph_context_init;
+		break;
+	case 0x41:
+	case 0x42:
+		ctx_size = NV41_GRCTX_SIZE;
+		ctx_init = nv41_graph_context_init;
+		break;
+	case 0x43:
+		ctx_size = NV43_GRCTX_SIZE;
+		ctx_init = nv43_graph_context_init;
+		break;
+	case 0x46:
+		ctx_size = NV46_GRCTX_SIZE;
+		ctx_init = nv46_graph_context_init;
+		break;
+	case 0x49:
+		ctx_size = NV49_GRCTX_SIZE;
+		ctx_init = nv49_graph_context_init;
+		break;
+	case 0x44:
+	case 0x4a:
+		ctx_size = NV4A_GRCTX_SIZE;
+		ctx_init = nv4a_graph_context_init;
+		break;
+	case 0x4b:
+		ctx_size = NV4B_GRCTX_SIZE;
+		ctx_init = nv4b_graph_context_init;
+		break;
+	case 0x4c:
+		ctx_size = NV4C_GRCTX_SIZE;
+		ctx_init = nv4c_graph_context_init;
+		break;
+	case 0x4e:
+		ctx_size = NV4E_GRCTX_SIZE;
+		ctx_init = nv4e_graph_context_init;
+		break;
+	default:
+		ctx_size = NV40_GRCTX_SIZE;
+		ctx_init = nv40_graph_context_init;
+		break;
+	}
+
+	if ((ret = nouveau_gpuobj_new_ref(dev, chan, NULL, 0, ctx_size, 16,
+					  NVOBJ_FLAG_ZERO_ALLOC,
+					  &chan->ramin_grctx)))
+		return ret;
+
+	/* Initialise default context values */
+	ctx_init(dev, chan->ramin_grctx->gpuobj);
+
+	return 0;
+}
+
+void
+nv40_graph_destroy_context(struct nouveau_channel *chan)
+{
+	nouveau_gpuobj_ref_del(chan->dev, &chan->ramin_grctx);
+}
+
+static int
+nv40_graph_transfer_context(struct drm_device *dev, uint32_t inst, int save)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t old_cp, tv = 1000, tmp;
+	int i;
+
+	old_cp = NV_READ(NV20_PGRAPH_CHANNEL_CTX_POINTER);
+	NV_WRITE(NV20_PGRAPH_CHANNEL_CTX_POINTER, inst);
+
+	tmp  = NV_READ(NV40_PGRAPH_CTXCTL_0310);
+	tmp |= save ? NV40_PGRAPH_CTXCTL_0310_XFER_SAVE :
+		      NV40_PGRAPH_CTXCTL_0310_XFER_LOAD;
+	NV_WRITE(NV40_PGRAPH_CTXCTL_0310, tmp);
+	
+	tmp  = NV_READ(NV40_PGRAPH_CTXCTL_0304);
+	tmp |= NV40_PGRAPH_CTXCTL_0304_XFER_CTX;
+	NV_WRITE(NV40_PGRAPH_CTXCTL_0304, tmp);
+
+	for (i = 0; i < tv; i++) {
+		if (NV_READ(NV40_PGRAPH_CTXCTL_030C) == 0)
+			break;
+	}
+
+	NV_WRITE(NV20_PGRAPH_CHANNEL_CTX_POINTER, old_cp);
+
+	if (i == tv) {
+		uint32_t ucstat = NV_READ(NV40_PGRAPH_CTXCTL_UCODE_STAT);
+		DRM_ERROR("Failed: Instance=0x%08x Save=%d\n", inst, save);
+		DRM_ERROR("IP: 0x%02x, Opcode: 0x%08x\n",
+			  ucstat >> NV40_PGRAPH_CTXCTL_UCODE_STAT_IP_SHIFT,
+			  ucstat  & NV40_PGRAPH_CTXCTL_UCODE_STAT_OP_MASK);
+		DRM_ERROR("0x40030C = 0x%08x\n",
+			  NV_READ(NV40_PGRAPH_CTXCTL_030C));
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/* Save current context (from PGRAPH) into the channel's context
+ *XXX: fails sometimes, not sure why..
+ */
+int
+nv40_graph_save_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	uint32_t inst;
+
+	if (!chan->ramin_grctx)
+		return -EINVAL;
+	inst = chan->ramin_grctx->instance >> 4;
+
+	return nv40_graph_transfer_context(dev, inst, 1);
+}
+
+/* Restore the context for a specific channel into PGRAPH
+ * XXX: fails sometimes.. not sure why
+ */
+int
+nv40_graph_load_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t inst;
+	int ret;
+
+	if (!chan->ramin_grctx)
+		return -EINVAL;
+	inst = chan->ramin_grctx->instance >> 4;
+
+	ret = nv40_graph_transfer_context(dev, inst, 0);
+	if (ret)
+		return ret;
+
+	/* 0x40032C, no idea of it's exact function.  Could simply be a
+	 * record of the currently active PGRAPH context.  It's currently
+	 * unknown as to what bit 24 does.  The nv ddx has it set, so we will
+	 * set it here too.
+	 */
+	NV_WRITE(NV20_PGRAPH_CHANNEL_CTX_POINTER, inst);
+	NV_WRITE(NV40_PGRAPH_CTXCTL_CUR,
+		 (inst & NV40_PGRAPH_CTXCTL_CUR_INST_MASK) |
+		  NV40_PGRAPH_CTXCTL_CUR_LOADED);
+	/* 0x32E0 records the instance address of the active FIFO's PGRAPH
+	 * context.  If at any time this doesn't match 0x40032C, you will
+	 * recieve PGRAPH_INTR_CONTEXT_SWITCH
+	 */
+	NV_WRITE(NV40_PFIFO_GRCTX_INSTANCE, inst);
+	return 0;
+}
+
+/* Some voodoo that makes context switching work without the binary driver
+ * initialising the card first.
+ *
+ * It is possible to effect how the context is saved from PGRAPH into a block
+ * of instance memory by altering the values in these tables.  This may mean
+ * that the context layout of each chipset is slightly different (at least
+ * NV40 and C51 are different).  It would also be possible for chipsets to
+ * have an identical context layout, but pull the data from different PGRAPH
+ * registers.
+ *
+ * TODO: decode the meaning of the magic values, may provide clues about the
+ *       differences between the various NV40 chipsets.
+ * TODO: one we have a better idea of how each chipset differs, perhaps think
+ *       about unifying these instead of providing a separate table for each
+ *       chip.
+ *
+ * mmio-trace dumps from other nv4x/g7x/c5x cards very welcome :)
+ */
+static uint32_t nv40_ctx_voodoo[] = {
+	0x00400889, 0x00200000, 0x0060000a, 0x00200000, 0x00300000, 0x00800001,
+	0x00700009, 0x0060000e, 0x00400d64, 0x00400d05, 0x00408f65, 0x00409406,
+	0x0040a268, 0x00200000, 0x0060000a, 0x00700000, 0x00106000, 0x00700080,
+	0x004014e6, 0x007000a0, 0x00401a84, 0x00700082, 0x00600001, 0x00500061,
+	0x00600002, 0x00401b68, 0x00500060, 0x00200001, 0x0060000a, 0x0011814d,
+	0x00110158, 0x00105401, 0x0020003a, 0x00100051, 0x001040c5, 0x0010c1c4,
+	0x001041c9, 0x0010c1dc, 0x00110205, 0x0011420a, 0x00114210, 0x00110216,
+	0x0012421b, 0x00120270, 0x001242c0, 0x00200040, 0x00100280, 0x00128100,
+	0x00128120, 0x00128143, 0x0011415f, 0x0010815c, 0x0010c140, 0x00104029,
+	0x00110400, 0x00104d10, 0x00500060, 0x00403b87, 0x0060000d, 0x004076e6,
+	0x002000f0, 0x0060000a, 0x00200045, 0x00100620, 0x00108668, 0x0011466b,
+	0x00120682, 0x0011068b, 0x00168691, 0x0010c6ae, 0x001206b4, 0x0020002a,
+	0x001006c4, 0x001246f0, 0x002000c0, 0x00100700, 0x0010c3d7, 0x001043e1,
+	0x00500060, 0x00405600, 0x00405684, 0x00600003, 0x00500067, 0x00600008,
+	0x00500060, 0x00700082, 0x0020026c, 0x0060000a, 0x00104800, 0x00104901,
+	0x00120920, 0x00200035, 0x00100940, 0x00148a00, 0x00104a14, 0x00200038,
+	0x00100b00, 0x00138d00, 0x00104e00, 0x0012d600, 0x00105c00, 0x00104f06,
+	0x0020031a, 0x0060000a, 0x00300000, 0x00200680, 0x00406c00, 0x00200684,
+	0x00800001, 0x00200b62, 0x0060000a, 0x0020a0b0, 0x0040728a, 0x00201b68,
+	0x00800041, 0x00407684, 0x00203e60, 0x00800002, 0x00408700, 0x00600006,
+	0x00700003, 0x004080e6, 0x00700080, 0x0020031a, 0x0060000a, 0x00200004,
+	0x00800001, 0x00700000, 0x00200000, 0x0060000a, 0x00106002, 0x0040a284,
+	0x00700002, 0x00600004, 0x0040a268, 0x00700000, 0x00200000, 0x0060000a,
+	0x00106002, 0x00700080, 0x00400a84, 0x00700002, 0x00400a68, 0x00500060,
+	0x00600007, 0x00409388, 0x0060000f, 0x00000000, 0x00500060, 0x00200000,
+	0x0060000a, 0x00700000, 0x00106001, 0x00700083, 0x00910880, 0x00901ffe,
+	0x00940400, 0x00200020, 0x0060000b, 0x00500069, 0x0060000c, 0x00401b68,
+	0x0040a406, 0x0040a505, 0x00600009, 0x00700005, 0x00700006, 0x0060000e,
+	~0
+};
+
+static uint32_t nv41_ctx_voodoo[] = {
+	0x00400889, 0x00200000, 0x0060000a, 0x00200000, 0x00300000, 0x00800001,
+	0x00700009, 0x0060000e, 0x00400d64, 0x00400d05, 0x00408f65, 0x00409306,
+	0x0040a068, 0x0040198f, 0x00200001, 0x0060000a, 0x00700080, 0x00104042,
+	0x00200001, 0x0060000a, 0x00700000, 0x001040c5, 0x00401826, 0x00401968,
+	0x0060000d, 0x00200000, 0x0060000a, 0x00700000, 0x00106000, 0x00700080,
+	0x004020e6, 0x007000a0, 0x00500060, 0x00200001, 0x0060000a, 0x0011814d,
+	0x00110158, 0x00105401, 0x0020003a, 0x00100051, 0x001040c5, 0x0010c1c4,
+	0x001041c9, 0x0010c1dc, 0x00150210, 0x0012c225, 0x00108238, 0x0010823e,
+	0x001242c0, 0x00200040, 0x00100280, 0x00128100, 0x00128120, 0x00128143,
+	0x0011415f, 0x0010815c, 0x0010c140, 0x00104029, 0x00110400, 0x00104d10,
+	0x001046ec, 0x00500060, 0x00404087, 0x0060000d, 0x004079e6, 0x002000f1,
+	0x0060000a, 0x00148653, 0x00104668, 0x0010c66d, 0x00120682, 0x0011068b,
+	0x00168691, 0x001046ae, 0x001046b0, 0x001206b4, 0x001046c4, 0x001146c6,
+	0x00200020, 0x001006cc, 0x001046ed, 0x001246f0, 0x002000c0, 0x00100700,
+	0x0010c3d7, 0x001043e1, 0x00500060, 0x00200233, 0x0060000a, 0x00104800,
+	0x00108901, 0x00124920, 0x0020001f, 0x00100940, 0x00140965, 0x00148a00,
+	0x00108a14, 0x00200020, 0x00100b00, 0x00134b2c, 0x0010cd00, 0x0010cd04,
+	0x00114d08, 0x00104d80, 0x00104e00, 0x0012d600, 0x00105c00, 0x00104f06,
+	0x002002d2, 0x0060000a, 0x00300000, 0x00200680, 0x00407200, 0x00200684,
+	0x00800001, 0x00200b1a, 0x0060000a, 0x00206380, 0x0040788a, 0x00201480,
+	0x00800041, 0x00408900, 0x00600006, 0x004085e6, 0x00700080, 0x0020007a,
+	0x0060000a, 0x00104280, 0x002002d2, 0x0060000a, 0x00200004, 0x00800001,
+	0x00700000, 0x00200000, 0x0060000a, 0x00106002, 0x0040a068, 0x00700000,
+	0x00200000, 0x0060000a, 0x00106002, 0x00700080, 0x00400a68, 0x00500060,
+	0x00600007, 0x00409388, 0x0060000f, 0x00500060, 0x00200000, 0x0060000a,
+	0x00700000, 0x00106001, 0x00910880, 0x00901ffe, 0x00940400, 0x00200020,
+	0x0060000b, 0x00500069, 0x0060000c, 0x00402168, 0x0040a206, 0x0040a305,
+	0x00600009, 0x00700005, 0x00700006, 0x0060000e, ~0
+};
+
+static uint32_t nv43_ctx_voodoo[] = {
+	0x00400889, 0x00200000, 0x0060000a, 0x00200000, 0x00300000, 0x00800001,
+	0x00700009, 0x0060000e, 0x00400d64, 0x00400d05, 0x00409565, 0x00409a06,
+	0x0040a868, 0x00200000, 0x0060000a, 0x00700000, 0x00106000, 0x00700080,
+	0x004014e6, 0x007000a0, 0x00401a84, 0x00700082, 0x00600001, 0x00500061,
+	0x00600002, 0x00401b68, 0x00500060, 0x00200001, 0x0060000a, 0x0011814d,
+	0x00110158, 0x00105401, 0x0020003a, 0x00100051, 0x001040c5, 0x0010c1c4,
+	0x001041c9, 0x0010c1dc, 0x00150210, 0x0012c225, 0x00108238, 0x0010823e,
+	0x001242c0, 0x00200040, 0x00100280, 0x00128100, 0x00128120, 0x00128143,
+	0x0011415f, 0x0010815c, 0x0010c140, 0x00104029, 0x00110400, 0x00104d10,
+	0x001046ec, 0x00500060, 0x00403a87, 0x0060000d, 0x00407ce6, 0x002000f1,
+	0x0060000a, 0x00148653, 0x00104668, 0x0010c66d, 0x00120682, 0x0011068b,
+	0x00168691, 0x001046ae, 0x001046b0, 0x001206b4, 0x001046c4, 0x001146c6,
+	0x00200020, 0x001006cc, 0x001046ed, 0x001246f0, 0x002000c0, 0x00100700,
+	0x0010c3d7, 0x001043e1, 0x00500060, 0x00405800, 0x00405884, 0x00600003,
+	0x00500067, 0x00600008, 0x00500060, 0x00700082, 0x00200233, 0x0060000a,
+	0x00104800, 0x00108901, 0x00124920, 0x0020001f, 0x00100940, 0x00140965,
+	0x00148a00, 0x00108a14, 0x00160b00, 0x00134b2c, 0x0010cd00, 0x0010cd04,
+	0x0010cd08, 0x00104d80, 0x00104e00, 0x0012d600, 0x00105c00, 0x00104f06,
+	0x002002c8, 0x0060000a, 0x00300000, 0x00200680, 0x00407200, 0x00200684,
+	0x00800001, 0x00200b10, 0x0060000a, 0x00203870, 0x0040788a, 0x00201350,
+	0x00800041, 0x00407c84, 0x00201560, 0x00800002, 0x00408d00, 0x00600006,
+	0x00700003, 0x004086e6, 0x00700080, 0x002002c8, 0x0060000a, 0x00200004,
+	0x00800001, 0x00700000, 0x00200000, 0x0060000a, 0x00106002, 0x0040a884,
+	0x00700002, 0x00600004, 0x0040a868, 0x00700000, 0x00200000, 0x0060000a,
+	0x00106002, 0x00700080, 0x00400a84, 0x00700002, 0x00400a68, 0x00500060,
+	0x00600007, 0x00409988, 0x0060000f, 0x00000000, 0x00500060, 0x00200000,
+	0x0060000a, 0x00700000, 0x00106001, 0x00700083, 0x00910880, 0x00901ffe,
+	0x00940400, 0x00200020, 0x0060000b, 0x00500069, 0x0060000c, 0x00401b68,
+	0x0040aa06, 0x0040ab05, 0x00600009, 0x00700005, 0x00700006, 0x0060000e,
+	~0
+};
+
+static uint32_t nv44_ctx_voodoo[] = {
+	0x00400889, 0x00200000, 0x0060000a, 0x00200000, 0x00300000, 0x00800001,
+	0x00700009, 0x0060000e, 0x00400d64, 0x00400d05, 0x00409a65, 0x00409f06,
+	0x0040ac68, 0x0040248f, 0x00200001, 0x0060000a, 0x00700080, 0x00104042,
+	0x001041c6, 0x00104040, 0x00200001, 0x0060000a, 0x00700000, 0x001040c5,
+	0x00402320, 0x00402321, 0x00402322, 0x00402324, 0x00402326, 0x0040232b,
+	0x001040c5, 0x00402328, 0x001040c5, 0x00402320, 0x00402468, 0x0060000d,
+	0x00200000, 0x0060000a, 0x00700000, 0x00106000, 0x00700080, 0x00402be6,
+	0x007000a0, 0x00500060, 0x00200001, 0x0060000a, 0x0011814d, 0x00110158,
+	0x00105401, 0x0020003a, 0x00100051, 0x001040c5, 0x0010c1c4, 0x001041c9,
+	0x0010c1dc, 0x00150210, 0x0012c225, 0x00108238, 0x0010823e, 0x001242c0,
+	0x00200040, 0x00100280, 0x00128100, 0x00128120, 0x00128143, 0x0011415f,
+	0x0010815c, 0x0010c140, 0x00104029, 0x00110400, 0x00104d10, 0x001046ec,
+	0x00500060, 0x00404b87, 0x0060000d, 0x004084e6, 0x002000f1, 0x0060000a,
+	0x00148653, 0x00104668, 0x0010c66d, 0x00120682, 0x0011068b, 0x00168691,
+	0x001046ae, 0x001046b0, 0x001206b4, 0x001046c4, 0x001146c6, 0x001646cc,
+	0x001186e6, 0x001046ed, 0x001246f0, 0x002000c0, 0x00100700, 0x0010c3d7,
+	0x001043e1, 0x00500060, 0x00200232, 0x0060000a, 0x00104800, 0x00108901,
+	0x00104910, 0x00124920, 0x0020001f, 0x00100940, 0x00140965, 0x00148a00,
+	0x00108a14, 0x00160b00, 0x00134b2c, 0x0010cd00, 0x0010cd04, 0x0010cd08,
+	0x00104d80, 0x00104e00, 0x0012d600, 0x00105c00, 0x00104f06, 0x002002c8,
+	0x0060000a, 0x00300000, 0x00200080, 0x00407d00, 0x00200084, 0x00800001,
+	0x00200510, 0x0060000a, 0x002037e0, 0x0040838a, 0x00201320, 0x00800029,
+	0x00409400, 0x00600006, 0x004090e6, 0x00700080, 0x0020007a, 0x0060000a,
+	0x00104280, 0x002002c8, 0x0060000a, 0x00200004, 0x00800001, 0x00700000,
+	0x00200000, 0x0060000a, 0x00106002, 0x0040ac68, 0x00700000, 0x00200000,
+	0x0060000a, 0x00106002, 0x00700080, 0x00400a68, 0x00500060, 0x00600007,
+	0x00409e88, 0x0060000f, 0x00000000, 0x00500060, 0x00200000, 0x0060000a,
+	0x00700000, 0x00106001, 0x00910880, 0x00901ffe, 0x01940000, 0x00200020,
+	0x0060000b, 0x00500069, 0x0060000c, 0x00402c68, 0x0040ae06, 0x0040af05,
+	0x00600009, 0x00700005, 0x00700006, 0x0060000e, ~0
+};
+
+static uint32_t nv46_ctx_voodoo[] = {
+	0x00400889, 0x00200000, 0x0060000a, 0x00200000, 0x00300000, 0x00800001,
+	0x00700009, 0x0060000e, 0x00400d64, 0x00400d05, 0x00408f65, 0x00409306,
+	0x0040a068, 0x0040198f, 0x00200001, 0x0060000a, 0x00700080, 0x00104042,
+	0x00200001, 0x0060000a, 0x00700000, 0x001040c5, 0x00401826, 0x00401968,
+	0x0060000d, 0x00200000, 0x0060000a, 0x00700000, 0x00106000, 0x00700080,
+	0x004020e6, 0x007000a0, 0x00500060, 0x00200008, 0x0060000a, 0x0011814d,
+	0x00110158, 0x00105401, 0x0020003a, 0x00100051, 0x001040c5, 0x0010c1c4,
+	0x001041c9, 0x0010c1dc, 0x00150210, 0x0012c225, 0x00108238, 0x0010823e,
+	0x001242c0, 0x00200040, 0x00100280, 0x00128100, 0x00128120, 0x00128143,
+	0x0011415f, 0x0010815c, 0x0010c140, 0x00104029, 0x00110400, 0x00104d10,
+	0x00500060, 0x00403f87, 0x0060000d, 0x004079e6, 0x002000f7, 0x0060000a,
+	0x00200045, 0x00100620, 0x00104668, 0x0017466d, 0x0011068b, 0x00168691,
+	0x001046ae, 0x001046b0, 0x001206b4, 0x001046c4, 0x001146c6, 0x00200022,
+	0x001006cc, 0x001246f0, 0x002000c0, 0x00100700, 0x0010c3d7, 0x001043e1,
+	0x00500060, 0x0020027f, 0x0060000a, 0x00104800, 0x00108901, 0x00104910,
+	0x00124920, 0x0020001f, 0x00100940, 0x00140965, 0x00148a00, 0x00108a14,
+	0x00160b00, 0x00134b2c, 0x0010cd00, 0x0010cd04, 0x0010cd08, 0x00104d80,
+	0x00104e00, 0x0012d600, 0x00105c00, 0x00104f06, 0x00105406, 0x00105709,
+	0x00200316, 0x0060000a, 0x00300000, 0x00200080, 0x00407200, 0x00200084,
+	0x00800001, 0x0020055e, 0x0060000a, 0x002037e0, 0x0040788a, 0x00201320,
+	0x00800029, 0x00408900, 0x00600006, 0x004085e6, 0x00700080, 0x00200081,
+	0x0060000a, 0x00104280, 0x00200316, 0x0060000a, 0x00200004, 0x00800001,
+	0x00700000, 0x00200000, 0x0060000a, 0x00106002, 0x0040a068, 0x00700000,
+	0x00200000, 0x0060000a, 0x00106002, 0x00700080, 0x00400a68, 0x00500060,
+	0x00600007, 0x00409388, 0x0060000f, 0x00500060, 0x00200000, 0x0060000a,
+	0x00700000, 0x00106001, 0x00910880, 0x00901ffe, 0x01940000, 0x00200020,
+	0x0060000b, 0x00500069, 0x0060000c, 0x00402168, 0x0040a206, 0x0040a305,
+	0x00600009, 0x00700005, 0x00700006, 0x0060000e, ~0
+};
+
+//this is used for nv49 and nv4b
+static uint32_t nv49_4b_ctx_voodoo[] ={
+	0x00400564, 0x00400505, 0x00408165, 0x00408206, 0x00409e68, 0x00200020,
+	0x0060000a, 0x00700080, 0x00104042, 0x00200020, 0x0060000a, 0x00700000,
+	0x001040c5, 0x00400f26, 0x00401068, 0x0060000d, 0x0070008f, 0x0070000e,
+	0x00408d68, 0x004015e6, 0x007000a0, 0x00700080, 0x0040180f, 0x00700000,
+	0x00200029, 0x0060000a, 0x0011814d, 0x00110158, 0x00105401, 0x0020003a,
+	0x00100051, 0x001040c5, 0x0010c1c4, 0x001041c9, 0x0010c1dc, 0x00150210,
+	0x0012c225, 0x00108238, 0x0010823e, 0x001242c0, 0x00200040, 0x00100280,
+	0x00128100, 0x00128120, 0x00128143, 0x0011415f, 0x0010815c, 0x0010c140,
+	0x00104029, 0x00110400, 0x00104d12, 0x00500060, 0x004071e6, 0x00200118,
+	0x0060000a, 0x00200020, 0x00100620, 0x00154650, 0x00104668, 0x0017466d,
+	0x0011068b, 0x00168691, 0x001046ae, 0x001046b0, 0x001206b4, 0x001046c4,
+	0x001146c6, 0x00200022, 0x001006cc, 0x001246f0, 0x002000c0, 0x00100700,
+	0x0010c3d7, 0x001043e1, 0x00500060, 0x00200290, 0x0060000a, 0x00104800,
+	0x00108901, 0x00124920, 0x0020001f, 0x00100940, 0x00140965, 0x00144a00,
+	0x00104a19, 0x0010ca1c, 0x00110b00, 0x00200028, 0x00100b08, 0x00134c2e,
+	0x0010cd00, 0x0010cd04, 0x00120d08, 0x00104d80, 0x00104e00, 0x0012d600,
+	0x00105c00, 0x00104f06, 0x00105406, 0x00105709, 0x00200340, 0x0060000a,
+	0x00300000, 0x00200680, 0x00406a0f, 0x00200684, 0x00800001, 0x00200b88,
+	0x0060000a, 0x00209540, 0x0040708a, 0x00201350, 0x00800041, 0x00407c0f,
+	0x00600006, 0x00407ce6, 0x00700080, 0x002000a2, 0x0060000a, 0x00104280,
+	0x00200340, 0x0060000a, 0x00200004, 0x00800001, 0x0070008e, 0x00408d68,
+	0x0040020f, 0x00600006, 0x00409e68, 0x00600007, 0x0070000f, 0x0070000e,
+	0x00408d68, 0x0091a880, 0x00901ffe, 0x10940000, 0x00200020, 0x0060000b,
+	0x00500069, 0x0060000c, 0x00401568, 0x00700000, 0x00200001, 0x0040910e,
+	0x00200021, 0x0060000a, 0x00409b0d, 0x00104a40, 0x00104a50, 0x00104a60,
+	0x00104a70, 0x00104a80, 0x00104a90, 0x00104aa0, 0x00104ab0, 0x00407e0e,
+	0x0040130f, 0x00408568, 0x0040a006, 0x0040a105, 0x00600009, 0x00700005,
+	0x00700006, 0x0060000e, ~0
+};
+
+
+static uint32_t nv4a_ctx_voodoo[] = {
+	0x00400889, 0x00200000, 0x0060000a, 0x00200000, 0x00300000, 0x00800001, 
+	0x00700009, 0x0060000e, 0x00400d64, 0x00400d05, 0x00409965, 0x00409e06, 
+	0x0040ac68, 0x00200000, 0x0060000a, 0x00700000, 0x00106000, 0x00700080, 
+	0x004014e6, 0x007000a0, 0x00401a84, 0x00700082, 0x00600001, 0x00500061, 
+	0x00600002, 0x00401b68, 0x00500060, 0x00200001, 0x0060000a, 0x0011814d, 
+	0x00110158, 0x00105401, 0x0020003a, 0x00100051, 0x001040c5, 0x0010c1c4, 
+	0x001041c9, 0x0010c1dc, 0x00150210, 0x0012c225, 0x00108238, 0x0010823e, 
+	0x001242c0, 0x00200040, 0x00100280, 0x00128100, 0x00128120, 0x00128143, 
+	0x0011415f, 0x0010815c, 0x0010c140, 0x00104029, 0x00110400, 0x00104d10, 
+	0x001046ec, 0x00500060, 0x00403a87, 0x0060000d, 0x00407de6, 0x002000f1, 
+	0x0060000a, 0x00148653, 0x00104668, 0x0010c66d, 0x00120682, 0x0011068b, 
+	0x00168691, 0x001046ae, 0x001046b0, 0x001206b4, 0x001046c4, 0x001146c6, 
+	0x001646cc, 0x001186e6, 0x001046ed, 0x001246f0, 0x002000c0, 0x00100700, 
+	0x0010c3d7, 0x001043e1, 0x00500060, 0x00405800, 0x00405884, 0x00600003, 
+	0x00500067, 0x00600008, 0x00500060, 0x00700082, 0x00200232, 0x0060000a, 
+	0x00104800, 0x00108901, 0x00104910, 0x00124920, 0x0020001f, 0x00100940, 
+	0x00140965, 0x00148a00, 0x00108a14, 0x00160b00, 0x00134b2c, 0x0010cd00, 
+	0x0010cd04, 0x0010cd08, 0x00104d80, 0x00104e00, 0x0012d600, 0x00105c00, 
+	0x00104f06, 0x002002c8, 0x0060000a, 0x00300000, 0x00200080, 0x00407300, 
+	0x00200084, 0x00800001, 0x00200510, 0x0060000a, 0x002037e0, 0x0040798a, 
+	0x00201320, 0x00800029, 0x00407d84, 0x00201560, 0x00800002, 0x00409100, 
+	0x00600006, 0x00700003, 0x00408ae6, 0x00700080, 0x0020007a, 0x0060000a, 
+	0x00104280, 0x002002c8, 0x0060000a, 0x00200004, 0x00800001, 0x00700000, 
+	0x00200000, 0x0060000a, 0x00106002, 0x0040ac84, 0x00700002, 0x00600004, 
+	0x0040ac68, 0x00700000, 0x00200000, 0x0060000a, 0x00106002, 0x00700080, 
+	0x00400a84, 0x00700002, 0x00400a68, 0x00500060, 0x00600007, 0x00409d88, 
+	0x0060000f, 0x00000000, 0x00500060, 0x00200000, 0x0060000a, 0x00700000, 
+	0x00106001, 0x00700083, 0x00910880, 0x00901ffe, 0x01940000, 0x00200020, 
+	0x0060000b, 0x00500069, 0x0060000c, 0x00401b68, 0x0040ae06, 0x0040af05, 
+	0x00600009, 0x00700005, 0x00700006, 0x0060000e, ~0
+};
+
+static uint32_t nv4c_ctx_voodoo[] = {
+	0x00400889, 0x00200000, 0x0060000a, 0x00200000, 0x00300000, 0x00800001,
+	0x00700009, 0x0060000e, 0x00400d64, 0x00400d05, 0x00409065, 0x00409406,
+	0x0040a168, 0x0040198f, 0x00200001, 0x0060000a, 0x00700080, 0x00104042,
+	0x00200001, 0x0060000a, 0x00700000, 0x001040c5, 0x00401826, 0x00401968,
+	0x0060000d, 0x00200000, 0x0060000a, 0x00700000, 0x00106000, 0x00700080,
+	0x004020e6, 0x007000a0, 0x00500060, 0x00200001, 0x0060000a, 0x0011814d,
+	0x00110158, 0x00105401, 0x0020003a, 0x00100051, 0x001040c5, 0x0010c1c4,
+	0x001041c9, 0x0010c1dc, 0x00150210, 0x0012c225, 0x00108238, 0x0010823e,
+	0x001242c0, 0x00200040, 0x00100280, 0x00128100, 0x00128120, 0x00128143,
+	0x0011415f, 0x0010815c, 0x0010c140, 0x00104029, 0x00110400, 0x00104d10,
+	0x0010427e, 0x001046ec, 0x00500060, 0x00404187, 0x0060000d, 0x00407ae6,
+	0x002000f2, 0x0060000a, 0x00148653, 0x00104668, 0x0010c66d, 0x00120682,
+	0x0011068b, 0x00168691, 0x001046ae, 0x001046b0, 0x001206b4, 0x001046c4,
+	0x001146c6, 0x00200020, 0x001006cc, 0x001046ed, 0x001246f0, 0x002000c0,
+	0x00100700, 0x0010c3d7, 0x001043e1, 0x00500060, 0x00200234, 0x0060000a,
+	0x00104800, 0x00108901, 0x00104910, 0x00124920, 0x0020001f, 0x00100940,
+	0x00140965, 0x00148a00, 0x00108a14, 0x00140b00, 0x00134b2c, 0x0010cd00,
+	0x0010cd04, 0x00104d08, 0x00104d80, 0x00104e00, 0x0012d600, 0x00105c00,
+	0x00104f06, 0x002002c0, 0x0060000a, 0x00300000, 0x00200080, 0x00407300,
+	0x00200084, 0x00800001, 0x00200508, 0x0060000a, 0x00201320, 0x0040798a,
+	0xfffffaf8, 0x00800029, 0x00408a00, 0x00600006, 0x004086e6, 0x00700080,
+	0x0020007a, 0x0060000a, 0x00104280, 0x002002c0, 0x0060000a, 0x00200004,
+	0x00800001, 0x00700000, 0x00200000, 0x0060000a, 0x00106002, 0x0040a168,
+	0x00700000, 0x00200000, 0x0060000a, 0x00106002, 0x00700080, 0x00400a68,
+	0x00500060, 0x00600007, 0x00409488, 0x0060000f, 0x00500060, 0x00200000,
+	0x0060000a, 0x00700000, 0x00106001, 0x00910880, 0x00901ffe, 0x01940000,
+	0x00200020, 0x0060000b, 0x00500069, 0x0060000c, 0x00402168, 0x0040a306,
+	0x0040a405, 0x00600009, 0x00700005, 0x00700006, 0x0060000e, ~0
+};
+
+static uint32_t nv4e_ctx_voodoo[] = {
+	0x00400889, 0x00200000, 0x0060000a, 0x00200000, 0x00300000, 0x00800001,
+	0x00700009, 0x0060000e, 0x00400d64, 0x00400d05, 0x00409565, 0x00409a06,
+	0x0040a868, 0x00200000, 0x0060000a, 0x00700000, 0x00106000, 0x00700080,
+	0x004014e6, 0x007000a0, 0x00401a84, 0x00700082, 0x00600001, 0x00500061,
+	0x00600002, 0x00401b68, 0x00500060, 0x00200001, 0x0060000a, 0x0011814d,
+	0x00110158, 0x00105401, 0x0020003a, 0x00100051, 0x001040c5, 0x0010c1c4,
+	0x001041c9, 0x0010c1dc, 0x00150210, 0x0012c225, 0x00108238, 0x0010823e,
+	0x001242c0, 0x00200040, 0x00100280, 0x00128100, 0x00128120, 0x00128143,
+	0x0011415f, 0x0010815c, 0x0010c140, 0x00104029, 0x00110400, 0x00104d10,
+	0x001046ec, 0x00500060, 0x00403a87, 0x0060000d, 0x00407ce6, 0x002000f1,
+	0x0060000a, 0x00148653, 0x00104668, 0x0010c66d, 0x00120682, 0x0011068b,
+	0x00168691, 0x001046ae, 0x001046b0, 0x001206b4, 0x001046c4, 0x001146c6,
+	0x001646cc, 0x001186e6, 0x001046ed, 0x001246f0, 0x002000c0, 0x00100700,
+	0x0010c3d7, 0x001043e1, 0x00500060, 0x00405800, 0x00405884, 0x00600003,
+	0x00500067, 0x00600008, 0x00500060, 0x00700082, 0x00200232, 0x0060000a,
+	0x00104800, 0x00108901, 0x00104910, 0x00124920, 0x0020001f, 0x00100940,
+	0x00140965, 0x00148a00, 0x00108a14, 0x00140b00, 0x00134b2c, 0x0010cd00,
+	0x0010cd04, 0x00104d08, 0x00104d80, 0x00104e00, 0x00105c00, 0x00104f06,
+	0x002002b2, 0x0060000a, 0x00300000, 0x00200080, 0x00407200, 0x00200084,
+	0x00800001, 0x002004fa, 0x0060000a, 0x00201320, 0x0040788a, 0xfffffb06,
+	0x00800029, 0x00407c84, 0x00200b20, 0x00800002, 0x00408d00, 0x00600006,
+	0x00700003, 0x004086e6, 0x00700080, 0x002002b2, 0x0060000a, 0x00200004,
+	0x00800001, 0x00700000, 0x00200000, 0x0060000a, 0x00106002, 0x0040a884,
+	0x00700002, 0x00600004, 0x0040a868, 0x00700000, 0x00200000, 0x0060000a,
+	0x00106002, 0x00700080, 0x00400a84, 0x00700002, 0x00400a68, 0x00500060,
+	0x00600007, 0x00409988, 0x0060000f, 0x00000000, 0x00500060, 0x00200000,
+	0x0060000a, 0x00700000, 0x00106001, 0x00700083, 0x00910880, 0x00901ffe,
+	0x01940000, 0x00200020, 0x0060000b, 0x00500069, 0x0060000c, 0x00401b68,
+	0x0040aa06, 0x0040ab05, 0x00600009, 0x00700005, 0x00700006, 0x0060000e,
+	~0
+};
+
+/*
+ * G70		0x47
+ * G71		0x49
+ * NV45		0x48
+ * G72[M]	0x46
+ * G73		0x4b
+ * C51_G7X	0x4c
+ * C51		0x4e
+ */
+int
+nv40_graph_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv =
+		(struct drm_nouveau_private *)dev->dev_private;
+	uint32_t *ctx_voodoo;
+	uint32_t vramsz, tmp;
+	int i, j;
+
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) &
+			~NV_PMC_ENABLE_PGRAPH);
+	NV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) |
+			 NV_PMC_ENABLE_PGRAPH);
+
+	switch (dev_priv->chipset) {
+	case 0x40: ctx_voodoo = nv40_ctx_voodoo; break;
+	case 0x41:
+	case 0x42: ctx_voodoo = nv41_ctx_voodoo; break;
+	case 0x43: ctx_voodoo = nv43_ctx_voodoo; break;
+	case 0x44: ctx_voodoo = nv44_ctx_voodoo; break;
+	case 0x46: ctx_voodoo = nv46_ctx_voodoo; break;
+	case 0x49: ctx_voodoo = nv49_4b_ctx_voodoo; break;
+	case 0x4a: ctx_voodoo = nv4a_ctx_voodoo; break;
+	case 0x4b: ctx_voodoo = nv49_4b_ctx_voodoo; break;
+	case 0x4c: ctx_voodoo = nv4c_ctx_voodoo; break;
+	case 0x4e: ctx_voodoo = nv4e_ctx_voodoo; break;
+	default:
+		DRM_ERROR("Unknown ctx_voodoo for chipset 0x%02x\n",
+				dev_priv->chipset);
+		ctx_voodoo = NULL;
+		break;
+	}
+
+	/* Load the context voodoo onto the card */
+	if (ctx_voodoo) {
+		DRM_DEBUG("Loading context-switch voodoo\n");
+		i = 0;
+
+		NV_WRITE(NV40_PGRAPH_CTXCTL_UCODE_INDEX, 0);
+		while (ctx_voodoo[i] != ~0) {
+			NV_WRITE(NV40_PGRAPH_CTXCTL_UCODE_DATA, ctx_voodoo[i]);
+			i++;
+		}
+	}	
+
+	/* No context present currently */
+	NV_WRITE(NV40_PGRAPH_CTXCTL_CUR, 0x00000000);
+
+	NV_WRITE(NV03_PGRAPH_INTR   , 0xFFFFFFFF);
+	NV_WRITE(NV40_PGRAPH_INTR_EN, 0xFFFFFFFF);
+
+	NV_WRITE(NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);
+	NV_WRITE(NV04_PGRAPH_DEBUG_0, 0x00000000);
+	NV_WRITE(NV04_PGRAPH_DEBUG_1, 0x401287c0);
+	NV_WRITE(NV04_PGRAPH_DEBUG_3, 0xe0de8055);
+	NV_WRITE(NV10_PGRAPH_DEBUG_4, 0x00008000);
+	NV_WRITE(NV04_PGRAPH_LIMIT_VIOL_PIX, 0x00be3c5f);
+
+	NV_WRITE(NV10_PGRAPH_CTX_CONTROL, 0x10010100);
+	NV_WRITE(NV10_PGRAPH_STATE      , 0xFFFFFFFF);
+	NV_WRITE(NV04_PGRAPH_FIFO       , 0x00000001);
+
+	j = NV_READ(0x1540) & 0xff;
+	if (j) {
+		for (i=0; !(j&1); j>>=1, i++);
+		NV_WRITE(0x405000, i);
+	}
+
+	if (dev_priv->chipset == 0x40) {
+		NV_WRITE(0x4009b0, 0x83280fff);
+		NV_WRITE(0x4009b4, 0x000000a0);
+	} else {
+		NV_WRITE(0x400820, 0x83280eff);
+		NV_WRITE(0x400824, 0x000000a0);
+	}
+
+	switch (dev_priv->chipset) {
+	case 0x40:
+	case 0x45:
+		NV_WRITE(0x4009b8, 0x0078e366);
+		NV_WRITE(0x4009bc, 0x0000014c);
+		break;
+	case 0x41:
+	case 0x42: /* pciid also 0x00Cx */
+//	case 0x0120: //XXX (pciid)
+		NV_WRITE(0x400828, 0x007596ff);
+		NV_WRITE(0x40082c, 0x00000108);
+		break;
+	case 0x43:
+		NV_WRITE(0x400828, 0x0072cb77);
+		NV_WRITE(0x40082c, 0x00000108);
+		break;
+	case 0x44:
+	case 0x46: /* G72 */
+	case 0x4a:
+	case 0x4c: /* G7x-based C51 */
+	case 0x4e:
+		NV_WRITE(0x400860, 0);
+		NV_WRITE(0x400864, 0);
+		break;
+	case 0x47: /* G70 */
+	case 0x49: /* G71 */
+	case 0x4b: /* G73 */
+		NV_WRITE(0x400828, 0x07830610);
+		NV_WRITE(0x40082c, 0x0000016A);
+		break;
+	default:
+		break;
+	}
+
+	NV_WRITE(0x400b38, 0x2ffff800);
+	NV_WRITE(0x400b3c, 0x00006000);
+
+	/* copy tile info from PFB */
+	switch (dev_priv->chipset) {
+	case 0x40: /* vanilla NV40 */
+		for (i=0; i<NV10_PFB_TILE__SIZE; i++) {
+			tmp = NV_READ(NV10_PFB_TILE(i));
+			NV_WRITE(NV40_PGRAPH_TILE0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TILE1(i), tmp);
+			tmp = NV_READ(NV10_PFB_TLIMIT(i));
+			NV_WRITE(NV40_PGRAPH_TLIMIT0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TLIMIT1(i), tmp);
+			tmp = NV_READ(NV10_PFB_TSIZE(i));
+			NV_WRITE(NV40_PGRAPH_TSIZE0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TSIZE1(i), tmp);
+			tmp = NV_READ(NV10_PFB_TSTATUS(i));
+			NV_WRITE(NV40_PGRAPH_TSTATUS0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TSTATUS1(i), tmp);
+		}
+		break;
+	case 0x44:
+	case 0x4a:
+	case 0x4e: /* NV44-based cores don't have 0x406900? */
+		for (i=0; i<NV40_PFB_TILE__SIZE_0; i++) {
+			tmp = NV_READ(NV40_PFB_TILE(i));
+			NV_WRITE(NV40_PGRAPH_TILE0(i), tmp);
+			tmp = NV_READ(NV40_PFB_TLIMIT(i));
+			NV_WRITE(NV40_PGRAPH_TLIMIT0(i), tmp);
+			tmp = NV_READ(NV40_PFB_TSIZE(i));
+			NV_WRITE(NV40_PGRAPH_TSIZE0(i), tmp);
+			tmp = NV_READ(NV40_PFB_TSTATUS(i));
+			NV_WRITE(NV40_PGRAPH_TSTATUS0(i), tmp);
+		}
+		break;
+	case 0x46:
+	case 0x47:
+	case 0x49:
+	case 0x4b: /* G7X-based cores */
+		for (i=0; i<NV40_PFB_TILE__SIZE_1; i++) {
+			tmp = NV_READ(NV40_PFB_TILE(i));
+			NV_WRITE(NV47_PGRAPH_TILE0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TILE1(i), tmp);
+			tmp = NV_READ(NV40_PFB_TLIMIT(i));
+			NV_WRITE(NV47_PGRAPH_TLIMIT0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TLIMIT1(i), tmp);
+			tmp = NV_READ(NV40_PFB_TSIZE(i));
+			NV_WRITE(NV47_PGRAPH_TSIZE0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TSIZE1(i), tmp);
+			tmp = NV_READ(NV40_PFB_TSTATUS(i));
+			NV_WRITE(NV47_PGRAPH_TSTATUS0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TSTATUS1(i), tmp);
+		}
+		break;
+	default: /* everything else */
+		for (i=0; i<NV40_PFB_TILE__SIZE_0; i++) {
+			tmp = NV_READ(NV40_PFB_TILE(i));
+			NV_WRITE(NV40_PGRAPH_TILE0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TILE1(i), tmp);
+			tmp = NV_READ(NV40_PFB_TLIMIT(i));
+			NV_WRITE(NV40_PGRAPH_TLIMIT0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TLIMIT1(i), tmp);
+			tmp = NV_READ(NV40_PFB_TSIZE(i));
+			NV_WRITE(NV40_PGRAPH_TSIZE0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TSIZE1(i), tmp);
+			tmp = NV_READ(NV40_PFB_TSTATUS(i));
+			NV_WRITE(NV40_PGRAPH_TSTATUS0(i), tmp);
+			NV_WRITE(NV40_PGRAPH_TSTATUS1(i), tmp);
+		}
+		break;
+	}
+
+	/* begin RAM config */
+	vramsz = drm_get_resource_len(dev, 0) - 1;
+	switch (dev_priv->chipset) {
+	case 0x40:
+		NV_WRITE(0x4009A4, NV_READ(NV04_PFB_CFG0));
+		NV_WRITE(0x4009A8, NV_READ(NV04_PFB_CFG1));
+		NV_WRITE(0x4069A4, NV_READ(NV04_PFB_CFG0));
+		NV_WRITE(0x4069A8, NV_READ(NV04_PFB_CFG1));
+		NV_WRITE(0x400820, 0);
+		NV_WRITE(0x400824, 0);
+		NV_WRITE(0x400864, vramsz);
+		NV_WRITE(0x400868, vramsz);
+		break;
+	default:
+		switch (dev_priv->chipset) {
+		case 0x46:
+		case 0x47:
+		case 0x49:
+		case 0x4b:
+			NV_WRITE(0x400DF0, NV_READ(NV04_PFB_CFG0));
+			NV_WRITE(0x400DF4, NV_READ(NV04_PFB_CFG1));
+			break;
+		default:
+			NV_WRITE(0x4009F0, NV_READ(NV04_PFB_CFG0));
+			NV_WRITE(0x4009F4, NV_READ(NV04_PFB_CFG1));
+			break;
+		}
+		NV_WRITE(0x4069F0, NV_READ(NV04_PFB_CFG0));
+		NV_WRITE(0x4069F4, NV_READ(NV04_PFB_CFG1));
+		NV_WRITE(0x400840, 0);
+		NV_WRITE(0x400844, 0);
+		NV_WRITE(0x4008A0, vramsz);
+		NV_WRITE(0x4008A4, vramsz);
+		break;
+	}
+
+	/* per-context state, doesn't belong here */
+	NV_WRITE(0x400B20, 0x00000000);
+	NV_WRITE(0x400B04, 0xFFFFFFFF);
+
+	tmp = NV_READ(NV10_PGRAPH_SURFACE) & 0x0007ff00;
+	NV_WRITE(NV10_PGRAPH_SURFACE, tmp);
+	tmp = NV_READ(NV10_PGRAPH_SURFACE) | 0x00020100;
+	NV_WRITE(NV10_PGRAPH_SURFACE, tmp);
+
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_XMIN, 0);
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_YMIN, 0);
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_XMAX, 0x7fff);
+	NV_WRITE(NV03_PGRAPH_ABS_UCLIP_YMAX, 0x7fff);
+
+	return 0;
+}
+
+void nv40_graph_takedown(struct drm_device *dev)
+{
+}
+
Index: git/shared-core/nv40_mc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv40_mc.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,39 @@
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+
+int
+nv40_mc_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t tmp;
+
+	/* Power up everything, resetting each individual unit will
+	 * be done later if needed.
+	 */
+	NV_WRITE(NV03_PMC_ENABLE, 0xFFFFFFFF);
+
+	switch (dev_priv->chipset) {
+	case 0x44:
+	case 0x46: /* G72 */
+	case 0x4e:
+	case 0x4c: /* C51_G7X */
+		tmp = NV_READ(NV40_PFB_020C);
+		NV_WRITE(NV40_PMC_1700, tmp);
+		NV_WRITE(NV40_PMC_1704, 0);
+		NV_WRITE(NV40_PMC_1708, 0);
+		NV_WRITE(NV40_PMC_170C, tmp);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+void
+nv40_mc_takedown(struct drm_device *dev)
+{
+}
+
Index: git/shared-core/nv50_fifo.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv50_fifo.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2007 Ben Skeggs.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+
+typedef struct {
+	struct nouveau_gpuobj_ref *thingo;
+} nv50_fifo_priv;
+
+#define IS_G80 ((dev_priv->chipset & 0xf0) == 0x50)
+
+static void
+nv50_fifo_init_thingo(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	nv50_fifo_priv *priv = dev_priv->Engine.fifo.priv;
+	struct nouveau_gpuobj_ref *thingo = priv->thingo;
+	int i, fi=2;
+
+	DRM_DEBUG("\n");
+
+	INSTANCE_WR(thingo->gpuobj, 0, 0x7e);
+	INSTANCE_WR(thingo->gpuobj, 1, 0x7e);
+	for (i = 1; i < 127; i++, fi) {
+		if (dev_priv->fifos[i]) {
+			INSTANCE_WR(thingo->gpuobj, fi, i);
+			fi++;
+		}
+	}
+
+	NV_WRITE(0x32f4, thingo->instance >> 12);
+	NV_WRITE(0x32ec, fi);
+	NV_WRITE(0x2500, 0x101);
+}
+
+static int
+nv50_fifo_channel_enable(struct drm_device *dev, int channel, int nt)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_channel *chan = dev_priv->fifos[channel];
+	uint32_t inst;
+
+	DRM_DEBUG("ch%d\n", channel);
+
+	if (!chan->ramfc)
+		return -EINVAL;
+
+	if (IS_G80) inst = chan->ramfc->instance >> 12;
+	else        inst = chan->ramfc->instance >> 8;
+	NV_WRITE(NV50_PFIFO_CTX_TABLE(channel),
+		 inst | NV50_PFIFO_CTX_TABLE_CHANNEL_ENABLED);
+
+	if (!nt) nv50_fifo_init_thingo(dev);
+	return 0;
+}
+
+static void
+nv50_fifo_channel_disable(struct drm_device *dev, int channel, int nt)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t inst;
+
+	DRM_DEBUG("ch%d, nt=%d\n", channel, nt);
+
+	if (IS_G80) inst = NV50_PFIFO_CTX_TABLE_INSTANCE_MASK_G80;
+	else        inst = NV50_PFIFO_CTX_TABLE_INSTANCE_MASK_G84;
+	NV_WRITE(NV50_PFIFO_CTX_TABLE(channel), inst);
+
+	if (!nt) nv50_fifo_init_thingo(dev);
+}
+
+static void
+nv50_fifo_init_reset(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t pmc_e;
+
+	DRM_DEBUG("\n");
+
+	pmc_e = NV_READ(NV03_PMC_ENABLE);
+	NV_WRITE(NV03_PMC_ENABLE, pmc_e & ~NV_PMC_ENABLE_PFIFO);
+	pmc_e = NV_READ(NV03_PMC_ENABLE);
+	NV_WRITE(NV03_PMC_ENABLE, pmc_e |  NV_PMC_ENABLE_PFIFO);
+}
+
+static void
+nv50_fifo_init_intr(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("\n");
+
+	NV_WRITE(NV03_PFIFO_INTR_0, 0xFFFFFFFF);
+	NV_WRITE(NV03_PFIFO_INTR_EN_0, 0xFFFFFFFF);
+}
+
+static void
+nv50_fifo_init_context_table(struct drm_device *dev)
+{
+	int i;
+
+	DRM_DEBUG("\n");
+
+	for (i = 0; i < NV50_PFIFO_CTX_TABLE__SIZE; i++)
+		nv50_fifo_channel_disable(dev, i, 1);
+	nv50_fifo_init_thingo(dev);
+}
+
+static void
+nv50_fifo_init_regs__nv(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("\n");
+
+	NV_WRITE(0x250c, 0x6f3cfc34);
+}
+
+static int
+nv50_fifo_init_regs(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("\n");
+
+	NV_WRITE(0x2500, 0);
+	NV_WRITE(0x3250, 0);
+	NV_WRITE(0x3220, 0);
+	NV_WRITE(0x3204, 0);
+	NV_WRITE(0x3210, 0);
+	NV_WRITE(0x3270, 0);
+
+	/* Enable dummy channels setup by nv50_instmem.c */
+	nv50_fifo_channel_enable(dev, 0, 1);
+	nv50_fifo_channel_enable(dev, 127, 1);
+
+	return 0;
+}
+
+int
+nv50_fifo_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	nv50_fifo_priv *priv;
+	int ret;
+
+	DRM_DEBUG("\n");
+
+	priv = drm_calloc(1, sizeof(*priv), DRM_MEM_DRIVER);
+	if (!priv)
+		return -ENOMEM;
+	dev_priv->Engine.fifo.priv = priv;
+
+	nv50_fifo_init_reset(dev);
+	nv50_fifo_init_intr(dev);
+
+	if ((ret = nouveau_gpuobj_new_ref(dev, NULL, NULL, 0, (128+2)*4, 0x1000,
+				   NVOBJ_FLAG_ZERO_ALLOC,
+				   &priv->thingo))) {
+		DRM_ERROR("error creating thingo: %d\n", ret);
+		return ret;
+	}
+
+	nv50_fifo_init_context_table(dev);
+
+	nv50_fifo_init_regs__nv(dev);
+	if ((ret = nv50_fifo_init_regs(dev)))
+		return ret;
+
+	return 0;
+}
+
+void
+nv50_fifo_takedown(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	nv50_fifo_priv *priv = dev_priv->Engine.fifo.priv;
+
+	DRM_DEBUG("\n");
+
+	if (!priv)
+		return;
+
+	nouveau_gpuobj_ref_del(dev, &priv->thingo);
+
+	dev_priv->Engine.fifo.priv = NULL;
+	drm_free(priv, sizeof(*priv), DRM_MEM_DRIVER);
+}
+
+int
+nv50_fifo_create_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_gpuobj *ramfc = NULL;
+	int ret;
+
+	DRM_DEBUG("ch%d\n", chan->id);
+
+	if (IS_G80) {
+		uint32_t ramfc_offset = chan->ramin->gpuobj->im_pramin->start;
+		uint32_t vram_offset = chan->ramin->gpuobj->im_backing->start;
+		if ((ret = nouveau_gpuobj_new_fake(dev, ramfc_offset,
+						   vram_offset, 0x100,
+						   NVOBJ_FLAG_ZERO_ALLOC |
+						   NVOBJ_FLAG_ZERO_FREE,
+						   &ramfc, &chan->ramfc)))
+				return ret;
+	} else {
+		if ((ret = nouveau_gpuobj_new_ref(dev, chan, NULL, 0, 0x100,
+						  256,
+						  NVOBJ_FLAG_ZERO_ALLOC |
+						  NVOBJ_FLAG_ZERO_FREE,
+						  &chan->ramfc)))
+			return ret;
+		ramfc = chan->ramfc->gpuobj;
+	}
+
+	INSTANCE_WR(ramfc, 0x48/4, chan->pushbuf->instance >> 4);
+	INSTANCE_WR(ramfc, 0x80/4, (0xc << 24) | (chan->ramht->instance >> 4));
+	INSTANCE_WR(ramfc, 0x3c/4, 0x000f0078); /* fetch? */
+	INSTANCE_WR(ramfc, 0x44/4, 0x2101ffff);
+	INSTANCE_WR(ramfc, 0x60/4, 0x7fffffff);
+	INSTANCE_WR(ramfc, 0x10/4, 0x00000000);
+	INSTANCE_WR(ramfc, 0x08/4, 0x00000000);
+	INSTANCE_WR(ramfc, 0x40/4, 0x00000000);
+	INSTANCE_WR(ramfc, 0x50/4, 0x2039b2e0);
+	INSTANCE_WR(ramfc, 0x54/4, 0x000f0000);
+	INSTANCE_WR(ramfc, 0x7c/4, 0x30000001);
+	INSTANCE_WR(ramfc, 0x78/4, 0x00000000);
+	INSTANCE_WR(ramfc, 0x4c/4, chan->pushbuf_mem->size - 1);
+
+	if (!IS_G80) {
+		INSTANCE_WR(chan->ramin->gpuobj, 0, chan->id);
+		INSTANCE_WR(chan->ramin->gpuobj, 1, chan->ramfc->instance);
+
+		INSTANCE_WR(ramfc, 0x88/4, 0x3d520); /* some vram addy >> 10 */
+		INSTANCE_WR(ramfc, 0x98/4, chan->ramin->instance >> 12);
+	}
+
+	if ((ret = nv50_fifo_channel_enable(dev, chan->id, 0))) {
+		DRM_ERROR("error enabling ch%d: %d\n", chan->id, ret);
+		nouveau_gpuobj_ref_del(dev, &chan->ramfc);
+		return ret;
+	}
+
+	return 0;
+}
+
+void
+nv50_fifo_destroy_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+
+	DRM_DEBUG("ch%d\n", chan->id);
+
+	nv50_fifo_channel_disable(dev, chan->id, 0);
+
+	/* Dummy channel, also used on ch 127 */
+	if (chan->id == 0)
+		nv50_fifo_channel_disable(dev, 127, 0);
+
+	nouveau_gpuobj_ref_del(dev, &chan->ramfc);
+}
+
+int
+nv50_fifo_load_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_gpuobj *ramfc = chan->ramfc->gpuobj;
+
+	DRM_DEBUG("ch%d\n", chan->id);
+
+	/*XXX: incomplete, only touches the regs that NV does */
+
+	NV_WRITE(0x3244, 0);
+	NV_WRITE(0x3240, 0);
+
+	NV_WRITE(0x3224, INSTANCE_RD(ramfc, 0x3c/4));
+	NV_WRITE(NV04_PFIFO_CACHE1_DMA_INSTANCE, INSTANCE_RD(ramfc, 0x48/4));
+	NV_WRITE(0x3234, INSTANCE_RD(ramfc, 0x4c/4));
+	NV_WRITE(0x3254, 1);
+	NV_WRITE(NV03_PFIFO_RAMHT, INSTANCE_RD(ramfc, 0x80/4));
+
+	if (!IS_G80) {
+		NV_WRITE(0x340c, INSTANCE_RD(ramfc, 0x88/4));
+		NV_WRITE(0x3410, INSTANCE_RD(ramfc, 0x98/4));
+	}
+
+	NV_WRITE(NV03_PFIFO_CACHE1_PUSH1, chan->id | (1<<16));
+	return 0;
+}
+
+int
+nv50_fifo_save_context(struct nouveau_channel *chan)
+{
+	DRM_DEBUG("ch%d\n", chan->id);
+	DRM_ERROR("stub!\n");
+	return 0;
+}
+
Index: git/shared-core/nv50_graph.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv50_graph.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,316 @@
+/*
+ * Copyright (C) 2007 Ben Skeggs.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+
+#define IS_G80 ((dev_priv->chipset & 0xf0) == 0x50)
+
+static void
+nv50_graph_init_reset(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t pmc_e;
+
+	DRM_DEBUG("\n");
+
+	pmc_e = NV_READ(NV03_PMC_ENABLE);
+	NV_WRITE(NV03_PMC_ENABLE, pmc_e & ~NV_PMC_ENABLE_PGRAPH);
+	pmc_e = NV_READ(NV03_PMC_ENABLE);
+	NV_WRITE(NV03_PMC_ENABLE, pmc_e |  NV_PMC_ENABLE_PGRAPH);
+}
+
+static void
+nv50_graph_init_intr(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("\n");
+	NV_WRITE(NV03_PGRAPH_INTR, 0xffffffff);
+	NV_WRITE(NV40_PGRAPH_INTR_EN, 0xffffffff);
+}
+
+static void
+nv50_graph_init_regs__nv(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("\n");
+
+	NV_WRITE(0x400804, 0xc0000000);
+	NV_WRITE(0x406800, 0xc0000000);
+	NV_WRITE(0x400c04, 0xc0000000);
+	NV_WRITE(0x401804, 0xc0000000);
+	NV_WRITE(0x405018, 0xc0000000);
+	NV_WRITE(0x402000, 0xc0000000);
+
+	NV_WRITE(0x400108, 0xffffffff);
+
+	NV_WRITE(0x400824, 0x00004000);
+	NV_WRITE(0x400500, 0x00010001);
+}
+
+static void
+nv50_graph_init_regs(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("\n");
+
+	NV_WRITE(NV04_PGRAPH_DEBUG_3, (1<<2) /* HW_CONTEXT_SWITCH_ENABLED */);
+}
+
+static uint32_t nv84_ctx_voodoo[] = {
+	0x0070008e, 0x0070009c, 0x00200020, 0x00600008, 0x0050004c, 0x00400e89,
+	0x00200000, 0x00600007, 0x00300000, 0x00c000ff, 0x00200000, 0x008000ff,
+	0x00700009, 0x0041634d, 0x00402944, 0x00402905, 0x0040290d, 0x00413e06,
+	0x00600005, 0x004015c5, 0x00600011, 0x0040270b, 0x004021c5, 0x00700000,
+	0x00700081, 0x00600004, 0x0050004a, 0x00216f40, 0x00600007, 0x00c02801,
+	0x0020002e, 0x00800001, 0x005000cb, 0x0090ffff, 0x0091ffff, 0x00200020,
+	0x00600008, 0x0050004c, 0x00600009, 0x00413e45, 0x0041594d, 0x0070009d,
+	0x00402dcf, 0x0070009f, 0x0050009f, 0x00402ac0, 0x00200200, 0x00600008,
+	0x00402a4f, 0x00402ac0, 0x004030cc, 0x00700081, 0x00200000, 0x00600006,
+	0x00700000, 0x00111bfc, 0x00700083, 0x00300000, 0x00216f40, 0x00600007,
+	0x00c00b01, 0x0020001e, 0x00800001, 0x005000cb, 0x00c000ff, 0x00700080,
+	0x00700083, 0x00200047, 0x00600006, 0x0011020a, 0x00200480, 0x00600007,
+	0x00300000, 0x00c000ff, 0x00c800ff, 0x00414907, 0x00202916, 0x008000ff,
+	0x0040508c, 0x005000cb, 0x00a0023f, 0x00200040, 0x00600006, 0x0070000f,
+	0x00170202, 0x0011020a, 0x00200032, 0x0010020d, 0x001c0242, 0x00120302,
+	0x00140402, 0x00180500, 0x00130509, 0x00150550, 0x00110605, 0x0020000f,
+	0x00100607, 0x00110700, 0x00110900, 0x00120902, 0x00110a00, 0x00160b02,
+	0x00120b28, 0x00140b2b, 0x00110c01, 0x00111400, 0x00111405, 0x00111407,
+	0x00111409, 0x0011140b, 0x002000cb, 0x00101500, 0x0040790f, 0x0040794b,
+	0x00214d40, 0x00600007, 0x0020043e, 0x008800ff, 0x0070008f, 0x0040798c,
+	0x005000cb, 0x00000000, 0x0020002b, 0x00101a05, 0x00131c00, 0x00121c04,
+	0x00141c20, 0x00111c25, 0x00131c40, 0x00121c44, 0x00141c60, 0x00111c65,
+	0x00131c80, 0x00121c84, 0x00141ca0, 0x00111ca5, 0x00131cc0, 0x00121cc4,
+	0x00141ce0, 0x00111ce5, 0x00131f00, 0x00191f40, 0x0040a1e0, 0x002001ed,
+	0x00600006, 0x00200044, 0x00102080, 0x001120c6, 0x001520c9, 0x001920d0,
+	0x00122100, 0x00122103, 0x00162200, 0x00122207, 0x00112280, 0x00112300,
+	0x00112302, 0x00122380, 0x0011238b, 0x00112394, 0x0011239c, 0x0040bee1,
+	0x00200254, 0x00600006, 0x00200044, 0x00102480, 0x0040af0f, 0x0040af4b,
+	0x00214d40, 0x00600007, 0x0020043e, 0x008800ff, 0x0070008f, 0x0040af8c,
+	0x005000cb, 0x00000000, 0x001124c6, 0x001524c9, 0x001924d0, 0x00122500,
+	0x00122503, 0x00162600, 0x00122607, 0x00112680, 0x00112700, 0x00112702,
+	0x00122780, 0x0011278b, 0x00112794, 0x0011279c, 0x0040d1e2, 0x002002bb,
+	0x00600006, 0x00200044, 0x00102880, 0x001128c6, 0x001528c9, 0x001928d0,
+	0x00122900, 0x00122903, 0x00162a00, 0x00122a07, 0x00112a80, 0x00112b00,
+	0x00112b02, 0x00122b80, 0x00112b8b, 0x00112b94, 0x00112b9c, 0x0040eee3,
+	0x00200322, 0x00600006, 0x00200044, 0x00102c80, 0x0040df0f, 0x0040df4b,
+	0x00214d40, 0x00600007, 0x0020043e, 0x008800ff, 0x0070008f, 0x0040df8c,
+	0x005000cb, 0x00000000, 0x00112cc6, 0x00152cc9, 0x00192cd0, 0x00122d00,
+	0x00122d03, 0x00162e00, 0x00122e07, 0x00112e80, 0x00112f00, 0x00112f02,
+	0x00122f80, 0x00112f8b, 0x00112f94, 0x00112f9c, 0x004101e4, 0x00200389,
+	0x00600006, 0x00200044, 0x00103080, 0x001130c6, 0x001530c9, 0x001930d0,
+	0x00123100, 0x00123103, 0x00163200, 0x00123207, 0x00113280, 0x00113300,
+	0x00113302, 0x00123380, 0x0011338b, 0x00113394, 0x0011339c, 0x00411ee5,
+	0x002003f0, 0x00600006, 0x00200044, 0x00103480, 0x00410f0f, 0x00410f4b,
+	0x00214d40, 0x00600007, 0x0020043e, 0x008800ff, 0x0070008f, 0x00410f8c,
+	0x005000cb, 0x00000000, 0x001134c6, 0x001534c9, 0x001934d0, 0x00123500,
+	0x00123503, 0x00163600, 0x00123607, 0x00113680, 0x00113700, 0x00113702,
+	0x00123780, 0x0011378b, 0x00113794, 0x0011379c, 0x00000000, 0x0041250f,
+	0x005000cb, 0x00214d40, 0x00600007, 0x0020043e, 0x008800ff, 0x005000cb,
+	0x00412887, 0x0060000a, 0x00000000, 0x00413700, 0x007000a0, 0x00700080,
+	0x00200480, 0x00600007, 0x00200004, 0x00c000ff, 0x008000ff, 0x005000cb,
+	0x00700000, 0x00200000, 0x00600006, 0x00111bfe, 0x0041594d, 0x00700000,
+	0x00200000, 0x00600006, 0x00111bfe, 0x00700080, 0x0070001d, 0x0040114d,
+	0x00700081, 0x00600004, 0x0050004a, 0x00414388, 0x0060000b, 0x00200000,
+	0x00600006, 0x00700000, 0x0041590b, 0x00111bfd, 0x0040424d, 0x00202916,
+	0x008000fd, 0x005000cb, 0x00c00002, 0x00200480, 0x00600007, 0x00200160,
+	0x00800002, 0x005000cb, 0x00c01802, 0x002027b6, 0x00800002, 0x005000cb,
+	0x00404e4d, 0x0060000b, 0x0041574d, 0x00700001, 0x005000cf, 0x00700003,
+	0x00415e06, 0x00415f05, 0x0060000d, 0x00700005, 0x0070000d, 0x00700006,
+	0x0070000b, 0x0070000e, 0x0070001c, 0x0060000c, ~0
+};
+
+static void
+nv50_graph_init_ctxctl(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t *voodoo;
+
+	DRM_DEBUG("\n");
+
+	switch (dev_priv->chipset) {
+	case 0x84:
+		voodoo = nv84_ctx_voodoo;
+		break;
+	default:
+		DRM_ERROR("no voodoo for chipset NV%02x\n", dev_priv->chipset);
+		break;
+	}
+
+	if (voodoo) {
+		NV_WRITE(NV40_PGRAPH_CTXCTL_UCODE_INDEX, 0);
+		while (*voodoo != ~0) {
+			NV_WRITE(NV40_PGRAPH_CTXCTL_UCODE_DATA, *voodoo);
+			voodoo++;
+		}
+	}
+
+	NV_WRITE(0x400320, 4);
+	NV_WRITE(NV40_PGRAPH_CTXCTL_CUR, 0);
+	NV_WRITE(NV20_PGRAPH_CHANNEL_CTX_POINTER, 0);
+}
+
+int 
+nv50_graph_init(struct drm_device *dev)
+{
+	DRM_DEBUG("\n");
+
+	nv50_graph_init_reset(dev);
+	nv50_graph_init_intr(dev);
+	nv50_graph_init_regs__nv(dev);
+	nv50_graph_init_regs(dev);
+	nv50_graph_init_ctxctl(dev);
+
+	return 0;
+}
+
+void
+nv50_graph_takedown(struct drm_device *dev)
+{
+	DRM_DEBUG("\n");
+}
+
+int
+nv50_graph_create_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_engine *engine = &dev_priv->Engine;
+	struct nouveau_gpuobj *ramin = chan->ramin->gpuobj;
+	int grctx_size = 0x60000, hdr;
+	int ret;
+
+	DRM_DEBUG("ch%d\n", chan->id);
+
+	if ((ret = nouveau_gpuobj_new_ref(dev, chan, NULL, 0,
+					  grctx_size, 0x1000,
+					  NVOBJ_FLAG_ZERO_ALLOC |
+					  NVOBJ_FLAG_ZERO_FREE,
+					  &chan->ramin_grctx)))
+		return ret;
+
+	hdr = IS_G80 ? 0x200 : 0x20;
+	INSTANCE_WR(ramin, (hdr + 0x00)/4, 0x00190002);
+	INSTANCE_WR(ramin, (hdr + 0x04)/4, chan->ramin_grctx->instance +
+					   grctx_size - 1);
+	INSTANCE_WR(ramin, (hdr + 0x08)/4, chan->ramin_grctx->instance);
+	INSTANCE_WR(ramin, (hdr + 0x0c)/4, 0);
+	INSTANCE_WR(ramin, (hdr + 0x10)/4, 0);
+	INSTANCE_WR(ramin, (hdr + 0x14)/4, 0x00010000);
+
+	if ((ret = engine->graph.load_context(chan))) {
+		DRM_ERROR("Error hacking up initial context: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+void
+nv50_graph_destroy_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	int i, hdr;
+
+	DRM_DEBUG("ch%d\n", chan->id);
+
+	hdr = IS_G80 ? 0x200 : 0x20;
+	for (i=hdr; i<hdr+24; i+=4)
+		INSTANCE_WR(chan->ramin->gpuobj, i/4, 0);
+
+	nouveau_gpuobj_ref_del(dev, &chan->ramin_grctx);
+}
+
+static int
+nv50_graph_transfer_context(struct drm_device *dev, uint32_t inst, int save)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t old_cp, tv = 20000;
+	int i;
+
+	DRM_DEBUG("inst=0x%08x, save=%d\n", inst, save);
+
+	old_cp = NV_READ(NV20_PGRAPH_CHANNEL_CTX_POINTER);
+	NV_WRITE(NV20_PGRAPH_CHANNEL_CTX_POINTER, inst | (1<<31));
+	NV_WRITE(0x400824, NV_READ(0x400824) |
+		 (save ? NV40_PGRAPH_CTXCTL_0310_XFER_SAVE :
+		  	 NV40_PGRAPH_CTXCTL_0310_XFER_LOAD));
+	NV_WRITE(NV40_PGRAPH_CTXCTL_0304, NV40_PGRAPH_CTXCTL_0304_XFER_CTX);
+
+	for (i = 0; i < tv; i++) {
+		if (NV_READ(NV40_PGRAPH_CTXCTL_030C) == 0)
+			break;
+	}
+	NV_WRITE(NV20_PGRAPH_CHANNEL_CTX_POINTER, old_cp);
+
+	if (i == tv) {
+		DRM_ERROR("failed: inst=0x%08x save=%d\n", inst, save);
+		DRM_ERROR("0x40030C = 0x%08x\n",
+			  NV_READ(NV40_PGRAPH_CTXCTL_030C));
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+int
+nv50_graph_load_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	uint32_t inst = ((chan->ramin->instance >> 12) | (1<<31));
+	int ret; (void)ret;
+
+	DRM_DEBUG("ch%d\n", chan->id);
+
+#if 0
+	if ((ret = nv50_graph_transfer_context(dev, inst, 0)))
+		return ret;
+#endif
+
+	NV_WRITE(NV20_PGRAPH_CHANNEL_CTX_POINTER, inst);
+	NV_WRITE(0x400320, 4);
+	NV_WRITE(NV40_PGRAPH_CTXCTL_CUR, inst);
+
+	return 0;
+}
+
+int
+nv50_graph_save_context(struct nouveau_channel *chan)
+{
+	struct drm_device *dev = chan->dev;
+	uint32_t inst = ((chan->ramin->instance >> 12) | (1<<31));
+
+	DRM_DEBUG("ch%d\n", chan->id);
+
+	return nv50_graph_transfer_context(dev, inst, 1);
+}
+
Index: git/shared-core/nv50_mc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv50_mc.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2007 Ben Skeggs.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "nouveau_drv.h"
+
+int
+nv50_mc_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	NV_WRITE(NV03_PMC_ENABLE, 0xFFFFFFFF);
+
+	return 0;
+}
+
+void nv50_mc_takedown(struct drm_device *dev)
+{
+}
Index: git/shared-core/nv_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/nv_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,52 @@
+/* nv_drv.h -- NV DRM template customization -*- linux-c -*-
+ * Created: Wed Feb 14 12:32:32 2001 by gareth@valinux.com
+ *
+ * Copyright 2005 Lars Knoll <lars@trolltech.com>
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Lars Knoll <lars@trolltech.com>
+ */
+
+#ifndef __NV_H__
+#define __NV_H__
+
+/* General customization:
+ */
+
+#define DRIVER_AUTHOR		"Lars Knoll"
+
+#define DRIVER_NAME		"nv"
+#define DRIVER_DESC		"NV"
+#define DRIVER_DATE		"20051006"
+
+#define DRIVER_MAJOR		0
+#define DRIVER_MINOR		0
+#define DRIVER_PATCHLEVEL	1
+
+#define NV04 04
+#define NV10 10
+#define NV20 20
+#define NV30 30
+#define NV40 40
+
+#endif
Index: git/shared-core/psb_drm.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/psb_drm.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,359 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
+ * develop this driver.
+ *
+ **************************************************************************/
+/*
+ */
+
+#ifndef _PSB_DRM_H_
+#define _PSB_DRM_H_
+
+#if defined(__linux__) && !defined(__KERNEL__)
+#include<stdint.h>
+#endif
+
+/*
+ * Intel Poulsbo driver package version.
+ *
+ */
+/* #define PSB_PACKAGE_VERSION "ED"__DATE__*/
+#define PSB_PACKAGE_VERSION "2.0.0.32L.0007"
+
+#define DRM_PSB_SAREA_MAJOR 0
+#define DRM_PSB_SAREA_MINOR 1
+#define PSB_FIXED_SHIFT 16
+
+/*
+ * Public memory types.
+ */
+
+#define DRM_PSB_MEM_MMU DRM_BO_MEM_PRIV1
+#define DRM_PSB_FLAG_MEM_MMU DRM_BO_FLAG_MEM_PRIV1
+#define DRM_PSB_MEM_PDS DRM_BO_MEM_PRIV2
+#define DRM_PSB_FLAG_MEM_PDS DRM_BO_FLAG_MEM_PRIV2
+#define DRM_PSB_MEM_APER DRM_BO_MEM_PRIV3
+#define DRM_PSB_FLAG_MEM_APER DRM_BO_FLAG_MEM_PRIV3
+#define DRM_PSB_MEM_RASTGEOM DRM_BO_MEM_PRIV4
+#define DRM_PSB_FLAG_MEM_RASTGEOM DRM_BO_FLAG_MEM_PRIV4
+#define PSB_MEM_RASTGEOM_START   0x30000000
+
+typedef int32_t psb_fixed;
+typedef uint32_t psb_ufixed;
+
+static inline psb_fixed psb_int_to_fixed(int a)
+{
+	return a * (1 << PSB_FIXED_SHIFT);
+}
+
+static inline psb_ufixed psb_unsigned_to_ufixed(unsigned int a)
+{
+	return a << PSB_FIXED_SHIFT;
+}
+
+/*Status of the command sent to the gfx device.*/
+typedef enum {
+	DRM_CMD_SUCCESS,
+	DRM_CMD_FAILED,
+	DRM_CMD_HANG
+} drm_cmd_status_t;
+
+struct drm_psb_scanout {
+	uint32_t buffer_id;	/* DRM buffer object ID */
+	uint32_t rotation;	/* Rotation as in RR_rotation definitions */
+	uint32_t stride;	/* Buffer stride in bytes */
+	uint32_t depth;		/* Buffer depth in bits (NOT) bpp */
+	uint32_t width;		/* Buffer width in pixels */
+	uint32_t height;	/* Buffer height in lines */
+	psb_fixed transform[3][3];	/* Buffer composite transform */
+	/* (scaling, rot, reflect) */
+};
+
+#define DRM_PSB_SAREA_OWNERS 16
+#define DRM_PSB_SAREA_OWNER_2D 0
+#define DRM_PSB_SAREA_OWNER_3D 1
+
+#define DRM_PSB_SAREA_SCANOUTS 3
+
+struct drm_psb_sarea {
+	/* Track changes of this data structure */
+
+	uint32_t major;
+	uint32_t minor;
+
+	/* Last context to touch part of hw */
+	uint32_t ctx_owners[DRM_PSB_SAREA_OWNERS];
+
+	/* Definition of front- and rotated buffers */
+	uint32_t num_scanouts;
+	struct drm_psb_scanout scanouts[DRM_PSB_SAREA_SCANOUTS];
+
+	int planeA_x;
+	int planeA_y;
+	int planeA_w;
+	int planeA_h;
+	int planeB_x;
+	int planeB_y;
+	int planeB_w;
+	int planeB_h;
+	uint32_t msvdx_state;
+	uint32_t msvdx_context;
+};
+
+#define PSB_RELOC_MAGIC         0x67676767
+#define PSB_RELOC_SHIFT_MASK    0x0000FFFF
+#define PSB_RELOC_SHIFT_SHIFT   0
+#define PSB_RELOC_ALSHIFT_MASK  0xFFFF0000
+#define PSB_RELOC_ALSHIFT_SHIFT 16
+
+#define PSB_RELOC_OP_OFFSET     0	/* Offset of the indicated
+					 * buffer
+					 */
+#define PSB_RELOC_OP_2D_OFFSET  1	/* Offset of the indicated
+					 *  buffer, relative to 2D
+					 *  base address
+					 */
+#define PSB_RELOC_OP_PDS_OFFSET 2	/* Offset of the indicated buffer,
+					 *  relative to PDS base address
+					 */
+#define PSB_RELOC_OP_STRIDE     3	/* Stride of the indicated
+					 * buffer (for tiling)
+					 */
+#define PSB_RELOC_OP_USE_OFFSET 4	/* Offset of USE buffer
+					 * relative to base reg
+					 */
+#define PSB_RELOC_OP_USE_REG    5	/* Base reg of USE buffer */
+
+struct drm_psb_reloc {
+	uint32_t reloc_op;
+	uint32_t where;		/* offset in destination buffer */
+	uint32_t buffer;	/* Buffer reloc applies to */
+	uint32_t mask;		/* Destination format: */
+	uint32_t shift;		/* Destination format: */
+	uint32_t pre_add;	/* Destination format: */
+	uint32_t background;	/* Destination add */
+	uint32_t dst_buffer;	/* Destination buffer. Index into buffer_list */
+	uint32_t arg0;		/* Reloc-op dependant */
+	uint32_t arg1;
+};
+
+#define PSB_BO_FLAG_TA              (1ULL << 48)
+#define PSB_BO_FLAG_SCENE           (1ULL << 49)
+#define PSB_BO_FLAG_FEEDBACK        (1ULL << 50)
+#define PSB_BO_FLAG_USSE            (1ULL << 51)
+
+#define PSB_ENGINE_2D 0
+#define PSB_ENGINE_VIDEO 1
+#define PSB_ENGINE_RASTERIZER 2
+#define PSB_ENGINE_TA 3
+#define PSB_ENGINE_HPRAST 4
+
+/*
+ * For this fence class we have a couple of
+ * fence types.
+ */
+
+#define _PSB_FENCE_EXE_SHIFT           0
+#define _PSB_FENCE_TA_DONE_SHIFT       1
+#define _PSB_FENCE_RASTER_DONE_SHIFT   2
+#define _PSB_FENCE_SCENE_DONE_SHIFT    3
+#define _PSB_FENCE_FEEDBACK_SHIFT      4
+
+#define _PSB_ENGINE_TA_FENCE_TYPES   5
+#define _PSB_FENCE_TYPE_TA_DONE     (1 << _PSB_FENCE_TA_DONE_SHIFT)
+#define _PSB_FENCE_TYPE_RASTER_DONE (1 << _PSB_FENCE_RASTER_DONE_SHIFT)
+#define _PSB_FENCE_TYPE_SCENE_DONE  (1 << _PSB_FENCE_SCENE_DONE_SHIFT)
+#define _PSB_FENCE_TYPE_FEEDBACK    (1 << _PSB_FENCE_FEEDBACK_SHIFT)
+
+#define PSB_ENGINE_HPRAST 4
+#define PSB_NUM_ENGINES 5
+
+#define PSB_TA_FLAG_FIRSTPASS    (1 << 0)
+#define PSB_TA_FLAG_LASTPASS     (1 << 1)
+
+#define PSB_FEEDBACK_OP_VISTEST (1 << 0)
+
+struct drm_psb_scene {
+	int handle_valid;
+	uint32_t handle;
+	uint32_t w;
+	uint32_t h;
+	uint32_t num_buffers;
+};
+
+typedef struct drm_psb_cmdbuf_arg {
+	uint64_t buffer_list;	/* List of buffers to validate */
+	uint64_t clip_rects;	/* See i915 counterpart */
+	uint64_t scene_arg;
+	uint64_t fence_arg;
+
+	uint32_t ta_flags;
+
+	uint32_t ta_handle;	/* TA reg-value pairs */
+	uint32_t ta_offset;
+	uint32_t ta_size;
+
+	uint32_t oom_handle;
+	uint32_t oom_offset;
+	uint32_t oom_size;
+
+	uint32_t cmdbuf_handle;	/* 2D Command buffer object or, */
+	uint32_t cmdbuf_offset;	/* rasterizer reg-value pairs */
+	uint32_t cmdbuf_size;
+
+	uint32_t reloc_handle;	/* Reloc buffer object */
+	uint32_t reloc_offset;
+	uint32_t num_relocs;
+
+	int32_t damage;		/* Damage front buffer with cliprects */
+	/* Not implemented yet */
+	uint32_t fence_flags;
+	uint32_t engine;
+
+	/*
+	 * Feedback;
+	 */
+
+	uint32_t feedback_ops;
+	uint32_t feedback_handle;
+	uint32_t feedback_offset;
+	uint32_t feedback_breakpoints;
+	uint32_t feedback_size;
+} drm_psb_cmdbuf_arg_t;
+
+struct drm_psb_xhw_init_arg {
+	uint32_t operation;
+	uint32_t buffer_handle;
+};
+
+/*
+ * Feedback components:
+ */
+
+/*
+ * Vistest component. The number of these in the feedback buffer
+ * equals the number of vistest breakpoints + 1.
+ * This is currently the only feedback component.
+ */
+
+struct drm_psb_vistest {
+	uint32_t vt[8];
+};
+
+#define PSB_HW_COOKIE_SIZE 16
+#define PSB_HW_FEEDBACK_SIZE 8
+#define PSB_HW_OOM_CMD_SIZE 6
+
+struct drm_psb_xhw_arg {
+	uint32_t op;
+	int ret;
+	uint32_t irq_op;
+	uint32_t issue_irq;
+	uint32_t cookie[PSB_HW_COOKIE_SIZE];
+	union {
+		struct {
+			uint32_t w;
+			uint32_t h;
+			uint32_t size;
+			uint32_t clear_p_start;
+			uint32_t clear_num_pages;
+		} si;
+		struct {
+			uint32_t fire_flags;
+			uint32_t hw_context;
+			uint32_t offset;
+			uint32_t engine;
+			uint32_t flags;
+			uint32_t rca;
+			uint32_t num_oom_cmds;
+			uint32_t oom_cmds[PSB_HW_OOM_CMD_SIZE];
+		} sb;
+		struct {
+			uint32_t pages;
+			uint32_t size;
+		} bi;
+		struct {
+			uint32_t bca;
+			uint32_t rca;
+			uint32_t flags;
+		} oom;
+		struct {
+			uint32_t pt_offset;
+			uint32_t param_offset;
+			uint32_t flags;
+		} bl;
+		uint32_t feedback[PSB_HW_FEEDBACK_SIZE];
+	} arg;
+};
+
+#define DRM_PSB_CMDBUF          0x00
+#define DRM_PSB_XHW_INIT        0x01
+#define DRM_PSB_XHW             0x02
+#define DRM_PSB_SCENE_UNREF     0x03
+/* Controlling the kernel modesetting buffers */
+#define DRM_PSB_KMS_OFF		0x04
+#define DRM_PSB_KMS_ON		0x05
+
+#define PSB_XHW_INIT            0x00
+#define PSB_XHW_TAKEDOWN        0x01
+
+#define PSB_XHW_FIRE_RASTER     0x00
+#define PSB_XHW_SCENE_INFO      0x01
+#define PSB_XHW_SCENE_BIND_FIRE 0x02
+#define PSB_XHW_TA_MEM_INFO    0x03
+#define PSB_XHW_RESET_DPM       0x04
+#define PSB_XHW_OOM             0x05
+#define PSB_XHW_TERMINATE       0x06
+#define PSB_XHW_VISTEST         0x07
+#define PSB_XHW_RESUME          0x08
+#define PSB_XHW_TA_MEM_LOAD    0x09
+
+#define PSB_SCENE_FLAG_DIRTY       (1 << 0)
+#define PSB_SCENE_FLAG_COMPLETE    (1 << 1)
+#define PSB_SCENE_FLAG_SETUP       (1 << 2)
+#define PSB_SCENE_FLAG_SETUP_ONLY  (1 << 3)
+#define PSB_SCENE_FLAG_CLEARED     (1 << 4)
+
+#define PSB_TA_MEM_FLAG_TA            (1 << 0)
+#define PSB_TA_MEM_FLAG_RASTER        (1 << 1)
+#define PSB_TA_MEM_FLAG_HOSTA         (1 << 2)
+#define PSB_TA_MEM_FLAG_HOSTD         (1 << 3)
+#define PSB_TA_MEM_FLAG_INIT          (1 << 4)
+#define PSB_TA_MEM_FLAG_NEW_PT_OFFSET (1 << 5)
+
+/*Raster fire will deallocate memory */
+#define PSB_FIRE_FLAG_RASTER_DEALLOC  (1 << 0)
+/*Isp reset needed due to change in ZLS format */
+#define PSB_FIRE_FLAG_NEEDS_ISP_RESET (1 << 1)
+/*These are set by Xpsb. */
+#define PSB_FIRE_FLAG_XHW_MASK        0xff000000
+/*The task has had at least one OOM and Xpsb will
+  send back messages on each fire. */
+#define PSB_FIRE_FLAG_XHW_OOM         (1 << 24)
+
+#define PSB_SCENE_ENGINE_TA    0
+#define PSB_SCENE_ENGINE_RASTER    1
+#define PSB_SCENE_NUM_ENGINES      2
+
+struct drm_psb_dev_info_arg {
+	uint32_t num_use_attribute_registers;
+};
+#define DRM_PSB_DEVINFO         0x01
+
+#endif
Index: git/shared-core/psb_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/psb_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,786 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
+ * develop this driver.
+ *
+ **************************************************************************/
+/*
+ */
+#ifndef _PSB_DRV_H_
+#define _PSB_DRV_H_
+
+#include "drmP.h"
+#include "psb_drm.h"
+#include "psb_reg.h"
+#include "psb_schedule.h"
+#include "intel_drv.h"
+
+enum {
+	CHIP_PSB_8108 = 0,
+	CHIP_PSB_8109 = 1
+};
+
+#define DRIVER_NAME "psb"
+#define DRIVER_DESC "drm driver for the Intel GMA500"
+#define DRIVER_AUTHOR "Tungsten Graphics Inc."
+
+#define PSB_DRM_DRIVER_DATE "20080107"
+#define PSB_DRM_DRIVER_MAJOR 4 
+#define PSB_DRM_DRIVER_MINOR 1
+#define PSB_DRM_DRIVER_PATCHLEVEL 0
+
+#define PSB_VDC_OFFSET           0x00000000
+#define PSB_VDC_SIZE             0x000080000
+#define PSB_SGX_SIZE             0x8000
+#define PSB_SGX_OFFSET           0x00040000
+#define PSB_MMIO_RESOURCE        0
+#define PSB_GATT_RESOURCE        2
+#define PSB_GTT_RESOURCE         3
+#define PSB_GMCH_CTRL            0x52
+#define PSB_BSM                  0x5C
+#define _PSB_GMCH_ENABLED        0x4
+#define PSB_PGETBL_CTL           0x2020
+#define _PSB_PGETBL_ENABLED      0x00000001
+#define PSB_SGX_2D_SLAVE_PORT    0x4000
+#define PSB_TT_PRIV0_LIMIT       (256*1024*1024)
+#define PSB_TT_PRIV0_PLIMIT      (PSB_TT_PRIV0_LIMIT >> PAGE_SHIFT)
+#define PSB_NUM_VALIDATE_BUFFERS 640
+#define PSB_MEM_KERNEL_START     0x10000000
+#define PSB_MEM_PDS_START        0x20000000
+#define PSB_MEM_MMU_START        0x40000000
+
+#define DRM_PSB_MEM_KERNEL       DRM_BO_MEM_PRIV0
+#define DRM_PSB_FLAG_MEM_KERNEL  DRM_BO_FLAG_MEM_PRIV0
+
+/*
+ * Flags for external memory type field.
+ */
+
+#define PSB_MSVDX_OFFSET        0x50000	/*MSVDX Base offset */
+#define PSB_MSVDX_SIZE          0x8000	/*MSVDX MMIO region is 0x50000 - 0x57fff ==> 32KB */
+
+#define PSB_MMU_CACHED_MEMORY     0x0001	/* Bind to MMU only */
+#define PSB_MMU_RO_MEMORY         0x0002	/* MMU RO memory */
+#define PSB_MMU_WO_MEMORY         0x0004	/* MMU WO memory */
+
+/*
+ * PTE's and PDE's
+ */
+
+#define PSB_PDE_MASK              0x003FFFFF
+#define PSB_PDE_SHIFT             22
+#define PSB_PTE_SHIFT             12
+
+#define PSB_PTE_VALID             0x0001	/* PTE / PDE valid */
+#define PSB_PTE_WO                0x0002	/* Write only */
+#define PSB_PTE_RO                0x0004	/* Read only */
+#define PSB_PTE_CACHED            0x0008	/* CPU cache coherent */
+
+/*
+ * VDC registers and bits
+ */
+#define PSB_HWSTAM                0x2098
+#define PSB_INSTPM                0x20C0
+#define PSB_INT_IDENTITY_R        0x20A4
+#define _PSB_VSYNC_PIPEB_FLAG     (1<<5)
+#define _PSB_VSYNC_PIPEA_FLAG     (1<<7)
+#define _PSB_IRQ_SGX_FLAG         (1<<18)
+#define _PSB_IRQ_MSVDX_FLAG       (1<<19)
+#define PSB_INT_MASK_R            0x20A8
+#define PSB_INT_ENABLE_R          0x20A0
+#define PSB_PIPEASTAT             0x70024
+#define _PSB_VBLANK_INTERRUPT_ENABLE (1 << 17)
+#define _PSB_VBLANK_CLEAR         (1 << 1)
+#define PSB_PIPEBSTAT             0x71024
+
+#define _PSB_MMU_ER_MASK      0x0001FF00
+#define _PSB_MMU_ER_HOST      (1 << 16)
+#define GPIOA			0x5010
+#define GPIOB			0x5014
+#define GPIOC			0x5018
+#define GPIOD			0x501c
+#define GPIOE			0x5020
+#define GPIOF			0x5024
+#define GPIOG			0x5028
+#define GPIOH			0x502c
+#define GPIO_CLOCK_DIR_MASK		(1 << 0)
+#define GPIO_CLOCK_DIR_IN		(0 << 1)
+#define GPIO_CLOCK_DIR_OUT		(1 << 1)
+#define GPIO_CLOCK_VAL_MASK		(1 << 2)
+#define GPIO_CLOCK_VAL_OUT		(1 << 3)
+#define GPIO_CLOCK_VAL_IN		(1 << 4)
+#define GPIO_CLOCK_PULLUP_DISABLE	(1 << 5)
+#define GPIO_DATA_DIR_MASK		(1 << 8)
+#define GPIO_DATA_DIR_IN		(0 << 9)
+#define GPIO_DATA_DIR_OUT		(1 << 9)
+#define GPIO_DATA_VAL_MASK		(1 << 10)
+#define GPIO_DATA_VAL_OUT		(1 << 11)
+#define GPIO_DATA_VAL_IN		(1 << 12)
+#define GPIO_DATA_PULLUP_DISABLE	(1 << 13)
+
+#define VCLK_DIVISOR_VGA0   0x6000
+#define VCLK_DIVISOR_VGA1   0x6004
+#define VCLK_POST_DIV       0x6010
+
+#define DRM_DRIVER_PRIVATE_T struct drm_psb_private
+#define I915_WRITE(_offs, _val) \
+  iowrite32(_val, dev_priv->vdc_reg + (_offs))
+#define I915_READ(_offs) \
+  ioread32(dev_priv->vdc_reg + (_offs))
+
+#define PSB_COMM_2D (PSB_ENGINE_2D << 4)
+#define PSB_COMM_3D (PSB_ENGINE_3D << 4)
+#define PSB_COMM_TA (PSB_ENGINE_TA << 4)
+#define PSB_COMM_HP (PSB_ENGINE_HP << 4)
+#define PSB_COMM_USER_IRQ (1024 >> 2)
+#define PSB_COMM_USER_IRQ_LOST (PSB_COMM_USER_IRQ + 1)
+#define PSB_COMM_FW (2048 >> 2)
+
+#define PSB_UIRQ_VISTEST               1
+#define PSB_UIRQ_OOM_REPLY             2
+#define PSB_UIRQ_FIRE_TA_REPLY         3
+#define PSB_UIRQ_FIRE_RASTER_REPLY     4
+
+#define PSB_2D_SIZE (256*1024*1024)
+#define PSB_MAX_RELOC_PAGES 1024
+
+#define PSB_LOW_REG_OFFS 0x0204
+#define PSB_HIGH_REG_OFFS 0x0600
+
+#define PSB_NUM_VBLANKS 2
+
+#define PSB_COMM_2D (PSB_ENGINE_2D << 4)
+#define PSB_COMM_3D (PSB_ENGINE_3D << 4)
+#define PSB_COMM_TA (PSB_ENGINE_TA << 4)
+#define PSB_COMM_HP (PSB_ENGINE_HP << 4)
+#define PSB_COMM_FW (2048 >> 2)
+
+#define PSB_2D_SIZE (256*1024*1024)
+#define PSB_MAX_RELOC_PAGES 1024
+
+#define PSB_LOW_REG_OFFS 0x0204
+#define PSB_HIGH_REG_OFFS 0x0600
+
+#define PSB_NUM_VBLANKS 2
+#define PSB_WATCHDOG_DELAY (DRM_HZ / 10)
+
+/*
+ * User options.
+ */
+
+struct drm_psb_uopt {
+	int disable_clock_gating;
+};
+
+struct psb_gtt {
+	struct drm_device *dev;
+	int initialized;
+	uint32_t gatt_start;
+	uint32_t gtt_start;
+	uint32_t gtt_phys_start;
+	unsigned gtt_pages;
+	unsigned gatt_pages;
+	uint32_t stolen_base;
+	uint32_t pge_ctl;
+	u16 gmch_ctrl;
+	unsigned long stolen_size;
+	uint32_t *gtt_map;
+	struct rw_semaphore sem;
+};
+
+struct psb_use_base {
+	struct list_head head;
+	struct drm_fence_object *fence;
+	unsigned int reg;
+	unsigned long offset;
+	unsigned int dm;
+};
+
+struct psb_buflist_item {
+	struct drm_buffer_object *bo;
+	void __user *data;
+	struct drm_bo_info_rep rep;
+	int ret;
+};
+
+struct psb_msvdx_cmd_queue {
+	struct list_head head;
+	void *cmd;
+	unsigned long cmd_size;
+	uint32_t sequence;
+};
+
+struct drm_psb_private {
+	unsigned long chipset;
+
+	struct psb_xhw_buf resume_buf;
+	struct drm_psb_dev_info_arg dev_info;
+	struct drm_psb_uopt uopt;
+
+	struct psb_gtt *pg;
+
+	struct page *scratch_page;
+	struct page *comm_page;
+
+	volatile uint32_t *comm;
+	uint32_t comm_mmu_offset;
+	uint32_t mmu_2d_offset;
+	uint32_t sequence[PSB_NUM_ENGINES];
+	uint32_t last_sequence[PSB_NUM_ENGINES];
+	int idle[PSB_NUM_ENGINES];
+	uint32_t last_submitted_seq[PSB_NUM_ENGINES];
+	int engine_lockup_2d;
+
+	struct psb_mmu_driver *mmu;
+	struct psb_mmu_pd *pf_pd;
+
+	uint8_t *sgx_reg;
+	uint8_t *vdc_reg;
+	uint8_t *msvdx_reg;
+	 /*MSVDX*/ int msvdx_needs_reset;
+	int has_msvdx;
+	uint32_t gatt_free_offset;
+
+	/*
+	 * Fencing / irq.
+	 */
+
+	uint32_t sgx_irq_mask;
+	uint32_t vdc_irq_mask;
+
+	spinlock_t irqmask_lock;
+	spinlock_t sequence_lock;
+	int fence0_irq_on;
+	int irq_enabled;
+	unsigned int irqen_count_2d;
+	wait_queue_head_t event_2d_queue;
+
+	uint32_t msvdx_current_sequence;
+	uint32_t msvdx_last_sequence;
+	int fence2_irq_on;
+	struct mutex mutex_2d;
+
+	/*
+	 * MSVDX Rendec Memory
+	 */
+	struct drm_buffer_object *ccb0;
+	uint32_t base_addr0;
+	struct drm_buffer_object *ccb1;
+	uint32_t base_addr1;
+
+	/*
+	 * Memory managers
+	 */
+
+	int have_vram;
+	int have_tt;
+	int have_mem_mmu;
+	int have_mem_aper;
+	int have_mem_kernel;
+	int have_mem_pds;
+	int have_mem_rastgeom;
+	struct mutex temp_mem;
+
+	/*
+	 * Relocation buffer mapping.
+	 */
+
+	spinlock_t reloc_lock;
+	unsigned int rel_mapped_pages;
+	wait_queue_head_t rel_mapped_queue;
+
+	/*
+	 * SAREA
+	 */
+	struct drm_psb_sarea *sarea_priv;
+
+	/*
+	 * LVDS info
+	 */
+	uint8_t blc_type;
+	uint8_t blc_pol;
+	uint8_t blc_freq;
+	uint8_t blc_minbrightness;
+	uint8_t blc_i2caddr;
+	uint8_t blc_brightnesscmd;
+	int backlight;	/* restore backlight to this value */
+
+	struct intel_i2c_chan *i2c_bus; 
+	u32 CoreClock;
+	u32 PWMControlRegFreq;
+
+	unsigned char * OpRegion;
+	unsigned int OpRegionSize;
+
+	int backlight_duty_cycle;	/* restore backlight to this value */
+	bool panel_wants_dither;
+	struct drm_display_mode *panel_fixed_mode;
+
+	/*
+	 * Register state
+	 */
+	uint32_t saveDSPACNTR;
+	uint32_t saveDSPBCNTR;
+	uint32_t savePIPEACONF;
+	uint32_t savePIPEBCONF;
+	uint32_t savePIPEASRC;
+	uint32_t savePIPEBSRC;
+	uint32_t saveFPA0;
+	uint32_t saveFPA1;
+	uint32_t saveDPLL_A;
+	uint32_t saveDPLL_A_MD;
+	uint32_t saveHTOTAL_A;
+	uint32_t saveHBLANK_A;
+	uint32_t saveHSYNC_A;
+	uint32_t saveVTOTAL_A;
+	uint32_t saveVBLANK_A;
+	uint32_t saveVSYNC_A;
+	uint32_t saveDSPASTRIDE;
+	uint32_t saveDSPASIZE;
+	uint32_t saveDSPAPOS;
+	uint32_t saveDSPABASE;
+	uint32_t saveDSPASURF;
+	uint32_t saveFPB0;
+	uint32_t saveFPB1;
+	uint32_t saveDPLL_B;
+	uint32_t saveDPLL_B_MD;
+	uint32_t saveHTOTAL_B;
+	uint32_t saveHBLANK_B;
+	uint32_t saveHSYNC_B;
+	uint32_t saveVTOTAL_B;
+	uint32_t saveVBLANK_B;
+	uint32_t saveVSYNC_B;
+	uint32_t saveDSPBSTRIDE;
+	uint32_t saveDSPBSIZE;
+	uint32_t saveDSPBPOS;
+	uint32_t saveDSPBBASE;
+	uint32_t saveDSPBSURF;
+	uint32_t saveVCLK_DIVISOR_VGA0;
+	uint32_t saveVCLK_DIVISOR_VGA1;
+	uint32_t saveVCLK_POST_DIV;
+	uint32_t saveVGACNTRL;
+	uint32_t saveADPA;
+	uint32_t saveLVDS;
+	uint32_t saveDVOA;
+	uint32_t saveDVOB;
+	uint32_t saveDVOC;
+	uint32_t savePP_ON;
+	uint32_t savePP_OFF;
+	uint32_t savePP_CONTROL;
+	uint32_t savePP_CYCLE;
+	uint32_t savePFIT_CONTROL;
+	uint32_t savePaletteA[256];
+	uint32_t savePaletteB[256];
+	uint32_t saveBLC_PWM_CTL;
+
+	/*
+	 * USE code base register management.
+	 */
+
+	struct drm_reg_manager use_manager;
+
+	/*
+	 * Xhw
+	 */
+
+	uint32_t *xhw;
+	struct drm_buffer_object *xhw_bo;
+	struct drm_bo_kmap_obj xhw_kmap;
+	struct list_head xhw_in;
+	spinlock_t xhw_lock;
+	atomic_t xhw_client;
+	struct drm_file *xhw_file;
+	wait_queue_head_t xhw_queue;
+	wait_queue_head_t xhw_caller_queue;
+	struct mutex xhw_mutex;
+	struct psb_xhw_buf *xhw_cur_buf;
+	int xhw_submit_ok;
+	int xhw_on;
+
+	/*
+	 * Scheduling.
+	 */
+
+	struct mutex reset_mutex;
+	struct mutex cmdbuf_mutex;
+	struct psb_scheduler scheduler;
+	struct psb_buflist_item buffers[PSB_NUM_VALIDATE_BUFFERS];
+        uint32_t ta_mem_pages;
+        struct psb_ta_mem *ta_mem;
+        int force_ta_mem_load;
+
+	/*
+	 * Watchdog
+	 */
+
+	spinlock_t watchdog_lock;
+	struct timer_list watchdog_timer;
+	struct work_struct watchdog_wq;
+	struct work_struct msvdx_watchdog_wq;
+	int timer_available;
+
+	/*
+	 * msvdx command queue
+	 */
+	spinlock_t msvdx_lock;
+	struct mutex msvdx_mutex;
+	struct list_head msvdx_queue;
+	int msvdx_busy;
+};
+
+struct psb_mmu_driver;
+
+extern struct psb_mmu_driver *psb_mmu_driver_init(uint8_t __iomem * registers,
+						  int trap_pagefaults,
+						  int invalid_type);
+extern void psb_mmu_driver_takedown(struct psb_mmu_driver *driver);
+extern struct psb_mmu_pd *psb_mmu_get_default_pd(struct psb_mmu_driver *driver);
+extern void psb_mmu_mirror_gtt(struct psb_mmu_pd *pd, uint32_t mmu_offset,
+			       uint32_t gtt_start, uint32_t gtt_pages);
+extern void psb_mmu_test(struct psb_mmu_driver *driver, uint32_t offset);
+extern struct psb_mmu_pd *psb_mmu_alloc_pd(struct psb_mmu_driver *driver,
+					   int trap_pagefaults,
+					   int invalid_type);
+extern void psb_mmu_free_pagedir(struct psb_mmu_pd *pd);
+extern void psb_mmu_flush(struct psb_mmu_driver *driver);
+extern void psb_mmu_remove_pfn_sequence(struct psb_mmu_pd *pd,
+					unsigned long address,
+					uint32_t num_pages);
+extern int psb_mmu_insert_pfn_sequence(struct psb_mmu_pd *pd,
+				       uint32_t start_pfn,
+				       unsigned long address,
+				       uint32_t num_pages, int type);
+extern int psb_mmu_virtual_to_pfn(struct psb_mmu_pd *pd, uint32_t virtual,
+				  unsigned long *pfn);
+
+/*
+ * Enable / disable MMU for different requestors.
+ */
+
+extern void psb_mmu_enable_requestor(struct psb_mmu_driver *driver,
+				     uint32_t mask);
+extern void psb_mmu_disable_requestor(struct psb_mmu_driver *driver,
+				      uint32_t mask);
+extern void psb_mmu_set_pd_context(struct psb_mmu_pd *pd, int hw_context);
+extern int psb_mmu_insert_pages(struct psb_mmu_pd *pd, struct page **pages,
+				unsigned long address, uint32_t num_pages,
+				uint32_t desired_tile_stride,
+				uint32_t hw_tile_stride, int type);
+extern void psb_mmu_remove_pages(struct psb_mmu_pd *pd, unsigned long address,
+				 uint32_t num_pages,
+				 uint32_t desired_tile_stride,
+				 uint32_t hw_tile_stride);
+/*
+ * psb_sgx.c
+ */
+
+extern int psb_blit_sequence(struct drm_psb_private *dev_priv,
+			     uint32_t sequence);
+extern void psb_init_2d(struct drm_psb_private *dev_priv);
+extern int drm_psb_idle(struct drm_device *dev);
+extern int psb_emit_2d_copy_blit(struct drm_device *dev,
+				 uint32_t src_offset,
+				 uint32_t dst_offset, uint32_t pages,
+				 int direction);
+extern int psb_cmdbuf_ioctl(struct drm_device *dev, void *data,
+			    struct drm_file *file_priv);
+extern int psb_reg_submit(struct drm_psb_private *dev_priv, uint32_t * regs,
+			  unsigned int cmds);
+extern int psb_submit_copy_cmdbuf(struct drm_device *dev,
+				  struct drm_buffer_object *cmd_buffer,
+				  unsigned long cmd_offset,
+				  unsigned long cmd_size, int engine,
+				  uint32_t * copy_buffer);
+
+extern int psb_fence_for_errors(struct drm_file *priv,
+				struct drm_psb_cmdbuf_arg *arg,
+				struct drm_fence_arg *fence_arg,
+				struct drm_fence_object **fence_p);
+
+/*
+ * psb_irq.c
+ */
+
+extern irqreturn_t psb_irq_handler(DRM_IRQ_ARGS);
+extern void psb_irq_preinstall(struct drm_device *dev);
+extern void psb_irq_postinstall(struct drm_device *dev);
+extern void psb_irq_uninstall(struct drm_device *dev);
+extern int psb_vblank_wait2(struct drm_device *dev, unsigned int *sequence);
+extern int psb_vblank_wait(struct drm_device *dev, unsigned int *sequence);
+
+/*
+ * psb_fence.c
+ */
+
+extern void psb_poke_flush(struct drm_device *dev, uint32_t class);
+extern int psb_fence_emit_sequence(struct drm_device *dev, uint32_t class,
+				   uint32_t flags, uint32_t * sequence,
+				   uint32_t * native_type);
+extern void psb_fence_handler(struct drm_device *dev, uint32_t class);
+extern int psb_fence_has_irq(struct drm_device *dev, uint32_t class,
+			     uint32_t flags);
+extern void psb_2D_irq_off(struct drm_psb_private *dev_priv);
+extern void psb_2D_irq_on(struct drm_psb_private *dev_priv);
+extern uint32_t psb_fence_advance_sequence(struct drm_device *dev,
+					   uint32_t class);
+extern void psb_fence_error(struct drm_device *dev,
+			    uint32_t class,
+			    uint32_t sequence, uint32_t type, int error);
+
+/*MSVDX stuff*/
+extern void psb_msvdx_irq_off(struct drm_psb_private *dev_priv);
+extern void psb_msvdx_irq_on(struct drm_psb_private *dev_priv);
+
+/*
+ * psb_buffer.c
+ */
+extern struct drm_ttm_backend *drm_psb_tbe_init(struct drm_device *dev);
+extern int psb_fence_types(struct drm_buffer_object *bo, uint32_t * class,
+			   uint32_t * type);
+extern uint32_t psb_evict_mask(struct drm_buffer_object *bo);
+extern int psb_invalidate_caches(struct drm_device *dev, uint64_t flags);
+extern int psb_init_mem_type(struct drm_device *dev, uint32_t type,
+			     struct drm_mem_type_manager *man);
+extern int psb_move(struct drm_buffer_object *bo,
+		    int evict, int no_wait, struct drm_bo_mem_reg *new_mem);
+
+/*
+ * psb_gtt.c
+ */
+extern int psb_gtt_init(struct psb_gtt *pg, int resume);
+extern int psb_gtt_insert_pages(struct psb_gtt *pg, struct page **pages,
+				unsigned offset_pages, unsigned num_pages,
+				unsigned desired_tile_stride,
+				unsigned hw_tile_stride, int type);
+extern int psb_gtt_remove_pages(struct psb_gtt *pg, unsigned offset_pages,
+				unsigned num_pages,
+				unsigned desired_tile_stride,
+				unsigned hw_tile_stride);
+
+extern struct psb_gtt *psb_gtt_alloc(struct drm_device *dev);
+extern void psb_gtt_takedown(struct psb_gtt *pg, int free);
+
+/*
+ * psb_fb.c
+ */
+extern int psbfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
+extern int psbfb_remove(struct drm_device *dev, struct drm_crtc *crtc);
+extern int psbfb_kms_off_ioctl(struct drm_device *dev, void *data,
+			       struct drm_file *file_priv);
+extern int psbfb_kms_on_ioctl(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv);
+
+/*
+ * psb_reset.c
+ */
+
+extern void psb_reset(struct drm_psb_private *dev_priv, int reset_2d);
+extern void psb_schedule_watchdog(struct drm_psb_private *dev_priv);
+extern void psb_watchdog_init(struct drm_psb_private *dev_priv);
+extern void psb_watchdog_takedown(struct drm_psb_private *dev_priv);
+
+/*
+ * psb_regman.c
+ */
+
+extern void psb_takedown_use_base(struct drm_psb_private *dev_priv);
+extern int psb_grab_use_base(struct drm_psb_private *dev_priv,
+			     unsigned long dev_virtual,
+			     unsigned long size,
+			     unsigned int data_master,
+			     uint32_t fence_class,
+			     uint32_t fence_type,
+			     int no_wait,
+			     int ignore_signals,
+			     int *r_reg, uint32_t * r_offset);
+extern int psb_init_use_base(struct drm_psb_private *dev_priv,
+			     unsigned int reg_start, unsigned int reg_num);
+
+/*
+ * psb_xhw.c
+ */
+
+extern int psb_xhw_ioctl(struct drm_device *dev, void *data,
+			 struct drm_file *file_priv);
+extern int psb_xhw_init_ioctl(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv);
+extern int psb_xhw_init(struct drm_device *dev);
+extern void psb_xhw_takedown(struct drm_psb_private *dev_priv);
+extern void psb_xhw_init_takedown(struct drm_psb_private *dev_priv,
+				  struct drm_file *file_priv, int closing);
+extern int psb_xhw_scene_bind_fire(struct drm_psb_private *dev_priv,
+				   struct psb_xhw_buf *buf,
+				   uint32_t fire_flags,
+				   uint32_t hw_context,
+				   uint32_t * cookie,
+				   uint32_t * oom_cmds,
+				   uint32_t num_oom_cmds,
+				   uint32_t offset,
+				   uint32_t engine, uint32_t flags);
+extern int psb_xhw_fire_raster(struct drm_psb_private *dev_priv,
+			       struct psb_xhw_buf *buf, uint32_t fire_flags);
+extern int psb_xhw_scene_info(struct drm_psb_private *dev_priv,
+			      struct psb_xhw_buf *buf,
+			      uint32_t w,
+			      uint32_t h,
+			      uint32_t * hw_cookie,
+			      uint32_t * bo_size,
+			      uint32_t * clear_p_start,
+			      uint32_t * clear_num_pages);
+
+extern int psb_xhw_reset_dpm(struct drm_psb_private *dev_priv,
+			     struct psb_xhw_buf *buf);
+extern int psb_xhw_ta_mem_info(struct drm_psb_private *dev_priv,
+				struct psb_xhw_buf *buf,
+				uint32_t pages,
+				uint32_t * hw_cookie, uint32_t * size);
+extern int psb_xhw_ta_oom(struct drm_psb_private *dev_priv,
+			  struct psb_xhw_buf *buf, uint32_t * cookie);
+extern void psb_xhw_ta_oom_reply(struct drm_psb_private *dev_priv,
+				 struct psb_xhw_buf *buf,
+				 uint32_t * cookie,
+				 uint32_t * bca,
+				 uint32_t * rca, uint32_t * flags);
+extern int psb_xhw_vistest(struct drm_psb_private *dev_priv,
+			   struct psb_xhw_buf *buf);
+extern int psb_xhw_handler(struct drm_psb_private *dev_priv);
+extern int psb_xhw_resume(struct drm_psb_private *dev_priv,
+			  struct psb_xhw_buf *buf);
+extern void psb_xhw_fire_reply(struct drm_psb_private *dev_priv,
+			       struct psb_xhw_buf *buf, uint32_t * cookie);
+extern int psb_xhw_ta_mem_load(struct drm_psb_private *dev_priv,
+				struct psb_xhw_buf *buf,
+				uint32_t flags, 
+				uint32_t param_offset, 
+				uint32_t pt_offset,
+				uint32_t *hw_cookie);
+extern void psb_xhw_clean_buf(struct drm_psb_private *dev_priv,
+			      struct psb_xhw_buf *buf);
+
+/*
+ * Utilities
+ */
+
+#define PSB_ALIGN_TO(_val, _align) \
+  (((_val) + ((_align) - 1)) & ~((_align) - 1))
+#define PSB_WVDC32(_val, _offs) \
+  iowrite32(_val, dev_priv->vdc_reg + (_offs))
+#define PSB_RVDC32(_offs) \
+  ioread32(dev_priv->vdc_reg + (_offs))
+#define PSB_WSGX32(_val, _offs) \
+  iowrite32(_val, dev_priv->sgx_reg + (_offs))
+#define PSB_RSGX32(_offs) \
+  ioread32(dev_priv->sgx_reg + (_offs))
+#define PSB_WMSVDX32(_val, _offs) \
+  iowrite32(_val, dev_priv->msvdx_reg + (_offs))
+#define PSB_RMSVDX32(_offs) \
+  ioread32(dev_priv->msvdx_reg + (_offs))
+
+#define PSB_ALPL(_val, _base)			\
+  (((_val) >> (_base ## _ALIGNSHIFT)) << (_base ## _SHIFT))
+#define PSB_ALPLM(_val, _base)			\
+  ((((_val) >> (_base ## _ALIGNSHIFT)) << (_base ## _SHIFT)) & (_base ## _MASK))
+
+static inline psb_fixed psb_mul_fixed(psb_fixed a, psb_fixed b)
+{
+	s64 tmp;
+	s64 a64 = (s64) a;
+	s64 b64 = (s64) b;
+
+	tmp = a64 * b64;
+	return tmp / (1ULL << PSB_FIXED_SHIFT) +
+	    ((tmp & 0x80000000ULL) ? 1 : 0);
+}
+
+static inline psb_fixed psb_mul_ufixed(psb_ufixed a, psb_fixed b)
+{
+	u64 tmp;
+	u64 a64 = (u64) a;
+	u64 b64 = (u64) b;
+
+	tmp = a64 * b64;
+	return (tmp >> PSB_FIXED_SHIFT) + ((tmp & 0x80000000ULL) ? 1 : 0);
+}
+
+static inline uint32_t psb_ufixed_to_float32(psb_ufixed a)
+{
+	uint32_t exp = 0x7f + 7;
+	uint32_t mantissa = (uint32_t) a;
+
+	if (a == 0)
+		return 0;
+	while ((mantissa & 0xff800000) == 0) {
+		exp -= 1;
+		mantissa <<= 1;
+	}
+	while ((mantissa & 0xff800000) > 0x00800000) {
+		exp += 1;
+		mantissa >>= 1;
+	}
+	return (mantissa & ~0xff800000) | (exp << 23);
+}
+
+static inline uint32_t psb_fixed_to_float32(psb_fixed a)
+{
+	if (a < 0)
+		return psb_ufixed_to_float32(-a) | 0x80000000;
+	else
+		return psb_ufixed_to_float32(a);
+}
+
+#define PSB_D_RENDER  (1 << 16)
+
+#define PSB_D_GENERAL (1 << 0)
+#define PSB_D_INIT    (1 << 1)
+#define PSB_D_IRQ     (1 << 2)
+#define PSB_D_FW      (1 << 3)
+#define PSB_D_PERF    (1 << 4)
+#define PSB_D_TMP    (1 << 5)
+
+extern int drm_psb_debug;
+extern int drm_psb_no_fb;
+extern int drm_psb_disable_vsync;
+
+#define PSB_DEBUG_FW(_fmt, _arg...) \
+	PSB_DEBUG(PSB_D_FW, _fmt, ##_arg)
+#define PSB_DEBUG_GENERAL(_fmt, _arg...) \
+	PSB_DEBUG(PSB_D_GENERAL, _fmt, ##_arg)
+#define PSB_DEBUG_INIT(_fmt, _arg...) \
+	PSB_DEBUG(PSB_D_INIT, _fmt, ##_arg)
+#define PSB_DEBUG_IRQ(_fmt, _arg...) \
+	PSB_DEBUG(PSB_D_IRQ, _fmt, ##_arg)
+#define PSB_DEBUG_RENDER(_fmt, _arg...) \
+	PSB_DEBUG(PSB_D_RENDER, _fmt, ##_arg)
+#define PSB_DEBUG_PERF(_fmt, _arg...) \
+	PSB_DEBUG(PSB_D_PERF, _fmt, ##_arg)
+#define PSB_DEBUG_TMP(_fmt, _arg...) \
+	PSB_DEBUG(PSB_D_TMP, _fmt, ##_arg)
+
+#if DRM_DEBUG_CODE
+#define PSB_DEBUG(_flag, _fmt, _arg...)					\
+	do {								\
+		if ((_flag) & drm_psb_debug)				\
+			printk(KERN_DEBUG				\
+			       "[psb:0x%02x:%s] " _fmt , _flag,	\
+			       __FUNCTION__ , ##_arg);			\
+	} while (0)
+#else
+#define PSB_DEBUG(_fmt, _arg...)     do { } while (0)
+#endif
+
+#endif
Index: git/shared-core/psb_reg.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/psb_reg.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,555 @@
+/**************************************************************************
+ *
+ * Copyright (c) (2005-2007) Imagination Technologies Limited.
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
+ * develop this driver.
+ *
+ **************************************************************************/
+/*
+ */
+#ifndef _PSB_REG_H_
+#define _PSB_REG_H_
+
+#define PSB_CR_CLKGATECTL                0x0000
+#define _PSB_C_CLKGATECTL_AUTO_MAN_REG   (1 << 24)
+#define _PSB_C_CLKGATECTL_USE_CLKG_SHIFT (20)
+#define _PSB_C_CLKGATECTL_USE_CLKG_MASK  (0x3 << 20)
+#define _PSB_C_CLKGATECTL_DPM_CLKG_SHIFT (16)
+#define _PSB_C_CLKGATECTL_DPM_CLKG_MASK  (0x3 << 16)
+#define _PSB_C_CLKGATECTL_TA_CLKG_SHIFT  (12)
+#define _PSB_C_CLKGATECTL_TA_CLKG_MASK   (0x3 << 12)
+#define _PSB_C_CLKGATECTL_TSP_CLKG_SHIFT (8)
+#define _PSB_C_CLKGATECTL_TSP_CLKG_MASK  (0x3 << 8)
+#define _PSB_C_CLKGATECTL_ISP_CLKG_SHIFT (4)
+#define _PSB_C_CLKGATECTL_ISP_CLKG_MASK  (0x3 << 4)
+#define _PSB_C_CLKGATECTL_2D_CLKG_SHIFT  (0)
+#define _PSB_C_CLKGATECTL_2D_CLKG_MASK   (0x3 << 0)
+#define _PSB_C_CLKGATECTL_CLKG_ENABLED   (0)
+#define _PSB_C_CLKGATECTL_CLKG_DISABLED  (1)
+#define _PSB_C_CLKGATECTL_CLKG_AUTO      (2)
+
+#define PSB_CR_CORE_ID                   0x0010
+#define _PSB_CC_ID_ID_SHIFT              (16)
+#define _PSB_CC_ID_ID_MASK               (0xFFFF << 16)
+#define _PSB_CC_ID_CONFIG_SHIFT          (0)
+#define _PSB_CC_ID_CONFIG_MASK           (0xFFFF << 0)
+
+#define PSB_CR_CORE_REVISION               0x0014
+#define _PSB_CC_REVISION_DESIGNER_SHIFT    (24)
+#define _PSB_CC_REVISION_DESIGNER_MASK     (0xFF << 24)
+#define _PSB_CC_REVISION_MAJOR_SHIFT       (16)
+#define _PSB_CC_REVISION_MAJOR_MASK        (0xFF << 16)
+#define _PSB_CC_REVISION_MINOR_SHIFT       (8)
+#define _PSB_CC_REVISION_MINOR_MASK        (0xFF << 8)
+#define _PSB_CC_REVISION_MAINTENANCE_SHIFT (0)
+#define _PSB_CC_REVISION_MAINTENANCE_MASK  (0xFF << 0)
+
+#define PSB_CR_DESIGNER_REV_FIELD1       0x0018
+
+#define PSB_CR_SOFT_RESET                0x0080
+#define _PSB_CS_RESET_TSP_RESET          (1 << 6)
+#define _PSB_CS_RESET_ISP_RESET          (1 << 5)
+#define _PSB_CS_RESET_USE_RESET          (1 << 4)
+#define _PSB_CS_RESET_TA_RESET           (1 << 3)
+#define _PSB_CS_RESET_DPM_RESET          (1 << 2)
+#define _PSB_CS_RESET_TWOD_RESET         (1 << 1)
+#define _PSB_CS_RESET_BIF_RESET          (1 << 0)
+
+#define PSB_CR_DESIGNER_REV_FIELD2       0x001C
+
+#define PSB_CR_EVENT_STATUS              0x012C
+
+#define PSB_CR_EVENT_HOST_ENABLE         0x0130
+
+#define PSB_CR_EVENT_HOST_CLEAR          0x0134
+#define _PSB_CE_MASTER_INTERRUPT         (1 << 31)
+#define _PSB_CE_TA_DPM_FAULT             (1 << 28)
+#define _PSB_CE_TWOD_COMPLETE            (1 << 27)
+#define _PSB_CE_DPM_OUT_OF_MEMORY_ZLS    (1 << 25)
+#define _PSB_CE_DPM_TA_MEM_FREE          (1 << 24)
+#define _PSB_CE_PIXELBE_END_RENDER       (1 << 18)
+#define _PSB_CE_SW_EVENT                 (1 << 14)
+#define _PSB_CE_TA_FINISHED              (1 << 13)
+#define _PSB_CE_TA_TERMINATE             (1 << 12)
+#define _PSB_CE_DPM_REACHED_MEM_THRESH   (1 << 3)
+#define _PSB_CE_DPM_OUT_OF_MEMORY_GBL    (1 << 2)
+#define _PSB_CE_DPM_OUT_OF_MEMORY_MT     (1 << 1)
+#define _PSB_CE_DPM_3D_MEM_FREE          (1 << 0)
+
+
+#define PSB_USE_OFFSET_MASK              0x0007FFFF
+#define PSB_USE_OFFSET_SIZE              (PSB_USE_OFFSET_MASK + 1)
+#define PSB_CR_USE_CODE_BASE0            0x0A0C
+#define PSB_CR_USE_CODE_BASE1            0x0A10
+#define PSB_CR_USE_CODE_BASE2            0x0A14
+#define PSB_CR_USE_CODE_BASE3            0x0A18
+#define PSB_CR_USE_CODE_BASE4            0x0A1C
+#define PSB_CR_USE_CODE_BASE5            0x0A20
+#define PSB_CR_USE_CODE_BASE6            0x0A24
+#define PSB_CR_USE_CODE_BASE7            0x0A28
+#define PSB_CR_USE_CODE_BASE8            0x0A2C
+#define PSB_CR_USE_CODE_BASE9            0x0A30
+#define PSB_CR_USE_CODE_BASE10           0x0A34
+#define PSB_CR_USE_CODE_BASE11           0x0A38
+#define PSB_CR_USE_CODE_BASE12           0x0A3C
+#define PSB_CR_USE_CODE_BASE13           0x0A40
+#define PSB_CR_USE_CODE_BASE14           0x0A44
+#define PSB_CR_USE_CODE_BASE15           0x0A48
+#define PSB_CR_USE_CODE_BASE(_i) (0x0A0C + ((_i) << 2))
+#define _PSB_CUC_BASE_DM_SHIFT           (25)
+#define _PSB_CUC_BASE_DM_MASK            (0x3 << 25)
+#define _PSB_CUC_BASE_ADDR_SHIFT         (0) // 1024-bit aligned address?
+#define _PSB_CUC_BASE_ADDR_ALIGNSHIFT    (7)
+#define _PSB_CUC_BASE_ADDR_MASK          (0x1FFFFFF << 0)
+#define _PSB_CUC_DM_VERTEX		 (0)
+#define _PSB_CUC_DM_PIXEL		 (1)
+#define _PSB_CUC_DM_RESERVED		 (2)
+#define _PSB_CUC_DM_EDM	                 (3)
+
+#define PSB_CR_PDS_EXEC_BASE             0x0AB8
+#define _PSB_CR_PDS_EXEC_BASE_ADDR_SHIFT (20) // 1MB aligned address
+#define _PSB_CR_PDS_EXEC_BASE_ADDR_ALIGNSHIFT (20)
+
+#define PSB_CR_EVENT_KICKER              0x0AC4
+#define _PSB_CE_KICKER_ADDRESS_SHIFT     (4) // 128-bit aligned address
+
+#define PSB_CR_EVENT_KICK                0x0AC8
+#define _PSB_CE_KICK_NOW                 (1 << 0)
+
+
+#define PSB_CR_BIF_DIR_LIST_BASE1        0x0C38
+
+#define PSB_CR_BIF_CTRL                  0x0C00
+#define _PSB_CB_CTRL_CLEAR_FAULT         (1 << 4)
+#define _PSB_CB_CTRL_INVALDC             (1 << 3)
+#define _PSB_CB_CTRL_FLUSH               (1 << 2)
+
+#define PSB_CR_BIF_INT_STAT              0x0C04
+
+#define PSB_CR_BIF_FAULT                 0x0C08
+#define _PSB_CBI_STAT_PF_N_RW            (1 << 14)
+#define _PSB_CBI_STAT_FAULT_SHIFT        (0)
+#define _PSB_CBI_STAT_FAULT_MASK         (0x3FFF << 0)
+#define _PSB_CBI_STAT_FAULT_CACHE        (1 << 1)
+#define _PSB_CBI_STAT_FAULT_TA           (1 << 2)
+#define _PSB_CBI_STAT_FAULT_VDM          (1 << 3)
+#define _PSB_CBI_STAT_FAULT_2D           (1 << 4)
+#define _PSB_CBI_STAT_FAULT_PBE          (1 << 5)
+#define _PSB_CBI_STAT_FAULT_TSP          (1 << 6)
+#define _PSB_CBI_STAT_FAULT_ISP          (1 << 7)
+#define _PSB_CBI_STAT_FAULT_USSEPDS      (1 << 8)
+#define _PSB_CBI_STAT_FAULT_HOST         (1 << 9)
+
+#define PSB_CR_BIF_BANK0                 0x0C78
+
+#define PSB_CR_BIF_BANK1                 0x0C7C
+
+#define PSB_CR_BIF_DIR_LIST_BASE0        0x0C84
+
+#define PSB_CR_BIF_TWOD_REQ_BASE         0x0C88
+#define PSB_CR_BIF_3D_REQ_BASE           0x0CAC
+
+#define PSB_CR_2D_SOCIF                  0x0E18
+#define _PSB_C2_SOCIF_FREESPACE_SHIFT    (0)
+#define _PSB_C2_SOCIF_FREESPACE_MASK     (0xFF << 0)
+#define _PSB_C2_SOCIF_EMPTY              (0x80 << 0)
+
+#define PSB_CR_2D_BLIT_STATUS            0x0E04
+#define _PSB_C2B_STATUS_BUSY             (1 << 24)
+#define _PSB_C2B_STATUS_COMPLETE_SHIFT   (0)
+#define _PSB_C2B_STATUS_COMPLETE_MASK    (0xFFFFFF << 0)
+
+/*
+ * 2D defs.
+ */
+
+/*
+ * 2D Slave Port Data : Block Header's Object Type
+ */
+
+#define	PSB_2D_CLIP_BH                   (0x00000000)
+#define	PSB_2D_PAT_BH                    (0x10000000)
+#define	PSB_2D_CTRL_BH                   (0x20000000)
+#define	PSB_2D_SRC_OFF_BH                (0x30000000)
+#define	PSB_2D_MASK_OFF_BH               (0x40000000)
+#define	PSB_2D_RESERVED1_BH              (0x50000000)
+#define	PSB_2D_RESERVED2_BH              (0x60000000)
+#define	PSB_2D_FENCE_BH                  (0x70000000)
+#define	PSB_2D_BLIT_BH                   (0x80000000)
+#define	PSB_2D_SRC_SURF_BH               (0x90000000)
+#define	PSB_2D_DST_SURF_BH               (0xA0000000)
+#define	PSB_2D_PAT_SURF_BH               (0xB0000000)
+#define	PSB_2D_SRC_PAL_BH                (0xC0000000)
+#define	PSB_2D_PAT_PAL_BH                (0xD0000000)
+#define	PSB_2D_MASK_SURF_BH              (0xE0000000)
+#define	PSB_2D_FLUSH_BH                  (0xF0000000)
+
+/*
+ * Clip Definition block (PSB_2D_CLIP_BH)
+ */
+#define PSB_2D_CLIPCOUNT_MAX             (1)
+#define PSB_2D_CLIPCOUNT_MASK            (0x00000000)
+#define PSB_2D_CLIPCOUNT_CLRMASK         (0xFFFFFFFF)
+#define PSB_2D_CLIPCOUNT_SHIFT           (0)
+// clip rectangle min & max
+#define PSB_2D_CLIP_XMAX_MASK            (0x00FFF000)
+#define PSB_2D_CLIP_XMAX_CLRMASK         (0xFF000FFF)
+#define PSB_2D_CLIP_XMAX_SHIFT           (12)
+#define PSB_2D_CLIP_XMIN_MASK            (0x00000FFF)
+#define PSB_2D_CLIP_XMIN_CLRMASK         (0x00FFF000)
+#define PSB_2D_CLIP_XMIN_SHIFT           (0)
+// clip rectangle offset
+#define PSB_2D_CLIP_YMAX_MASK            (0x00FFF000)
+#define PSB_2D_CLIP_YMAX_CLRMASK         (0xFF000FFF)
+#define PSB_2D_CLIP_YMAX_SHIFT           (12)
+#define PSB_2D_CLIP_YMIN_MASK            (0x00000FFF)
+#define PSB_2D_CLIP_YMIN_CLRMASK         (0x00FFF000)
+#define PSB_2D_CLIP_YMIN_SHIFT           (0)
+
+/*
+ * Pattern Control (PSB_2D_PAT_BH)
+ */
+#define PSB_2D_PAT_HEIGHT_MASK           (0x0000001F)
+#define PSB_2D_PAT_HEIGHT_SHIFT          (0)
+#define PSB_2D_PAT_WIDTH_MASK            (0x000003E0)
+#define PSB_2D_PAT_WIDTH_SHIFT           (5)
+#define PSB_2D_PAT_YSTART_MASK           (0x00007C00)
+#define PSB_2D_PAT_YSTART_SHIFT          (10)
+#define PSB_2D_PAT_XSTART_MASK           (0x000F8000)
+#define PSB_2D_PAT_XSTART_SHIFT          (15)
+
+/*
+ * 2D Control block (PSB_2D_CTRL_BH)
+ */
+// Present Flags
+#define PSB_2D_SRCCK_CTRL                (0x00000001)
+#define PSB_2D_DSTCK_CTRL                (0x00000002)
+#define PSB_2D_ALPHA_CTRL                (0x00000004)
+// Colour Key Colour (SRC/DST)
+#define PSB_2D_CK_COL_MASK               (0xFFFFFFFF)
+#define PSB_2D_CK_COL_CLRMASK            (0x00000000)
+#define PSB_2D_CK_COL_SHIFT              (0)
+// Colour Key Mask (SRC/DST)
+#define PSB_2D_CK_MASK_MASK              (0xFFFFFFFF)
+#define PSB_2D_CK_MASK_CLRMASK           (0x00000000)
+#define PSB_2D_CK_MASK_SHIFT             (0)
+// Alpha Control (Alpha/RGB)
+#define PSB_2D_GBLALPHA_MASK             (0x000FF000)
+#define PSB_2D_GBLALPHA_CLRMASK          (0xFFF00FFF)
+#define PSB_2D_GBLALPHA_SHIFT            (12)
+#define PSB_2D_SRCALPHA_OP_MASK          (0x00700000)
+#define PSB_2D_SRCALPHA_OP_CLRMASK       (0xFF8FFFFF)
+#define PSB_2D_SRCALPHA_OP_SHIFT         (20)
+#define PSB_2D_SRCALPHA_OP_ONE           (0x00000000)
+#define PSB_2D_SRCALPHA_OP_SRC           (0x00100000)
+#define PSB_2D_SRCALPHA_OP_DST           (0x00200000)
+#define PSB_2D_SRCALPHA_OP_SG            (0x00300000)
+#define PSB_2D_SRCALPHA_OP_DG            (0x00400000)
+#define PSB_2D_SRCALPHA_OP_GBL           (0x00500000)
+#define PSB_2D_SRCALPHA_OP_ZERO          (0x00600000)
+#define PSB_2D_SRCALPHA_INVERT           (0x00800000)
+#define PSB_2D_SRCALPHA_INVERT_CLR       (0xFF7FFFFF)
+#define PSB_2D_DSTALPHA_OP_MASK          (0x07000000)
+#define PSB_2D_DSTALPHA_OP_CLRMASK       (0xF8FFFFFF)
+#define PSB_2D_DSTALPHA_OP_SHIFT         (24)
+#define PSB_2D_DSTALPHA_OP_ONE           (0x00000000)
+#define PSB_2D_DSTALPHA_OP_SRC           (0x01000000)
+#define PSB_2D_DSTALPHA_OP_DST           (0x02000000)
+#define PSB_2D_DSTALPHA_OP_SG            (0x03000000)
+#define PSB_2D_DSTALPHA_OP_DG            (0x04000000)
+#define PSB_2D_DSTALPHA_OP_GBL           (0x05000000)
+#define PSB_2D_DSTALPHA_OP_ZERO          (0x06000000)
+#define PSB_2D_DSTALPHA_INVERT           (0x08000000)
+#define PSB_2D_DSTALPHA_INVERT_CLR       (0xF7FFFFFF)
+
+#define PSB_2D_PRE_MULTIPLICATION_ENABLE  (0x10000000)
+#define PSB_2D_PRE_MULTIPLICATION_CLRMASK (0xEFFFFFFF)
+#define PSB_2D_ZERO_SOURCE_ALPHA_ENABLE   (0x20000000)
+#define PSB_2D_ZERO_SOURCE_ALPHA_CLRMASK  (0xDFFFFFFF)
+
+/*
+ *Source Offset (PSB_2D_SRC_OFF_BH)
+ */
+#define PSB_2D_SRCOFF_XSTART_MASK        ((0x00000FFF) << 12)
+#define PSB_2D_SRCOFF_XSTART_SHIFT       (12)
+#define PSB_2D_SRCOFF_YSTART_MASK        (0x00000FFF)
+#define PSB_2D_SRCOFF_YSTART_SHIFT       (0)
+
+/*
+ * Mask Offset (PSB_2D_MASK_OFF_BH)
+ */
+#define PSB_2D_MASKOFF_XSTART_MASK       ((0x00000FFF) << 12)
+#define PSB_2D_MASKOFF_XSTART_SHIFT      (12)
+#define PSB_2D_MASKOFF_YSTART_MASK       (0x00000FFF)
+#define PSB_2D_MASKOFF_YSTART_SHIFT      (0)
+
+/*
+ * 2D Fence (see PSB_2D_FENCE_BH): bits 0:27 are ignored
+ */
+
+/*
+ *Blit Rectangle (PSB_2D_BLIT_BH)
+ */
+
+#define PSB_2D_ROT_MASK                  (3<<25)
+#define PSB_2D_ROT_CLRMASK               (~PSB_2D_ROT_MASK)
+#define PSB_2D_ROT_NONE                  (0<<25)
+#define PSB_2D_ROT_90DEGS                (1<<25)
+#define PSB_2D_ROT_180DEGS               (2<<25)
+#define PSB_2D_ROT_270DEGS               (3<<25)
+
+#define PSB_2D_COPYORDER_MASK            (3<<23)
+#define PSB_2D_COPYORDER_CLRMASK         (~PSB_2D_COPYORDER_MASK)
+#define PSB_2D_COPYORDER_TL2BR           (0<<23)
+#define PSB_2D_COPYORDER_BR2TL           (1<<23)
+#define PSB_2D_COPYORDER_TR2BL           (2<<23)
+#define PSB_2D_COPYORDER_BL2TR           (3<<23)
+
+#define PSB_2D_DSTCK_CLRMASK             (0xFF9FFFFF)
+#define PSB_2D_DSTCK_DISABLE             (0x00000000)
+#define PSB_2D_DSTCK_PASS                (0x00200000)
+#define PSB_2D_DSTCK_REJECT              (0x00400000)
+
+#define PSB_2D_SRCCK_CLRMASK             (0xFFE7FFFF)
+#define PSB_2D_SRCCK_DISABLE             (0x00000000)
+#define PSB_2D_SRCCK_PASS                (0x00080000)
+#define PSB_2D_SRCCK_REJECT              (0x00100000)
+
+#define PSB_2D_CLIP_ENABLE               (0x00040000)
+
+#define PSB_2D_ALPHA_ENABLE              (0x00020000)
+
+#define PSB_2D_PAT_CLRMASK               (0xFFFEFFFF)
+#define PSB_2D_PAT_MASK                  (0x00010000)
+#define PSB_2D_USE_PAT                   (0x00010000)
+#define PSB_2D_USE_FILL                  (0x00000000)
+/*
+ * Tungsten Graphics note on rop codes: If rop A and rop B are
+ * identical, the mask surface will not be read and need not be
+ * set up.
+ */
+
+#define PSB_2D_ROP3B_MASK                (0x0000FF00)
+#define PSB_2D_ROP3B_CLRMASK             (0xFFFF00FF)
+#define PSB_2D_ROP3B_SHIFT               (8)
+// rop code A
+#define PSB_2D_ROP3A_MASK                (0x000000FF)
+#define PSB_2D_ROP3A_CLRMASK             (0xFFFFFF00)
+#define PSB_2D_ROP3A_SHIFT               (0)
+
+#define PSB_2D_ROP4_MASK                 (0x0000FFFF)
+/*
+ *	DWORD0:	(Only pass if Pattern control == Use Fill Colour)
+ *	Fill Colour RGBA8888
+ */
+#define PSB_2D_FILLCOLOUR_MASK           (0xFFFFFFFF)
+#define PSB_2D_FILLCOLOUR_SHIFT          (0)
+/*
+ *	DWORD1: (Always Present)
+ *	X Start (Dest)
+ *	Y Start (Dest)
+ */
+#define PSB_2D_DST_XSTART_MASK           (0x00FFF000)
+#define PSB_2D_DST_XSTART_CLRMASK        (0xFF000FFF)
+#define PSB_2D_DST_XSTART_SHIFT          (12)
+#define PSB_2D_DST_YSTART_MASK           (0x00000FFF)
+#define PSB_2D_DST_YSTART_CLRMASK        (0xFFFFF000)
+#define PSB_2D_DST_YSTART_SHIFT          (0)
+/*
+ *	DWORD2: (Always Present)
+ *	X Size (Dest)
+ *	Y Size (Dest)
+ */
+#define PSB_2D_DST_XSIZE_MASK            (0x00FFF000)
+#define PSB_2D_DST_XSIZE_CLRMASK         (0xFF000FFF)
+#define PSB_2D_DST_XSIZE_SHIFT           (12)
+#define PSB_2D_DST_YSIZE_MASK            (0x00000FFF)
+#define PSB_2D_DST_YSIZE_CLRMASK         (0xFFFFF000)
+#define PSB_2D_DST_YSIZE_SHIFT           (0)
+
+/*
+ * Source Surface (PSB_2D_SRC_SURF_BH)
+ */
+/*
+ *      WORD 0
+ */
+
+#define PSB_2D_SRC_FORMAT_MASK           (0x00078000)
+#define PSB_2D_SRC_1_PAL                 (0x00000000)
+#define PSB_2D_SRC_2_PAL                 (0x00008000)
+#define PSB_2D_SRC_4_PAL                 (0x00010000)
+#define PSB_2D_SRC_8_PAL                 (0x00018000)
+#define PSB_2D_SRC_8_ALPHA               (0x00020000)
+#define PSB_2D_SRC_4_ALPHA               (0x00028000)
+#define PSB_2D_SRC_332RGB                (0x00030000)
+#define PSB_2D_SRC_4444ARGB              (0x00038000)
+#define PSB_2D_SRC_555RGB                (0x00040000)
+#define PSB_2D_SRC_1555ARGB              (0x00048000)
+#define PSB_2D_SRC_565RGB                (0x00050000)
+#define PSB_2D_SRC_0888ARGB              (0x00058000)
+#define PSB_2D_SRC_8888ARGB              (0x00060000)
+#define PSB_2D_SRC_8888UYVY              (0x00068000)
+#define PSB_2D_SRC_RESERVED              (0x00070000)
+#define PSB_2D_SRC_1555ARGB_LOOKUP       (0x00078000)
+
+
+#define PSB_2D_SRC_STRIDE_MASK           (0x00007FFF)
+#define PSB_2D_SRC_STRIDE_CLRMASK        (0xFFFF8000)
+#define PSB_2D_SRC_STRIDE_SHIFT          (0)
+/*
+ *  WORD 1 - Base Address
+ */
+#define PSB_2D_SRC_ADDR_MASK             (0x0FFFFFFC)
+#define PSB_2D_SRC_ADDR_CLRMASK          (0x00000003)
+#define PSB_2D_SRC_ADDR_SHIFT            (2)
+#define PSB_2D_SRC_ADDR_ALIGNSHIFT       (2)
+
+/*
+ * Pattern Surface (PSB_2D_PAT_SURF_BH)
+ */
+/*
+ *  WORD 0
+ */
+
+#define PSB_2D_PAT_FORMAT_MASK           (0x00078000)
+#define PSB_2D_PAT_1_PAL                 (0x00000000)
+#define PSB_2D_PAT_2_PAL                 (0x00008000)
+#define PSB_2D_PAT_4_PAL                 (0x00010000)
+#define PSB_2D_PAT_8_PAL                 (0x00018000)
+#define PSB_2D_PAT_8_ALPHA               (0x00020000)
+#define PSB_2D_PAT_4_ALPHA               (0x00028000)
+#define PSB_2D_PAT_332RGB                (0x00030000)
+#define PSB_2D_PAT_4444ARGB              (0x00038000)
+#define PSB_2D_PAT_555RGB                (0x00040000)
+#define PSB_2D_PAT_1555ARGB              (0x00048000)
+#define PSB_2D_PAT_565RGB                (0x00050000)
+#define PSB_2D_PAT_0888ARGB              (0x00058000)
+#define PSB_2D_PAT_8888ARGB              (0x00060000)
+
+#define PSB_2D_PAT_STRIDE_MASK           (0x00007FFF)
+#define PSB_2D_PAT_STRIDE_CLRMASK        (0xFFFF8000)
+#define PSB_2D_PAT_STRIDE_SHIFT          (0)
+/*
+ *  WORD 1 - Base Address
+ */
+#define PSB_2D_PAT_ADDR_MASK             (0x0FFFFFFC)
+#define PSB_2D_PAT_ADDR_CLRMASK          (0x00000003)
+#define PSB_2D_PAT_ADDR_SHIFT            (2)
+#define PSB_2D_PAT_ADDR_ALIGNSHIFT       (2)
+
+/*
+ * Destination Surface (PSB_2D_DST_SURF_BH)
+ */
+/*
+ * WORD 0
+ */
+
+#define PSB_2D_DST_FORMAT_MASK           (0x00078000)
+#define PSB_2D_DST_332RGB                (0x00030000)
+#define PSB_2D_DST_4444ARGB              (0x00038000)
+#define PSB_2D_DST_555RGB                (0x00040000)
+#define PSB_2D_DST_1555ARGB              (0x00048000)
+#define PSB_2D_DST_565RGB                (0x00050000)
+#define PSB_2D_DST_0888ARGB              (0x00058000)
+#define PSB_2D_DST_8888ARGB              (0x00060000)
+#define PSB_2D_DST_8888AYUV              (0x00070000)
+
+#define PSB_2D_DST_STRIDE_MASK           (0x00007FFF)
+#define PSB_2D_DST_STRIDE_CLRMASK        (0xFFFF8000)
+#define PSB_2D_DST_STRIDE_SHIFT          (0)
+/*
+ * WORD 1 - Base Address
+ */
+#define PSB_2D_DST_ADDR_MASK             (0x0FFFFFFC)
+#define PSB_2D_DST_ADDR_CLRMASK          (0x00000003)
+#define PSB_2D_DST_ADDR_SHIFT            (2)
+#define PSB_2D_DST_ADDR_ALIGNSHIFT       (2)
+
+/*
+ * Mask Surface (PSB_2D_MASK_SURF_BH)
+ */
+/*
+ * WORD 0
+ */
+#define PSB_2D_MASK_STRIDE_MASK          (0x00007FFF)
+#define PSB_2D_MASK_STRIDE_CLRMASK       (0xFFFF8000)
+#define PSB_2D_MASK_STRIDE_SHIFT         (0)
+/*
+ *  WORD 1 - Base Address
+ */
+#define PSB_2D_MASK_ADDR_MASK            (0x0FFFFFFC)
+#define PSB_2D_MASK_ADDR_CLRMASK         (0x00000003)
+#define PSB_2D_MASK_ADDR_SHIFT           (2)
+#define PSB_2D_MASK_ADDR_ALIGNSHIFT      (2)
+
+/*
+ * Source Palette (PSB_2D_SRC_PAL_BH)
+ */
+
+#define PSB_2D_SRCPAL_ADDR_SHIFT         (0)
+#define PSB_2D_SRCPAL_ADDR_CLRMASK       (0xF0000007)
+#define PSB_2D_SRCPAL_ADDR_MASK          (0x0FFFFFF8)
+#define PSB_2D_SRCPAL_BYTEALIGN          (1024)
+
+/*
+ * Pattern Palette (PSB_2D_PAT_PAL_BH)
+ */
+
+#define PSB_2D_PATPAL_ADDR_SHIFT         (0)
+#define PSB_2D_PATPAL_ADDR_CLRMASK       (0xF0000007)
+#define PSB_2D_PATPAL_ADDR_MASK          (0x0FFFFFF8)
+#define PSB_2D_PATPAL_BYTEALIGN          (1024)
+
+/*
+ * Rop3 Codes (2 LS bytes)
+ */
+
+#define PSB_2D_ROP3_SRCCOPY              (0xCCCC)
+#define PSB_2D_ROP3_PATCOPY              (0xF0F0)
+#define PSB_2D_ROP3_WHITENESS            (0xFFFF)
+#define PSB_2D_ROP3_BLACKNESS            (0x0000)
+#define PSB_2D_ROP3_SRC                  (0xCC)
+#define PSB_2D_ROP3_PAT                  (0xF0)
+#define PSB_2D_ROP3_DST                  (0xAA)
+
+
+/*
+ * Sizes.
+ */
+
+#define PSB_SCENE_HW_COOKIE_SIZE 16
+#define PSB_TA_MEM_HW_COOKIE_SIZE 16
+
+/*
+ * Scene stuff.
+ */
+
+#define PSB_NUM_HW_SCENES          2
+
+/*
+ * Scheduler completion actions.
+ */
+
+#define PSB_RASTER_BLOCK 0
+#define PSB_RASTER       1
+#define PSB_RETURN       2
+#define PSB_TA       3
+
+
+#endif
Index: git/shared-core/r128_cce.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/r128_cce.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,932 @@
+/* r128_cce.c -- ATI Rage 128 driver -*- linux-c -*-
+ * Created: Wed Apr  5 19:24:19 2000 by kevin@precisioninsight.com
+ */
+/*
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "r128_drm.h"
+#include "r128_drv.h"
+
+#define R128_FIFO_DEBUG		0
+
+/* CCE microcode (from ATI) */
+static u32 r128_cce_microcode[] = {
+	0, 276838400, 0, 268449792, 2, 142, 2, 145, 0, 1076765731, 0,
+	1617039951, 0, 774592877, 0, 1987540286, 0, 2307490946U, 0,
+	599558925, 0, 589505315, 0, 596487092, 0, 589505315, 1,
+	11544576, 1, 206848, 1, 311296, 1, 198656, 2, 912273422, 11,
+	262144, 0, 0, 1, 33559837, 1, 7438, 1, 14809, 1, 6615, 12, 28,
+	1, 6614, 12, 28, 2, 23, 11, 18874368, 0, 16790922, 1, 409600, 9,
+	30, 1, 147854772, 16, 420483072, 3, 8192, 0, 10240, 1, 198656,
+	1, 15630, 1, 51200, 10, 34858, 9, 42, 1, 33559823, 2, 10276, 1,
+	15717, 1, 15718, 2, 43, 1, 15936948, 1, 570480831, 1, 14715071,
+	12, 322123831, 1, 33953125, 12, 55, 1, 33559908, 1, 15718, 2,
+	46, 4, 2099258, 1, 526336, 1, 442623, 4, 4194365, 1, 509952, 1,
+	459007, 3, 0, 12, 92, 2, 46, 12, 176, 1, 15734, 1, 206848, 1,
+	18432, 1, 133120, 1, 100670734, 1, 149504, 1, 165888, 1,
+	15975928, 1, 1048576, 6, 3145806, 1, 15715, 16, 2150645232U, 2,
+	268449859, 2, 10307, 12, 176, 1, 15734, 1, 15735, 1, 15630, 1,
+	15631, 1, 5253120, 6, 3145810, 16, 2150645232U, 1, 15864, 2, 82,
+	1, 343310, 1, 1064207, 2, 3145813, 1, 15728, 1, 7817, 1, 15729,
+	3, 15730, 12, 92, 2, 98, 1, 16168, 1, 16167, 1, 16002, 1, 16008,
+	1, 15974, 1, 15975, 1, 15990, 1, 15976, 1, 15977, 1, 15980, 0,
+	15981, 1, 10240, 1, 5253120, 1, 15720, 1, 198656, 6, 110, 1,
+	180224, 1, 103824738, 2, 112, 2, 3145839, 0, 536885440, 1,
+	114880, 14, 125, 12, 206975, 1, 33559995, 12, 198784, 0,
+	33570236, 1, 15803, 0, 15804, 3, 294912, 1, 294912, 3, 442370,
+	1, 11544576, 0, 811612160, 1, 12593152, 1, 11536384, 1,
+	14024704, 7, 310382726, 0, 10240, 1, 14796, 1, 14797, 1, 14793,
+	1, 14794, 0, 14795, 1, 268679168, 1, 9437184, 1, 268449792, 1,
+	198656, 1, 9452827, 1, 1075854602, 1, 1075854603, 1, 557056, 1,
+	114880, 14, 159, 12, 198784, 1, 1109409213, 12, 198783, 1,
+	1107312059, 12, 198784, 1, 1109409212, 2, 162, 1, 1075854781, 1,
+	1073757627, 1, 1075854780, 1, 540672, 1, 10485760, 6, 3145894,
+	16, 274741248, 9, 168, 3, 4194304, 3, 4209949, 0, 0, 0, 256, 14,
+	174, 1, 114857, 1, 33560007, 12, 176, 0, 10240, 1, 114858, 1,
+	33560018, 1, 114857, 3, 33560007, 1, 16008, 1, 114874, 1,
+	33560360, 1, 114875, 1, 33560154, 0, 15963, 0, 256, 0, 4096, 1,
+	409611, 9, 188, 0, 10240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+static int R128_READ_PLL(struct drm_device * dev, int addr)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+
+	R128_WRITE8(R128_CLOCK_CNTL_INDEX, addr & 0x1f);
+	return R128_READ(R128_CLOCK_CNTL_DATA);
+}
+
+#if R128_FIFO_DEBUG
+static void r128_status(drm_r128_private_t * dev_priv)
+{
+	printk("GUI_STAT           = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_GUI_STAT));
+	printk("PM4_STAT           = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_PM4_STAT));
+	printk("PM4_BUFFER_DL_WPTR = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_PM4_BUFFER_DL_WPTR));
+	printk("PM4_BUFFER_DL_RPTR = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_PM4_BUFFER_DL_RPTR));
+	printk("PM4_MICRO_CNTL     = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_PM4_MICRO_CNTL));
+	printk("PM4_BUFFER_CNTL    = 0x%08x\n",
+	       (unsigned int)R128_READ(R128_PM4_BUFFER_CNTL));
+}
+#endif
+
+/* ================================================================
+ * Engine, FIFO control
+ */
+
+static int r128_do_pixcache_flush(drm_r128_private_t * dev_priv)
+{
+	u32 tmp;
+	int i;
+
+	tmp = R128_READ(R128_PC_NGUI_CTLSTAT) | R128_PC_FLUSH_ALL;
+	R128_WRITE(R128_PC_NGUI_CTLSTAT, tmp);
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (!(R128_READ(R128_PC_NGUI_CTLSTAT) & R128_PC_BUSY)) {
+			return 0;
+		}
+		DRM_UDELAY(1);
+	}
+
+#if R128_FIFO_DEBUG
+	DRM_ERROR("failed!\n");
+#endif
+	return -EBUSY;
+}
+
+static int r128_do_wait_for_fifo(drm_r128_private_t * dev_priv, int entries)
+{
+	int i;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		int slots = R128_READ(R128_GUI_STAT) & R128_GUI_FIFOCNT_MASK;
+		if (slots >= entries)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if R128_FIFO_DEBUG
+	DRM_ERROR("failed!\n");
+#endif
+	return -EBUSY;
+}
+
+static int r128_do_wait_for_idle(drm_r128_private_t * dev_priv)
+{
+	int i, ret;
+
+	ret = r128_do_wait_for_fifo(dev_priv, 64);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (!(R128_READ(R128_GUI_STAT) & R128_GUI_ACTIVE)) {
+			r128_do_pixcache_flush(dev_priv);
+			return 0;
+		}
+		DRM_UDELAY(1);
+	}
+
+#if R128_FIFO_DEBUG
+	DRM_ERROR("failed!\n");
+#endif
+	return -EBUSY;
+}
+
+/* ================================================================
+ * CCE control, initialization
+ */
+
+/* Load the microcode for the CCE */
+static void r128_cce_load_microcode(drm_r128_private_t * dev_priv)
+{
+	int i;
+
+	DRM_DEBUG("\n");
+
+	r128_do_wait_for_idle(dev_priv);
+
+	R128_WRITE(R128_PM4_MICROCODE_ADDR, 0);
+	for (i = 0; i < 256; i++) {
+		R128_WRITE(R128_PM4_MICROCODE_DATAH, r128_cce_microcode[i * 2]);
+		R128_WRITE(R128_PM4_MICROCODE_DATAL,
+			   r128_cce_microcode[i * 2 + 1]);
+	}
+}
+
+/* Flush any pending commands to the CCE.  This should only be used just
+ * prior to a wait for idle, as it informs the engine that the command
+ * stream is ending.
+ */
+static void r128_do_cce_flush(drm_r128_private_t * dev_priv)
+{
+	u32 tmp;
+
+	tmp = R128_READ(R128_PM4_BUFFER_DL_WPTR) | R128_PM4_BUFFER_DL_DONE;
+	R128_WRITE(R128_PM4_BUFFER_DL_WPTR, tmp);
+}
+
+/* Wait for the CCE to go idle.
+ */
+int r128_do_cce_idle(drm_r128_private_t * dev_priv)
+{
+	int i;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (GET_RING_HEAD(dev_priv) == dev_priv->ring.tail) {
+			int pm4stat = R128_READ(R128_PM4_STAT);
+			if (((pm4stat & R128_PM4_FIFOCNT_MASK) >=
+			     dev_priv->cce_fifo_size) &&
+			    !(pm4stat & (R128_PM4_BUSY |
+					 R128_PM4_GUI_ACTIVE))) {
+				return r128_do_pixcache_flush(dev_priv);
+			}
+		}
+		DRM_UDELAY(1);
+	}
+
+#if R128_FIFO_DEBUG
+	DRM_ERROR("failed!\n");
+	r128_status(dev_priv);
+#endif
+	return -EBUSY;
+}
+
+/* Start the Concurrent Command Engine.
+ */
+static void r128_do_cce_start(drm_r128_private_t * dev_priv)
+{
+	r128_do_wait_for_idle(dev_priv);
+
+	R128_WRITE(R128_PM4_BUFFER_CNTL,
+		   dev_priv->cce_mode | dev_priv->ring.size_l2qw
+		   | R128_PM4_BUFFER_CNTL_NOUPDATE);
+	R128_READ(R128_PM4_BUFFER_ADDR);	/* as per the sample code */
+	R128_WRITE(R128_PM4_MICRO_CNTL, R128_PM4_MICRO_FREERUN);
+
+	dev_priv->cce_running = 1;
+}
+
+/* Reset the Concurrent Command Engine.  This will not flush any pending
+ * commands, so you must wait for the CCE command stream to complete
+ * before calling this routine.
+ */
+static void r128_do_cce_reset(drm_r128_private_t * dev_priv)
+{
+	R128_WRITE(R128_PM4_BUFFER_DL_WPTR, 0);
+	R128_WRITE(R128_PM4_BUFFER_DL_RPTR, 0);
+	dev_priv->ring.tail = 0;
+}
+
+/* Stop the Concurrent Command Engine.  This will not flush any pending
+ * commands, so you must flush the command stream and wait for the CCE
+ * to go idle before calling this routine.
+ */
+static void r128_do_cce_stop(drm_r128_private_t * dev_priv)
+{
+	R128_WRITE(R128_PM4_MICRO_CNTL, 0);
+	R128_WRITE(R128_PM4_BUFFER_CNTL,
+		   R128_PM4_NONPM4 | R128_PM4_BUFFER_CNTL_NOUPDATE);
+
+	dev_priv->cce_running = 0;
+}
+
+/* Reset the engine.  This will stop the CCE if it is running.
+ */
+static int r128_do_engine_reset(struct drm_device * dev)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	u32 clock_cntl_index, mclk_cntl, gen_reset_cntl;
+
+	r128_do_pixcache_flush(dev_priv);
+
+	clock_cntl_index = R128_READ(R128_CLOCK_CNTL_INDEX);
+	mclk_cntl = R128_READ_PLL(dev, R128_MCLK_CNTL);
+
+	R128_WRITE_PLL(R128_MCLK_CNTL,
+		       mclk_cntl | R128_FORCE_GCP | R128_FORCE_PIPE3D_CP);
+
+	gen_reset_cntl = R128_READ(R128_GEN_RESET_CNTL);
+
+	/* Taken from the sample code - do not change */
+	R128_WRITE(R128_GEN_RESET_CNTL, gen_reset_cntl | R128_SOFT_RESET_GUI);
+	R128_READ(R128_GEN_RESET_CNTL);
+	R128_WRITE(R128_GEN_RESET_CNTL, gen_reset_cntl & ~R128_SOFT_RESET_GUI);
+	R128_READ(R128_GEN_RESET_CNTL);
+
+	R128_WRITE_PLL(R128_MCLK_CNTL, mclk_cntl);
+	R128_WRITE(R128_CLOCK_CNTL_INDEX, clock_cntl_index);
+	R128_WRITE(R128_GEN_RESET_CNTL, gen_reset_cntl);
+
+	/* Reset the CCE ring */
+	r128_do_cce_reset(dev_priv);
+
+	/* The CCE is no longer running after an engine reset */
+	dev_priv->cce_running = 0;
+
+	/* Reset any pending vertex, indirect buffers */
+	r128_freelist_reset(dev);
+
+	return 0;
+}
+
+static void r128_cce_init_ring_buffer(struct drm_device * dev,
+				      drm_r128_private_t * dev_priv)
+{
+	u32 ring_start;
+	u32 tmp;
+
+	DRM_DEBUG("\n");
+
+	/* The manual (p. 2) says this address is in "VM space".  This
+	 * means it's an offset from the start of AGP space.
+	 */
+#if __OS_HAS_AGP
+	if (!dev_priv->is_pci)
+		ring_start = dev_priv->cce_ring->offset - dev->agp->base;
+	else
+#endif
+		ring_start = dev_priv->cce_ring->offset - 
+				(unsigned long)dev->sg->virtual;
+
+	R128_WRITE(R128_PM4_BUFFER_OFFSET, ring_start | R128_AGP_OFFSET);
+
+	R128_WRITE(R128_PM4_BUFFER_DL_WPTR, 0);
+	R128_WRITE(R128_PM4_BUFFER_DL_RPTR, 0);
+
+	/* Set watermark control */
+	R128_WRITE(R128_PM4_BUFFER_WM_CNTL,
+		   ((R128_WATERMARK_L / 4) << R128_WMA_SHIFT)
+		   | ((R128_WATERMARK_M / 4) << R128_WMB_SHIFT)
+		   | ((R128_WATERMARK_N / 4) << R128_WMC_SHIFT)
+		   | ((R128_WATERMARK_K / 64) << R128_WB_WM_SHIFT));
+
+	/* Force read.  Why?  Because it's in the examples... */
+	R128_READ(R128_PM4_BUFFER_ADDR);
+
+	/* Turn on bus mastering */
+	tmp = R128_READ(R128_BUS_CNTL) & ~R128_BUS_MASTER_DIS;
+	R128_WRITE(R128_BUS_CNTL, tmp);
+}
+
+static int r128_do_init_cce(struct drm_device * dev, drm_r128_init_t * init)
+{
+	drm_r128_private_t *dev_priv;
+
+	DRM_DEBUG("\n");
+
+	dev_priv = drm_alloc(sizeof(drm_r128_private_t), DRM_MEM_DRIVER);
+	if (dev_priv == NULL)
+		return -ENOMEM;
+
+	memset(dev_priv, 0, sizeof(drm_r128_private_t));
+
+	dev_priv->is_pci = init->is_pci;
+
+	if (dev_priv->is_pci && !dev->sg) {
+		DRM_ERROR("PCI GART memory not allocated!\n");
+		dev->dev_private = (void *)dev_priv;
+		r128_do_cleanup_cce(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->usec_timeout = init->usec_timeout;
+	if (dev_priv->usec_timeout < 1 ||
+	    dev_priv->usec_timeout > R128_MAX_USEC_TIMEOUT) {
+		DRM_DEBUG("TIMEOUT problem!\n");
+		dev->dev_private = (void *)dev_priv;
+		r128_do_cleanup_cce(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->cce_mode = init->cce_mode;
+
+	/* GH: Simple idle check.
+	 */
+	atomic_set(&dev_priv->idle_count, 0);
+
+	/* We don't support anything other than bus-mastering ring mode,
+	 * but the ring can be in either AGP or PCI space for the ring
+	 * read pointer.
+	 */
+	if ((init->cce_mode != R128_PM4_192BM) &&
+	    (init->cce_mode != R128_PM4_128BM_64INDBM) &&
+	    (init->cce_mode != R128_PM4_64BM_128INDBM) &&
+	    (init->cce_mode != R128_PM4_64BM_64VCBM_64INDBM)) {
+		DRM_DEBUG("Bad cce_mode!\n");
+		dev->dev_private = (void *)dev_priv;
+		r128_do_cleanup_cce(dev);
+		return -EINVAL;
+	}
+
+	switch (init->cce_mode) {
+	case R128_PM4_NONPM4:
+		dev_priv->cce_fifo_size = 0;
+		break;
+	case R128_PM4_192PIO:
+	case R128_PM4_192BM:
+		dev_priv->cce_fifo_size = 192;
+		break;
+	case R128_PM4_128PIO_64INDBM:
+	case R128_PM4_128BM_64INDBM:
+		dev_priv->cce_fifo_size = 128;
+		break;
+	case R128_PM4_64PIO_128INDBM:
+	case R128_PM4_64BM_128INDBM:
+	case R128_PM4_64PIO_64VCBM_64INDBM:
+	case R128_PM4_64BM_64VCBM_64INDBM:
+	case R128_PM4_64PIO_64VCPIO_64INDPIO:
+		dev_priv->cce_fifo_size = 64;
+		break;
+	}
+
+	switch (init->fb_bpp) {
+	case 16:
+		dev_priv->color_fmt = R128_DATATYPE_RGB565;
+		break;
+	case 32:
+	default:
+		dev_priv->color_fmt = R128_DATATYPE_ARGB8888;
+		break;
+	}
+	dev_priv->front_offset = init->front_offset;
+	dev_priv->front_pitch = init->front_pitch;
+	dev_priv->back_offset = init->back_offset;
+	dev_priv->back_pitch = init->back_pitch;
+
+	switch (init->depth_bpp) {
+	case 16:
+		dev_priv->depth_fmt = R128_DATATYPE_RGB565;
+		break;
+	case 24:
+	case 32:
+	default:
+		dev_priv->depth_fmt = R128_DATATYPE_ARGB8888;
+		break;
+	}
+	dev_priv->depth_offset = init->depth_offset;
+	dev_priv->depth_pitch = init->depth_pitch;
+	dev_priv->span_offset = init->span_offset;
+
+	dev_priv->front_pitch_offset_c = (((dev_priv->front_pitch / 8) << 21) |
+					  (dev_priv->front_offset >> 5));
+	dev_priv->back_pitch_offset_c = (((dev_priv->back_pitch / 8) << 21) |
+					 (dev_priv->back_offset >> 5));
+	dev_priv->depth_pitch_offset_c = (((dev_priv->depth_pitch / 8) << 21) |
+					  (dev_priv->depth_offset >> 5) |
+					  R128_DST_TILE);
+	dev_priv->span_pitch_offset_c = (((dev_priv->depth_pitch / 8) << 21) |
+					 (dev_priv->span_offset >> 5));
+
+	dev_priv->sarea = drm_getsarea(dev);
+	if (!dev_priv->sarea) {
+		DRM_ERROR("could not find sarea!\n");
+		dev->dev_private = (void *)dev_priv;
+		r128_do_cleanup_cce(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);
+	if (!dev_priv->mmio) {
+		DRM_ERROR("could not find mmio region!\n");
+		dev->dev_private = (void *)dev_priv;
+		r128_do_cleanup_cce(dev);
+		return -EINVAL;
+	}
+	dev_priv->cce_ring = drm_core_findmap(dev, init->ring_offset);
+	if (!dev_priv->cce_ring) {
+		DRM_ERROR("could not find cce ring region!\n");
+		dev->dev_private = (void *)dev_priv;
+		r128_do_cleanup_cce(dev);
+		return -EINVAL;
+	}
+	dev_priv->ring_rptr = drm_core_findmap(dev, init->ring_rptr_offset);
+	if (!dev_priv->ring_rptr) {
+		DRM_ERROR("could not find ring read pointer!\n");
+		dev->dev_private = (void *)dev_priv;
+		r128_do_cleanup_cce(dev);
+		return -EINVAL;
+	}
+	dev->agp_buffer_token = init->buffers_offset;
+	dev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);
+	if (!dev->agp_buffer_map) {
+		DRM_ERROR("could not find dma buffer region!\n");
+		dev->dev_private = (void *)dev_priv;
+		r128_do_cleanup_cce(dev);
+		return -EINVAL;
+	}
+
+	if (!dev_priv->is_pci) {
+		dev_priv->agp_textures =
+		    drm_core_findmap(dev, init->agp_textures_offset);
+		if (!dev_priv->agp_textures) {
+			DRM_ERROR("could not find agp texture region!\n");
+			dev->dev_private = (void *)dev_priv;
+			r128_do_cleanup_cce(dev);
+			return -EINVAL;
+		}
+	}
+
+	dev_priv->sarea_priv =
+	    (drm_r128_sarea_t *) ((u8 *) dev_priv->sarea->handle +
+				  init->sarea_priv_offset);
+
+#if __OS_HAS_AGP
+	if (!dev_priv->is_pci) {
+		drm_core_ioremap(dev_priv->cce_ring, dev);
+		drm_core_ioremap(dev_priv->ring_rptr, dev);
+		drm_core_ioremap(dev->agp_buffer_map, dev);
+		if (!dev_priv->cce_ring->handle ||
+		    !dev_priv->ring_rptr->handle ||
+		    !dev->agp_buffer_map->handle) {
+			DRM_ERROR("Could not ioremap agp regions!\n");
+			dev->dev_private = (void *)dev_priv;
+			r128_do_cleanup_cce(dev);
+			return -ENOMEM;
+		}
+	} else
+#endif
+	{
+		dev_priv->cce_ring->handle = (void *)dev_priv->cce_ring->offset;
+		dev_priv->ring_rptr->handle =
+		    (void *)dev_priv->ring_rptr->offset;
+		dev->agp_buffer_map->handle =
+		    (void *)dev->agp_buffer_map->offset;
+	}
+
+#if __OS_HAS_AGP
+	if (!dev_priv->is_pci)
+		dev_priv->cce_buffers_offset = dev->agp->base;
+	else
+#endif
+		dev_priv->cce_buffers_offset = (unsigned long)dev->sg->virtual;
+
+	dev_priv->ring.start = (u32 *) dev_priv->cce_ring->handle;
+	dev_priv->ring.end = ((u32 *) dev_priv->cce_ring->handle
+			      + init->ring_size / sizeof(u32));
+	dev_priv->ring.size = init->ring_size;
+	dev_priv->ring.size_l2qw = drm_order(init->ring_size / 8);
+
+	dev_priv->ring.tail_mask = (dev_priv->ring.size / sizeof(u32)) - 1;
+
+	dev_priv->ring.high_mark = 128;
+
+	dev_priv->sarea_priv->last_frame = 0;
+	R128_WRITE(R128_LAST_FRAME_REG, dev_priv->sarea_priv->last_frame);
+
+	dev_priv->sarea_priv->last_dispatch = 0;
+	R128_WRITE(R128_LAST_DISPATCH_REG, dev_priv->sarea_priv->last_dispatch);
+
+#if __OS_HAS_AGP
+	if (dev_priv->is_pci) {
+#endif
+		dev_priv->gart_info.gart_table_location = DRM_ATI_GART_MAIN;
+		dev_priv->gart_info.table_size = R128_PCIGART_TABLE_SIZE;
+		dev_priv->gart_info.addr = NULL;
+		dev_priv->gart_info.bus_addr = 0;
+		dev_priv->gart_info.gart_reg_if = DRM_ATI_GART_PCI;
+		if (!drm_ati_pcigart_init(dev, &dev_priv->gart_info)) {
+			DRM_ERROR("failed to init PCI GART!\n");
+			dev->dev_private = (void *)dev_priv;
+			r128_do_cleanup_cce(dev);
+			return -ENOMEM;
+		}
+		R128_WRITE(R128_PCI_GART_PAGE, dev_priv->gart_info.bus_addr);
+#if __OS_HAS_AGP
+	}
+#endif
+
+	r128_cce_init_ring_buffer(dev, dev_priv);
+	r128_cce_load_microcode(dev_priv);
+
+	dev->dev_private = (void *)dev_priv;
+
+	r128_do_engine_reset(dev);
+
+	return 0;
+}
+
+int r128_do_cleanup_cce(struct drm_device * dev)
+{
+
+	/* Make sure interrupts are disabled here because the uninstall ioctl
+	 * may not have been called from userspace and after dev_private
+	 * is freed, it's too late.
+	 */
+	if (dev->irq_enabled)
+		drm_irq_uninstall(dev);
+
+	if (dev->dev_private) {
+		drm_r128_private_t *dev_priv = dev->dev_private;
+
+#if __OS_HAS_AGP
+		if (!dev_priv->is_pci) {
+			if (dev_priv->cce_ring != NULL)
+				drm_core_ioremapfree(dev_priv->cce_ring, dev);
+			if (dev_priv->ring_rptr != NULL)
+				drm_core_ioremapfree(dev_priv->ring_rptr, dev);
+			if (dev->agp_buffer_map != NULL) {
+				drm_core_ioremapfree(dev->agp_buffer_map, dev);
+				dev->agp_buffer_map = NULL;
+			}
+		} else
+#endif
+		{
+			if (dev_priv->gart_info.bus_addr)
+				if (!drm_ati_pcigart_cleanup(dev, &dev_priv->gart_info))
+					DRM_ERROR("failed to cleanup PCI GART!\n");
+		}
+
+		drm_free(dev->dev_private, sizeof(drm_r128_private_t),
+			 DRM_MEM_DRIVER);
+		dev->dev_private = NULL;
+	}
+
+	return 0;
+}
+
+int r128_cce_init(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_init_t *init = data;
+
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	switch (init->func) {
+	case R128_INIT_CCE:
+		return r128_do_init_cce(dev, init);
+	case R128_CLEANUP_CCE:
+		return r128_do_cleanup_cce(dev);
+	}
+
+	return -EINVAL;
+}
+
+int r128_cce_start(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (dev_priv->cce_running || dev_priv->cce_mode == R128_PM4_NONPM4) {
+		DRM_DEBUG("%s while CCE running\n", __FUNCTION__);
+		return 0;
+	}
+
+	r128_do_cce_start(dev_priv);
+
+	return 0;
+}
+
+/* Stop the CCE.  The engine must have been idled before calling this
+ * routine.
+ */
+int r128_cce_stop(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_cce_stop_t *stop = data;
+	int ret;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	/* Flush any pending CCE commands.  This ensures any outstanding
+	 * commands are exectuted by the engine before we turn it off.
+	 */
+	if (stop->flush) {
+		r128_do_cce_flush(dev_priv);
+	}
+
+	/* If we fail to make the engine go idle, we return an error
+	 * code so that the DRM ioctl wrapper can try again.
+	 */
+	if (stop->idle) {
+		ret = r128_do_cce_idle(dev_priv);
+		if (ret)
+			return ret;
+	}
+
+	/* Finally, we can turn off the CCE.  If the engine isn't idle,
+	 * we will get some dropped triangles as they won't be fully
+	 * rendered before the CCE is shut down.
+	 */
+	r128_do_cce_stop(dev_priv);
+
+	/* Reset the engine */
+	r128_do_engine_reset(dev);
+
+	return 0;
+}
+
+/* Just reset the CCE ring.  Called as part of an X Server engine reset.
+ */
+int r128_cce_reset(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_DEBUG("%s called before init done\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	r128_do_cce_reset(dev_priv);
+
+	/* The CCE is no longer running after an engine reset */
+	dev_priv->cce_running = 0;
+
+	return 0;
+}
+
+int r128_cce_idle(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (dev_priv->cce_running) {
+		r128_do_cce_flush(dev_priv);
+	}
+
+	return r128_do_cce_idle(dev_priv);
+}
+
+int r128_engine_reset(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	return r128_do_engine_reset(dev);
+}
+
+int r128_fullscreen(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	return -EINVAL;
+}
+
+/* ================================================================
+ * Freelist management
+ */
+#define R128_BUFFER_USED	0xffffffff
+#define R128_BUFFER_FREE	0
+
+#if 0
+static int r128_freelist_init(struct drm_device * dev)
+{
+	struct drm_device_dma *dma = dev->dma;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	struct drm_buf *buf;
+	drm_r128_buf_priv_t *buf_priv;
+	drm_r128_freelist_t *entry;
+	int i;
+
+	dev_priv->head = drm_alloc(sizeof(drm_r128_freelist_t), DRM_MEM_DRIVER);
+	if (dev_priv->head == NULL)
+		return -ENOMEM;
+
+	memset(dev_priv->head, 0, sizeof(drm_r128_freelist_t));
+	dev_priv->head->age = R128_BUFFER_USED;
+
+	for (i = 0; i < dma->buf_count; i++) {
+		buf = dma->buflist[i];
+		buf_priv = buf->dev_private;
+
+		entry = drm_alloc(sizeof(drm_r128_freelist_t), DRM_MEM_DRIVER);
+		if (!entry)
+			return -ENOMEM;
+
+		entry->age = R128_BUFFER_FREE;
+		entry->buf = buf;
+		entry->prev = dev_priv->head;
+		entry->next = dev_priv->head->next;
+		if (!entry->next)
+			dev_priv->tail = entry;
+
+		buf_priv->discard = 0;
+		buf_priv->dispatched = 0;
+		buf_priv->list_entry = entry;
+
+		dev_priv->head->next = entry;
+
+		if (dev_priv->head->next)
+			dev_priv->head->next->prev = entry;
+	}
+
+	return 0;
+
+}
+#endif
+
+static struct drm_buf *r128_freelist_get(struct drm_device * dev)
+{
+	struct drm_device_dma *dma = dev->dma;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_buf_priv_t *buf_priv;
+	struct drm_buf *buf;
+	int i, t;
+
+	/* FIXME: Optimize -- use freelist code */
+
+	for (i = 0; i < dma->buf_count; i++) {
+		buf = dma->buflist[i];
+		buf_priv = buf->dev_private;
+		if (buf->file_priv == 0)
+			return buf;
+	}
+
+	for (t = 0; t < dev_priv->usec_timeout; t++) {
+		u32 done_age = R128_READ(R128_LAST_DISPATCH_REG);
+
+		for (i = 0; i < dma->buf_count; i++) {
+			buf = dma->buflist[i];
+			buf_priv = buf->dev_private;
+			if (buf->pending && buf_priv->age <= done_age) {
+				/* The buffer has been processed, so it
+				 * can now be used.
+				 */
+				buf->pending = 0;
+				return buf;
+			}
+		}
+		DRM_UDELAY(1);
+	}
+
+	DRM_DEBUG("returning NULL!\n");
+	return NULL;
+}
+
+void r128_freelist_reset(struct drm_device * dev)
+{
+	struct drm_device_dma *dma = dev->dma;
+	int i;
+
+	for (i = 0; i < dma->buf_count; i++) {
+		struct drm_buf *buf = dma->buflist[i];
+		drm_r128_buf_priv_t *buf_priv = buf->dev_private;
+		buf_priv->age = 0;
+	}
+}
+
+/* ================================================================
+ * CCE command submission
+ */
+
+int r128_wait_ring(drm_r128_private_t * dev_priv, int n)
+{
+	drm_r128_ring_buffer_t *ring = &dev_priv->ring;
+	int i;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		r128_update_ring_snapshot(dev_priv);
+		if (ring->space >= n)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+	/* FIXME: This is being ignored... */
+	DRM_ERROR("failed!\n");
+	return -EBUSY;
+}
+
+static int r128_cce_get_buffers(struct drm_device * dev,
+				struct drm_file *file_priv,
+				struct drm_dma * d)
+{
+	int i;
+	struct drm_buf *buf;
+
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = r128_freelist_get(dev);
+		if (!buf)
+			return -EAGAIN;
+
+		buf->file_priv = file_priv;
+
+		if (DRM_COPY_TO_USER(&d->request_indices[i], &buf->idx,
+				     sizeof(buf->idx)))
+			return -EFAULT;
+		if (DRM_COPY_TO_USER(&d->request_sizes[i], &buf->total,
+				     sizeof(buf->total)))
+			return -EFAULT;
+
+		d->granted_count++;
+	}
+	return 0;
+}
+
+int r128_cce_buffers(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	struct drm_device_dma *dma = dev->dma;
+	int ret = 0;
+	struct drm_dma *d = data;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	/* Please don't send us buffers.
+	 */
+	if (d->send_count != 0) {
+		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
+			  DRM_CURRENTPID, d->send_count);
+		return -EINVAL;
+	}
+
+	/* We'll send you buffers.
+	 */
+	if (d->request_count < 0 || d->request_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
+			  DRM_CURRENTPID, d->request_count, dma->buf_count);
+		return -EINVAL;
+	}
+
+	d->granted_count = 0;
+
+	if (d->request_count) {
+		ret = r128_cce_get_buffers(dev, file_priv, d);
+	}
+
+	return ret;
+}
Index: git/shared-core/r128_drm.h
===================================================================
--- git.orig/shared-core/r128_drm.h	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/r128_drm.h	2008-12-12 17:35:22.000000000 +0000
@@ -153,7 +153,7 @@
 
 	/* The current cliprects, or a subset thereof.
 	 */
-	drm_clip_rect_t boxes[R128_NR_SAREA_CLIPRECTS];
+	struct drm_clip_rect boxes[R128_NR_SAREA_CLIPRECTS];
 	unsigned int nbox;
 
 	/* Counters for client-side throttling of rendering clients.
@@ -161,7 +161,7 @@
 	unsigned int last_frame;
 	unsigned int last_dispatch;
 
-	drm_tex_region_t tex_list[R128_NR_TEX_HEAPS][R128_NR_TEX_REGIONS + 1];
+	struct drm_tex_region tex_list[R128_NR_TEX_HEAPS][R128_NR_TEX_REGIONS + 1];
 	unsigned int tex_age[R128_NR_TEX_HEAPS];
 	int ctx_owner;
 	int pfAllowPageFlip;	/* number of 3d windows (0,1,2 or more) */
@@ -222,11 +222,7 @@
 		R128_INIT_CCE = 0x01,
 		R128_CLEANUP_CCE = 0x02
 	} func;
-#if CONFIG_XFREE86_VERSION < XFREE86_VERSION(4,1,0,0)
-	int sarea_priv_offset;
-#else
 	unsigned long sarea_priv_offset;
-#endif
 	int is_pci;
 	int cce_mode;
 	int cce_secure;
@@ -240,21 +236,12 @@
 	unsigned int depth_offset, depth_pitch;
 	unsigned int span_offset;
 
-#if CONFIG_XFREE86_VERSION < XFREE86_VERSION(4,1,0,0)
-	unsigned int fb_offset;
-	unsigned int mmio_offset;
-	unsigned int ring_offset;
-	unsigned int ring_rptr_offset;
-	unsigned int buffers_offset;
-	unsigned int agp_textures_offset;
-#else
 	unsigned long fb_offset;
 	unsigned long mmio_offset;
 	unsigned long ring_offset;
 	unsigned long ring_rptr_offset;
 	unsigned long buffers_offset;
 	unsigned long agp_textures_offset;
-#endif
 } drm_r128_init_t;
 
 typedef struct drm_r128_cce_stop {
@@ -264,15 +251,10 @@
 
 typedef struct drm_r128_clear {
 	unsigned int flags;
-#if CONFIG_XFREE86_VERSION < XFREE86_VERSION(4,1,0,0)
-	int x, y, w, h;
-#endif
 	unsigned int clear_color;
 	unsigned int clear_depth;
-#if CONFIG_XFREE86_VERSION >= XFREE86_VERSION(4,1,0,0)
 	unsigned int color_mask;
 	unsigned int depth_mask;
-#endif
 } drm_r128_clear_t;
 
 typedef struct drm_r128_vertex {
Index: git/shared-core/r128_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/r128_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,523 @@
+/* r128_drv.h -- Private header for r128 driver -*- linux-c -*-
+ * Created: Mon Dec 13 09:51:11 1999 by faith@precisioninsight.com
+ */
+/*
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *    Kevin E. Martin <martin@valinux.com>
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Michel Dzer <daenzerm@student.ethz.ch>
+ */
+
+#ifndef __R128_DRV_H__
+#define __R128_DRV_H__
+
+/* General customization:
+ */
+#define DRIVER_AUTHOR		"Gareth Hughes, VA Linux Systems Inc."
+
+#define DRIVER_NAME		"r128"
+#define DRIVER_DESC		"ATI Rage 128"
+#define DRIVER_DATE		"20030725"
+
+/* Interface history:
+ *
+ * ??  - ??
+ * 2.4 - Add support for ycbcr textures (no new ioctls)
+ * 2.5 - Add FLIP ioctl, disable FULLSCREEN.
+ */
+#define DRIVER_MAJOR		2
+#define DRIVER_MINOR		5
+#define DRIVER_PATCHLEVEL	0
+
+#define GET_RING_HEAD(dev_priv)		R128_READ( R128_PM4_BUFFER_DL_RPTR )
+
+typedef struct drm_r128_freelist {
+	unsigned int age;
+	struct drm_buf *buf;
+	struct drm_r128_freelist *next;
+	struct drm_r128_freelist *prev;
+} drm_r128_freelist_t;
+
+typedef struct drm_r128_ring_buffer {
+	u32 *start;
+	u32 *end;
+	int size;
+	int size_l2qw;
+
+	u32 tail;
+	u32 tail_mask;
+	int space;
+
+	int high_mark;
+} drm_r128_ring_buffer_t;
+
+typedef struct drm_r128_private {
+	drm_r128_ring_buffer_t ring;
+	drm_r128_sarea_t *sarea_priv;
+
+	int cce_mode;
+	int cce_fifo_size;
+	int cce_running;
+
+	drm_r128_freelist_t *head;
+	drm_r128_freelist_t *tail;
+
+	int usec_timeout;
+	int is_pci;
+	unsigned long cce_buffers_offset;
+
+	atomic_t idle_count;
+
+	int page_flipping;
+	int current_page;
+	u32 crtc_offset;
+	u32 crtc_offset_cntl;
+
+	u32 color_fmt;
+	unsigned int front_offset;
+	unsigned int front_pitch;
+	unsigned int back_offset;
+	unsigned int back_pitch;
+
+	u32 depth_fmt;
+	unsigned int depth_offset;
+	unsigned int depth_pitch;
+	unsigned int span_offset;
+
+	u32 front_pitch_offset_c;
+	u32 back_pitch_offset_c;
+	u32 depth_pitch_offset_c;
+	u32 span_pitch_offset_c;
+
+	drm_local_map_t *sarea;
+	drm_local_map_t *mmio;
+	drm_local_map_t *cce_ring;
+	drm_local_map_t *ring_rptr;
+	drm_local_map_t *agp_textures;
+	struct ati_pcigart_info gart_info;
+} drm_r128_private_t;
+
+typedef struct drm_r128_buf_priv {
+	u32 age;
+	int prim;
+	int discard;
+	int dispatched;
+	drm_r128_freelist_t *list_entry;
+} drm_r128_buf_priv_t;
+
+extern struct drm_ioctl_desc r128_ioctls[];
+extern int r128_max_ioctl;
+
+				/* r128_cce.c */
+extern int r128_cce_init(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int r128_cce_start(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int r128_cce_stop(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int r128_cce_reset(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int r128_cce_idle(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int r128_engine_reset(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int r128_fullscreen(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int r128_cce_buffers(struct drm_device *dev, void *data, struct drm_file *file_priv);
+
+extern void r128_freelist_reset(struct drm_device * dev);
+
+extern int r128_wait_ring(drm_r128_private_t * dev_priv, int n);
+
+extern int r128_do_cce_idle(drm_r128_private_t * dev_priv);
+extern int r128_do_cleanup_cce(struct drm_device * dev);
+
+extern int r128_driver_vblank_wait(struct drm_device * dev, unsigned int *sequence);
+
+extern irqreturn_t r128_driver_irq_handler(DRM_IRQ_ARGS);
+extern void r128_driver_irq_preinstall(struct drm_device * dev);
+extern void r128_driver_irq_postinstall(struct drm_device * dev);
+extern void r128_driver_irq_uninstall(struct drm_device * dev);
+extern void r128_driver_lastclose(struct drm_device * dev);
+extern void r128_driver_preclose(struct drm_device * dev,
+				 struct drm_file *file_priv);
+
+extern long r128_compat_ioctl(struct file *filp, unsigned int cmd,
+			      unsigned long arg);
+
+/* Register definitions, register access macros and drmAddMap constants
+ * for Rage 128 kernel driver.
+ */
+
+#define R128_AUX_SC_CNTL		0x1660
+#	define R128_AUX1_SC_EN			(1 << 0)
+#	define R128_AUX1_SC_MODE_OR		(0 << 1)
+#	define R128_AUX1_SC_MODE_NAND		(1 << 1)
+#	define R128_AUX2_SC_EN			(1 << 2)
+#	define R128_AUX2_SC_MODE_OR		(0 << 3)
+#	define R128_AUX2_SC_MODE_NAND		(1 << 3)
+#	define R128_AUX3_SC_EN			(1 << 4)
+#	define R128_AUX3_SC_MODE_OR		(0 << 5)
+#	define R128_AUX3_SC_MODE_NAND		(1 << 5)
+#define R128_AUX1_SC_LEFT		0x1664
+#define R128_AUX1_SC_RIGHT		0x1668
+#define R128_AUX1_SC_TOP		0x166c
+#define R128_AUX1_SC_BOTTOM		0x1670
+#define R128_AUX2_SC_LEFT		0x1674
+#define R128_AUX2_SC_RIGHT		0x1678
+#define R128_AUX2_SC_TOP		0x167c
+#define R128_AUX2_SC_BOTTOM		0x1680
+#define R128_AUX3_SC_LEFT		0x1684
+#define R128_AUX3_SC_RIGHT		0x1688
+#define R128_AUX3_SC_TOP		0x168c
+#define R128_AUX3_SC_BOTTOM		0x1690
+
+#define R128_BRUSH_DATA0		0x1480
+#define R128_BUS_CNTL			0x0030
+#	define R128_BUS_MASTER_DIS		(1 << 6)
+
+#define R128_CLOCK_CNTL_INDEX		0x0008
+#define R128_CLOCK_CNTL_DATA		0x000c
+#	define R128_PLL_WR_EN			(1 << 7)
+#define R128_CONSTANT_COLOR_C		0x1d34
+#define R128_CRTC_OFFSET		0x0224
+#define R128_CRTC_OFFSET_CNTL		0x0228
+#	define R128_CRTC_OFFSET_FLIP_CNTL	(1 << 16)
+
+#define R128_DP_GUI_MASTER_CNTL		0x146c
+#       define R128_GMC_SRC_PITCH_OFFSET_CNTL	(1    <<  0)
+#       define R128_GMC_DST_PITCH_OFFSET_CNTL	(1    <<  1)
+#	define R128_GMC_BRUSH_SOLID_COLOR	(13   <<  4)
+#	define R128_GMC_BRUSH_NONE		(15   <<  4)
+#	define R128_GMC_DST_16BPP		(4    <<  8)
+#	define R128_GMC_DST_24BPP		(5    <<  8)
+#	define R128_GMC_DST_32BPP		(6    <<  8)
+#       define R128_GMC_DST_DATATYPE_SHIFT	8
+#	define R128_GMC_SRC_DATATYPE_COLOR	(3    << 12)
+#	define R128_DP_SRC_SOURCE_MEMORY	(2    << 24)
+#	define R128_DP_SRC_SOURCE_HOST_DATA	(3    << 24)
+#	define R128_GMC_CLR_CMP_CNTL_DIS	(1    << 28)
+#	define R128_GMC_AUX_CLIP_DIS		(1    << 29)
+#	define R128_GMC_WR_MSK_DIS		(1    << 30)
+#	define R128_ROP3_S			0x00cc0000
+#	define R128_ROP3_P			0x00f00000
+#define R128_DP_WRITE_MASK		0x16cc
+#define R128_DST_PITCH_OFFSET_C		0x1c80
+#	define R128_DST_TILE			(1 << 31)
+
+#define R128_GEN_INT_CNTL		0x0040
+#	define R128_CRTC_VBLANK_INT_EN		(1 <<  0)
+#define R128_GEN_INT_STATUS		0x0044
+#	define R128_CRTC_VBLANK_INT		(1 <<  0)
+#	define R128_CRTC_VBLANK_INT_AK		(1 <<  0)
+#define R128_GEN_RESET_CNTL		0x00f0
+#	define R128_SOFT_RESET_GUI		(1 <<  0)
+
+#define R128_GUI_SCRATCH_REG0		0x15e0
+#define R128_GUI_SCRATCH_REG1		0x15e4
+#define R128_GUI_SCRATCH_REG2		0x15e8
+#define R128_GUI_SCRATCH_REG3		0x15ec
+#define R128_GUI_SCRATCH_REG4		0x15f0
+#define R128_GUI_SCRATCH_REG5		0x15f4
+
+#define R128_GUI_STAT			0x1740
+#	define R128_GUI_FIFOCNT_MASK		0x0fff
+#	define R128_GUI_ACTIVE			(1 << 31)
+
+#define R128_MCLK_CNTL			0x000f
+#	define R128_FORCE_GCP			(1 << 16)
+#	define R128_FORCE_PIPE3D_CP		(1 << 17)
+#	define R128_FORCE_RCP			(1 << 18)
+
+#define R128_PC_GUI_CTLSTAT		0x1748
+#define R128_PC_NGUI_CTLSTAT		0x0184
+#	define R128_PC_FLUSH_GUI		(3 << 0)
+#	define R128_PC_RI_GUI			(1 << 2)
+#	define R128_PC_FLUSH_ALL		0x00ff
+#	define R128_PC_BUSY			(1 << 31)
+
+#define R128_PCI_GART_PAGE		0x017c
+#define R128_PRIM_TEX_CNTL_C		0x1cb0
+
+#define R128_SCALE_3D_CNTL		0x1a00
+#define R128_SEC_TEX_CNTL_C		0x1d00
+#define R128_SEC_TEXTURE_BORDER_COLOR_C	0x1d3c
+#define R128_SETUP_CNTL			0x1bc4
+#define R128_STEN_REF_MASK_C		0x1d40
+
+#define R128_TEX_CNTL_C			0x1c9c
+#	define R128_TEX_CACHE_FLUSH		(1 << 23)
+
+#define R128_WAIT_UNTIL			0x1720
+#	define R128_EVENT_CRTC_OFFSET		(1 << 0)
+#define R128_WINDOW_XY_OFFSET		0x1bcc
+
+/* CCE registers
+ */
+#define R128_PM4_BUFFER_OFFSET		0x0700
+#define R128_PM4_BUFFER_CNTL		0x0704
+#	define R128_PM4_MASK			(15 << 28)
+#	define R128_PM4_NONPM4			(0  << 28)
+#	define R128_PM4_192PIO			(1  << 28)
+#	define R128_PM4_192BM			(2  << 28)
+#	define R128_PM4_128PIO_64INDBM		(3  << 28)
+#	define R128_PM4_128BM_64INDBM		(4  << 28)
+#	define R128_PM4_64PIO_128INDBM		(5  << 28)
+#	define R128_PM4_64BM_128INDBM		(6  << 28)
+#	define R128_PM4_64PIO_64VCBM_64INDBM	(7  << 28)
+#	define R128_PM4_64BM_64VCBM_64INDBM	(8  << 28)
+#	define R128_PM4_64PIO_64VCPIO_64INDPIO	(15 << 28)
+#	define R128_PM4_BUFFER_CNTL_NOUPDATE	(1  << 27)
+
+#define R128_PM4_BUFFER_WM_CNTL		0x0708
+#	define R128_WMA_SHIFT			0
+#	define R128_WMB_SHIFT			8
+#	define R128_WMC_SHIFT			16
+#	define R128_WB_WM_SHIFT			24
+
+#define R128_PM4_BUFFER_DL_RPTR_ADDR	0x070c
+#define R128_PM4_BUFFER_DL_RPTR		0x0710
+#define R128_PM4_BUFFER_DL_WPTR		0x0714
+#	define R128_PM4_BUFFER_DL_DONE		(1 << 31)
+
+#define R128_PM4_VC_FPU_SETUP		0x071c
+
+#define R128_PM4_IW_INDOFF		0x0738
+#define R128_PM4_IW_INDSIZE		0x073c
+
+#define R128_PM4_STAT			0x07b8
+#	define R128_PM4_FIFOCNT_MASK		0x0fff
+#	define R128_PM4_BUSY			(1 << 16)
+#	define R128_PM4_GUI_ACTIVE		(1 << 31)
+
+#define R128_PM4_MICROCODE_ADDR		0x07d4
+#define R128_PM4_MICROCODE_RADDR	0x07d8
+#define R128_PM4_MICROCODE_DATAH	0x07dc
+#define R128_PM4_MICROCODE_DATAL	0x07e0
+
+#define R128_PM4_BUFFER_ADDR		0x07f0
+#define R128_PM4_MICRO_CNTL		0x07fc
+#	define R128_PM4_MICRO_FREERUN		(1 << 30)
+
+#define R128_PM4_FIFO_DATA_EVEN		0x1000
+#define R128_PM4_FIFO_DATA_ODD		0x1004
+
+/* CCE command packets
+ */
+#define R128_CCE_PACKET0		0x00000000
+#define R128_CCE_PACKET1		0x40000000
+#define R128_CCE_PACKET2		0x80000000
+#define R128_CCE_PACKET3		0xC0000000
+#	define R128_CNTL_HOSTDATA_BLT		0x00009400
+#	define R128_CNTL_PAINT_MULTI		0x00009A00
+#	define R128_CNTL_BITBLT_MULTI		0x00009B00
+#	define R128_3D_RNDR_GEN_INDX_PRIM	0x00002300
+
+#define R128_CCE_PACKET_MASK		0xC0000000
+#define R128_CCE_PACKET_COUNT_MASK	0x3fff0000
+#define R128_CCE_PACKET0_REG_MASK	0x000007ff
+#define R128_CCE_PACKET1_REG0_MASK	0x000007ff
+#define R128_CCE_PACKET1_REG1_MASK	0x003ff800
+
+#define R128_CCE_VC_CNTL_PRIM_TYPE_NONE		0x00000000
+#define R128_CCE_VC_CNTL_PRIM_TYPE_POINT	0x00000001
+#define R128_CCE_VC_CNTL_PRIM_TYPE_LINE		0x00000002
+#define R128_CCE_VC_CNTL_PRIM_TYPE_POLY_LINE	0x00000003
+#define R128_CCE_VC_CNTL_PRIM_TYPE_TRI_LIST	0x00000004
+#define R128_CCE_VC_CNTL_PRIM_TYPE_TRI_FAN	0x00000005
+#define R128_CCE_VC_CNTL_PRIM_TYPE_TRI_STRIP	0x00000006
+#define R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2	0x00000007
+#define R128_CCE_VC_CNTL_PRIM_WALK_IND		0x00000010
+#define R128_CCE_VC_CNTL_PRIM_WALK_LIST		0x00000020
+#define R128_CCE_VC_CNTL_PRIM_WALK_RING		0x00000030
+#define R128_CCE_VC_CNTL_NUM_SHIFT		16
+
+#define R128_DATATYPE_VQ		0
+#define R128_DATATYPE_CI4		1
+#define R128_DATATYPE_CI8		2
+#define R128_DATATYPE_ARGB1555		3
+#define R128_DATATYPE_RGB565		4
+#define R128_DATATYPE_RGB888		5
+#define R128_DATATYPE_ARGB8888		6
+#define R128_DATATYPE_RGB332		7
+#define R128_DATATYPE_Y8		8
+#define R128_DATATYPE_RGB8		9
+#define R128_DATATYPE_CI16		10
+#define R128_DATATYPE_YVYU422		11
+#define R128_DATATYPE_VYUY422		12
+#define R128_DATATYPE_AYUV444		14
+#define R128_DATATYPE_ARGB4444		15
+
+/* Constants */
+#define R128_AGP_OFFSET			0x02000000
+
+#define R128_WATERMARK_L		16
+#define R128_WATERMARK_M		8
+#define R128_WATERMARK_N		8
+#define R128_WATERMARK_K		128
+
+#define R128_MAX_USEC_TIMEOUT		100000	/* 100 ms */
+
+#define R128_LAST_FRAME_REG		R128_GUI_SCRATCH_REG0
+#define R128_LAST_DISPATCH_REG		R128_GUI_SCRATCH_REG1
+#define R128_MAX_VB_AGE			0x7fffffff
+#define R128_MAX_VB_VERTS		(0xffff)
+
+#define R128_RING_HIGH_MARK		128
+
+#define R128_PERFORMANCE_BOXES		0
+
+#define R128_PCIGART_TABLE_SIZE         32768
+
+#define R128_READ(reg)		DRM_READ32(  dev_priv->mmio, (reg) )
+#define R128_WRITE(reg,val)	DRM_WRITE32( dev_priv->mmio, (reg), (val) )
+#define R128_READ8(reg)		DRM_READ8(   dev_priv->mmio, (reg) )
+#define R128_WRITE8(reg,val)	DRM_WRITE8(  dev_priv->mmio, (reg), (val) )
+
+#define R128_WRITE_PLL(addr,val)					\
+do {									\
+	R128_WRITE8(R128_CLOCK_CNTL_INDEX,				\
+		    ((addr) & 0x1f) | R128_PLL_WR_EN);			\
+	R128_WRITE(R128_CLOCK_CNTL_DATA, (val));			\
+} while (0)
+
+#define CCE_PACKET0( reg, n )		(R128_CCE_PACKET0 |		\
+					 ((n) << 16) | ((reg) >> 2))
+#define CCE_PACKET1( reg0, reg1 )	(R128_CCE_PACKET1 |		\
+					 (((reg1) >> 2) << 11) | ((reg0) >> 2))
+#define CCE_PACKET2()			(R128_CCE_PACKET2)
+#define CCE_PACKET3( pkt, n )		(R128_CCE_PACKET3 |		\
+					 (pkt) | ((n) << 16))
+
+static __inline__ void r128_update_ring_snapshot(drm_r128_private_t * dev_priv)
+{
+	drm_r128_ring_buffer_t *ring = &dev_priv->ring;
+	ring->space = (GET_RING_HEAD(dev_priv) - ring->tail) * sizeof(u32);
+	if (ring->space <= 0)
+		ring->space += ring->size;
+}
+
+/* ================================================================
+ * Misc helper macros
+ */
+
+#define RING_SPACE_TEST_WITH_RETURN( dev_priv )				\
+do {									\
+	drm_r128_ring_buffer_t *ring = &dev_priv->ring; int i;		\
+	if ( ring->space < ring->high_mark ) {				\
+		for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {	\
+			r128_update_ring_snapshot( dev_priv );		\
+			if ( ring->space >= ring->high_mark )		\
+				goto __ring_space_done;			\
+			DRM_UDELAY(1);				\
+		}							\
+		DRM_ERROR( "ring space check failed!\n" );		\
+		return -EBUSY;				\
+	}								\
+ __ring_space_done:							\
+	;								\
+} while (0)
+
+#define VB_AGE_TEST_WITH_RETURN( dev_priv )				\
+do {									\
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;		\
+	if ( sarea_priv->last_dispatch >= R128_MAX_VB_AGE ) {		\
+		int __ret = r128_do_cce_idle( dev_priv );		\
+		if ( __ret ) return __ret;				\
+		sarea_priv->last_dispatch = 0;				\
+		r128_freelist_reset( dev );				\
+	}								\
+} while (0)
+
+#define R128_WAIT_UNTIL_PAGE_FLIPPED() do {				\
+	OUT_RING( CCE_PACKET0( R128_WAIT_UNTIL, 0 ) );			\
+	OUT_RING( R128_EVENT_CRTC_OFFSET );				\
+} while (0)
+
+/* ================================================================
+ * Ring control
+ */
+
+#define R128_VERBOSE	0
+
+#define RING_LOCALS							\
+	int write, _nr; unsigned int tail_mask; volatile u32 *ring;
+
+#define BEGIN_RING( n ) do {						\
+	if ( R128_VERBOSE ) {						\
+		DRM_INFO( "BEGIN_RING( %d ) in %s\n",			\
+			   (n), __FUNCTION__ );				\
+	}								\
+	if ( dev_priv->ring.space <= (n) * sizeof(u32) ) {		\
+		COMMIT_RING();						\
+		r128_wait_ring( dev_priv, (n) * sizeof(u32) );		\
+	}								\
+	_nr = n; dev_priv->ring.space -= (n) * sizeof(u32);		\
+	ring = dev_priv->ring.start;					\
+	write = dev_priv->ring.tail;					\
+	tail_mask = dev_priv->ring.tail_mask;				\
+} while (0)
+
+/* You can set this to zero if you want.  If the card locks up, you'll
+ * need to keep this set.  It works around a bug in early revs of the
+ * Rage 128 chipset, where the CCE would read 32 dwords past the end of
+ * the ring buffer before wrapping around.
+ */
+#define R128_BROKEN_CCE	1
+
+#define ADVANCE_RING() do {						\
+	if ( R128_VERBOSE ) {						\
+		DRM_INFO( "ADVANCE_RING() wr=0x%06x tail=0x%06x\n",	\
+			  write, dev_priv->ring.tail );			\
+	}								\
+	if ( R128_BROKEN_CCE && write < 32 ) {				\
+		memcpy( dev_priv->ring.end,				\
+			dev_priv->ring.start,				\
+			write * sizeof(u32) );				\
+	}								\
+	if (((dev_priv->ring.tail + _nr) & tail_mask) != write) {	\
+		DRM_ERROR( 						\
+			"ADVANCE_RING(): mismatch: nr: %x write: %x line: %d\n",	\
+			((dev_priv->ring.tail + _nr) & tail_mask),	\
+			write, __LINE__);				\
+	} else								\
+		dev_priv->ring.tail = write;				\
+} while (0)
+
+#define COMMIT_RING() do {						\
+	if ( R128_VERBOSE ) {						\
+		DRM_INFO( "COMMIT_RING() tail=0x%06x\n",		\
+			dev_priv->ring.tail );				\
+	}								\
+	DRM_MEMORYBARRIER();						\
+	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, dev_priv->ring.tail );	\
+	R128_READ( R128_PM4_BUFFER_DL_WPTR );				\
+} while (0)
+
+#define OUT_RING( x ) do {						\
+	if ( R128_VERBOSE ) {						\
+		DRM_INFO( "   OUT_RING( 0x%08x ) at 0x%x\n",		\
+			   (unsigned int)(x), write );			\
+	}								\
+	ring[write++] = cpu_to_le32( x );				\
+	write &= tail_mask;						\
+} while (0)
+
+#endif				/* __R128_DRV_H__ */
Index: git/shared-core/r128_irq.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/r128_irq.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,101 @@
+/* r128_irq.c -- IRQ handling for radeon -*- linux-c -*- */
+/*
+ * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
+ *
+ * The Weather Channel (TM) funded Tungsten Graphics to develop the
+ * initial release of the Radeon 8500 driver under the XFree86 license.
+ * This notice must be preserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ *    Eric Anholt <anholt@FreeBSD.org>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "r128_drm.h"
+#include "r128_drv.h"
+
+irqreturn_t r128_driver_irq_handler(DRM_IRQ_ARGS)
+{
+	struct drm_device *dev = (struct drm_device *) arg;
+	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;
+	int status;
+
+	status = R128_READ(R128_GEN_INT_STATUS);
+
+	/* VBLANK interrupt */
+	if (status & R128_CRTC_VBLANK_INT) {
+		R128_WRITE(R128_GEN_INT_STATUS, R128_CRTC_VBLANK_INT_AK);
+		atomic_inc(&dev->vbl_received);
+		DRM_WAKEUP(&dev->vbl_queue);
+		drm_vbl_send_signals(dev);
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+int r128_driver_vblank_wait(struct drm_device * dev, unsigned int *sequence)
+{
+	unsigned int cur_vblank;
+	int ret = 0;
+
+	/* Assume that the user has missed the current sequence number
+	 * by about a day rather than she wants to wait for years
+	 * using vertical blanks...
+	 */
+	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
+		    (((cur_vblank = atomic_read(&dev->vbl_received))
+		      - *sequence) <= (1 << 23)));
+
+	*sequence = cur_vblank;
+
+	return ret;
+}
+
+void r128_driver_irq_preinstall(struct drm_device * dev)
+{
+	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;
+
+	/* Disable *all* interrupts */
+	R128_WRITE(R128_GEN_INT_CNTL, 0);
+	/* Clear vblank bit if it's already high */
+	R128_WRITE(R128_GEN_INT_STATUS, R128_CRTC_VBLANK_INT_AK);
+}
+
+void r128_driver_irq_postinstall(struct drm_device * dev)
+{
+	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;
+
+	/* Turn on VBL interrupt */
+	R128_WRITE(R128_GEN_INT_CNTL, R128_CRTC_VBLANK_INT_EN);
+}
+
+void r128_driver_irq_uninstall(struct drm_device * dev)
+{
+	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;
+	if (!dev_priv)
+		return;
+
+	/* Disable *all* interrupts */
+	R128_WRITE(R128_GEN_INT_CNTL, 0);
+}
Index: git/shared-core/r128_state.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/r128_state.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,1682 @@
+/* r128_state.c -- State support for r128 -*- linux-c -*-
+ * Created: Thu Jan 27 02:53:43 2000 by gareth@valinux.com
+ */
+/*
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "r128_drm.h"
+#include "r128_drv.h"
+
+/* ================================================================
+ * CCE hardware state programming functions
+ */
+
+static void r128_emit_clip_rects(drm_r128_private_t * dev_priv,
+				 struct drm_clip_rect * boxes, int count)
+{
+	u32 aux_sc_cntl = 0x00000000;
+	RING_LOCALS;
+	DRM_DEBUG("    %s\n", __FUNCTION__);
+
+	BEGIN_RING((count < 3 ? count : 3) * 5 + 2);
+
+	if (count >= 1) {
+		OUT_RING(CCE_PACKET0(R128_AUX1_SC_LEFT, 3));
+		OUT_RING(boxes[0].x1);
+		OUT_RING(boxes[0].x2 - 1);
+		OUT_RING(boxes[0].y1);
+		OUT_RING(boxes[0].y2 - 1);
+
+		aux_sc_cntl |= (R128_AUX1_SC_EN | R128_AUX1_SC_MODE_OR);
+	}
+	if (count >= 2) {
+		OUT_RING(CCE_PACKET0(R128_AUX2_SC_LEFT, 3));
+		OUT_RING(boxes[1].x1);
+		OUT_RING(boxes[1].x2 - 1);
+		OUT_RING(boxes[1].y1);
+		OUT_RING(boxes[1].y2 - 1);
+
+		aux_sc_cntl |= (R128_AUX2_SC_EN | R128_AUX2_SC_MODE_OR);
+	}
+	if (count >= 3) {
+		OUT_RING(CCE_PACKET0(R128_AUX3_SC_LEFT, 3));
+		OUT_RING(boxes[2].x1);
+		OUT_RING(boxes[2].x2 - 1);
+		OUT_RING(boxes[2].y1);
+		OUT_RING(boxes[2].y2 - 1);
+
+		aux_sc_cntl |= (R128_AUX3_SC_EN | R128_AUX3_SC_MODE_OR);
+	}
+
+	OUT_RING(CCE_PACKET0(R128_AUX_SC_CNTL, 0));
+	OUT_RING(aux_sc_cntl);
+
+	ADVANCE_RING();
+}
+
+static __inline__ void r128_emit_core(drm_r128_private_t * dev_priv)
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG("    %s\n", __FUNCTION__);
+
+	BEGIN_RING(2);
+
+	OUT_RING(CCE_PACKET0(R128_SCALE_3D_CNTL, 0));
+	OUT_RING(ctx->scale_3d_cntl);
+
+	ADVANCE_RING();
+}
+
+static __inline__ void r128_emit_context(drm_r128_private_t * dev_priv)
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG("    %s\n", __FUNCTION__);
+
+	BEGIN_RING(13);
+
+	OUT_RING(CCE_PACKET0(R128_DST_PITCH_OFFSET_C, 11));
+	OUT_RING(ctx->dst_pitch_offset_c);
+	OUT_RING(ctx->dp_gui_master_cntl_c);
+	OUT_RING(ctx->sc_top_left_c);
+	OUT_RING(ctx->sc_bottom_right_c);
+	OUT_RING(ctx->z_offset_c);
+	OUT_RING(ctx->z_pitch_c);
+	OUT_RING(ctx->z_sten_cntl_c);
+	OUT_RING(ctx->tex_cntl_c);
+	OUT_RING(ctx->misc_3d_state_cntl_reg);
+	OUT_RING(ctx->texture_clr_cmp_clr_c);
+	OUT_RING(ctx->texture_clr_cmp_msk_c);
+	OUT_RING(ctx->fog_color_c);
+
+	ADVANCE_RING();
+}
+
+static __inline__ void r128_emit_setup(drm_r128_private_t * dev_priv)
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG("    %s\n", __FUNCTION__);
+
+	BEGIN_RING(3);
+
+	OUT_RING(CCE_PACKET1(R128_SETUP_CNTL, R128_PM4_VC_FPU_SETUP));
+	OUT_RING(ctx->setup_cntl);
+	OUT_RING(ctx->pm4_vc_fpu_setup);
+
+	ADVANCE_RING();
+}
+
+static __inline__ void r128_emit_masks(drm_r128_private_t * dev_priv)
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG("    %s\n", __FUNCTION__);
+
+	BEGIN_RING(5);
+
+	OUT_RING(CCE_PACKET0(R128_DP_WRITE_MASK, 0));
+	OUT_RING(ctx->dp_write_mask);
+
+	OUT_RING(CCE_PACKET0(R128_STEN_REF_MASK_C, 1));
+	OUT_RING(ctx->sten_ref_mask_c);
+	OUT_RING(ctx->plane_3d_mask_c);
+
+	ADVANCE_RING();
+}
+
+static __inline__ void r128_emit_window(drm_r128_private_t * dev_priv)
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG("    %s\n", __FUNCTION__);
+
+	BEGIN_RING(2);
+
+	OUT_RING(CCE_PACKET0(R128_WINDOW_XY_OFFSET, 0));
+	OUT_RING(ctx->window_xy_offset);
+
+	ADVANCE_RING();
+}
+
+static __inline__ void r128_emit_tex0(drm_r128_private_t * dev_priv)
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	drm_r128_texture_regs_t *tex = &sarea_priv->tex_state[0];
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG("    %s\n", __FUNCTION__);
+
+	BEGIN_RING(7 + R128_MAX_TEXTURE_LEVELS);
+
+	OUT_RING(CCE_PACKET0(R128_PRIM_TEX_CNTL_C,
+			     2 + R128_MAX_TEXTURE_LEVELS));
+	OUT_RING(tex->tex_cntl);
+	OUT_RING(tex->tex_combine_cntl);
+	OUT_RING(ctx->tex_size_pitch_c);
+	for (i = 0; i < R128_MAX_TEXTURE_LEVELS; i++) {
+		OUT_RING(tex->tex_offset[i]);
+	}
+
+	OUT_RING(CCE_PACKET0(R128_CONSTANT_COLOR_C, 1));
+	OUT_RING(ctx->constant_color_c);
+	OUT_RING(tex->tex_border_color);
+
+	ADVANCE_RING();
+}
+
+static __inline__ void r128_emit_tex1(drm_r128_private_t * dev_priv)
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_texture_regs_t *tex = &sarea_priv->tex_state[1];
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG("    %s\n", __FUNCTION__);
+
+	BEGIN_RING(5 + R128_MAX_TEXTURE_LEVELS);
+
+	OUT_RING(CCE_PACKET0(R128_SEC_TEX_CNTL_C, 1 + R128_MAX_TEXTURE_LEVELS));
+	OUT_RING(tex->tex_cntl);
+	OUT_RING(tex->tex_combine_cntl);
+	for (i = 0; i < R128_MAX_TEXTURE_LEVELS; i++) {
+		OUT_RING(tex->tex_offset[i]);
+	}
+
+	OUT_RING(CCE_PACKET0(R128_SEC_TEXTURE_BORDER_COLOR_C, 0));
+	OUT_RING(tex->tex_border_color);
+
+	ADVANCE_RING();
+}
+
+static void r128_emit_state(drm_r128_private_t * dev_priv)
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int dirty = sarea_priv->dirty;
+
+	DRM_DEBUG("%s: dirty=0x%08x\n", __FUNCTION__, dirty);
+
+	if (dirty & R128_UPLOAD_CORE) {
+		r128_emit_core(dev_priv);
+		sarea_priv->dirty &= ~R128_UPLOAD_CORE;
+	}
+
+	if (dirty & R128_UPLOAD_CONTEXT) {
+		r128_emit_context(dev_priv);
+		sarea_priv->dirty &= ~R128_UPLOAD_CONTEXT;
+	}
+
+	if (dirty & R128_UPLOAD_SETUP) {
+		r128_emit_setup(dev_priv);
+		sarea_priv->dirty &= ~R128_UPLOAD_SETUP;
+	}
+
+	if (dirty & R128_UPLOAD_MASKS) {
+		r128_emit_masks(dev_priv);
+		sarea_priv->dirty &= ~R128_UPLOAD_MASKS;
+	}
+
+	if (dirty & R128_UPLOAD_WINDOW) {
+		r128_emit_window(dev_priv);
+		sarea_priv->dirty &= ~R128_UPLOAD_WINDOW;
+	}
+
+	if (dirty & R128_UPLOAD_TEX0) {
+		r128_emit_tex0(dev_priv);
+		sarea_priv->dirty &= ~R128_UPLOAD_TEX0;
+	}
+
+	if (dirty & R128_UPLOAD_TEX1) {
+		r128_emit_tex1(dev_priv);
+		sarea_priv->dirty &= ~R128_UPLOAD_TEX1;
+	}
+
+	/* Turn off the texture cache flushing */
+	sarea_priv->context_state.tex_cntl_c &= ~R128_TEX_CACHE_FLUSH;
+
+	sarea_priv->dirty &= ~R128_REQUIRE_QUIESCENCE;
+}
+
+#if R128_PERFORMANCE_BOXES
+/* ================================================================
+ * Performance monitoring functions
+ */
+
+static void r128_clear_box(drm_r128_private_t * dev_priv,
+			   int x, int y, int w, int h, int r, int g, int b)
+{
+	u32 pitch, offset;
+	u32 fb_bpp, color;
+	RING_LOCALS;
+
+	switch (dev_priv->fb_bpp) {
+	case 16:
+		fb_bpp = R128_GMC_DST_16BPP;
+		color = (((r & 0xf8) << 8) |
+			 ((g & 0xfc) << 3) | ((b & 0xf8) >> 3));
+		break;
+	case 24:
+		fb_bpp = R128_GMC_DST_24BPP;
+		color = ((r << 16) | (g << 8) | b);
+		break;
+	case 32:
+		fb_bpp = R128_GMC_DST_32BPP;
+		color = (((0xff) << 24) | (r << 16) | (g << 8) | b);
+		break;
+	default:
+		return;
+	}
+
+	offset = dev_priv->back_offset;
+	pitch = dev_priv->back_pitch >> 3;
+
+	BEGIN_RING(6);
+
+	OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+	OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+		 R128_GMC_BRUSH_SOLID_COLOR |
+		 fb_bpp |
+		 R128_GMC_SRC_DATATYPE_COLOR |
+		 R128_ROP3_P |
+		 R128_GMC_CLR_CMP_CNTL_DIS | R128_GMC_AUX_CLIP_DIS);
+
+	OUT_RING((pitch << 21) | (offset >> 5));
+	OUT_RING(color);
+
+	OUT_RING((x << 16) | y);
+	OUT_RING((w << 16) | h);
+
+	ADVANCE_RING();
+}
+
+static void r128_cce_performance_boxes(drm_r128_private_t * dev_priv)
+{
+	if (atomic_read(&dev_priv->idle_count) == 0) {
+		r128_clear_box(dev_priv, 64, 4, 8, 8, 0, 255, 0);
+	} else {
+		atomic_set(&dev_priv->idle_count, 0);
+	}
+}
+
+#endif
+
+/* ================================================================
+ * CCE command dispatch functions
+ */
+
+static void r128_print_dirty(const char *msg, unsigned int flags)
+{
+	DRM_INFO("%s: (0x%x) %s%s%s%s%s%s%s%s%s\n",
+		 msg,
+		 flags,
+		 (flags & R128_UPLOAD_CORE) ? "core, " : "",
+		 (flags & R128_UPLOAD_CONTEXT) ? "context, " : "",
+		 (flags & R128_UPLOAD_SETUP) ? "setup, " : "",
+		 (flags & R128_UPLOAD_TEX0) ? "tex0, " : "",
+		 (flags & R128_UPLOAD_TEX1) ? "tex1, " : "",
+		 (flags & R128_UPLOAD_MASKS) ? "masks, " : "",
+		 (flags & R128_UPLOAD_WINDOW) ? "window, " : "",
+		 (flags & R128_UPLOAD_CLIPRECTS) ? "cliprects, " : "",
+		 (flags & R128_REQUIRE_QUIESCENCE) ? "quiescence, " : "");
+}
+
+static void r128_cce_dispatch_clear(struct drm_device * dev,
+				    drm_r128_clear_t * clear)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int nbox = sarea_priv->nbox;
+	struct drm_clip_rect *pbox = sarea_priv->boxes;
+	unsigned int flags = clear->flags;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	if (dev_priv->page_flipping && dev_priv->current_page == 1) {
+		unsigned int tmp = flags;
+
+		flags &= ~(R128_FRONT | R128_BACK);
+		if (tmp & R128_FRONT)
+			flags |= R128_BACK;
+		if (tmp & R128_BACK)
+			flags |= R128_FRONT;
+	}
+
+	for (i = 0; i < nbox; i++) {
+		int x = pbox[i].x1;
+		int y = pbox[i].y1;
+		int w = pbox[i].x2 - x;
+		int h = pbox[i].y2 - y;
+
+		DRM_DEBUG("dispatch clear %d,%d-%d,%d flags 0x%x\n",
+			  pbox[i].x1, pbox[i].y1, pbox[i].x2,
+			  pbox[i].y2, flags);
+
+		if (flags & (R128_FRONT | R128_BACK)) {
+			BEGIN_RING(2);
+
+			OUT_RING(CCE_PACKET0(R128_DP_WRITE_MASK, 0));
+			OUT_RING(clear->color_mask);
+
+			ADVANCE_RING();
+		}
+
+		if (flags & R128_FRONT) {
+			BEGIN_RING(6);
+
+			OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+			OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+				 R128_GMC_BRUSH_SOLID_COLOR |
+				 (dev_priv->color_fmt << 8) |
+				 R128_GMC_SRC_DATATYPE_COLOR |
+				 R128_ROP3_P |
+				 R128_GMC_CLR_CMP_CNTL_DIS |
+				 R128_GMC_AUX_CLIP_DIS);
+
+			OUT_RING(dev_priv->front_pitch_offset_c);
+			OUT_RING(clear->clear_color);
+
+			OUT_RING((x << 16) | y);
+			OUT_RING((w << 16) | h);
+
+			ADVANCE_RING();
+		}
+
+		if (flags & R128_BACK) {
+			BEGIN_RING(6);
+
+			OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+			OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+				 R128_GMC_BRUSH_SOLID_COLOR |
+				 (dev_priv->color_fmt << 8) |
+				 R128_GMC_SRC_DATATYPE_COLOR |
+				 R128_ROP3_P |
+				 R128_GMC_CLR_CMP_CNTL_DIS |
+				 R128_GMC_AUX_CLIP_DIS);
+
+			OUT_RING(dev_priv->back_pitch_offset_c);
+			OUT_RING(clear->clear_color);
+
+			OUT_RING((x << 16) | y);
+			OUT_RING((w << 16) | h);
+
+			ADVANCE_RING();
+		}
+
+		if (flags & R128_DEPTH) {
+			BEGIN_RING(6);
+
+			OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+			OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+				 R128_GMC_BRUSH_SOLID_COLOR |
+				 (dev_priv->depth_fmt << 8) |
+				 R128_GMC_SRC_DATATYPE_COLOR |
+				 R128_ROP3_P |
+				 R128_GMC_CLR_CMP_CNTL_DIS |
+				 R128_GMC_AUX_CLIP_DIS | R128_GMC_WR_MSK_DIS);
+
+			OUT_RING(dev_priv->depth_pitch_offset_c);
+			OUT_RING(clear->clear_depth);
+
+			OUT_RING((x << 16) | y);
+			OUT_RING((w << 16) | h);
+
+			ADVANCE_RING();
+		}
+	}
+}
+
+static void r128_cce_dispatch_swap(struct drm_device * dev)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int nbox = sarea_priv->nbox;
+	struct drm_clip_rect *pbox = sarea_priv->boxes;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+#if R128_PERFORMANCE_BOXES
+	/* Do some trivial performance monitoring...
+	 */
+	r128_cce_performance_boxes(dev_priv);
+#endif
+
+	for (i = 0; i < nbox; i++) {
+		int x = pbox[i].x1;
+		int y = pbox[i].y1;
+		int w = pbox[i].x2 - x;
+		int h = pbox[i].y2 - y;
+
+		BEGIN_RING(7);
+
+		OUT_RING(CCE_PACKET3(R128_CNTL_BITBLT_MULTI, 5));
+		OUT_RING(R128_GMC_SRC_PITCH_OFFSET_CNTL |
+			 R128_GMC_DST_PITCH_OFFSET_CNTL |
+			 R128_GMC_BRUSH_NONE |
+			 (dev_priv->color_fmt << 8) |
+			 R128_GMC_SRC_DATATYPE_COLOR |
+			 R128_ROP3_S |
+			 R128_DP_SRC_SOURCE_MEMORY |
+			 R128_GMC_CLR_CMP_CNTL_DIS |
+			 R128_GMC_AUX_CLIP_DIS | R128_GMC_WR_MSK_DIS);
+
+		/* Make this work even if front & back are flipped:
+		 */
+		if (dev_priv->current_page == 0) {
+			OUT_RING(dev_priv->back_pitch_offset_c);
+			OUT_RING(dev_priv->front_pitch_offset_c);
+		} else {
+			OUT_RING(dev_priv->front_pitch_offset_c);
+			OUT_RING(dev_priv->back_pitch_offset_c);
+		}
+
+		OUT_RING((x << 16) | y);
+		OUT_RING((x << 16) | y);
+		OUT_RING((w << 16) | h);
+
+		ADVANCE_RING();
+	}
+
+	/* Increment the frame counter.  The client-side 3D driver must
+	 * throttle the framerate by waiting for this value before
+	 * performing the swapbuffer ioctl.
+	 */
+	dev_priv->sarea_priv->last_frame++;
+
+	BEGIN_RING(2);
+
+	OUT_RING(CCE_PACKET0(R128_LAST_FRAME_REG, 0));
+	OUT_RING(dev_priv->sarea_priv->last_frame);
+
+	ADVANCE_RING();
+}
+
+static void r128_cce_dispatch_flip(struct drm_device * dev)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	RING_LOCALS;
+	DRM_DEBUG("%s: page=%d pfCurrentPage=%d\n",
+		  __FUNCTION__,
+		  dev_priv->current_page, dev_priv->sarea_priv->pfCurrentPage);
+
+#if R128_PERFORMANCE_BOXES
+	/* Do some trivial performance monitoring...
+	 */
+	r128_cce_performance_boxes(dev_priv);
+#endif
+
+	BEGIN_RING(4);
+
+	R128_WAIT_UNTIL_PAGE_FLIPPED();
+	OUT_RING(CCE_PACKET0(R128_CRTC_OFFSET, 0));
+
+	if (dev_priv->current_page == 0) {
+		OUT_RING(dev_priv->back_offset);
+	} else {
+		OUT_RING(dev_priv->front_offset);
+	}
+
+	ADVANCE_RING();
+
+	/* Increment the frame counter.  The client-side 3D driver must
+	 * throttle the framerate by waiting for this value before
+	 * performing the swapbuffer ioctl.
+	 */
+	dev_priv->sarea_priv->last_frame++;
+	dev_priv->sarea_priv->pfCurrentPage = dev_priv->current_page =
+	    1 - dev_priv->current_page;
+
+	BEGIN_RING(2);
+
+	OUT_RING(CCE_PACKET0(R128_LAST_FRAME_REG, 0));
+	OUT_RING(dev_priv->sarea_priv->last_frame);
+
+	ADVANCE_RING();
+}
+
+static void r128_cce_dispatch_vertex(struct drm_device * dev, struct drm_buf * buf)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_buf_priv_t *buf_priv = buf->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int format = sarea_priv->vc_format;
+	int offset = buf->bus_address;
+	int size = buf->used;
+	int prim = buf_priv->prim;
+	int i = 0;
+	RING_LOCALS;
+	DRM_DEBUG("buf=%d nbox=%d\n", buf->idx, sarea_priv->nbox);
+
+	if (0)
+		r128_print_dirty("dispatch_vertex", sarea_priv->dirty);
+
+	if (buf->used) {
+		buf_priv->dispatched = 1;
+
+		if (sarea_priv->dirty & ~R128_UPLOAD_CLIPRECTS) {
+			r128_emit_state(dev_priv);
+		}
+
+		do {
+			/* Emit the next set of up to three cliprects */
+			if (i < sarea_priv->nbox) {
+				r128_emit_clip_rects(dev_priv,
+						     &sarea_priv->boxes[i],
+						     sarea_priv->nbox - i);
+			}
+
+			/* Emit the vertex buffer rendering commands */
+			BEGIN_RING(5);
+
+			OUT_RING(CCE_PACKET3(R128_3D_RNDR_GEN_INDX_PRIM, 3));
+			OUT_RING(offset);
+			OUT_RING(size);
+			OUT_RING(format);
+			OUT_RING(prim | R128_CCE_VC_CNTL_PRIM_WALK_LIST |
+				 (size << R128_CCE_VC_CNTL_NUM_SHIFT));
+
+			ADVANCE_RING();
+
+			i += 3;
+		} while (i < sarea_priv->nbox);
+	}
+
+	if (buf_priv->discard) {
+		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
+
+		/* Emit the vertex buffer age */
+		BEGIN_RING(2);
+
+		OUT_RING(CCE_PACKET0(R128_LAST_DISPATCH_REG, 0));
+		OUT_RING(buf_priv->age);
+
+		ADVANCE_RING();
+
+		buf->pending = 1;
+		buf->used = 0;
+		/* FIXME: Check dispatched field */
+		buf_priv->dispatched = 0;
+	}
+
+	dev_priv->sarea_priv->last_dispatch++;
+
+	sarea_priv->dirty &= ~R128_UPLOAD_CLIPRECTS;
+	sarea_priv->nbox = 0;
+}
+
+static void r128_cce_dispatch_indirect(struct drm_device * dev,
+				       struct drm_buf * buf, int start, int end)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_buf_priv_t *buf_priv = buf->dev_private;
+	RING_LOCALS;
+	DRM_DEBUG("indirect: buf=%d s=0x%x e=0x%x\n", buf->idx, start, end);
+
+	if (start != end) {
+		int offset = buf->bus_address + start;
+		int dwords = (end - start + 3) / sizeof(u32);
+
+		/* Indirect buffer data must be an even number of
+		 * dwords, so if we've been given an odd number we must
+		 * pad the data with a Type-2 CCE packet.
+		 */
+		if (dwords & 1) {
+			u32 *data = (u32 *)
+			    ((char *)dev->agp_buffer_map->handle
+			     + buf->offset + start);
+			data[dwords++] = cpu_to_le32(R128_CCE_PACKET2);
+		}
+
+		buf_priv->dispatched = 1;
+
+		/* Fire off the indirect buffer */
+		BEGIN_RING(3);
+
+		OUT_RING(CCE_PACKET0(R128_PM4_IW_INDOFF, 1));
+		OUT_RING(offset);
+		OUT_RING(dwords);
+
+		ADVANCE_RING();
+	}
+
+	if (buf_priv->discard) {
+		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
+
+		/* Emit the indirect buffer age */
+		BEGIN_RING(2);
+
+		OUT_RING(CCE_PACKET0(R128_LAST_DISPATCH_REG, 0));
+		OUT_RING(buf_priv->age);
+
+		ADVANCE_RING();
+
+		buf->pending = 1;
+		buf->used = 0;
+		/* FIXME: Check dispatched field */
+		buf_priv->dispatched = 0;
+	}
+
+	dev_priv->sarea_priv->last_dispatch++;
+}
+
+static void r128_cce_dispatch_indices(struct drm_device * dev,
+				      struct drm_buf * buf,
+				      int start, int end, int count)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_buf_priv_t *buf_priv = buf->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int format = sarea_priv->vc_format;
+	int offset = dev->agp_buffer_map->offset - dev_priv->cce_buffers_offset;
+	int prim = buf_priv->prim;
+	u32 *data;
+	int dwords;
+	int i = 0;
+	RING_LOCALS;
+	DRM_DEBUG("indices: s=%d e=%d c=%d\n", start, end, count);
+
+	if (0)
+		r128_print_dirty("dispatch_indices", sarea_priv->dirty);
+
+	if (start != end) {
+		buf_priv->dispatched = 1;
+
+		if (sarea_priv->dirty & ~R128_UPLOAD_CLIPRECTS) {
+			r128_emit_state(dev_priv);
+		}
+
+		dwords = (end - start + 3) / sizeof(u32);
+
+		data = (u32 *) ((char *)dev->agp_buffer_map->handle
+				+ buf->offset + start);
+
+		data[0] = cpu_to_le32(CCE_PACKET3(R128_3D_RNDR_GEN_INDX_PRIM,
+						  dwords - 2));
+
+		data[1] = cpu_to_le32(offset);
+		data[2] = cpu_to_le32(R128_MAX_VB_VERTS);
+		data[3] = cpu_to_le32(format);
+		data[4] = cpu_to_le32((prim | R128_CCE_VC_CNTL_PRIM_WALK_IND |
+				       (count << 16)));
+
+		if (count & 0x1) {
+#ifdef __LITTLE_ENDIAN
+			data[dwords - 1] &= 0x0000ffff;
+#else
+			data[dwords - 1] &= 0xffff0000;
+#endif
+		}
+
+		do {
+			/* Emit the next set of up to three cliprects */
+			if (i < sarea_priv->nbox) {
+				r128_emit_clip_rects(dev_priv,
+						     &sarea_priv->boxes[i],
+						     sarea_priv->nbox - i);
+			}
+
+			r128_cce_dispatch_indirect(dev, buf, start, end);
+
+			i += 3;
+		} while (i < sarea_priv->nbox);
+	}
+
+	if (buf_priv->discard) {
+		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
+
+		/* Emit the vertex buffer age */
+		BEGIN_RING(2);
+
+		OUT_RING(CCE_PACKET0(R128_LAST_DISPATCH_REG, 0));
+		OUT_RING(buf_priv->age);
+
+		ADVANCE_RING();
+
+		buf->pending = 1;
+		/* FIXME: Check dispatched field */
+		buf_priv->dispatched = 0;
+	}
+
+	dev_priv->sarea_priv->last_dispatch++;
+
+	sarea_priv->dirty &= ~R128_UPLOAD_CLIPRECTS;
+	sarea_priv->nbox = 0;
+}
+
+static int r128_cce_dispatch_blit(struct drm_device * dev,
+				  struct drm_file *file_priv,
+				  drm_r128_blit_t * blit)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_r128_buf_priv_t *buf_priv;
+	u32 *data;
+	int dword_shift, dwords;
+	RING_LOCALS;
+	DRM_DEBUG("\n");
+
+	/* The compiler won't optimize away a division by a variable,
+	 * even if the only legal values are powers of two.  Thus, we'll
+	 * use a shift instead.
+	 */
+	switch (blit->format) {
+	case R128_DATATYPE_ARGB8888:
+		dword_shift = 0;
+		break;
+	case R128_DATATYPE_ARGB1555:
+	case R128_DATATYPE_RGB565:
+	case R128_DATATYPE_ARGB4444:
+	case R128_DATATYPE_YVYU422:
+	case R128_DATATYPE_VYUY422:
+		dword_shift = 1;
+		break;
+	case R128_DATATYPE_CI8:
+	case R128_DATATYPE_RGB8:
+		dword_shift = 2;
+		break;
+	default:
+		DRM_ERROR("invalid blit format %d\n", blit->format);
+		return -EINVAL;
+	}
+
+	/* Flush the pixel cache, and mark the contents as Read Invalid.
+	 * This ensures no pixel data gets mixed up with the texture
+	 * data from the host data blit, otherwise part of the texture
+	 * image may be corrupted.
+	 */
+	BEGIN_RING(2);
+
+	OUT_RING(CCE_PACKET0(R128_PC_GUI_CTLSTAT, 0));
+	OUT_RING(R128_PC_RI_GUI | R128_PC_FLUSH_GUI);
+
+	ADVANCE_RING();
+
+	/* Dispatch the indirect buffer.
+	 */
+	buf = dma->buflist[blit->idx];
+	buf_priv = buf->dev_private;
+
+	if (buf->file_priv != file_priv) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
+	}
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", blit->idx);
+		return -EINVAL;
+	}
+
+	buf_priv->discard = 1;
+
+	dwords = (blit->width * blit->height) >> dword_shift;
+
+	data = (u32 *) ((char *)dev->agp_buffer_map->handle + buf->offset);
+
+	data[0] = cpu_to_le32(CCE_PACKET3(R128_CNTL_HOSTDATA_BLT, dwords + 6));
+	data[1] = cpu_to_le32((R128_GMC_DST_PITCH_OFFSET_CNTL |
+			       R128_GMC_BRUSH_NONE |
+			       (blit->format << 8) |
+			       R128_GMC_SRC_DATATYPE_COLOR |
+			       R128_ROP3_S |
+			       R128_DP_SRC_SOURCE_HOST_DATA |
+			       R128_GMC_CLR_CMP_CNTL_DIS |
+			       R128_GMC_AUX_CLIP_DIS | R128_GMC_WR_MSK_DIS));
+
+	data[2] = cpu_to_le32((blit->pitch << 21) | (blit->offset >> 5));
+	data[3] = cpu_to_le32(0xffffffff);
+	data[4] = cpu_to_le32(0xffffffff);
+	data[5] = cpu_to_le32((blit->y << 16) | blit->x);
+	data[6] = cpu_to_le32((blit->height << 16) | blit->width);
+	data[7] = cpu_to_le32(dwords);
+
+	buf->used = (dwords + 8) * sizeof(u32);
+
+	r128_cce_dispatch_indirect(dev, buf, 0, buf->used);
+
+	/* Flush the pixel cache after the blit completes.  This ensures
+	 * the texture data is written out to memory before rendering
+	 * continues.
+	 */
+	BEGIN_RING(2);
+
+	OUT_RING(CCE_PACKET0(R128_PC_GUI_CTLSTAT, 0));
+	OUT_RING(R128_PC_FLUSH_GUI);
+
+	ADVANCE_RING();
+
+	return 0;
+}
+
+/* ================================================================
+ * Tiled depth buffer management
+ *
+ * FIXME: These should all set the destination write mask for when we
+ * have hardware stencil support.
+ */
+
+static int r128_cce_dispatch_write_span(struct drm_device * dev,
+					drm_r128_depth_t * depth)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	int count, x, y;
+	u32 *buffer;
+	u8 *mask;
+	int i, buffer_size, mask_size;
+	RING_LOCALS;
+	DRM_DEBUG("\n");
+
+	count = depth->n;
+	if (count > 4096 || count <= 0)
+		return -EMSGSIZE;
+
+	if (DRM_COPY_FROM_USER(&x, depth->x, sizeof(x))) {
+		return -EFAULT;
+	}
+	if (DRM_COPY_FROM_USER(&y, depth->y, sizeof(y))) {
+		return -EFAULT;
+	}
+
+	buffer_size = depth->n * sizeof(u32);
+	buffer = drm_alloc(buffer_size, DRM_MEM_BUFS);
+	if (buffer == NULL)
+		return -ENOMEM;
+	if (DRM_COPY_FROM_USER(buffer, depth->buffer, buffer_size)) {
+		drm_free(buffer, buffer_size, DRM_MEM_BUFS);
+		return -EFAULT;
+	}
+
+	mask_size = depth->n * sizeof(u8);
+	if (depth->mask) {
+		mask = drm_alloc(mask_size, DRM_MEM_BUFS);
+		if (mask == NULL) {
+			drm_free(buffer, buffer_size, DRM_MEM_BUFS);
+			return -ENOMEM;
+		}
+		if (DRM_COPY_FROM_USER(mask, depth->mask, mask_size)) {
+			drm_free(buffer, buffer_size, DRM_MEM_BUFS);
+			drm_free(mask, mask_size, DRM_MEM_BUFS);
+			return -EFAULT;
+		}
+
+		for (i = 0; i < count; i++, x++) {
+			if (mask[i]) {
+				BEGIN_RING(6);
+
+				OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+				OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+					 R128_GMC_BRUSH_SOLID_COLOR |
+					 (dev_priv->depth_fmt << 8) |
+					 R128_GMC_SRC_DATATYPE_COLOR |
+					 R128_ROP3_P |
+					 R128_GMC_CLR_CMP_CNTL_DIS |
+					 R128_GMC_WR_MSK_DIS);
+
+				OUT_RING(dev_priv->depth_pitch_offset_c);
+				OUT_RING(buffer[i]);
+
+				OUT_RING((x << 16) | y);
+				OUT_RING((1 << 16) | 1);
+
+				ADVANCE_RING();
+			}
+		}
+
+		drm_free(mask, mask_size, DRM_MEM_BUFS);
+	} else {
+		for (i = 0; i < count; i++, x++) {
+			BEGIN_RING(6);
+
+			OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+			OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+				 R128_GMC_BRUSH_SOLID_COLOR |
+				 (dev_priv->depth_fmt << 8) |
+				 R128_GMC_SRC_DATATYPE_COLOR |
+				 R128_ROP3_P |
+				 R128_GMC_CLR_CMP_CNTL_DIS |
+				 R128_GMC_WR_MSK_DIS);
+
+			OUT_RING(dev_priv->depth_pitch_offset_c);
+			OUT_RING(buffer[i]);
+
+			OUT_RING((x << 16) | y);
+			OUT_RING((1 << 16) | 1);
+
+			ADVANCE_RING();
+		}
+	}
+
+	drm_free(buffer, buffer_size, DRM_MEM_BUFS);
+
+	return 0;
+}
+
+static int r128_cce_dispatch_write_pixels(struct drm_device * dev,
+					  drm_r128_depth_t * depth)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	int count, *x, *y;
+	u32 *buffer;
+	u8 *mask;
+	int i, xbuf_size, ybuf_size, buffer_size, mask_size;
+	RING_LOCALS;
+	DRM_DEBUG("\n");
+
+	count = depth->n;
+	if (count > 4096 || count <= 0)
+		return -EMSGSIZE;
+
+	xbuf_size = count * sizeof(*x);
+	ybuf_size = count * sizeof(*y);
+	x = drm_alloc(xbuf_size, DRM_MEM_BUFS);
+	if (x == NULL) {
+		return -ENOMEM;
+	}
+	y = drm_alloc(ybuf_size, DRM_MEM_BUFS);
+	if (y == NULL) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		return -ENOMEM;
+	}
+	if (DRM_COPY_FROM_USER(x, depth->x, xbuf_size)) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
+		return -EFAULT;
+	}
+	if (DRM_COPY_FROM_USER(y, depth->y, xbuf_size)) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
+		return -EFAULT;
+	}
+
+	buffer_size = depth->n * sizeof(u32);
+	buffer = drm_alloc(buffer_size, DRM_MEM_BUFS);
+	if (buffer == NULL) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
+		return -ENOMEM;
+	}
+	if (DRM_COPY_FROM_USER(buffer, depth->buffer, buffer_size)) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
+		drm_free(buffer, buffer_size, DRM_MEM_BUFS);
+		return -EFAULT;
+	}
+
+	if (depth->mask) {
+		mask_size = depth->n * sizeof(u8);
+		mask = drm_alloc(mask_size, DRM_MEM_BUFS);
+		if (mask == NULL) {
+			drm_free(x, xbuf_size, DRM_MEM_BUFS);
+			drm_free(y, ybuf_size, DRM_MEM_BUFS);
+			drm_free(buffer, buffer_size, DRM_MEM_BUFS);
+			return -ENOMEM;
+		}
+		if (DRM_COPY_FROM_USER(mask, depth->mask, mask_size)) {
+			drm_free(x, xbuf_size, DRM_MEM_BUFS);
+			drm_free(y, ybuf_size, DRM_MEM_BUFS);
+			drm_free(buffer, buffer_size, DRM_MEM_BUFS);
+			drm_free(mask, mask_size, DRM_MEM_BUFS);
+			return -EFAULT;
+		}
+
+		for (i = 0; i < count; i++) {
+			if (mask[i]) {
+				BEGIN_RING(6);
+
+				OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+				OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+					 R128_GMC_BRUSH_SOLID_COLOR |
+					 (dev_priv->depth_fmt << 8) |
+					 R128_GMC_SRC_DATATYPE_COLOR |
+					 R128_ROP3_P |
+					 R128_GMC_CLR_CMP_CNTL_DIS |
+					 R128_GMC_WR_MSK_DIS);
+
+				OUT_RING(dev_priv->depth_pitch_offset_c);
+				OUT_RING(buffer[i]);
+
+				OUT_RING((x[i] << 16) | y[i]);
+				OUT_RING((1 << 16) | 1);
+
+				ADVANCE_RING();
+			}
+		}
+
+		drm_free(mask, mask_size, DRM_MEM_BUFS);
+	} else {
+		for (i = 0; i < count; i++) {
+			BEGIN_RING(6);
+
+			OUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));
+			OUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |
+				 R128_GMC_BRUSH_SOLID_COLOR |
+				 (dev_priv->depth_fmt << 8) |
+				 R128_GMC_SRC_DATATYPE_COLOR |
+				 R128_ROP3_P |
+				 R128_GMC_CLR_CMP_CNTL_DIS |
+				 R128_GMC_WR_MSK_DIS);
+
+			OUT_RING(dev_priv->depth_pitch_offset_c);
+			OUT_RING(buffer[i]);
+
+			OUT_RING((x[i] << 16) | y[i]);
+			OUT_RING((1 << 16) | 1);
+
+			ADVANCE_RING();
+		}
+	}
+
+	drm_free(x, xbuf_size, DRM_MEM_BUFS);
+	drm_free(y, ybuf_size, DRM_MEM_BUFS);
+	drm_free(buffer, buffer_size, DRM_MEM_BUFS);
+
+	return 0;
+}
+
+static int r128_cce_dispatch_read_span(struct drm_device * dev,
+				       drm_r128_depth_t * depth)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	int count, x, y;
+	RING_LOCALS;
+	DRM_DEBUG("\n");
+
+	count = depth->n;
+	if (count > 4096 || count <= 0)
+		return -EMSGSIZE;
+
+	if (DRM_COPY_FROM_USER(&x, depth->x, sizeof(x))) {
+		return -EFAULT;
+	}
+	if (DRM_COPY_FROM_USER(&y, depth->y, sizeof(y))) {
+		return -EFAULT;
+	}
+
+	BEGIN_RING(7);
+
+	OUT_RING(CCE_PACKET3(R128_CNTL_BITBLT_MULTI, 5));
+	OUT_RING(R128_GMC_SRC_PITCH_OFFSET_CNTL |
+		 R128_GMC_DST_PITCH_OFFSET_CNTL |
+		 R128_GMC_BRUSH_NONE |
+		 (dev_priv->depth_fmt << 8) |
+		 R128_GMC_SRC_DATATYPE_COLOR |
+		 R128_ROP3_S |
+		 R128_DP_SRC_SOURCE_MEMORY |
+		 R128_GMC_CLR_CMP_CNTL_DIS | R128_GMC_WR_MSK_DIS);
+
+	OUT_RING(dev_priv->depth_pitch_offset_c);
+	OUT_RING(dev_priv->span_pitch_offset_c);
+
+	OUT_RING((x << 16) | y);
+	OUT_RING((0 << 16) | 0);
+	OUT_RING((count << 16) | 1);
+
+	ADVANCE_RING();
+
+	return 0;
+}
+
+static int r128_cce_dispatch_read_pixels(struct drm_device * dev,
+					 drm_r128_depth_t * depth)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	int count, *x, *y;
+	int i, xbuf_size, ybuf_size;
+	RING_LOCALS;
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	count = depth->n;
+	if (count > 4096 || count <= 0)
+		return -EMSGSIZE;
+
+	if (count > dev_priv->depth_pitch) {
+		count = dev_priv->depth_pitch;
+	}
+
+	xbuf_size = count * sizeof(*x);
+	ybuf_size = count * sizeof(*y);
+	x = drm_alloc(xbuf_size, DRM_MEM_BUFS);
+	if (x == NULL) {
+		return -ENOMEM;
+	}
+	y = drm_alloc(ybuf_size, DRM_MEM_BUFS);
+	if (y == NULL) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		return -ENOMEM;
+	}
+	if (DRM_COPY_FROM_USER(x, depth->x, xbuf_size)) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
+		return -EFAULT;
+	}
+	if (DRM_COPY_FROM_USER(y, depth->y, ybuf_size)) {
+		drm_free(x, xbuf_size, DRM_MEM_BUFS);
+		drm_free(y, ybuf_size, DRM_MEM_BUFS);
+		return -EFAULT;
+	}
+
+	for (i = 0; i < count; i++) {
+		BEGIN_RING(7);
+
+		OUT_RING(CCE_PACKET3(R128_CNTL_BITBLT_MULTI, 5));
+		OUT_RING(R128_GMC_SRC_PITCH_OFFSET_CNTL |
+			 R128_GMC_DST_PITCH_OFFSET_CNTL |
+			 R128_GMC_BRUSH_NONE |
+			 (dev_priv->depth_fmt << 8) |
+			 R128_GMC_SRC_DATATYPE_COLOR |
+			 R128_ROP3_S |
+			 R128_DP_SRC_SOURCE_MEMORY |
+			 R128_GMC_CLR_CMP_CNTL_DIS | R128_GMC_WR_MSK_DIS);
+
+		OUT_RING(dev_priv->depth_pitch_offset_c);
+		OUT_RING(dev_priv->span_pitch_offset_c);
+
+		OUT_RING((x[i] << 16) | y[i]);
+		OUT_RING((i << 16) | 0);
+		OUT_RING((1 << 16) | 1);
+
+		ADVANCE_RING();
+	}
+
+	drm_free(x, xbuf_size, DRM_MEM_BUFS);
+	drm_free(y, ybuf_size, DRM_MEM_BUFS);
+
+	return 0;
+}
+
+/* ================================================================
+ * Polygon stipple
+ */
+
+static void r128_cce_dispatch_stipple(struct drm_device * dev, u32 * stipple)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	BEGIN_RING(33);
+
+	OUT_RING(CCE_PACKET0(R128_BRUSH_DATA0, 31));
+	for (i = 0; i < 32; i++) {
+		OUT_RING(stipple[i]);
+	}
+
+	ADVANCE_RING();
+}
+
+/* ================================================================
+ * IOCTL functions
+ */
+
+static int r128_cce_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_clear_t *clear = data;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+
+	if (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;
+
+	r128_cce_dispatch_clear(dev, clear);
+	COMMIT_RING();
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	dev_priv->sarea_priv->dirty |= R128_UPLOAD_CONTEXT | R128_UPLOAD_MASKS;
+
+	return 0;
+}
+
+static int r128_do_init_pageflip(struct drm_device * dev)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("\n");
+
+	dev_priv->crtc_offset = R128_READ(R128_CRTC_OFFSET);
+	dev_priv->crtc_offset_cntl = R128_READ(R128_CRTC_OFFSET_CNTL);
+
+	R128_WRITE(R128_CRTC_OFFSET, dev_priv->front_offset);
+	R128_WRITE(R128_CRTC_OFFSET_CNTL,
+		   dev_priv->crtc_offset_cntl | R128_CRTC_OFFSET_FLIP_CNTL);
+
+	dev_priv->page_flipping = 1;
+	dev_priv->current_page = 0;
+	dev_priv->sarea_priv->pfCurrentPage = dev_priv->current_page;
+
+	return 0;
+}
+
+static int r128_do_cleanup_pageflip(struct drm_device * dev)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("\n");
+
+	R128_WRITE(R128_CRTC_OFFSET, dev_priv->crtc_offset);
+	R128_WRITE(R128_CRTC_OFFSET_CNTL, dev_priv->crtc_offset_cntl);
+
+	if (dev_priv->current_page != 0) {
+		r128_cce_dispatch_flip(dev);
+		COMMIT_RING();
+	}
+
+	dev_priv->page_flipping = 0;
+	return 0;
+}
+
+/* Swapping and flipping are different operations, need different ioctls.
+ * They can & should be intermixed to support multiple 3d windows.
+ */
+
+static int r128_cce_flip(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+
+	if (!dev_priv->page_flipping)
+		r128_do_init_pageflip(dev);
+
+	r128_cce_dispatch_flip(dev);
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int r128_cce_swap(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+
+	if (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;
+
+	r128_cce_dispatch_swap(dev);
+	dev_priv->sarea_priv->dirty |= (R128_UPLOAD_CONTEXT |
+					R128_UPLOAD_MASKS);
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int r128_cce_vertex(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_r128_buf_priv_t *buf_priv;
+	drm_r128_vertex_t *vertex = data;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",
+		  DRM_CURRENTPID, vertex->idx, vertex->count, vertex->discard);
+
+	if (vertex->idx < 0 || vertex->idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  vertex->idx, dma->buf_count - 1);
+		return -EINVAL;
+	}
+	if (vertex->prim < 0 ||
+	    vertex->prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2) {
+		DRM_ERROR("buffer prim %d\n", vertex->prim);
+		return -EINVAL;
+	}
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
+
+	buf = dma->buflist[vertex->idx];
+	buf_priv = buf->dev_private;
+
+	if (buf->file_priv != file_priv) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
+	}
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", vertex->idx);
+		return -EINVAL;
+	}
+
+	buf->used = vertex->count;
+	buf_priv->prim = vertex->prim;
+	buf_priv->discard = vertex->discard;
+
+	r128_cce_dispatch_vertex(dev, buf);
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int r128_cce_indices(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_r128_buf_priv_t *buf_priv;
+	drm_r128_indices_t *elts = data;
+	int count;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("pid=%d buf=%d s=%d e=%d d=%d\n", DRM_CURRENTPID,
+		  elts->idx, elts->start, elts->end, elts->discard);
+
+	if (elts->idx < 0 || elts->idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  elts->idx, dma->buf_count - 1);
+		return -EINVAL;
+	}
+	if (elts->prim < 0 ||
+	    elts->prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2) {
+		DRM_ERROR("buffer prim %d\n", elts->prim);
+		return -EINVAL;
+	}
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
+
+	buf = dma->buflist[elts->idx];
+	buf_priv = buf->dev_private;
+
+	if (buf->file_priv != file_priv) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
+	}
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", elts->idx);
+		return -EINVAL;
+	}
+
+	count = (elts->end - elts->start) / sizeof(u16);
+	elts->start -= R128_INDEX_PRIM_OFFSET;
+
+	if (elts->start & 0x7) {
+		DRM_ERROR("misaligned buffer 0x%x\n", elts->start);
+		return -EINVAL;
+	}
+	if (elts->start < buf->used) {
+		DRM_ERROR("no header 0x%x - 0x%x\n", elts->start, buf->used);
+		return -EINVAL;
+	}
+
+	buf->used = elts->end;
+	buf_priv->prim = elts->prim;
+	buf_priv->discard = elts->discard;
+
+	r128_cce_dispatch_indices(dev, buf, elts->start, elts->end, count);
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int r128_cce_blit(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	struct drm_device_dma *dma = dev->dma;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_blit_t *blit = data;
+	int ret;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	DRM_DEBUG("pid=%d index=%d\n", DRM_CURRENTPID, blit->idx);
+
+	if (blit->idx < 0 || blit->idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  blit->idx, dma->buf_count - 1);
+		return -EINVAL;
+	}
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
+
+	ret = r128_cce_dispatch_blit(dev, file_priv, blit);
+
+	COMMIT_RING();
+	return ret;
+}
+
+static int r128_cce_depth(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_depth_t *depth = data;
+	int ret;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+
+	ret = -EINVAL;
+	switch (depth->func) {
+	case R128_WRITE_SPAN:
+		ret = r128_cce_dispatch_write_span(dev, depth);
+		break;
+	case R128_WRITE_PIXELS:
+		ret = r128_cce_dispatch_write_pixels(dev, depth);
+		break;
+	case R128_READ_SPAN:
+		ret = r128_cce_dispatch_read_span(dev, depth);
+		break;
+	case R128_READ_PIXELS:
+		ret = r128_cce_dispatch_read_pixels(dev, depth);
+		break;
+	}
+
+	COMMIT_RING();
+	return ret;
+}
+
+static int r128_cce_stipple(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_stipple_t *stipple = data;
+	u32 mask[32];
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (DRM_COPY_FROM_USER(&mask, stipple->mask, 32 * sizeof(u32)))
+		return -EFAULT;
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+
+	r128_cce_dispatch_stipple(dev, mask);
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int r128_cce_indirect(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_r128_buf_priv_t *buf_priv;
+	drm_r128_indirect_t *indirect = data;
+#if 0
+	RING_LOCALS;
+#endif
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("indirect: idx=%d s=%d e=%d d=%d\n",
+		  indirect->idx, indirect->start, indirect->end,
+		  indirect->discard);
+
+	if (indirect->idx < 0 || indirect->idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  indirect->idx, dma->buf_count - 1);
+		return -EINVAL;
+	}
+
+	buf = dma->buflist[indirect->idx];
+	buf_priv = buf->dev_private;
+
+	if (buf->file_priv != file_priv) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
+	}
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", indirect->idx);
+		return -EINVAL;
+	}
+
+	if (indirect->start < buf->used) {
+		DRM_ERROR("reusing indirect: start=0x%x actual=0x%x\n",
+			  indirect->start, buf->used);
+		return -EINVAL;
+	}
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
+
+	buf->used = indirect->end;
+	buf_priv->discard = indirect->discard;
+
+#if 0
+	/* Wait for the 3D stream to idle before the indirect buffer
+	 * containing 2D acceleration commands is processed.
+	 */
+	BEGIN_RING(2);
+	RADEON_WAIT_UNTIL_3D_IDLE();
+	ADVANCE_RING();
+#endif
+
+	/* Dispatch the indirect buffer full of commands from the
+	 * X server.  This is insecure and is thus only available to
+	 * privileged clients.
+	 */
+	r128_cce_dispatch_indirect(dev, buf, indirect->start, indirect->end);
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int r128_getparam(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_getparam_t *param = data;
+	int value;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
+
+	switch (param->param) {
+	case R128_PARAM_IRQ_NR:
+		value = dev->irq;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (DRM_COPY_TO_USER(param->value, &value, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+void r128_driver_preclose(struct drm_device * dev, struct drm_file *file_priv)
+{
+	if (dev->dev_private) {
+		drm_r128_private_t *dev_priv = dev->dev_private;
+		if (dev_priv->page_flipping) {
+			r128_do_cleanup_pageflip(dev);
+		}
+	}
+}
+
+void r128_driver_lastclose(struct drm_device * dev)
+{
+	r128_do_cleanup_cce(dev);
+}
+
+struct drm_ioctl_desc r128_ioctls[] = {
+	DRM_IOCTL_DEF(DRM_R128_INIT, r128_cce_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_R128_CCE_START, r128_cce_start, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_R128_CCE_STOP, r128_cce_stop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_R128_CCE_RESET, r128_cce_reset, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_R128_CCE_IDLE, r128_cce_idle, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_R128_RESET, r128_engine_reset, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_R128_FULLSCREEN, r128_fullscreen, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_R128_SWAP, r128_cce_swap, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_R128_FLIP, r128_cce_flip, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_R128_CLEAR, r128_cce_clear, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_R128_VERTEX, r128_cce_vertex, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_R128_INDICES, r128_cce_indices, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_R128_BLIT, r128_cce_blit, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_R128_DEPTH, r128_cce_depth, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_R128_STIPPLE, r128_cce_stipple, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_R128_INDIRECT, r128_cce_indirect, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_R128_GETPARAM, r128_getparam, DRM_AUTH),
+};
+
+int r128_max_ioctl = DRM_ARRAY_SIZE(r128_ioctls);
Index: git/shared-core/r300_cmdbuf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/r300_cmdbuf.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,954 @@
+/* r300_cmdbuf.c -- Command buffer emission for R300 -*- linux-c -*-
+ *
+ * Copyright (C) The Weather Channel, Inc.  2002.
+ * Copyright (C) 2004 Nicolai Haehnle.
+ * All Rights Reserved.
+ *
+ * The Weather Channel (TM) funded Tungsten Graphics to develop the
+ * initial release of the Radeon 8500 driver under the XFree86 license.
+ * This notice must be preserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Nicolai Haehnle <prefect_@gmx.net>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "radeon_drm.h"
+#include "radeon_drv.h"
+#include "r300_reg.h"
+
+#define R300_SIMULTANEOUS_CLIPRECTS		4
+
+/* Values for R300_RE_CLIPRECT_CNTL depending on the number of cliprects
+ */
+static const int r300_cliprect_cntl[4] = {
+	0xAAAA,
+	0xEEEE,
+	0xFEFE,
+	0xFFFE
+};
+
+/**
+ * Emit up to R300_SIMULTANEOUS_CLIPRECTS cliprects from the given command
+ * buffer, starting with index n.
+ */
+static int r300_emit_cliprects(drm_radeon_private_t *dev_priv,
+			       drm_radeon_kcmd_buffer_t *cmdbuf, int n)
+{
+	struct drm_clip_rect box;
+	int nr;
+	int i;
+	RING_LOCALS;
+
+	nr = cmdbuf->nbox - n;
+	if (nr > R300_SIMULTANEOUS_CLIPRECTS)
+		nr = R300_SIMULTANEOUS_CLIPRECTS;
+
+	DRM_DEBUG("%i cliprects\n", nr);
+
+	if (nr) {
+		BEGIN_RING(6 + nr * 2);
+		OUT_RING(CP_PACKET0(R300_RE_CLIPRECT_TL_0, nr * 2 - 1));
+
+		for (i = 0; i < nr; ++i) {
+			if (DRM_COPY_FROM_USER_UNCHECKED
+			    (&box, &cmdbuf->boxes[n + i], sizeof(box))) {
+				DRM_ERROR("copy cliprect faulted\n");
+				return -EFAULT;
+			}
+
+			box.x1 =
+			    (box.x1 +
+			     R300_CLIPRECT_OFFSET) & R300_CLIPRECT_MASK;
+			box.y1 =
+			    (box.y1 +
+			     R300_CLIPRECT_OFFSET) & R300_CLIPRECT_MASK;
+			box.x2 =
+			    (box.x2 +
+			     R300_CLIPRECT_OFFSET) & R300_CLIPRECT_MASK;
+			box.y2 =
+			    (box.y2 +
+			     R300_CLIPRECT_OFFSET) & R300_CLIPRECT_MASK;
+
+			OUT_RING((box.x1 << R300_CLIPRECT_X_SHIFT) |
+				 (box.y1 << R300_CLIPRECT_Y_SHIFT));
+			OUT_RING((box.x2 << R300_CLIPRECT_X_SHIFT) |
+				 (box.y2 << R300_CLIPRECT_Y_SHIFT));
+		}
+
+		OUT_RING_REG(R300_RE_CLIPRECT_CNTL, r300_cliprect_cntl[nr - 1]);
+
+		/* TODO/SECURITY: Force scissors to a safe value, otherwise the
+		 * client might be able to trample over memory.
+		 * The impact should be very limited, but I'd rather be safe than
+		 * sorry.
+		 */
+		OUT_RING(CP_PACKET0(R300_RE_SCISSORS_TL, 1));
+		OUT_RING(0);
+		OUT_RING(R300_SCISSORS_X_MASK | R300_SCISSORS_Y_MASK);
+		ADVANCE_RING();
+	} else {
+		/* Why we allow zero cliprect rendering:
+		 * There are some commands in a command buffer that must be submitted
+		 * even when there are no cliprects, e.g. DMA buffer discard
+		 * or state setting (though state setting could be avoided by
+		 * simulating a loss of context).
+		 *
+		 * Now since the cmdbuf interface is so chaotic right now (and is
+		 * bound to remain that way for a bit until things settle down),
+		 * it is basically impossible to filter out the commands that are
+		 * necessary and those that aren't.
+		 *
+		 * So I choose the safe way and don't do any filtering at all;
+		 * instead, I simply set up the engine so that all rendering
+		 * can't produce any fragments.
+		 */
+		BEGIN_RING(2);
+		OUT_RING_REG(R300_RE_CLIPRECT_CNTL, 0);
+		ADVANCE_RING();
+	}
+
+	return 0;
+}
+
+static u8 r300_reg_flags[0x10000 >> 2];
+
+void r300_init_reg_flags(void)
+{
+	int i;
+	memset(r300_reg_flags, 0, 0x10000 >> 2);
+#define ADD_RANGE_MARK(reg, count,mark) \
+		for(i=((reg)>>2);i<((reg)>>2)+(count);i++)\
+			r300_reg_flags[i]|=(mark);
+
+#define MARK_SAFE		1
+#define MARK_CHECK_OFFSET	2
+
+#define ADD_RANGE(reg, count)	ADD_RANGE_MARK(reg, count, MARK_SAFE)
+
+	/* these match cmducs() command in r300_driver/r300/r300_cmdbuf.c */
+	ADD_RANGE(R300_SE_VPORT_XSCALE, 6);
+	ADD_RANGE(R300_VAP_CNTL, 1);
+	ADD_RANGE(R300_SE_VTE_CNTL, 2);
+	ADD_RANGE(0x2134, 2);
+	ADD_RANGE(R300_VAP_CNTL_STATUS, 1);
+	ADD_RANGE(R300_VAP_INPUT_CNTL_0, 2);
+	ADD_RANGE(0x21DC, 1);
+	ADD_RANGE(R300_VAP_UNKNOWN_221C, 1);
+	ADD_RANGE(R300_VAP_CLIP_X_0, 4);
+	ADD_RANGE(R300_VAP_PVS_WAITIDLE, 1);
+	ADD_RANGE(R300_VAP_UNKNOWN_2288, 1);
+	ADD_RANGE(R300_VAP_OUTPUT_VTX_FMT_0, 2);
+	ADD_RANGE(R300_VAP_PVS_CNTL_1, 3);
+	ADD_RANGE(R300_GB_ENABLE, 1);
+	ADD_RANGE(R300_GB_MSPOS0, 5);
+	ADD_RANGE(R300_TX_CNTL, 1);
+	ADD_RANGE(R300_TX_ENABLE, 1);
+	ADD_RANGE(0x4200, 4);
+	ADD_RANGE(0x4214, 1);
+	ADD_RANGE(R300_RE_POINTSIZE, 1);
+	ADD_RANGE(0x4230, 3);
+	ADD_RANGE(R300_RE_LINE_CNT, 1);
+	ADD_RANGE(R300_RE_UNK4238, 1);
+	ADD_RANGE(0x4260, 3);
+	ADD_RANGE(R300_RE_SHADE, 4);
+	ADD_RANGE(R300_RE_POLYGON_MODE, 5);
+	ADD_RANGE(R300_RE_ZBIAS_CNTL, 1);
+	ADD_RANGE(R300_RE_ZBIAS_T_FACTOR, 4);
+	ADD_RANGE(R300_RE_OCCLUSION_CNTL, 1);
+	ADD_RANGE(R300_RE_CULL_CNTL, 1);
+	ADD_RANGE(0x42C0, 2);
+	ADD_RANGE(R300_RS_CNTL_0, 2);
+	ADD_RANGE(R300_RS_INTERP_0, 8);
+	ADD_RANGE(R300_RS_ROUTE_0, 8);
+	ADD_RANGE(0x43A4, 2);
+	ADD_RANGE(0x43E8, 1);
+	ADD_RANGE(R300_PFS_CNTL_0, 3);
+	ADD_RANGE(R300_PFS_NODE_0, 4);
+	ADD_RANGE(R300_PFS_TEXI_0, 64);
+	ADD_RANGE(0x46A4, 5);
+	ADD_RANGE(R300_PFS_INSTR0_0, 64);
+	ADD_RANGE(R300_PFS_INSTR1_0, 64);
+	ADD_RANGE(R300_PFS_INSTR2_0, 64);
+	ADD_RANGE(R300_PFS_INSTR3_0, 64);
+	ADD_RANGE(R300_RE_FOG_STATE, 1);
+	ADD_RANGE(R300_FOG_COLOR_R, 3);
+	ADD_RANGE(R300_PP_ALPHA_TEST, 2);
+	ADD_RANGE(0x4BD8, 1);
+	ADD_RANGE(R300_PFS_PARAM_0_X, 64);
+	ADD_RANGE(0x4E00, 1);
+	ADD_RANGE(R300_RB3D_CBLEND, 2);
+	ADD_RANGE(R300_RB3D_COLORMASK, 1);
+	ADD_RANGE(R300_RB3D_BLEND_COLOR, 3);
+	ADD_RANGE_MARK(R300_RB3D_COLOROFFSET0, 1, MARK_CHECK_OFFSET);	/* check offset */
+	ADD_RANGE(R300_RB3D_COLORPITCH0, 1);
+	ADD_RANGE(0x4E50, 9);
+	ADD_RANGE(0x4E88, 1);
+	ADD_RANGE(0x4EA0, 2);
+	ADD_RANGE(R300_RB3D_ZSTENCIL_CNTL_0, 3);
+	ADD_RANGE(R300_RB3D_ZSTENCIL_FORMAT, 4);
+	ADD_RANGE_MARK(R300_RB3D_DEPTHOFFSET, 1, MARK_CHECK_OFFSET);	/* check offset */
+	ADD_RANGE(R300_RB3D_DEPTHPITCH, 1);
+	ADD_RANGE(0x4F28, 1);
+	ADD_RANGE(0x4F30, 2);
+	ADD_RANGE(0x4F44, 1);
+	ADD_RANGE(0x4F54, 1);
+
+	ADD_RANGE(R300_TX_FILTER_0, 16);
+	ADD_RANGE(R300_TX_FILTER1_0, 16);
+	ADD_RANGE(R300_TX_SIZE_0, 16);
+	ADD_RANGE(R300_TX_FORMAT_0, 16);
+	ADD_RANGE(R300_TX_PITCH_0, 16);
+	/* Texture offset is dangerous and needs more checking */
+	ADD_RANGE_MARK(R300_TX_OFFSET_0, 16, MARK_CHECK_OFFSET);
+	ADD_RANGE(R300_TX_CHROMA_KEY_0, 16);
+	ADD_RANGE(R300_TX_BORDER_COLOR_0, 16);
+
+	/* Sporadic registers used as primitives are emitted */
+	ADD_RANGE(R300_RB3D_ZCACHE_CTLSTAT, 1);
+	ADD_RANGE(R300_RB3D_DSTCACHE_CTLSTAT, 1);
+	ADD_RANGE(R300_VAP_INPUT_ROUTE_0_0, 8);
+	ADD_RANGE(R300_VAP_INPUT_ROUTE_1_0, 8);
+
+}
+
+static __inline__ int r300_check_range(unsigned reg, int count)
+{
+	int i;
+	if (reg & ~0xffff)
+		return -1;
+	for (i = (reg >> 2); i < (reg >> 2) + count; i++)
+		if (r300_reg_flags[i] != MARK_SAFE)
+			return 1;
+	return 0;
+}
+
+static __inline__ int r300_emit_carefully_checked_packet0(drm_radeon_private_t *
+							  dev_priv,
+							  drm_radeon_kcmd_buffer_t
+							  * cmdbuf,
+							  drm_r300_cmd_header_t
+							  header)
+{
+	int reg;
+	int sz;
+	int i;
+	int values[64];
+	RING_LOCALS;
+
+	sz = header.packet0.count;
+	reg = (header.packet0.reghi << 8) | header.packet0.reglo;
+
+	if ((sz > 64) || (sz < 0)) {
+		DRM_ERROR
+		    ("Cannot emit more than 64 values at a time (reg=%04x sz=%d)\n",
+		     reg, sz);
+		return -EINVAL;
+	}
+	for (i = 0; i < sz; i++) {
+		values[i] = ((int *)cmdbuf->buf)[i];
+		switch (r300_reg_flags[(reg >> 2) + i]) {
+		case MARK_SAFE:
+			break;
+		case MARK_CHECK_OFFSET:
+			if (!radeon_check_offset(dev_priv, (u32) values[i])) {
+				DRM_ERROR
+				    ("Offset failed range check (reg=%04x sz=%d)\n",
+				     reg, sz);
+				return -EINVAL;
+			}
+			break;
+		default:
+			DRM_ERROR("Register %04x failed check as flag=%02x\n",
+				  reg + i * 4, r300_reg_flags[(reg >> 2) + i]);
+			return -EINVAL;
+		}
+	}
+
+	BEGIN_RING(1 + sz);
+	OUT_RING(CP_PACKET0(reg, sz - 1));
+	OUT_RING_TABLE(values, sz);
+	ADVANCE_RING();
+
+	cmdbuf->buf += sz * 4;
+	cmdbuf->bufsz -= sz * 4;
+
+	return 0;
+}
+
+/**
+ * Emits a packet0 setting arbitrary registers.
+ * Called by r300_do_cp_cmdbuf.
+ *
+ * Note that checks are performed on contents and addresses of the registers
+ */
+static __inline__ int r300_emit_packet0(drm_radeon_private_t *dev_priv,
+					drm_radeon_kcmd_buffer_t *cmdbuf,
+					drm_r300_cmd_header_t header)
+{
+	int reg;
+	int sz;
+	RING_LOCALS;
+
+	sz = header.packet0.count;
+	reg = (header.packet0.reghi << 8) | header.packet0.reglo;
+
+	if (!sz)
+		return 0;
+
+	if (sz * 4 > cmdbuf->bufsz)
+		return -EINVAL;
+
+	if (reg + sz * 4 >= 0x10000) {
+		DRM_ERROR("No such registers in hardware reg=%04x sz=%d\n", reg,
+			  sz);
+		return -EINVAL;
+	}
+
+	if (r300_check_range(reg, sz)) {
+		/* go and check everything */
+		return r300_emit_carefully_checked_packet0(dev_priv, cmdbuf,
+							   header);
+	}
+	/* the rest of the data is safe to emit, whatever the values the user passed */
+
+	BEGIN_RING(1 + sz);
+	OUT_RING(CP_PACKET0(reg, sz - 1));
+	OUT_RING_TABLE((int *)cmdbuf->buf, sz);
+	ADVANCE_RING();
+
+	cmdbuf->buf += sz * 4;
+	cmdbuf->bufsz -= sz * 4;
+
+	return 0;
+}
+
+/**
+ * Uploads user-supplied vertex program instructions or parameters onto
+ * the graphics card.
+ * Called by r300_do_cp_cmdbuf.
+ */
+static __inline__ int r300_emit_vpu(drm_radeon_private_t *dev_priv,
+				    drm_radeon_kcmd_buffer_t *cmdbuf,
+				    drm_r300_cmd_header_t header)
+{
+	int sz;
+	int addr;
+	RING_LOCALS;
+
+	sz = header.vpu.count;
+	addr = (header.vpu.adrhi << 8) | header.vpu.adrlo;
+
+	if (!sz)
+		return 0;
+	if (sz * 16 > cmdbuf->bufsz)
+		return -EINVAL;
+
+	BEGIN_RING(5 + sz * 4);
+	/* Wait for VAP to come to senses.. */
+	/* there is no need to emit it multiple times, (only once before VAP is programmed,
+	   but this optimization is for later */
+	OUT_RING_REG(R300_VAP_PVS_WAITIDLE, 0);
+	OUT_RING_REG(R300_VAP_PVS_UPLOAD_ADDRESS, addr);
+	OUT_RING(CP_PACKET0_TABLE(R300_VAP_PVS_UPLOAD_DATA, sz * 4 - 1));
+	OUT_RING_TABLE((int *)cmdbuf->buf, sz * 4);
+
+	ADVANCE_RING();
+
+	cmdbuf->buf += sz * 16;
+	cmdbuf->bufsz -= sz * 16;
+
+	return 0;
+}
+
+/**
+ * Emit a clear packet from userspace.
+ * Called by r300_emit_packet3.
+ */
+static __inline__ int r300_emit_clear(drm_radeon_private_t *dev_priv,
+				      drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	RING_LOCALS;
+
+	if (8 * 4 > cmdbuf->bufsz)
+		return -EINVAL;
+
+	BEGIN_RING(10);
+	OUT_RING(CP_PACKET3(R200_3D_DRAW_IMMD_2, 8));
+	OUT_RING(R300_PRIM_TYPE_POINT | R300_PRIM_WALK_RING |
+		 (1 << R300_PRIM_NUM_VERTICES_SHIFT));
+	OUT_RING_TABLE((int *)cmdbuf->buf, 8);
+	ADVANCE_RING();
+
+	cmdbuf->buf += 8 * 4;
+	cmdbuf->bufsz -= 8 * 4;
+
+	return 0;
+}
+
+static __inline__ int r300_emit_3d_load_vbpntr(drm_radeon_private_t *dev_priv,
+					       drm_radeon_kcmd_buffer_t *cmdbuf,
+					       u32 header)
+{
+	int count, i, k;
+#define MAX_ARRAY_PACKET  64
+	u32 payload[MAX_ARRAY_PACKET];
+	u32 narrays;
+	RING_LOCALS;
+
+	count = (header >> 16) & 0x3fff;
+
+	if ((count + 1) > MAX_ARRAY_PACKET) {
+		DRM_ERROR("Too large payload in 3D_LOAD_VBPNTR (count=%d)\n",
+			  count);
+		return -EINVAL;
+	}
+	memset(payload, 0, MAX_ARRAY_PACKET * 4);
+	memcpy(payload, cmdbuf->buf + 4, (count + 1) * 4);
+
+	/* carefully check packet contents */
+
+	narrays = payload[0];
+	k = 0;
+	i = 1;
+	while ((k < narrays) && (i < (count + 1))) {
+		i++;		/* skip attribute field */
+		if (!radeon_check_offset(dev_priv, payload[i])) {
+			DRM_ERROR
+			    ("Offset failed range check (k=%d i=%d) while processing 3D_LOAD_VBPNTR packet.\n",
+			     k, i);
+			return -EINVAL;
+		}
+		k++;
+		i++;
+		if (k == narrays)
+			break;
+		/* have one more to process, they come in pairs */
+		if (!radeon_check_offset(dev_priv, payload[i])) {
+			DRM_ERROR
+			    ("Offset failed range check (k=%d i=%d) while processing 3D_LOAD_VBPNTR packet.\n",
+			     k, i);
+			return -EINVAL;
+		}
+		k++;
+		i++;
+	}
+	/* do the counts match what we expect ? */
+	if ((k != narrays) || (i != (count + 1))) {
+		DRM_ERROR
+		    ("Malformed 3D_LOAD_VBPNTR packet (k=%d i=%d narrays=%d count+1=%d).\n",
+		     k, i, narrays, count + 1);
+		return -EINVAL;
+	}
+
+	/* all clear, output packet */
+
+	BEGIN_RING(count + 2);
+	OUT_RING(header);
+	OUT_RING_TABLE(payload, count + 1);
+	ADVANCE_RING();
+
+	cmdbuf->buf += (count + 2) * 4;
+	cmdbuf->bufsz -= (count + 2) * 4;
+
+	return 0;
+}
+
+static __inline__ int r300_emit_bitblt_multi(drm_radeon_private_t *dev_priv,
+					     drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	u32 *cmd = (u32 *) cmdbuf->buf;
+	int count, ret;
+	RING_LOCALS;
+
+	count=(cmd[0]>>16) & 0x3fff;
+
+	if (cmd[0] & 0x8000) {
+		u32 offset;
+
+		if (cmd[1] & (RADEON_GMC_SRC_PITCH_OFFSET_CNTL 
+			      | RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {
+			offset = cmd[2] << 10;
+			ret = !radeon_check_offset(dev_priv, offset);
+			if (ret) {
+				DRM_ERROR("Invalid bitblt first offset is %08X\n", offset);
+				return -EINVAL;
+			}
+		}
+
+		if ((cmd[1] & RADEON_GMC_SRC_PITCH_OFFSET_CNTL) &&
+		    (cmd[1] & RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {
+			offset = cmd[3] << 10;
+			ret = !radeon_check_offset(dev_priv, offset);
+			if (ret) {
+				DRM_ERROR("Invalid bitblt second offset is %08X\n", offset);
+				return -EINVAL;
+			}
+			
+		}
+	}
+
+	BEGIN_RING(count+2);
+	OUT_RING(cmd[0]);
+	OUT_RING_TABLE((int *)(cmdbuf->buf + 4), count + 1);
+	ADVANCE_RING();
+
+	cmdbuf->buf += (count+2)*4;
+	cmdbuf->bufsz -= (count+2)*4;
+
+	return 0;
+}
+
+static __inline__ int r300_emit_indx_buffer(drm_radeon_private_t *dev_priv,
+					     drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	u32 *cmd = (u32 *) cmdbuf->buf;
+	int count, ret;
+	RING_LOCALS;
+
+	count=(cmd[0]>>16) & 0x3fff;
+
+	if ((cmd[1] & 0x8000ffff) != 0x80000810) {
+		DRM_ERROR("Invalid indx_buffer reg address %08X\n", cmd[1]);
+		return -EINVAL;
+	}
+	ret = !radeon_check_offset(dev_priv, cmd[2]);
+	if (ret) {
+		DRM_ERROR("Invalid indx_buffer offset is %08X\n", cmd[2]);
+		return -EINVAL;
+	}
+
+	BEGIN_RING(count+2);
+	OUT_RING(cmd[0]);
+	OUT_RING_TABLE((int *)(cmdbuf->buf + 4), count + 1);
+	ADVANCE_RING();
+
+	cmdbuf->buf += (count+2)*4;
+	cmdbuf->bufsz -= (count+2)*4;
+
+	return 0;
+}
+
+static __inline__ int r300_emit_raw_packet3(drm_radeon_private_t *dev_priv,
+					    drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	u32 header;
+	int count;
+	RING_LOCALS;
+
+	if (4 > cmdbuf->bufsz)
+		return -EINVAL;
+
+	/* Fixme !! This simply emits a packet without much checking.
+	   We need to be smarter. */
+
+	/* obtain first word - actual packet3 header */
+	header = *(u32 *) cmdbuf->buf;
+
+	/* Is it packet 3 ? */
+	if ((header >> 30) != 0x3) {
+		DRM_ERROR("Not a packet3 header (0x%08x)\n", header);
+		return -EINVAL;
+	}
+
+	count = (header >> 16) & 0x3fff;
+
+	/* Check again now that we know how much data to expect */
+	if ((count + 2) * 4 > cmdbuf->bufsz) {
+		DRM_ERROR
+		    ("Expected packet3 of length %d but have only %d bytes left\n",
+		     (count + 2) * 4, cmdbuf->bufsz);
+		return -EINVAL;
+	}
+
+	/* Is it a packet type we know about ? */
+	switch (header & 0xff00) {
+	case RADEON_3D_LOAD_VBPNTR:	/* load vertex array pointers */
+		return r300_emit_3d_load_vbpntr(dev_priv, cmdbuf, header);
+
+	case RADEON_CNTL_BITBLT_MULTI:
+		return r300_emit_bitblt_multi(dev_priv, cmdbuf);
+
+	case RADEON_CP_INDX_BUFFER:	/* DRAW_INDX_2 without INDX_BUFFER seems to lock up the gpu */
+		return r300_emit_indx_buffer(dev_priv, cmdbuf);
+	case RADEON_CP_3D_DRAW_IMMD_2:	/* triggers drawing using in-packet vertex data */
+	case RADEON_CP_3D_DRAW_VBUF_2:	/* triggers drawing of vertex buffers setup elsewhere */
+	case RADEON_CP_3D_DRAW_INDX_2:	/* triggers drawing using indices to vertex buffer */
+	case RADEON_WAIT_FOR_IDLE:
+	case RADEON_CP_NOP:
+		/* these packets are safe */
+		break;
+	default:
+		DRM_ERROR("Unknown packet3 header (0x%08x)\n", header);
+		return -EINVAL;
+	}
+
+	BEGIN_RING(count + 2);
+	OUT_RING(header);
+	OUT_RING_TABLE((int *)(cmdbuf->buf + 4), count + 1);
+	ADVANCE_RING();
+
+	cmdbuf->buf += (count + 2) * 4;
+	cmdbuf->bufsz -= (count + 2) * 4;
+
+	return 0;
+}
+
+/**
+ * Emit a rendering packet3 from userspace.
+ * Called by r300_do_cp_cmdbuf.
+ */
+static __inline__ int r300_emit_packet3(drm_radeon_private_t *dev_priv,
+					drm_radeon_kcmd_buffer_t *cmdbuf,
+					drm_r300_cmd_header_t header)
+{
+	int n;
+	int ret;
+	char *orig_buf = cmdbuf->buf;
+	int orig_bufsz = cmdbuf->bufsz;
+
+	/* This is a do-while-loop so that we run the interior at least once,
+	 * even if cmdbuf->nbox is 0. Compare r300_emit_cliprects for rationale.
+	 */
+	n = 0;
+	do {
+		if (cmdbuf->nbox > R300_SIMULTANEOUS_CLIPRECTS) {
+			ret = r300_emit_cliprects(dev_priv, cmdbuf, n);
+			if (ret)
+				return ret;
+
+			cmdbuf->buf = orig_buf;
+			cmdbuf->bufsz = orig_bufsz;
+		}
+
+		switch (header.packet3.packet) {
+		case R300_CMD_PACKET3_CLEAR:
+			DRM_DEBUG("R300_CMD_PACKET3_CLEAR\n");
+			ret = r300_emit_clear(dev_priv, cmdbuf);
+			if (ret) {
+				DRM_ERROR("r300_emit_clear failed\n");
+				return ret;
+			}
+			break;
+
+		case R300_CMD_PACKET3_RAW:
+			DRM_DEBUG("R300_CMD_PACKET3_RAW\n");
+			ret = r300_emit_raw_packet3(dev_priv, cmdbuf);
+			if (ret) {
+				DRM_ERROR("r300_emit_raw_packet3 failed\n");
+				return ret;
+			}
+			break;
+
+		default:
+			DRM_ERROR("bad packet3 type %i at %p\n",
+				  header.packet3.packet,
+				  cmdbuf->buf - sizeof(header));
+			return -EINVAL;
+		}
+
+		n += R300_SIMULTANEOUS_CLIPRECTS;
+	} while (n < cmdbuf->nbox);
+
+	return 0;
+}
+
+/* Some of the R300 chips seem to be extremely touchy about the two registers
+ * that are configured in r300_pacify.
+ * Among the worst offenders seems to be the R300 ND (0x4E44): When userspace
+ * sends a command buffer that contains only state setting commands and a
+ * vertex program/parameter upload sequence, this will eventually lead to a
+ * lockup, unless the sequence is bracketed by calls to r300_pacify.
+ * So we should take great care to *always* call r300_pacify before
+ * *anything* 3D related, and again afterwards. This is what the
+ * call bracket in r300_do_cp_cmdbuf is for.
+ */
+
+/**
+ * Emit the sequence to pacify R300.
+ */
+static __inline__ void r300_pacify(drm_radeon_private_t *dev_priv)
+{
+	RING_LOCALS;
+
+	BEGIN_RING(6);
+	OUT_RING(CP_PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));
+	OUT_RING(R300_RB3D_DSTCACHE_UNKNOWN_0A);
+	OUT_RING(CP_PACKET0(R300_RB3D_ZCACHE_CTLSTAT, 0));
+	OUT_RING(R300_RB3D_ZCACHE_UNKNOWN_03);
+	OUT_RING(CP_PACKET3(RADEON_CP_NOP, 0));
+	OUT_RING(0x0);
+	ADVANCE_RING();
+}
+
+/**
+ * Called by r300_do_cp_cmdbuf to update the internal buffer age and state.
+ * The actual age emit is done by r300_do_cp_cmdbuf, which is why you must
+ * be careful about how this function is called.
+ */
+static void r300_discard_buffer(struct drm_device * dev, struct drm_buf * buf)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_buf_priv_t *buf_priv = buf->dev_private;
+
+	buf_priv->age = ++dev_priv->sarea_priv->last_dispatch;
+	buf->pending = 1;
+	buf->used = 0;
+}
+
+static int r300_scratch(drm_radeon_private_t *dev_priv,
+			drm_radeon_kcmd_buffer_t *cmdbuf,
+			drm_r300_cmd_header_t header)
+{
+	u32 *ref_age_base;
+	u32 i, buf_idx, h_pending;
+	RING_LOCALS;
+	
+	if (cmdbuf->bufsz < sizeof(uint64_t) + header.scratch.n_bufs * sizeof(buf_idx) ) {
+		return -EINVAL;
+	}
+	
+	if (header.scratch.reg >= 5) {
+		return -EINVAL;
+	}
+	
+	dev_priv->scratch_ages[header.scratch.reg] ++;
+	
+	ref_age_base = (u32 *)(unsigned long)*((uint64_t *)cmdbuf->buf);
+	
+	cmdbuf->buf += sizeof(uint64_t);
+	cmdbuf->bufsz -= sizeof(uint64_t);
+	
+	for (i=0; i < header.scratch.n_bufs; i++) {
+		buf_idx = *(u32 *)cmdbuf->buf;
+		buf_idx *= 2; /* 8 bytes per buf */
+		
+		if (DRM_COPY_TO_USER(ref_age_base + buf_idx, &dev_priv->scratch_ages[header.scratch.reg], sizeof(u32))) {
+			return -EINVAL;
+		}
+					
+		if (DRM_COPY_FROM_USER(&h_pending, ref_age_base + buf_idx + 1, sizeof(u32))) {
+			return -EINVAL;
+		}
+					
+		if (h_pending == 0) {
+			return -EINVAL;
+		}
+					
+		h_pending--;
+						
+		if (DRM_COPY_TO_USER(ref_age_base + buf_idx + 1, &h_pending, sizeof(u32))) {
+			return -EINVAL;
+		}
+					
+		cmdbuf->buf += sizeof(buf_idx);
+		cmdbuf->bufsz -= sizeof(buf_idx);
+	}
+	
+	BEGIN_RING(2);
+	OUT_RING( CP_PACKET0( RADEON_SCRATCH_REG0 + header.scratch.reg * 4, 0 ) );
+	OUT_RING( dev_priv->scratch_ages[header.scratch.reg] );
+	ADVANCE_RING();
+	
+	return 0;
+}
+
+/**
+ * Parses and validates a user-supplied command buffer and emits appropriate
+ * commands on the DMA ring buffer.
+ * Called by the ioctl handler function radeon_cp_cmdbuf.
+ */
+int r300_do_cp_cmdbuf(struct drm_device *dev,
+		      struct drm_file *file_priv,
+		      drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf = NULL;
+	int emit_dispatch_age = 0;
+	int ret = 0;
+
+	DRM_DEBUG("\n");
+
+	/* See the comment above r300_emit_begin3d for why this call must be here,
+	 * and what the cleanup gotos are for. */
+	r300_pacify(dev_priv);
+
+	if (cmdbuf->nbox <= R300_SIMULTANEOUS_CLIPRECTS) {
+		ret = r300_emit_cliprects(dev_priv, cmdbuf, 0);
+		if (ret)
+			goto cleanup;
+	}
+
+	while (cmdbuf->bufsz >= sizeof(drm_r300_cmd_header_t)) {
+		int idx;
+		drm_r300_cmd_header_t header;
+
+		header.u = *(unsigned int *)cmdbuf->buf;
+
+		cmdbuf->buf += sizeof(header);
+		cmdbuf->bufsz -= sizeof(header);
+
+		switch (header.header.cmd_type) {
+		case R300_CMD_PACKET0:
+			DRM_DEBUG("R300_CMD_PACKET0\n");
+			ret = r300_emit_packet0(dev_priv, cmdbuf, header);
+			if (ret) {
+				DRM_ERROR("r300_emit_packet0 failed\n");
+				goto cleanup;
+			}
+			break;
+
+		case R300_CMD_VPU:
+			DRM_DEBUG("R300_CMD_VPU\n");
+			ret = r300_emit_vpu(dev_priv, cmdbuf, header);
+			if (ret) {
+				DRM_ERROR("r300_emit_vpu failed\n");
+				goto cleanup;
+			}
+			break;
+
+		case R300_CMD_PACKET3:
+			DRM_DEBUG("R300_CMD_PACKET3\n");
+			ret = r300_emit_packet3(dev_priv, cmdbuf, header);
+			if (ret) {
+				DRM_ERROR("r300_emit_packet3 failed\n");
+				goto cleanup;
+			}
+			break;
+
+		case R300_CMD_END3D:
+			DRM_DEBUG("R300_CMD_END3D\n");
+			/* TODO:
+			   Ideally userspace driver should not need to issue this call,
+			   i.e. the drm driver should issue it automatically and prevent
+			   lockups.
+
+			   In practice, we do not understand why this call is needed and what
+			   it does (except for some vague guesses that it has to do with cache
+			   coherence) and so the user space driver does it.
+
+			   Once we are sure which uses prevent lockups the code could be moved
+			   into the kernel and the userspace driver will not
+			   need to use this command.
+
+			   Note that issuing this command does not hurt anything
+			   except, possibly, performance */
+			r300_pacify(dev_priv);
+			break;
+
+		case R300_CMD_CP_DELAY:
+			/* simple enough, we can do it here */
+			DRM_DEBUG("R300_CMD_CP_DELAY\n");
+			{
+				int i;
+				RING_LOCALS;
+
+				BEGIN_RING(header.delay.count);
+				for (i = 0; i < header.delay.count; i++)
+					OUT_RING(RADEON_CP_PACKET2);
+				ADVANCE_RING();
+			}
+			break;
+
+		case R300_CMD_DMA_DISCARD:
+			DRM_DEBUG("RADEON_CMD_DMA_DISCARD\n");
+			idx = header.dma.buf_idx;
+			if (idx < 0 || idx >= dma->buf_count) {
+				DRM_ERROR("buffer index %d (of %d max)\n",
+					  idx, dma->buf_count - 1);
+				ret = -EINVAL;
+				goto cleanup;
+			}
+
+			buf = dma->buflist[idx];
+			if (buf->file_priv != file_priv || buf->pending) {
+				DRM_ERROR("bad buffer %p %p %d\n",
+					  buf->file_priv, file_priv,
+					  buf->pending);
+				ret = -EINVAL;
+				goto cleanup;
+			}
+
+			emit_dispatch_age = 1;
+			r300_discard_buffer(dev, buf);
+			break;
+
+		case R300_CMD_WAIT:
+			/* simple enough, we can do it here */
+			DRM_DEBUG("R300_CMD_WAIT\n");
+			if (header.wait.flags == 0)
+				break;	/* nothing to do */
+
+			{
+				RING_LOCALS;
+
+				BEGIN_RING(2);
+				OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));
+				OUT_RING((header.wait.flags & 0xf) << 14);
+				ADVANCE_RING();
+			}
+			break;
+
+		case R300_CMD_SCRATCH:
+			DRM_DEBUG("R300_CMD_SCRATCH\n");
+			ret = r300_scratch(dev_priv, cmdbuf, header);
+			if (ret) {
+				DRM_ERROR("r300_scratch failed\n");
+				goto cleanup;
+			}
+			break;
+			
+		default:
+			DRM_ERROR("bad cmd_type %i at %p\n",
+				  header.header.cmd_type,
+				  cmdbuf->buf - sizeof(header));
+			ret = -EINVAL;
+			goto cleanup;
+		}
+	}
+
+	DRM_DEBUG("END\n");
+
+      cleanup:
+	r300_pacify(dev_priv);
+
+	/* We emit the vertex buffer age here, outside the pacifier "brackets"
+	 * for two reasons:
+	 *  (1) This may coalesce multiple age emissions into a single one and
+	 *  (2) more importantly, some chips lock up hard when scratch registers
+	 *      are written inside the pacifier bracket.
+	 */
+	if (emit_dispatch_age) {
+		RING_LOCALS;
+
+		/* Emit the vertex buffer age */
+		BEGIN_RING(2);
+		RADEON_DISPATCH_AGE(dev_priv->sarea_priv->last_dispatch);
+		ADVANCE_RING();
+	}
+
+	COMMIT_RING();
+
+	return ret;
+}
Index: git/shared-core/r300_reg.h
===================================================================
--- git.orig/shared-core/r300_reg.h	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/r300_reg.h	2008-12-12 17:35:22.000000000 +0000
@@ -23,6 +23,8 @@
 
 **************************************************************************/
 
+/* *INDENT-OFF* */
+
 #ifndef _R300_REG_H
 #define _R300_REG_H
 
@@ -48,12 +50,12 @@
 #	define R300_MC_MISC__MC_GLOBW_FULL_LAT_SHIFT	28
 
 /*
-This file contains registers and constants for the R300. They have been
-found mostly by examining command buffers captured using glxtest, as well
-as by extrapolating some known registers and constants from the R200.
-
-I am fairly certain that they are correct unless stated otherwise in comments.
-*/
+ * This file contains registers and constants for the R300. They have been
+ * found mostly by examining command buffers captured using glxtest, as well
+ * as by extrapolating some known registers and constants from the R200.
+ * I am fairly certain that they are correct unless stated otherwise
+ * in comments.
+ */
 
 #define R300_SE_VPORT_XSCALE                0x1D98
 #define R300_SE_VPORT_XOFFSET               0x1D9C
@@ -63,49 +65,59 @@
 #define R300_SE_VPORT_ZOFFSET               0x1DAC
 
 
-/* This register is written directly and also starts data section in many 3d CP_PACKET3's */
-#define R300_VAP_VF_CNTL	0x2084
+/*
+ * Vertex Array Processing (VAP) Control
+ * Stolen from r200 code from Christoph Brill (It's a guess!)
+ */
+#define R300_VAP_CNTL	0x2080
 
-#	define	R300_VAP_VF_CNTL__PRIM_TYPE__SHIFT                       0
-#	define  R300_VAP_VF_CNTL__PRIM_NONE				 (0<<0)
-#	define  R300_VAP_VF_CNTL__PRIM_POINTS				 (1<<0)
-#	define  R300_VAP_VF_CNTL__PRIM_LINES				 (2<<0)
-#	define  R300_VAP_VF_CNTL__PRIM_LINE_STRIP			 (3<<0)
-#	define  R300_VAP_VF_CNTL__PRIM_TRIANGLES			 (4<<0)
-#	define  R300_VAP_VF_CNTL__PRIM_TRIANGLE_FAN			 (5<<0)
-#	define  R300_VAP_VF_CNTL__PRIM_TRIANGLE_STRIP			 (6<<0)
-#	define  R300_VAP_VF_CNTL__PRIM_LINE_LOOP			 (12<<0)
-#	define  R300_VAP_VF_CNTL__PRIM_QUADS			 	 (13<<0)
-#	define  R300_VAP_VF_CNTL__PRIM_QUAD_STRIP			 (14<<0)
-#	define  R300_VAP_VF_CNTL__PRIM_POLYGON			 	 (15<<0)
-
-#	define	R300_VAP_VF_CNTL__PRIM_WALK__SHIFT                       4
-	/* State based - direct writes to registers trigger vertex generation */
-#	define	R300_VAP_VF_CNTL__PRIM_WALK_STATE_BASED                      (0<<4)
-#	define	R300_VAP_VF_CNTL__PRIM_WALK_INDICES                          (1<<4)
-#	define	R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_LIST                      (2<<4)
-#	define	R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_EMBEDDED                  (3<<4)
-
-		/* I don't think I saw these three used.. */
-#	define	R300_VAP_VF_CNTL__COLOR_ORDER__SHIFT                     6
-#	define	R300_VAP_VF_CNTL__TCL_OUTPUT_CTL_ENA__SHIFT              9
-#	define	R300_VAP_VF_CNTL__PROG_STREAM_ENA__SHIFT                 10
-
-		/* index size - when not set the indices are assumed to be 16 bit */
-#	define	R300_VAP_VF_CNTL__INDEX_SIZE_32bit                      (1<<11)
-                /* number of vertices */
-#	define	R300_VAP_VF_CNTL__NUM_VERTICES__SHIFT                    16
+/* This register is written directly and also starts data section
+ * in many 3d CP_PACKET3's
+ */
+#define R300_VAP_VF_CNTL	0x2084
+#	define	R300_VAP_VF_CNTL__PRIM_TYPE__SHIFT              0
+#	define  R300_VAP_VF_CNTL__PRIM_NONE                     (0<<0)
+#	define  R300_VAP_VF_CNTL__PRIM_POINTS                   (1<<0)
+#	define  R300_VAP_VF_CNTL__PRIM_LINES                    (2<<0)
+#	define  R300_VAP_VF_CNTL__PRIM_LINE_STRIP               (3<<0)
+#	define  R300_VAP_VF_CNTL__PRIM_TRIANGLES                (4<<0)
+#	define  R300_VAP_VF_CNTL__PRIM_TRIANGLE_FAN             (5<<0)
+#	define  R300_VAP_VF_CNTL__PRIM_TRIANGLE_STRIP           (6<<0)
+#	define  R300_VAP_VF_CNTL__PRIM_LINE_LOOP                (12<<0)
+#	define  R300_VAP_VF_CNTL__PRIM_QUADS                    (13<<0)
+#	define  R300_VAP_VF_CNTL__PRIM_QUAD_STRIP               (14<<0)
+#	define  R300_VAP_VF_CNTL__PRIM_POLYGON                  (15<<0)
+
+#	define	R300_VAP_VF_CNTL__PRIM_WALK__SHIFT              4
+	/* State based - direct writes to registers trigger vertex
+           generation */
+#	define	R300_VAP_VF_CNTL__PRIM_WALK_STATE_BASED         (0<<4)
+#	define	R300_VAP_VF_CNTL__PRIM_WALK_INDICES             (1<<4)
+#	define	R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_LIST         (2<<4)
+#	define	R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_EMBEDDED     (3<<4)
+
+	/* I don't think I saw these three used.. */
+#	define	R300_VAP_VF_CNTL__COLOR_ORDER__SHIFT            6
+#	define	R300_VAP_VF_CNTL__TCL_OUTPUT_CTL_ENA__SHIFT     9
+#	define	R300_VAP_VF_CNTL__PROG_STREAM_ENA__SHIFT        10
+
+	/* index size - when not set the indices are assumed to be 16 bit */
+#	define	R300_VAP_VF_CNTL__INDEX_SIZE_32bit              (1<<11)
+	/* number of vertices */
+#	define	R300_VAP_VF_CNTL__NUM_VERTICES__SHIFT           16
 
 /* BEGIN: Wild guesses */
 #define R300_VAP_OUTPUT_VTX_FMT_0           0x2090
 #       define R300_VAP_OUTPUT_VTX_FMT_0__POS_PRESENT     (1<<0)
 #       define R300_VAP_OUTPUT_VTX_FMT_0__COLOR_PRESENT   (1<<1)
-#       define R300_VAP_OUTPUT_VTX_FMT_0__COLOR_1_PRESENT (1<<2) /* GUESS */
-#       define R300_VAP_OUTPUT_VTX_FMT_0__COLOR_2_PRESENT (1<<3) /* GUESS */
-#       define R300_VAP_OUTPUT_VTX_FMT_0__COLOR_3_PRESENT (1<<4) /* GUESS */
+#       define R300_VAP_OUTPUT_VTX_FMT_0__COLOR_1_PRESENT (1<<2)  /* GUESS */
+#       define R300_VAP_OUTPUT_VTX_FMT_0__COLOR_2_PRESENT (1<<3)  /* GUESS */
+#       define R300_VAP_OUTPUT_VTX_FMT_0__COLOR_3_PRESENT (1<<4)  /* GUESS */
 #       define R300_VAP_OUTPUT_VTX_FMT_0__PT_SIZE_PRESENT (1<<16) /* GUESS */
 
 #define R300_VAP_OUTPUT_VTX_FMT_1           0x2094
+	/* each of the following is 3 bits wide, specifies number
+	   of components */
 #       define R300_VAP_OUTPUT_VTX_FMT_1__TEX_0_COMP_CNT_SHIFT 0
 #       define R300_VAP_OUTPUT_VTX_FMT_1__TEX_1_COMP_CNT_SHIFT 3
 #       define R300_VAP_OUTPUT_VTX_FMT_1__TEX_2_COMP_CNT_SHIFT 6
@@ -114,7 +126,7 @@
 #       define R300_VAP_OUTPUT_VTX_FMT_1__TEX_5_COMP_CNT_SHIFT 15
 #       define R300_VAP_OUTPUT_VTX_FMT_1__TEX_6_COMP_CNT_SHIFT 18
 #       define R300_VAP_OUTPUT_VTX_FMT_1__TEX_7_COMP_CNT_SHIFT 21
-/* END */
+/* END: Wild guesses */
 
 #define R300_SE_VTE_CNTL                  0x20b0
 #	define     R300_VPORT_X_SCALE_ENA                0x00000001
@@ -130,29 +142,40 @@
 #	define     R300_VTX_ST_DENORMALIZED              0x00001000
 
 /* BEGIN: Vertex data assembly - lots of uncertainties */
+
 /* gap */
+
+#define R300_VAP_CNTL_STATUS              0x2140
+#	define R300_VC_NO_SWAP                  (0 << 0)
+#	define R300_VC_16BIT_SWAP               (1 << 0)
+#	define R300_VC_32BIT_SWAP               (2 << 0)
+#	define R300_VAP_TCL_BYPASS		(1 << 8)
+
+/* gap */
+
 /* Where do we get our vertex data?
-//
-// Vertex data either comes either from immediate mode registers or from
-// vertex arrays.
-// There appears to be no mixed mode (though we can force the pitch of
-// vertex arrays to 0, effectively reusing the same element over and over
-// again).
-//
-// Immediate mode is controlled by the INPUT_CNTL registers. I am not sure
-// if these registers influence vertex array processing.
-//
-// Vertex arrays are controlled via the 3D_LOAD_VBPNTR packet3.
-//
-// In both cases, vertex attributes are then passed through INPUT_ROUTE.
-
-// Beginning with INPUT_ROUTE_0_0 is a list of WORDs that route vertex data
-// into the vertex processor's input registers.
-// The first word routes the first input, the second word the second, etc.
-// The corresponding input is routed into the register with the given index.
-// The list is ended by a word with INPUT_ROUTE_END set.
-//
-// Always set COMPONENTS_4 in immediate mode. */
+ *
+ * Vertex data either comes either from immediate mode registers or from
+ * vertex arrays.
+ * There appears to be no mixed mode (though we can force the pitch of
+ * vertex arrays to 0, effectively reusing the same element over and over
+ * again).
+ *
+ * Immediate mode is controlled by the INPUT_CNTL registers. I am not sure
+ * if these registers influence vertex array processing.
+ *
+ * Vertex arrays are controlled via the 3D_LOAD_VBPNTR packet3.
+ *
+ * In both cases, vertex attributes are then passed through INPUT_ROUTE.
+ *
+ * Beginning with INPUT_ROUTE_0_0 is a list of WORDs that route vertex data
+ * into the vertex processor's input registers.
+ * The first word routes the first input, the second word the second, etc.
+ * The corresponding input is routed into the register with the given index.
+ * The list is ended by a word with INPUT_ROUTE_END set.
+ *
+ * Always set COMPONENTS_4 in immediate mode.
+ */
 
 #define R300_VAP_INPUT_ROUTE_0_0            0x2150
 #       define R300_INPUT_ROUTE_COMPONENTS_1     (0 << 0)
@@ -176,10 +199,12 @@
 #define R300_VAP_INPUT_ROUTE_0_7            0x216C
 
 /* gap */
+
 /* Notes:
-//  - always set up to produce at least two attributes:
-//    if vertex program uses only position, fglrx will set normal, too
-//  - INPUT_CNTL_0_COLOR and INPUT_CNTL_COLOR bits are always equal */
+ *  - always set up to produce at least two attributes:
+ *    if vertex program uses only position, fglrx will set normal, too
+ *  - INPUT_CNTL_0_COLOR and INPUT_CNTL_COLOR bits are always equal.
+ */
 #define R300_VAP_INPUT_CNTL_0               0x2180
 #       define R300_INPUT_CNTL_0_COLOR           0x00000001
 #define R300_VAP_INPUT_CNTL_1               0x2184
@@ -196,12 +221,14 @@
 #       define R300_INPUT_CNTL_TC7               0x00020000 /* GUESS */
 
 /* gap */
+
 /* Words parallel to INPUT_ROUTE_0; All words that are active in INPUT_ROUTE_0
-// are set to a swizzling bit pattern, other words are 0.
-//
-// In immediate mode, the pattern is always set to xyzw. In vertex array
-// mode, the swizzling pattern is e.g. used to set zw components in texture
-// coordinates with only tweo components. */
+ * are set to a swizzling bit pattern, other words are 0.
+ *
+ * In immediate mode, the pattern is always set to xyzw. In vertex array
+ * mode, the swizzling pattern is e.g. used to set zw components in texture
+ * coordinates with only tweo components.
+ */
 #define R300_VAP_INPUT_ROUTE_1_0            0x21E0
 #       define R300_INPUT_ROUTE_SELECT_X    0
 #       define R300_INPUT_ROUTE_SELECT_Y    1
@@ -210,11 +237,11 @@
 #       define R300_INPUT_ROUTE_SELECT_ZERO 4
 #       define R300_INPUT_ROUTE_SELECT_ONE  5
 #       define R300_INPUT_ROUTE_SELECT_MASK 7
-#       define R300_INPUT_ROUTE_X_SHIFT          0
-#       define R300_INPUT_ROUTE_Y_SHIFT          3
-#       define R300_INPUT_ROUTE_Z_SHIFT          6
-#       define R300_INPUT_ROUTE_W_SHIFT          9
-#       define R300_INPUT_ROUTE_ENABLE           (15 << 12)
+#       define R300_INPUT_ROUTE_X_SHIFT     0
+#       define R300_INPUT_ROUTE_Y_SHIFT     3
+#       define R300_INPUT_ROUTE_Z_SHIFT     6
+#       define R300_INPUT_ROUTE_W_SHIFT     9
+#       define R300_INPUT_ROUTE_ENABLE      (15 << 12)
 #define R300_VAP_INPUT_ROUTE_1_1            0x21E4
 #define R300_VAP_INPUT_ROUTE_1_2            0x21E8
 #define R300_VAP_INPUT_ROUTE_1_3            0x21EC
@@ -223,53 +250,76 @@
 #define R300_VAP_INPUT_ROUTE_1_6            0x21F8
 #define R300_VAP_INPUT_ROUTE_1_7            0x21FC
 
-/* END */
+/* END: Vertex data assembly */
 
 /* gap */
-/* BEGIN: Upload vertex program and data
-// The programmable vertex shader unit has a memory bank of unknown size
-// that can be written to in 16 byte units by writing the address into
-// UPLOAD_ADDRESS, followed by data in UPLOAD_DATA (multiples of 4 DWORDs).
-//
-// Pointers into the memory bank are always in multiples of 16 bytes.
-//
-// The memory bank is divided into areas with fixed meaning.
-//
-// Starting at address UPLOAD_PROGRAM: Vertex program instructions.
-// Native limits reported by drivers from ATI suggest size 256 (i.e. 4KB),
-// whereas the difference between known addresses suggests size 512.
-//
-// Starting at address UPLOAD_PARAMETERS: Vertex program parameters.
-// Native reported limits and the VPI layout suggest size 256, whereas
-// difference between known addresses suggests size 512.
-//
-// At address UPLOAD_POINTSIZE is a vector (0, 0, ps, 0), where ps is the
-// floating point pointsize. The exact purpose of this state is uncertain,
-// as there is also the R300_RE_POINTSIZE register.
-//
-// Multiple vertex programs and parameter sets can be loaded at once,
-// which could explain the size discrepancy. */
+
+/* BEGIN: Upload vertex program and data */
+
+/*
+ * The programmable vertex shader unit has a memory bank of unknown size
+ * that can be written to in 16 byte units by writing the address into
+ * UPLOAD_ADDRESS, followed by data in UPLOAD_DATA (multiples of 4 DWORDs).
+ *
+ * Pointers into the memory bank are always in multiples of 16 bytes.
+ *
+ * The memory bank is divided into areas with fixed meaning.
+ *
+ * Starting at address UPLOAD_PROGRAM: Vertex program instructions.
+ * Native limits reported by drivers from ATI suggest size 256 (i.e. 4KB),
+ * whereas the difference between known addresses suggests size 512.
+ *
+ * Starting at address UPLOAD_PARAMETERS: Vertex program parameters.
+ * Native reported limits and the VPI layout suggest size 256, whereas
+ * difference between known addresses suggests size 512.
+ *
+ * At address UPLOAD_POINTSIZE is a vector (0, 0, ps, 0), where ps is the
+ * floating point pointsize. The exact purpose of this state is uncertain,
+ * as there is also the R300_RE_POINTSIZE register.
+ *
+ * Multiple vertex programs and parameter sets can be loaded at once,
+ * which could explain the size discrepancy.
+ */
 #define R300_VAP_PVS_UPLOAD_ADDRESS         0x2200
 #       define R300_PVS_UPLOAD_PROGRAM           0x00000000
 #       define R300_PVS_UPLOAD_PARAMETERS        0x00000200
 #       define R300_PVS_UPLOAD_POINTSIZE         0x00000406
+
 /* gap */
+
 #define R300_VAP_PVS_UPLOAD_DATA            0x2208
-/* END */
+
+/* END: Upload vertex program and data */
 
 /* gap */
+
 /* I do not know the purpose of this register. However, I do know that
-// it is set to 221C_CLEAR for clear operations and to 221C_NORMAL
-// for normal rendering. */
+ * it is set to 221C_CLEAR for clear operations and to 221C_NORMAL
+ * for normal rendering.
+ */
 #define R300_VAP_UNKNOWN_221C               0x221C
 #       define R300_221C_NORMAL                  0x00000000
 #       define R300_221C_CLEAR                   0x0001C000
 
+/* These seem to be per-pixel and per-vertex X and Y clipping planes. The first
+ * plane is per-pixel and the second plane is per-vertex.
+ *
+ * This was determined by experimentation alone but I believe it is correct.
+ *
+ * These registers are called X_QUAD0_1_FL to X_QUAD0_4_FL by glxtest.
+ */
+#define R300_VAP_CLIP_X_0                   0x2220
+#define R300_VAP_CLIP_X_1                   0x2224
+#define R300_VAP_CLIP_Y_0                   0x2228
+#define R300_VAP_CLIP_Y_1                   0x2230
+
 /* gap */
+
 /* Sometimes, END_OF_PKT and 0x2284=0 are the only commands sent between
-// rendering commands and overwriting vertex program parameters.
-// Therefore, I suspect writing zero to 0x2284 synchronizes the engine and
-// avoids bugs caused by still running shaders reading bad data from memory. */
+ * rendering commands and overwriting vertex program parameters.
+ * Therefore, I suspect writing zero to 0x2284 synchronizes the engine and
+ * avoids bugs caused by still running shaders reading bad data from memory.
+ */
 #define R300_VAP_PVS_WAITIDLE               0x2284 /* GUESS */
 
 /* Absolutely no clue what this register is about. */
@@ -278,19 +328,24 @@
 #       define R300_2288_RV350                   0x0000FFFF /* -- Vladimir */
 
 /* gap */
+
 /* Addresses are relative to the vertex program instruction area of the
-// memory bank. PROGRAM_END points to the last instruction of the active
-// program
-//
-// The meaning of the two UNKNOWN fields is obviously not known. However,
-// experiments so far have shown that both *must* point to an instruction
-// inside the vertex program, otherwise the GPU locks up.
-// fglrx usually sets CNTL_3_UNKNOWN to the end of the program and
-// CNTL_1_UNKNOWN points to instruction where last write to position takes place. 
-// Most likely this is used to ignore rest of the program in cases where group of verts arent visible.
-// For some reason this "section" is sometimes accepted other instruction that have
-// no relationship with position calculations. 
-*/
+ * memory bank. PROGRAM_END points to the last instruction of the active
+ * program
+ *
+ * The meaning of the two UNKNOWN fields is obviously not known. However,
+ * experiments so far have shown that both *must* point to an instruction
+ * inside the vertex program, otherwise the GPU locks up.
+ *
+ * fglrx usually sets CNTL_3_UNKNOWN to the end of the program and
+ * R300_PVS_CNTL_1_POS_END_SHIFT points to instruction where last write to
+ * position takes place.
+ *
+ * Most likely this is used to ignore rest of the program in cases
+ * where group of verts arent visible. For some reason this "section"
+ * is sometimes accepted other instruction that have no relationship with
+ * position calculations.
+ */
 #define R300_VAP_PVS_CNTL_1                 0x22D0
 #       define R300_PVS_CNTL_1_PROGRAM_START_SHIFT   0
 #       define R300_PVS_CNTL_1_POS_END_SHIFT         10
@@ -304,7 +359,8 @@
 #       define R300_PVS_CNTL_3_PROGRAM_UNKNOWN2_SHIFT 0
 
 /* The entire range from 0x2300 to 0x2AC inclusive seems to be used for
-// immediate vertices */
+ * immediate vertices
+ */
 #define R300_VAP_VTX_COLOR_R                0x2464
 #define R300_VAP_VTX_COLOR_G                0x2468
 #define R300_VAP_VTX_COLOR_B                0x246C
@@ -314,13 +370,15 @@
 #define R300_VAP_VTX_POS_0_X_2              0x24A0 /* used for glVertex3*() */
 #define R300_VAP_VTX_POS_0_Y_2              0x24A4
 #define R300_VAP_VTX_POS_0_Z_2              0x24A8
-#define R300_VAP_VTX_END_OF_PKT             0x24AC /* write 0 to indicate end of packet? */
+/* write 0 to indicate end of packet? */
+#define R300_VAP_VTX_END_OF_PKT             0x24AC
 
 /* gap */
 
 /* These are values from r300_reg/r300_reg.h - they are known to be correct
-   and are here so we can use one register file instead of several
-   - Vladimir */
+ * and are here so we can use one register file instead of several
+ * - Vladimir
+ */
 #define R300_GB_VAP_RASTER_VTX_FMT_0	0x4000
 #	define R300_GB_VAP_RASTER_VTX_FMT_0__POS_PRESENT	(1<<0)
 #	define R300_GB_VAP_RASTER_VTX_FMT_0__COLOR_0_PRESENT	(1<<1)
@@ -343,14 +401,16 @@
 #	define R300_GB_VAP_RASTER_VTX_FMT_1__TEX_7_COMP_CNT_SHIFT	21
 
 /* UNK30 seems to enables point to quad transformation on textures
-   (or something closely related to that).
-   This bit is rather fatal at the time being due to lackings at pixel shader side */
+ * (or something closely related to that).
+ * This bit is rather fatal at the time being due to lackings at pixel
+ * shader side
+ */
 #define R300_GB_ENABLE	0x4008
 #	define R300_GB_POINT_STUFF_ENABLE	(1<<0)
 #	define R300_GB_LINE_STUFF_ENABLE	(1<<1)
 #	define R300_GB_TRIANGLE_STUFF_ENABLE	(1<<2)
 #	define R300_GB_STENCIL_AUTO_ENABLE	(1<<4)
-#	define R300_GB_UNK30			(1<<30)
+#	define R300_GB_UNK31			(1<<31)
 	/* each of the following is 2 bits wide */
 #define R300_GB_TEX_REPLICATE	0
 #define R300_GB_TEX_ST		1
@@ -391,6 +451,7 @@
 #	define R300_GB_TILE_PIPE_COUNT_RV300	0
 #	define R300_GB_TILE_PIPE_COUNT_R300	(3<<1)
 #	define R300_GB_TILE_PIPE_COUNT_R420	(7<<1)
+#	define R300_GB_TILE_PIPE_COUNT_RV410	(3<<1)
 #	define R300_GB_TILE_SIZE_8		0
 #	define R300_GB_TILE_SIZE_16		(1<<4)
 #	define R300_GB_TILE_SIZE_32		(2<<4)
@@ -445,17 +506,18 @@
 #	define R300_GB_W_SELECT_1		(1<<4)
 
 #define R300_GB_AA_CONFIG		0x4020
+#	define R300_AA_DISABLE			0x00
 #	define R300_AA_ENABLE			0x01
 #	define R300_AA_SUBSAMPLES_2		0
 #	define R300_AA_SUBSAMPLES_3		(1<<1)
 #	define R300_AA_SUBSAMPLES_4		(2<<1)
 #	define R300_AA_SUBSAMPLES_6		(3<<1)
 
-/* END */
-
 /* gap */
+
 /* Zero to flush caches. */
 #define R300_TX_CNTL                        0x4100
+#define R300_TX_FLUSH                       0x0
 
 /* The upper enable bits are guessed, based on fglrx reported limits. */
 #define R300_TX_ENABLE                      0x4104
@@ -477,8 +539,9 @@
 #       define R300_TX_ENABLE_15                 (1 << 15)
 
 /* The pointsize is given in multiples of 6. The pointsize can be
-// enormous: Clear() renders a single point that fills the entire
-// framebuffer. */
+ * enormous: Clear() renders a single point that fills the entire
+ * framebuffer.
+ */
 #define R300_RE_POINTSIZE                   0x421C
 #       define R300_POINTSIZE_Y_SHIFT            0
 #       define R300_POINTSIZE_Y_MASK             (0xFFFF << 0) /* GUESS */
@@ -487,11 +550,11 @@
 #       define R300_POINTSIZE_MAX             (R300_POINTSIZE_Y_MASK / 6)
 
 /* The line width is given in multiples of 6.
-   In default mode lines are classified as vertical lines.
-   HO: horizontal
-   VE: vertical or horizontal
-   HO & VE: no classification
-*/
+ * In default mode lines are classified as vertical lines.
+ * HO: horizontal
+ * VE: vertical or horizontal
+ * HO & VE: no classification
+ */
 #define R300_RE_LINE_CNT                      0x4234
 #       define R300_LINESIZE_SHIFT            0
 #       define R300_LINESIZE_MASK             (0xFFFF << 0) /* GUESS */
@@ -502,6 +565,9 @@
 /* Some sort of scale or clamp value for texcoordless textures. */
 #define R300_RE_UNK4238                       0x4238
 
+/* Something shade related */
+#define R300_RE_SHADE                         0x4274
+
 #define R300_RE_SHADE_MODEL                   0x4278
 #	define R300_RE_SHADE_MODEL_SMOOTH     0x3aaaa
 #	define R300_RE_SHADE_MODEL_FLAT       0x39595
@@ -516,24 +582,31 @@
 #	define R300_PM_BACK_LINE              (1 << 7)
 #	define R300_PM_BACK_FILL              (1 << 8)
 
-/* Not sure why there are duplicate of factor and constant values. 
-   My best guess so far is that there are seperate zbiases for test and write. 
-   Ordering might be wrong.
-   Some of the tests indicate that fgl has a fallback implementation of zbias
-   via pixel shaders. */
+/* Fog parameters */
+#define R300_RE_FOG_SCALE                     0x4294
+#define R300_RE_FOG_START                     0x4298
+
+/* Not sure why there are duplicate of factor and constant values.
+ * My best guess so far is that there are seperate zbiases for test and write.
+ * Ordering might be wrong.
+ * Some of the tests indicate that fgl has a fallback implementation of zbias
+ * via pixel shaders.
+ */
+#define R300_RE_ZBIAS_CNTL                    0x42A0 /* GUESS */
 #define R300_RE_ZBIAS_T_FACTOR                0x42A4
 #define R300_RE_ZBIAS_T_CONSTANT              0x42A8
 #define R300_RE_ZBIAS_W_FACTOR                0x42AC
 #define R300_RE_ZBIAS_W_CONSTANT              0x42B0
 
 /* This register needs to be set to (1<<1) for RV350 to correctly
-   perform depth test (see --vb-triangles in r300_demo)
-   Don't know about other chips. - Vladimir
-   This is set to 3 when GL_POLYGON_OFFSET_FILL is on.
-   My guess is that there are two bits for each zbias primitive (FILL, LINE, POINT).
-   One to enable depth test and one for depth write.
-   Yet this doesnt explain why depth writes work ...
-    */
+ * perform depth test (see --vb-triangles in r300_demo)
+ * Don't know about other chips. - Vladimir
+ * This is set to 3 when GL_POLYGON_OFFSET_FILL is on.
+ * My guess is that there are two bits for each zbias primitive
+ * (FILL, LINE, POINT).
+ *  One to enable depth test and one for depth write.
+ * Yet this doesnt explain why depth writes work ...
+ */
 #define R300_RE_OCCLUSION_CNTL		    0x42B4
 #	define R300_OCCLUSION_ON		(1<<1)
 
@@ -544,30 +617,37 @@
 #       define R300_FRONT_FACE_CW                (1 << 2)
 
 
-/* BEGIN: Rasterization / Interpolators - many guesses
-// 0_UNKNOWN_18 has always been set except for clear operations.
-// TC_CNT is the number of incoming texture coordinate sets (i.e. it depends
-// on the vertex program, *not* the fragment program) */
+/* BEGIN: Rasterization / Interpolators - many guesses */
+
+/* 0_UNKNOWN_18 has always been set except for clear operations.
+ * TC_CNT is the number of incoming texture coordinate sets (i.e. it depends
+ * on the vertex program, *not* the fragment program)
+ */
 #define R300_RS_CNTL_0                      0x4300
 #       define R300_RS_CNTL_TC_CNT_SHIFT         2
 #       define R300_RS_CNTL_TC_CNT_MASK          (7 << 2)
-#		define R300_RS_CNTL_CI_CNT_SHIFT         7 /* number of color interpolators used */
+	/* number of color interpolators used */
+#	define R300_RS_CNTL_CI_CNT_SHIFT         7
 #       define R300_RS_CNTL_0_UNKNOWN_18         (1 << 18)
-/* Guess: RS_CNTL_1 holds the index of the highest used RS_ROUTE_n register. */
+	/* Guess: RS_CNTL_1 holds the index of the highest used RS_ROUTE_n
+	   register. */
 #define R300_RS_CNTL_1                      0x4304
 
 /* gap */
+
 /* Only used for texture coordinates.
-// Use the source field to route texture coordinate input from the vertex program
-// to the desired interpolator. Note that the source field is relative to the
-// outputs the vertex program *actually* writes. If a vertex program only writes
-// texcoord[1], this will be source index 0.
-// Set INTERP_USED on all interpolators that produce data used by the
-// fragment program. INTERP_USED looks like a swizzling mask, but
-// I haven't seen it used that way.
-//
-// Note: The _UNKNOWN constants are always set in their respective register.
-// I don't know if this is necessary. */
+ * Use the source field to route texture coordinate input from the
+ * vertex program to the desired interpolator. Note that the source
+ * field is relative to the outputs the vertex program *actually*
+ * writes. If a vertex program only writes texcoord[1], this will
+ * be source index 0.
+ * Set INTERP_USED on all interpolators that produce data used by
+ * the fragment program. INTERP_USED looks like a swizzling mask,
+ * but I haven't seen it used that way.
+ *
+ * Note: The _UNKNOWN constants are always set in their respective
+ * register. I don't know if this is necessary.
+ */
 #define R300_RS_INTERP_0                    0x4310
 #define R300_RS_INTERP_1                    0x4314
 #       define R300_RS_INTERP_1_UNKNOWN          0x40
@@ -584,7 +664,8 @@
 #       define R300_RS_INTERP_USED               0x00D10000
 
 /* These DWORDs control how vertex data is routed into fragment program
-// registers, after interpolators. */
+ * registers, after interpolators.
+ */
 #define R300_RS_ROUTE_0                     0x4330
 #define R300_RS_ROUTE_1                     0x4334
 #define R300_RS_ROUTE_2                     0x4338
@@ -606,8 +687,14 @@
 #       define R300_RS_ROUTE_DEST_MASK           (31 << 6) /* GUESS */
 
 /* Special handling for color: When the fragment program uses color,
-// the ROUTE_0_COLOR bit is set and ROUTE_0_COLOR_DEST contains the
-// color register index. */
+ * the ROUTE_0_COLOR bit is set and ROUTE_0_COLOR_DEST contains the
+ * color register index.
+ *
+ * Apperently you may set the R300_RS_ROUTE_0_COLOR bit, but not provide any
+ * R300_RS_ROUTE_0_COLOR_DEST value; this setup is used for clearing the state.
+ * See r300_ioctl.c:r300EmitClearState. I'm not sure if this setup is strictly
+ * correct or not. - Oliver.
+ */
 #       define R300_RS_ROUTE_0_COLOR             (1 << 14)
 #       define R300_RS_ROUTE_0_COLOR_DEST_SHIFT  17
 #       define R300_RS_ROUTE_0_COLOR_DEST_MASK   (31 << 17) /* GUESS */
@@ -616,22 +703,24 @@
 #		define R300_RS_ROUTE_1_COLOR1_DEST_SHIFT 17
 #		define R300_RS_ROUTE_1_COLOR1_DEST_MASK  (31 << 17)
 #		define R300_RS_ROUTE_1_UNKNOWN11         (1 << 11)
-/* END */
+/* END: Rasterization / Interpolators - many guesses */
+
+/* BEGIN: Scissors and cliprects */
 
-/* BEGIN: Scissors and cliprects
-// There are four clipping rectangles. Their corner coordinates are inclusive.
-// Every pixel is assigned a number from 0 and 15 by setting bits 0-3 depending
-// on whether the pixel is inside cliprects 0-3, respectively. For example,
-// if a pixel is inside cliprects 0 and 1, but outside 2 and 3, it is assigned
-// the number 3 (binary 0011).
-// Iff the bit corresponding to the pixel's number in RE_CLIPRECT_CNTL is set,
-// the pixel is rasterized.
-//
-// In addition to this, there is a scissors rectangle. Only pixels inside the
-// scissors rectangle are drawn. (coordinates are inclusive)
-//
-// For some reason, the top-left corner of the framebuffer is at (1440, 1440)
-// for the purpose of clipping and scissors. */
+/* There are four clipping rectangles. Their corner coordinates are inclusive.
+ * Every pixel is assigned a number from 0 and 15 by setting bits 0-3 depending
+ * on whether the pixel is inside cliprects 0-3, respectively. For example,
+ * if a pixel is inside cliprects 0 and 1, but outside 2 and 3, it is assigned
+ * the number 3 (binary 0011).
+ * Iff the bit corresponding to the pixel's number in RE_CLIPRECT_CNTL is set,
+ * the pixel is rasterized.
+ *
+ * In addition to this, there is a scissors rectangle. Only pixels inside the
+ * scissors rectangle are drawn. (coordinates are inclusive)
+ *
+ * For some reason, the top-left corner of the framebuffer is at (1440, 1440)
+ * for the purpose of clipping and scissors.
+ */
 #define R300_RE_CLIPRECT_TL_0               0x43B0
 #define R300_RE_CLIPRECT_BR_0               0x43B4
 #define R300_RE_CLIPRECT_TL_1               0x43B8
@@ -665,6 +754,7 @@
 #       define R300_CLIP_3210                    (1 << 15)
 
 /* gap */
+
 #define R300_RE_SCISSORS_TL                 0x43E0
 #define R300_RE_SCISSORS_BR                 0x43E4
 #       define R300_SCISSORS_OFFSET              1440
@@ -672,12 +762,15 @@
 #       define R300_SCISSORS_X_MASK              (0x1FFF << 0)
 #       define R300_SCISSORS_Y_SHIFT             13
 #       define R300_SCISSORS_Y_MASK              (0x1FFF << 13)
-/* END */
+/* END: Scissors and cliprects */
+
+/* BEGIN: Texture specification */
 
-/* BEGIN: Texture specification
-// The texture specification dwords are grouped by meaning and not by texture unit.
-// This means that e.g. the offset for texture image unit N is found in register
-// TX_OFFSET_0 + (4*N) */
+/*
+ * The texture specification dwords are grouped by meaning and not by texture
+ * unit. This means that e.g. the offset for texture image unit N is found in
+ * register TX_OFFSET_0 + (4*N)
+ */
 #define R300_TX_FILTER_0                    0x4400
 #       define R300_TX_REPEAT                    0
 #       define R300_TX_MIRRORED                  1
@@ -701,13 +794,14 @@
 #	define R300_TX_MIN_FILTER_LINEAR_MIP_LINEAR         (10 <<  11)
 
 /* NOTE: NEAREST doesnt seem to exist.
-   Im not seting MAG_FILTER_MASK and (3 << 11) on for all
-   anisotropy modes because that would void selected mag filter */
-#	define R300_TX_MIN_FILTER_ANISO_NEAREST             ((0 << 13) /*|R300_TX_MAG_FILTER_MASK|(3<<11)*/)
-#	define R300_TX_MIN_FILTER_ANISO_LINEAR              ((0 << 13) /*|R300_TX_MAG_FILTER_MASK|(3<<11)*/)
-#	define R300_TX_MIN_FILTER_ANISO_NEAREST_MIP_NEAREST ((1 << 13) /*|R300_TX_MAG_FILTER_MASK|(3<<11)*/)
-#	define R300_TX_MIN_FILTER_ANISO_NEAREST_MIP_LINEAR  ((2 << 13) /*|R300_TX_MAG_FILTER_MASK|(3<<11)*/)
-#       define R300_TX_MIN_FILTER_MASK           ( (15 << 11) | (3 << 13) )
+ * Im not seting MAG_FILTER_MASK and (3 << 11) on for all
+ * anisotropy modes because that would void selected mag filter
+ */
+#	define R300_TX_MIN_FILTER_ANISO_NEAREST             (0 << 13)
+#	define R300_TX_MIN_FILTER_ANISO_LINEAR              (0 << 13)
+#	define R300_TX_MIN_FILTER_ANISO_NEAREST_MIP_NEAREST (1 << 13)
+#	define R300_TX_MIN_FILTER_ANISO_NEAREST_MIP_LINEAR  (2 << 13)
+#       define R300_TX_MIN_FILTER_MASK   ( (15 << 11) | (3 << 13) )
 #	define R300_TX_MAX_ANISO_1_TO_1  (0 << 21)
 #	define R300_TX_MAX_ANISO_2_TO_1  (2 << 21)
 #	define R300_TX_MAX_ANISO_4_TO_1  (4 << 21)
@@ -738,10 +832,10 @@
 #       define R300_TX_HEIGHTMASK_SHIFT          11
 #       define R300_TX_HEIGHTMASK_MASK           (2047 << 11)
 #       define R300_TX_UNK23                     (1 << 23)
-#       define R300_TX_SIZE_SHIFT                26 /* largest of width, height */
-#       define R300_TX_SIZE_MASK                 (15 << 26)
-#       define R300_TX_SIZE_PROJECTED                     (1<<30)
-#       define R300_TX_SIZE_TXPITCH_EN                     (1<<31)
+#       define R300_TX_MAX_MIP_LEVEL_SHIFT       26
+#       define R300_TX_MAX_MIP_LEVEL_MASK        (0xf << 26)
+#       define R300_TX_SIZE_PROJECTED            (1<<30)
+#       define R300_TX_SIZE_TXPITCH_EN           (1<<31)
 #define R300_TX_FORMAT_0                    0x44C0
 	/* The interpretation of the format word by Wladimir van der Laan */
 	/* The X, Y, Z and W refer to the layout of the components.
@@ -762,33 +856,33 @@
 #	define R300_TX_FORMAT_W8Z8Y8X8		    0xC
 #	define R300_TX_FORMAT_W2Z10Y10X10	    0xD
 #	define R300_TX_FORMAT_W16Z16Y16X16	    0xE
-#	define R300_TX_FORMAT_DXT1	    	    0xF
-#	define R300_TX_FORMAT_DXT3	    	    0x10
-#	define R300_TX_FORMAT_DXT5	    	    0x11
+#	define R300_TX_FORMAT_DXT1		    0xF
+#	define R300_TX_FORMAT_DXT3		    0x10
+#	define R300_TX_FORMAT_DXT5		    0x11
 #	define R300_TX_FORMAT_D3DMFT_CxV8U8	    0x12     /* no swizzle */
-#	define R300_TX_FORMAT_A8R8G8B8	    	    0x13     /* no swizzle */
-#	define R300_TX_FORMAT_B8G8_B8G8	    	    0x14     /* no swizzle */
-#	define R300_TX_FORMAT_G8R8_G8B8	    	    0x15     /* no swizzle */
-						  /* 0x16 - some 16 bit green format.. ?? */
+#	define R300_TX_FORMAT_A8R8G8B8		    0x13     /* no swizzle */
+#	define R300_TX_FORMAT_B8G8_B8G8		    0x14     /* no swizzle */
+#	define R300_TX_FORMAT_G8R8_G8B8		    0x15     /* no swizzle */
+	/* 0x16 - some 16 bit green format.. ?? */
 #	define R300_TX_FORMAT_UNK25		   (1 << 25) /* no swizzle */
 #	define R300_TX_FORMAT_CUBIC_MAP		   (1 << 26)
 
 	/* gap */
 	/* Floating point formats */
 	/* Note - hardware supports both 16 and 32 bit floating point */
-#	define R300_TX_FORMAT_FL_I16	    	    0x18
-#	define R300_TX_FORMAT_FL_I16A16	    	    0x19
+#	define R300_TX_FORMAT_FL_I16		    0x18
+#	define R300_TX_FORMAT_FL_I16A16		    0x19
 #	define R300_TX_FORMAT_FL_R16G16B16A16	    0x1A
-#	define R300_TX_FORMAT_FL_I32	    	    0x1B
-#	define R300_TX_FORMAT_FL_I32A32	    	    0x1C
+#	define R300_TX_FORMAT_FL_I32		    0x1B
+#	define R300_TX_FORMAT_FL_I32A32		    0x1C
 #	define R300_TX_FORMAT_FL_R32G32B32A32	    0x1D
 	/* alpha modes, convenience mostly */
 	/* if you have alpha, pick constant appropriate to the
 	   number of channels (1 for I8, 2 for I8A8, 4 for R8G8B8A8, etc */
-# 	define R300_TX_FORMAT_ALPHA_1CH		    0x000
-# 	define R300_TX_FORMAT_ALPHA_2CH		    0x200
-# 	define R300_TX_FORMAT_ALPHA_4CH		    0x600
-# 	define R300_TX_FORMAT_ALPHA_NONE	    0xA00
+#	define R300_TX_FORMAT_ALPHA_1CH		    0x000
+#	define R300_TX_FORMAT_ALPHA_2CH		    0x200
+#	define R300_TX_FORMAT_ALPHA_4CH		    0x600
+#	define R300_TX_FORMAT_ALPHA_NONE	    0xA00
 	/* Swizzling */
 	/* constants */
 #	define R300_TX_FORMAT_X		0
@@ -797,23 +891,26 @@
 #	define R300_TX_FORMAT_W		3
 #	define R300_TX_FORMAT_ZERO	4
 #	define R300_TX_FORMAT_ONE	5
-#	define R300_TX_FORMAT_CUT_Z	6		/* 2.0*Z, everything above 1.0 is set to 0.0 */
-#	define R300_TX_FORMAT_CUT_W	7		/* 2.0*W, everything above 1.0 is set to 0.0 */
+	/* 2.0*Z, everything above 1.0 is set to 0.0 */
+#	define R300_TX_FORMAT_CUT_Z	6
+	/* 2.0*W, everything above 1.0 is set to 0.0 */
+#	define R300_TX_FORMAT_CUT_W	7
 
 #	define R300_TX_FORMAT_B_SHIFT	18
 #	define R300_TX_FORMAT_G_SHIFT	15
 #	define R300_TX_FORMAT_R_SHIFT	12
 #	define R300_TX_FORMAT_A_SHIFT	9
 	/* Convenience macro to take care of layout and swizzling */
-#	define R300_EASY_TX_FORMAT(B, G, R, A, FMT)	(\
-	  ((R300_TX_FORMAT_##B)<<R300_TX_FORMAT_B_SHIFT) \
-	| ((R300_TX_FORMAT_##G)<<R300_TX_FORMAT_G_SHIFT) \
-	| ((R300_TX_FORMAT_##R)<<R300_TX_FORMAT_R_SHIFT) \
-	| ((R300_TX_FORMAT_##A)<<R300_TX_FORMAT_A_SHIFT) \
-	| (R300_TX_FORMAT_##FMT) \
-	  )
-	/* These can be ORed with result of R300_EASY_TX_FORMAT() */
-	/* We don't really know what they do. Take values from a constant color ? */
+#	define R300_EASY_TX_FORMAT(B, G, R, A, FMT)	(		\
+		((R300_TX_FORMAT_##B)<<R300_TX_FORMAT_B_SHIFT)		\
+		| ((R300_TX_FORMAT_##G)<<R300_TX_FORMAT_G_SHIFT)	\
+		| ((R300_TX_FORMAT_##R)<<R300_TX_FORMAT_R_SHIFT)	\
+		| ((R300_TX_FORMAT_##A)<<R300_TX_FORMAT_A_SHIFT)	\
+		| (R300_TX_FORMAT_##FMT)				\
+		)
+	/* These can be ORed with result of R300_EASY_TX_FORMAT()
+	   We don't really know what they do. Take values from a
+           constant color ? */
 #	define R300_TX_FORMAT_CONST_X		(1<<5)
 #	define R300_TX_FORMAT_CONST_Y		(2<<5)
 #	define R300_TX_FORMAT_CONST_Z		(4<<5)
@@ -823,7 +920,7 @@
 
 #define R300_TX_PITCH_0			    0x4500 /* obvious missing in gap */
 #define R300_TX_OFFSET_0                    0x4540
-/* BEGIN: Guess from R200 */
+	/* BEGIN: Guess from R200 */
 #       define R300_TXO_ENDIAN_NO_SWAP           (0 << 0)
 #       define R300_TXO_ENDIAN_BYTE_SWAP         (1 << 0)
 #       define R300_TXO_ENDIAN_WORD_SWAP         (2 << 0)
@@ -832,53 +929,61 @@
 #       define R300_TXO_MICRO_TILE               (1 << 3)
 #       define R300_TXO_OFFSET_MASK              0xffffffe0
 #       define R300_TXO_OFFSET_SHIFT             5
-/* END */
-#define R300_TX_CHROMA_KEY_0                      0x4580 /* 32 bit chroma key */
-#define R300_TX_BORDER_COLOR_0              0x45C0 //ff00ff00 == { 0, 1.0, 0, 1.0 }
-
-/* END */
-
-/* BEGIN: Fragment program instruction set
-// Fragment programs are written directly into register space.
-// There are separate instruction streams for texture instructions and ALU
-// instructions.
-// In order to synchronize these streams, the program is divided into up
-// to 4 nodes. Each node begins with a number of TEX operations, followed
-// by a number of ALU operations.
-// The first node can have zero TEX ops, all subsequent nodes must have at least
-// one TEX ops.
-// All nodes must have at least one ALU op.
-//
-// The index of the last node is stored in PFS_CNTL_0: A value of 0 means
-// 1 node, a value of 3 means 4 nodes.
-// The total amount of instructions is defined in PFS_CNTL_2. The offsets are
-// offsets into the respective instruction streams, while *_END points to the
-// last instruction relative to this offset. */
+	/* END: Guess from R200 */
+
+/* 32 bit chroma key */
+#define R300_TX_CHROMA_KEY_0                      0x4580
+/* ff00ff00 == { 0, 1.0, 0, 1.0 } */
+#define R300_TX_BORDER_COLOR_0              0x45C0
+
+/* END: Texture specification */
+
+/* BEGIN: Fragment program instruction set */
+
+/* Fragment programs are written directly into register space.
+ * There are separate instruction streams for texture instructions and ALU
+ * instructions.
+ * In order to synchronize these streams, the program is divided into up
+ * to 4 nodes. Each node begins with a number of TEX operations, followed
+ * by a number of ALU operations.
+ * The first node can have zero TEX ops, all subsequent nodes must have at
+ * least
+ * one TEX ops.
+ * All nodes must have at least one ALU op.
+ *
+ * The index of the last node is stored in PFS_CNTL_0: A value of 0 means
+ * 1 node, a value of 3 means 4 nodes.
+ * The total amount of instructions is defined in PFS_CNTL_2. The offsets are
+ * offsets into the respective instruction streams, while *_END points to the
+ * last instruction relative to this offset.
+ */
 #define R300_PFS_CNTL_0                     0x4600
 #       define R300_PFS_CNTL_LAST_NODES_SHIFT    0
 #       define R300_PFS_CNTL_LAST_NODES_MASK     (3 << 0)
 #       define R300_PFS_CNTL_FIRST_NODE_HAS_TEX  (1 << 3)
 #define R300_PFS_CNTL_1                     0x4604
 /* There is an unshifted value here which has so far always been equal to the
-// index of the highest used temporary register. */
+ * index of the highest used temporary register.
+ */
 #define R300_PFS_CNTL_2                     0x4608
 #       define R300_PFS_CNTL_ALU_OFFSET_SHIFT    0
 #       define R300_PFS_CNTL_ALU_OFFSET_MASK     (63 << 0)
 #       define R300_PFS_CNTL_ALU_END_SHIFT       6
-#       define R300_PFS_CNTL_ALU_END_MASK        (63 << 0)
+#       define R300_PFS_CNTL_ALU_END_MASK        (63 << 6)
 #       define R300_PFS_CNTL_TEX_OFFSET_SHIFT    12
 #       define R300_PFS_CNTL_TEX_OFFSET_MASK     (31 << 12) /* GUESS */
 #       define R300_PFS_CNTL_TEX_END_SHIFT       18
 #       define R300_PFS_CNTL_TEX_END_MASK        (31 << 18) /* GUESS */
 
 /* gap */
+
 /* Nodes are stored backwards. The last active node is always stored in
-// PFS_NODE_3.
-// Example: In a 2-node program, NODE_0 and NODE_1 are set to 0. The
-// first node is stored in NODE_2, the second node is stored in NODE_3.
-//
-// Offsets are relative to the master offset from PFS_CNTL_2.
-// LAST_NODE is set for the last node, and only for the last node. */
+ * PFS_NODE_3.
+ * Example: In a 2-node program, NODE_0 and NODE_1 are set to 0. The
+ * first node is stored in NODE_2, the second node is stored in NODE_3.
+ *
+ * Offsets are relative to the master offset from PFS_CNTL_2.
+ */
 #define R300_PFS_NODE_0                     0x4610
 #define R300_PFS_NODE_1                     0x4614
 #define R300_PFS_NODE_2                     0x4618
@@ -891,91 +996,98 @@
 #       define R300_PFS_NODE_TEX_OFFSET_MASK     (31 << 12)
 #       define R300_PFS_NODE_TEX_END_SHIFT       17
 #       define R300_PFS_NODE_TEX_END_MASK        (31 << 17)
-/*#       define R300_PFS_NODE_LAST_NODE           (1 << 22) */
 #		define R300_PFS_NODE_OUTPUT_COLOR        (1 << 22)
 #		define R300_PFS_NODE_OUTPUT_DEPTH        (1 << 23)
 
 /* TEX
-// As far as I can tell, texture instructions cannot write into output
-// registers directly. A subsequent ALU instruction is always necessary,
-// even if it's just MAD o0, r0, 1, 0 */
+ * As far as I can tell, texture instructions cannot write into output
+ * registers directly. A subsequent ALU instruction is always necessary,
+ * even if it's just MAD o0, r0, 1, 0
+ */
 #define R300_PFS_TEXI_0                     0x4620
-#       define R300_FPITX_SRC_SHIFT              0
-#       define R300_FPITX_SRC_MASK               (31 << 0)
-#       define R300_FPITX_SRC_CONST              (1 << 5) /* GUESS */
-#       define R300_FPITX_DST_SHIFT              6
-#       define R300_FPITX_DST_MASK               (31 << 6)
-#       define R300_FPITX_IMAGE_SHIFT            11
-#       define R300_FPITX_IMAGE_MASK             (15 << 11) /* GUESS based on layout and native limits */
+#	define R300_FPITX_SRC_SHIFT              0
+#	define R300_FPITX_SRC_MASK               (31 << 0)
+	/* GUESS */
+#	define R300_FPITX_SRC_CONST              (1 << 5)
+#	define R300_FPITX_DST_SHIFT              6
+#	define R300_FPITX_DST_MASK               (31 << 6)
+#	define R300_FPITX_IMAGE_SHIFT            11
+	/* GUESS based on layout and native limits */
+#       define R300_FPITX_IMAGE_MASK             (15 << 11)
 /* Unsure if these are opcodes, or some kind of bitfield, but this is how
  * they were set when I checked
  */
-#		define R300_FPITX_OPCODE_SHIFT			15
-#			define R300_FPITX_OP_TEX			1
-#			define R300_FPITX_OP_KIL			2
-#			define R300_FPITX_OP_TXP			3
-#			define R300_FPITX_OP_TXB			4
+#	define R300_FPITX_OPCODE_SHIFT		15
+#		define R300_FPITX_OP_TEX	1
+#		define R300_FPITX_OP_KIL	2
+#		define R300_FPITX_OP_TXP	3
+#		define R300_FPITX_OP_TXB	4
+#	define R300_FPITX_OPCODE_MASK           (7 << 15)
 
 /* ALU
-// The ALU instructions register blocks are enumerated according to the order
-// in which fglrx. I assume there is space for 64 instructions, since
-// each block has space for a maximum of 64 DWORDs, and this matches reported
-// native limits.
-//
-// The basic functional block seems to be one MAD for each color and alpha,
-// and an adder that adds all components after the MUL.
-//  - ADD, MUL, MAD etc.: use MAD with appropriate neutral operands
-//  - DP4: Use OUTC_DP4, OUTA_DP4
-//  - DP3: Use OUTC_DP3, OUTA_DP4, appropriate alpha operands
-//  - DPH: Use OUTC_DP4, OUTA_DP4, appropriate alpha operands
-//  - CMP: If ARG2 < 0, return ARG1, else return ARG0
-//  - FLR: use FRC+MAD
-//  - XPD: use MAD+MAD
-//  - SGE, SLT: use MAD+CMP
-//  - RSQ: use ABS modifier for argument
-//  - Use OUTC_REPL_ALPHA to write results of an alpha-only operation (e.g. RCP)
-//    into color register
-//  - apparently, there's no quick DST operation
-//  - fglrx set FPI2_UNKNOWN_31 on a "MAD fragment.color, tmp0, tmp1, tmp2"
-//  - fglrx set FPI2_UNKNOWN_31 on a "MAX r2, r1, c0"
-//  - fglrx once set FPI0_UNKNOWN_31 on a "FRC r1, r1"
-//
-// Operand selection
-// First stage selects three sources from the available registers and
-// constant parameters. This is defined in INSTR1 (color) and INSTR3 (alpha).
-// fglrx sorts the three source fields: Registers before constants,
-// lower indices before higher indices; I do not know whether this is necessary.
-// fglrx fills unused sources with "read constant 0"
-// According to specs, you cannot select more than two different constants.
-//
-// Second stage selects the operands from the sources. This is defined in
-// INSTR0 (color) and INSTR2 (alpha). You can also select the special constants
-// zero and one.
-// Swizzling and negation happens in this stage, as well.
-//
-// Important: Color and alpha seem to be mostly separate, i.e. their sources
-// selection appears to be fully independent (the register storage is probably
-// physically split into a color and an alpha section).
-// However (because of the apparent physical split), there is some interaction
-// WRT swizzling. If, for example, you want to load an R component into an
-// Alpha operand, this R component is taken from a *color* source, not from
-// an alpha source. The corresponding register doesn't even have to appear in
-// the alpha sources list. (I hope this alll makes sense to you)
-//
-// Destination selection
-// The destination register index is in FPI1 (color) and FPI3 (alpha) together
-// with enable bits.
-// There are separate enable bits for writing into temporary registers
-// (DSTC_REG_* /DSTA_REG) and and program output registers (DSTC_OUTPUT_* /DSTA_OUTPUT).
-// You can write to both at once, or not write at all (the same index
-// must be used for both).
-//
-// Note: There is a special form for LRP
-//  - Argument order is the same as in ARB_fragment_program.
-//  - Operation is MAD
-//  - ARG1 is set to ARGC_SRC1C_LRP/ARGC_SRC1A_LRP
-//  - Set FPI0/FPI2_SPECIAL_LRP
-// Arbitrary LRP (including support for swizzling) requires vanilla MAD+MAD */
+ * The ALU instructions register blocks are enumerated according to the order
+ * in which fglrx. I assume there is space for 64 instructions, since
+ * each block has space for a maximum of 64 DWORDs, and this matches reported
+ * native limits.
+ *
+ * The basic functional block seems to be one MAD for each color and alpha,
+ * and an adder that adds all components after the MUL.
+ *  - ADD, MUL, MAD etc.: use MAD with appropriate neutral operands
+ *  - DP4: Use OUTC_DP4, OUTA_DP4
+ *  - DP3: Use OUTC_DP3, OUTA_DP4, appropriate alpha operands
+ *  - DPH: Use OUTC_DP4, OUTA_DP4, appropriate alpha operands
+ *  - CMPH: If ARG2 > 0.5, return ARG0, else return ARG1
+ *  - CMP: If ARG2 < 0, return ARG1, else return ARG0
+ *  - FLR: use FRC+MAD
+ *  - XPD: use MAD+MAD
+ *  - SGE, SLT: use MAD+CMP
+ *  - RSQ: use ABS modifier for argument
+ *  - Use OUTC_REPL_ALPHA to write results of an alpha-only operation
+ *    (e.g. RCP) into color register
+ *  - apparently, there's no quick DST operation
+ *  - fglrx set FPI2_UNKNOWN_31 on a "MAD fragment.color, tmp0, tmp1, tmp2"
+ *  - fglrx set FPI2_UNKNOWN_31 on a "MAX r2, r1, c0"
+ *  - fglrx once set FPI0_UNKNOWN_31 on a "FRC r1, r1"
+ *
+ * Operand selection
+ * First stage selects three sources from the available registers and
+ * constant parameters. This is defined in INSTR1 (color) and INSTR3 (alpha).
+ * fglrx sorts the three source fields: Registers before constants,
+ * lower indices before higher indices; I do not know whether this is
+ * necessary.
+ *
+ * fglrx fills unused sources with "read constant 0"
+ * According to specs, you cannot select more than two different constants.
+ *
+ * Second stage selects the operands from the sources. This is defined in
+ * INSTR0 (color) and INSTR2 (alpha). You can also select the special constants
+ * zero and one.
+ * Swizzling and negation happens in this stage, as well.
+ *
+ * Important: Color and alpha seem to be mostly separate, i.e. their sources
+ * selection appears to be fully independent (the register storage is probably
+ * physically split into a color and an alpha section).
+ * However (because of the apparent physical split), there is some interaction
+ * WRT swizzling. If, for example, you want to load an R component into an
+ * Alpha operand, this R component is taken from a *color* source, not from
+ * an alpha source. The corresponding register doesn't even have to appear in
+ * the alpha sources list. (I hope this all makes sense to you)
+ *
+ * Destination selection
+ * The destination register index is in FPI1 (color) and FPI3 (alpha)
+ * together with enable bits.
+ * There are separate enable bits for writing into temporary registers
+ * (DSTC_REG_* /DSTA_REG) and and program output registers (DSTC_OUTPUT_*
+ * /DSTA_OUTPUT). You can write to both at once, or not write at all (the
+ * same index must be used for both).
+ *
+ * Note: There is a special form for LRP
+ *  - Argument order is the same as in ARB_fragment_program.
+ *  - Operation is MAD
+ *  - ARG1 is set to ARGC_SRC1C_LRP/ARGC_SRC1A_LRP
+ *  - Set FPI0/FPI2_SPECIAL_LRP
+ * Arbitrary LRP (including support for swizzling) requires vanilla MAD+MAD
+ */
 #define R300_PFS_INSTR1_0                   0x46C0
 #       define R300_FPI1_SRC0C_SHIFT             0
 #       define R300_FPI1_SRC0C_MASK              (31 << 0)
@@ -986,6 +1098,7 @@
 #       define R300_FPI1_SRC2C_SHIFT             12
 #       define R300_FPI1_SRC2C_MASK              (31 << 12)
 #       define R300_FPI1_SRC2C_CONST             (1 << 17)
+#       define R300_FPI1_SRC_MASK                0x0003ffff
 #       define R300_FPI1_DSTC_SHIFT              18
 #       define R300_FPI1_DSTC_MASK               (31 << 18)
 #		define R300_FPI1_DSTC_REG_MASK_SHIFT     23
@@ -1007,6 +1120,7 @@
 #       define R300_FPI3_SRC2A_SHIFT             12
 #       define R300_FPI3_SRC2A_MASK              (31 << 12)
 #       define R300_FPI3_SRC2A_CONST             (1 << 17)
+#       define R300_FPI3_SRC_MASK                0x0003ffff
 #       define R300_FPI3_DSTA_SHIFT              18
 #       define R300_FPI3_DSTA_MASK               (31 << 18)
 #       define R300_FPI3_DSTA_REG                (1 << 23)
@@ -1032,7 +1146,8 @@
 #       define R300_FPI0_ARGC_SRC1C_LRP          15
 #       define R300_FPI0_ARGC_ZERO               20
 #       define R300_FPI0_ARGC_ONE                21
-#       define R300_FPI0_ARGC_HALF               22 /* GUESS */
+	/* GUESS */
+#       define R300_FPI0_ARGC_HALF               22
 #       define R300_FPI0_ARGC_SRC0C_YZX          23
 #       define R300_FPI0_ARGC_SRC1C_YZX          24
 #       define R300_FPI0_ARGC_SRC2C_YZX          25
@@ -1061,6 +1176,7 @@
 #       define R300_FPI0_OUTC_DP4                (2 << 23)
 #       define R300_FPI0_OUTC_MIN                (4 << 23)
 #       define R300_FPI0_OUTC_MAX                (5 << 23)
+#       define R300_FPI0_OUTC_CMPH               (7 << 23)
 #       define R300_FPI0_OUTC_CMP                (8 << 23)
 #       define R300_FPI0_OUTC_FRC                (9 << 23)
 #       define R300_FPI0_OUTC_REPL_ALPHA         (10 << 23)
@@ -1083,20 +1199,23 @@
 #       define R300_FPI2_ARGA_SRC1A_LRP          15
 #       define R300_FPI2_ARGA_ZERO               16
 #       define R300_FPI2_ARGA_ONE                17
-#       define R300_FPI2_ARGA_HALF               18 /* GUESS */
-
+	/* GUESS */
+#       define R300_FPI2_ARGA_HALF               18
 #       define R300_FPI2_ARG0A_SHIFT             0
 #       define R300_FPI2_ARG0A_MASK              (31 << 0)
 #       define R300_FPI2_ARG0A_NEG               (1 << 5)
-#		define R300_FPI2_ARG0A_ABS				 (1 << 6) /* GUESS */
+	/* GUESS */
+#	define R300_FPI2_ARG0A_ABS		 (1 << 6)
 #       define R300_FPI2_ARG1A_SHIFT             7
 #       define R300_FPI2_ARG1A_MASK              (31 << 7)
 #       define R300_FPI2_ARG1A_NEG               (1 << 12)
-#		define R300_FPI2_ARG1A_ABS				 (1 << 13) /* GUESS */
+	/* GUESS */
+#	define R300_FPI2_ARG1A_ABS		 (1 << 13)
 #       define R300_FPI2_ARG2A_SHIFT             14
 #       define R300_FPI2_ARG2A_MASK              (31 << 14)
 #       define R300_FPI2_ARG2A_NEG               (1 << 19)
-#		define R300_FPI2_ARG2A_ABS				 (1 << 20) /* GUESS */
+	/* GUESS */
+#	define R300_FPI2_ARG2A_ABS		 (1 << 20)
 #       define R300_FPI2_SPECIAL_LRP             (1 << 21)
 #       define R300_FPI2_OUTA_MAD                (0 << 23)
 #       define R300_FPI2_OUTA_DP4                (1 << 23)
@@ -1110,9 +1229,19 @@
 #       define R300_FPI2_OUTA_RSQ                (11 << 23)
 #       define R300_FPI2_OUTA_SAT                (1 << 30)
 #       define R300_FPI2_UNKNOWN_31              (1 << 31)
-/* END */
+/* END: Fragment program instruction set */
+
+/* Fog state and color */
+#define R300_RE_FOG_STATE                   0x4BC0
+#       define R300_FOG_ENABLE                   (1 << 0)
+#	define R300_FOG_MODE_LINEAR              (0 << 1)
+#	define R300_FOG_MODE_EXP                 (1 << 1)
+#	define R300_FOG_MODE_EXP2                (2 << 1)
+#	define R300_FOG_MODE_MASK                (3 << 1)
+#define R300_FOG_COLOR_R                    0x4BC8
+#define R300_FOG_COLOR_G                    0x4BCC
+#define R300_FOG_COLOR_B                    0x4BD0
 
-/* gap */
 #define R300_PP_ALPHA_TEST                  0x4BD4
 #       define R300_REF_ALPHA_MASK               0x000000ff
 #       define R300_ALPHA_TEST_FAIL              (0 << 8)
@@ -1127,6 +1256,7 @@
 #       define R300_ALPHA_TEST_ENABLE            (1 << 11)
 
 /* gap */
+
 /* Fragment program parameters in 7.16 floating point */
 #define R300_PFS_PARAM_0_X                  0x4C00
 #define R300_PFS_PARAM_0_Y                  0x4C04
@@ -1139,45 +1269,48 @@
 #define R300_PFS_PARAM_31_W                 0x4DFC
 
 /* Notes:
-// - AFAIK fglrx always sets BLEND_UNKNOWN when blending is used in the application
-// - AFAIK fglrx always sets BLEND_NO_SEPARATE when CBLEND and ABLEND are set to the same
-//   function (both registers are always set up completely in any case)
-// - Most blend flags are simply copied from R200 and not tested yet */
+ * - AFAIK fglrx always sets BLEND_UNKNOWN when blending is used in
+ *   the application
+ * - AFAIK fglrx always sets BLEND_NO_SEPARATE when CBLEND and ABLEND
+ *    are set to the same
+ *   function (both registers are always set up completely in any case)
+ * - Most blend flags are simply copied from R200 and not tested yet
+ */
 #define R300_RB3D_CBLEND                    0x4E04
 #define R300_RB3D_ABLEND                    0x4E08
- /* the following only appear in CBLEND */
+/* the following only appear in CBLEND */
 #       define R300_BLEND_ENABLE                     (1 << 0)
 #       define R300_BLEND_UNKNOWN                    (3 << 1)
 #       define R300_BLEND_NO_SEPARATE                (1 << 3)
- /* the following are shared between CBLEND and ABLEND */
+/* the following are shared between CBLEND and ABLEND */
 #       define R300_FCN_MASK                         (3  << 12)
 #       define R300_COMB_FCN_ADD_CLAMP               (0  << 12)
 #       define R300_COMB_FCN_ADD_NOCLAMP             (1  << 12)
 #       define R300_COMB_FCN_SUB_CLAMP               (2  << 12)
 #       define R300_COMB_FCN_SUB_NOCLAMP             (3  << 12)
-#       define R300_SRC_BLEND_GL_ZERO                (32 << 16)
-#       define R300_SRC_BLEND_GL_ONE                 (33 << 16)
-#       define R300_SRC_BLEND_GL_SRC_COLOR           (34 << 16)
-#       define R300_SRC_BLEND_GL_ONE_MINUS_SRC_COLOR (35 << 16)
-#       define R300_SRC_BLEND_GL_DST_COLOR           (36 << 16)
-#       define R300_SRC_BLEND_GL_ONE_MINUS_DST_COLOR (37 << 16)
-#       define R300_SRC_BLEND_GL_SRC_ALPHA           (38 << 16)
-#       define R300_SRC_BLEND_GL_ONE_MINUS_SRC_ALPHA (39 << 16)
-#       define R300_SRC_BLEND_GL_DST_ALPHA           (40 << 16)
-#       define R300_SRC_BLEND_GL_ONE_MINUS_DST_ALPHA (41 << 16)
-#       define R300_SRC_BLEND_GL_SRC_ALPHA_SATURATE  (42 << 16)
-#       define R300_SRC_BLEND_MASK                   (63 << 16)
-#       define R300_DST_BLEND_GL_ZERO                (32 << 24)
-#       define R300_DST_BLEND_GL_ONE                 (33 << 24)
-#       define R300_DST_BLEND_GL_SRC_COLOR           (34 << 24)
-#       define R300_DST_BLEND_GL_ONE_MINUS_SRC_COLOR (35 << 24)
-#       define R300_DST_BLEND_GL_DST_COLOR           (36 << 24)
-#       define R300_DST_BLEND_GL_ONE_MINUS_DST_COLOR (37 << 24)
-#       define R300_DST_BLEND_GL_SRC_ALPHA           (38 << 24)
-#       define R300_DST_BLEND_GL_ONE_MINUS_SRC_ALPHA (39 << 24)
-#       define R300_DST_BLEND_GL_DST_ALPHA           (40 << 24)
-#       define R300_DST_BLEND_GL_ONE_MINUS_DST_ALPHA (41 << 24)
-#       define R300_DST_BLEND_MASK                   (63 << 24)
+#       define R300_COMB_FCN_MIN                     (4  << 12)
+#       define R300_COMB_FCN_MAX                     (5  << 12)
+#       define R300_COMB_FCN_RSUB_CLAMP              (6  << 12)
+#       define R300_COMB_FCN_RSUB_NOCLAMP            (7  << 12)
+#       define R300_BLEND_GL_ZERO                    (32)
+#       define R300_BLEND_GL_ONE                     (33)
+#       define R300_BLEND_GL_SRC_COLOR               (34)
+#       define R300_BLEND_GL_ONE_MINUS_SRC_COLOR     (35)
+#       define R300_BLEND_GL_DST_COLOR               (36)
+#       define R300_BLEND_GL_ONE_MINUS_DST_COLOR     (37)
+#       define R300_BLEND_GL_SRC_ALPHA               (38)
+#       define R300_BLEND_GL_ONE_MINUS_SRC_ALPHA     (39)
+#       define R300_BLEND_GL_DST_ALPHA               (40)
+#       define R300_BLEND_GL_ONE_MINUS_DST_ALPHA     (41)
+#       define R300_BLEND_GL_SRC_ALPHA_SATURATE      (42)
+#       define R300_BLEND_GL_CONST_COLOR             (43)
+#       define R300_BLEND_GL_ONE_MINUS_CONST_COLOR   (44)
+#       define R300_BLEND_GL_CONST_ALPHA             (45)
+#       define R300_BLEND_GL_ONE_MINUS_CONST_ALPHA   (46)
+#       define R300_BLEND_MASK                       (63)
+#       define R300_SRC_BLEND_SHIFT                  (16)
+#       define R300_DST_BLEND_SHIFT                  (24)
+#define R300_RB3D_BLEND_COLOR               0x4E10
 #define R300_RB3D_COLORMASK                 0x4E0C
 #       define R300_COLORMASK0_B                 (1<<0)
 #       define R300_COLORMASK0_G                 (1<<1)
@@ -1185,15 +1318,19 @@
 #       define R300_COLORMASK0_A                 (1<<3)
 
 /* gap */
+
 #define R300_RB3D_COLOROFFSET0              0x4E28
 #       define R300_COLOROFFSET_MASK             0xFFFFFFF0 /* GUESS */
 #define R300_RB3D_COLOROFFSET1              0x4E2C /* GUESS */
 #define R300_RB3D_COLOROFFSET2              0x4E30 /* GUESS */
 #define R300_RB3D_COLOROFFSET3              0x4E34 /* GUESS */
+
 /* gap */
+
 /* Bit 16: Larger tiles
-// Bit 17: 4x2 tiles
-// Bit 18: Extremely weird tile like, but some pixels duplicated? */
+ * Bit 17: 4x2 tiles
+ * Bit 18: Extremely weird tile like, but some pixels duplicated?
+ */
 #define R300_RB3D_COLORPITCH0               0x4E38
 #       define R300_COLORPITCH_MASK              0x00001FF8 /* GUESS */
 #       define R300_COLOR_TILE_ENABLE            (1 << 16) /* GUESS */
@@ -1208,29 +1345,33 @@
 #define R300_RB3D_COLORPITCH3               0x4E44 /* GUESS */
 
 /* gap */
+
 /* Guess by Vladimir.
-// Set to 0A before 3D operations, set to 02 afterwards. */
+ * Set to 0A before 3D operations, set to 02 afterwards.
+ */
 #define R300_RB3D_DSTCACHE_CTLSTAT          0x4E4C
-#       define R300_RB3D_DSTCACHE_02             0x00000002
-#       define R300_RB3D_DSTCACHE_0A             0x0000000A
+#       define R300_RB3D_DSTCACHE_UNKNOWN_02             0x00000002
+#       define R300_RB3D_DSTCACHE_UNKNOWN_0A             0x0000000A
 
 /* gap */
-/* There seems to be no "write only" setting, so use Z-test = ALWAYS for this. */
-/* Bit (1<<8) is the "test" bit. so plain write is 6  - vd */
+/* There seems to be no "write only" setting, so use Z-test = ALWAYS
+ * for this.
+ * Bit (1<<8) is the "test" bit. so plain write is 6  - vd
+ */
 #define R300_RB3D_ZSTENCIL_CNTL_0                   0x4F00
-#       define R300_RB3D_Z_DISABLED_1            0x00000010 /* GUESS */
-#       define R300_RB3D_Z_DISABLED_2            0x00000014 /* GUESS */
+#       define R300_RB3D_Z_DISABLED_1            0x00000010
+#       define R300_RB3D_Z_DISABLED_2            0x00000014
 #       define R300_RB3D_Z_TEST                  0x00000012
 #       define R300_RB3D_Z_TEST_AND_WRITE        0x00000016
-#       define R300_RB3D_Z_WRITE_ONLY        	 0x00000006
+#       define R300_RB3D_Z_WRITE_ONLY		 0x00000006
 
 #       define R300_RB3D_Z_TEST                  0x00000012
 #       define R300_RB3D_Z_TEST_AND_WRITE        0x00000016
-#       define R300_RB3D_Z_WRITE_ONLY        	 0x00000006
+#       define R300_RB3D_Z_WRITE_ONLY		 0x00000006
 #	define R300_RB3D_STENCIL_ENABLE		 0x00000001
 
 #define R300_RB3D_ZSTENCIL_CNTL_1                   0x4F04
-		/* functions */
+	/* functions */
 #	define R300_ZS_NEVER			0
 #	define R300_ZS_LESS			1
 #	define R300_ZS_LEQUAL			2
@@ -1240,7 +1381,7 @@
 #	define R300_ZS_NOTEQUAL			6
 #	define R300_ZS_ALWAYS			7
 #       define R300_ZS_MASK                     7
-		/* operations */
+	/* operations */
 #	define R300_ZS_KEEP			0
 #	define R300_ZS_ZERO			1
 #	define R300_ZS_REPLACE			2
@@ -1249,9 +1390,8 @@
 #	define R300_ZS_INVERT			5
 #	define R300_ZS_INCR_WRAP		6
 #	define R300_ZS_DECR_WRAP		7
-
-       /* front and back refer to operations done for front
-          and back faces, i.e. separate stencil function support */
+	/* front and back refer to operations done for front
+	   and back faces, i.e. separate stencil function support */
 #	define R300_RB3D_ZS1_DEPTH_FUNC_SHIFT		0
 #	define R300_RB3D_ZS1_FRONT_FUNC_SHIFT		3
 #	define R300_RB3D_ZS1_FRONT_FAIL_OP_SHIFT	6
@@ -1262,8 +1402,6 @@
 #	define R300_RB3D_ZS1_BACK_ZPASS_OP_SHIFT       21
 #	define R300_RB3D_ZS1_BACK_ZFAIL_OP_SHIFT       24
 
-
-
 #define R300_RB3D_ZSTENCIL_CNTL_2                   0x4F08
 #	define R300_RB3D_ZS2_STENCIL_REF_SHIFT		0
 #	define R300_RB3D_ZS2_STENCIL_MASK		0xFF
@@ -1275,8 +1413,21 @@
 #define R300_RB3D_ZSTENCIL_FORMAT                   0x4F10
 #	define R300_DEPTH_FORMAT_16BIT_INT_Z     (0 << 0)
 #	define R300_DEPTH_FORMAT_24BIT_INT_Z     (2 << 0)
+	/* 16 bit format or some aditional bit ? */
+#	define R300_DEPTH_FORMAT_UNK32          (32 << 0)
+
+#define R300_RB3D_EARLY_Z                           0x4F14
+#	define R300_EARLY_Z_DISABLE              (0 << 0)
+#	define R300_EARLY_Z_ENABLE               (1 << 0)
+
+/* gap */
+
+#define R300_RB3D_ZCACHE_CTLSTAT            0x4F18 /* GUESS */
+#       define R300_RB3D_ZCACHE_UNKNOWN_01  0x1
+#       define R300_RB3D_ZCACHE_UNKNOWN_03  0x3
 
 /* gap */
+
 #define R300_RB3D_DEPTHOFFSET               0x4F20
 #define R300_RB3D_DEPTHPITCH                0x4F24
 #       define R300_DEPTHPITCH_MASK              0x00001FF8 /* GUESS */
@@ -1286,34 +1437,40 @@
 #       define R300_DEPTH_ENDIAN_WORD_SWAP       (1 << 18) /* GUESS */
 #       define R300_DEPTH_ENDIAN_DWORD_SWAP      (2 << 18) /* GUESS */
 
-/* BEGIN: Vertex program instruction set
-// Every instruction is four dwords long:
-//  DWORD 0: output and opcode
-//  DWORD 1: first argument
-//  DWORD 2: second argument
-//  DWORD 3: third argument
-//
-// Notes:
-//  - ABS r, a is implemented as MAX r, a, -a
-//  - MOV is implemented as ADD to zero
-//  - XPD is implemented as MUL + MAD
-//  - FLR is implemented as FRC + ADD
-//  - apparently, fglrx tries to schedule instructions so that there is at least
-//    one instruction between the write to a temporary and the first read
-//    from said temporary; however, violations of this scheduling are allowed
-//  - register indices seem to be unrelated with OpenGL aliasing to conventional state
-//  - only one attribute and one parameter can be loaded at a time; however, the
-//    same attribute/parameter can be used for more than one argument
-//  - the second software argument for POW is the third hardware argument (no idea why)
-//  - MAD with only temporaries as input seems to use VPI_OUT_SELECT_MAD_2
-//
-// There is some magic surrounding LIT:
-//  The single argument is replicated across all three inputs, but swizzled:
-//   First argument: xyzy
-//   Second argument: xyzx
-//   Third argument: xyzw
-//  Whenever the result is used later in the fragment program, fglrx forces x and w
-//  to be 1.0 in the input selection; I don't know whether this is strictly necessary */
+/* BEGIN: Vertex program instruction set */
+
+/* Every instruction is four dwords long:
+ *  DWORD 0: output and opcode
+ *  DWORD 1: first argument
+ *  DWORD 2: second argument
+ *  DWORD 3: third argument
+ *
+ * Notes:
+ *  - ABS r, a is implemented as MAX r, a, -a
+ *  - MOV is implemented as ADD to zero
+ *  - XPD is implemented as MUL + MAD
+ *  - FLR is implemented as FRC + ADD
+ *  - apparently, fglrx tries to schedule instructions so that there is at
+ *    least one instruction between the write to a temporary and the first
+ *    read from said temporary; however, violations of this scheduling are
+ *    allowed
+ *  - register indices seem to be unrelated with OpenGL aliasing to
+ *    conventional state
+ *  - only one attribute and one parameter can be loaded at a time; however,
+ *    the same attribute/parameter can be used for more than one argument
+ *  - the second software argument for POW is the third hardware argument
+ *    (no idea why)
+ *  - MAD with only temporaries as input seems to use VPI_OUT_SELECT_MAD_2
+ *
+ * There is some magic surrounding LIT:
+ *   The single argument is replicated across all three inputs, but swizzled:
+ *     First argument: xyzy
+ *     Second argument: xyzx
+ *     Third argument: xyzw
+ *   Whenever the result is used later in the fragment program, fglrx forces
+ *   x and w to be 1.0 in the input selection; I don't know whether this is
+ *   strictly necessary
+ */
 #define R300_VPI_OUT_OP_DOT                     (1 << 0)
 #define R300_VPI_OUT_OP_MUL                     (2 << 0)
 #define R300_VPI_OUT_OP_ADD                     (3 << 0)
@@ -1324,26 +1481,33 @@
 #define R300_VPI_OUT_OP_MIN                     (8 << 0)
 #define R300_VPI_OUT_OP_SGE                     (9 << 0)
 #define R300_VPI_OUT_OP_SLT                     (10 << 0)
-#define R300_VPI_OUT_OP_UNK12                   (12 << 0) /* Used in GL_POINT_DISTANCE_ATTENUATION_ARB, vector(scalar, vector) */
+	/* Used in GL_POINT_DISTANCE_ATTENUATION_ARB, vector(scalar, vector) */
+#define R300_VPI_OUT_OP_UNK12                   (12 << 0)
+#define R300_VPI_OUT_OP_ARL                     (13 << 0)
 #define R300_VPI_OUT_OP_EXP                     (65 << 0)
 #define R300_VPI_OUT_OP_LOG                     (66 << 0)
-#define R300_VPI_OUT_OP_UNK67                   (67 << 0) /* Used in fog computations, scalar(scalar) */
+	/* Used in fog computations, scalar(scalar) */
+#define R300_VPI_OUT_OP_UNK67                   (67 << 0)
 #define R300_VPI_OUT_OP_LIT                     (68 << 0)
 #define R300_VPI_OUT_OP_POW                     (69 << 0)
 #define R300_VPI_OUT_OP_RCP                     (70 << 0)
 #define R300_VPI_OUT_OP_RSQ                     (72 << 0)
-#define R300_VPI_OUT_OP_UNK73                   (73 << 0) /* Used in GL_POINT_DISTANCE_ATTENUATION_ARB, scalar(scalar) */
+	/* Used in GL_POINT_DISTANCE_ATTENUATION_ARB, scalar(scalar) */
+#define R300_VPI_OUT_OP_UNK73                   (73 << 0)
 #define R300_VPI_OUT_OP_EX2                     (75 << 0)
 #define R300_VPI_OUT_OP_LG2                     (76 << 0)
 #define R300_VPI_OUT_OP_MAD_2                   (128 << 0)
-#define R300_VPI_OUT_OP_UNK129                  (129 << 0) /* all temps, vector(scalar, vector, vector) */
+	/* all temps, vector(scalar, vector, vector) */
+#define R300_VPI_OUT_OP_UNK129                  (129 << 0)
 
 #define R300_VPI_OUT_REG_CLASS_TEMPORARY        (0 << 8)
+#define R300_VPI_OUT_REG_CLASS_ADDR             (1 << 8)
 #define R300_VPI_OUT_REG_CLASS_RESULT           (2 << 8)
 #define R300_VPI_OUT_REG_CLASS_MASK             (31 << 8)
 
 #define R300_VPI_OUT_REG_INDEX_SHIFT            13
-#define R300_VPI_OUT_REG_INDEX_MASK             (31 << 13) /* GUESS based on fglrx native limits */
+	/* GUESS based on fglrx native limits */
+#define R300_VPI_OUT_REG_INDEX_MASK             (31 << 13)
 
 #define R300_VPI_OUT_WRITE_X                    (1 << 20)
 #define R300_VPI_OUT_WRITE_Y                    (1 << 21)
@@ -1354,14 +1518,16 @@
 #define R300_VPI_IN_REG_CLASS_ATTRIBUTE         (1 << 0)
 #define R300_VPI_IN_REG_CLASS_PARAMETER         (2 << 0)
 #define R300_VPI_IN_REG_CLASS_NONE              (9 << 0)
-#define R300_VPI_IN_REG_CLASS_MASK              (31 << 0) /* GUESS */
+#define R300_VPI_IN_REG_CLASS_MASK              (31 << 0)
 
 #define R300_VPI_IN_REG_INDEX_SHIFT             5
-#define R300_VPI_IN_REG_INDEX_MASK              (255 << 5) /* GUESS based on fglrx native limits */
+	/* GUESS based on fglrx native limits */
+#define R300_VPI_IN_REG_INDEX_MASK              (255 << 5)
 
 /* The R300 can select components from the input register arbitrarily.
-// Use the following constants, shifted by the component shift you
-// want to select */
+ * Use the following constants, shifted by the component shift you
+ * want to select
+ */
 #define R300_VPI_IN_SELECT_X    0
 #define R300_VPI_IN_SELECT_Y    1
 #define R300_VPI_IN_SELECT_Z    2
@@ -1379,11 +1545,11 @@
 #define R300_VPI_IN_NEG_Y                       (1 << 26)
 #define R300_VPI_IN_NEG_Z                       (1 << 27)
 #define R300_VPI_IN_NEG_W                       (1 << 28)
-/* END */
+/* END: Vertex program instruction set */
 
-//BEGIN: Packet 3 commands
+/* BEGIN: Packet 3 commands */
 
-// A primitive emission dword.
+/* A primitive emission dword. */
 #define R300_PRIM_TYPE_NONE                     (0 << 0)
 #define R300_PRIM_TYPE_POINT                    (1 << 0)
 #define R300_PRIM_TYPE_LINE                     (2 << 0)
@@ -1395,7 +1561,8 @@
 #define R300_PRIM_TYPE_RECT_LIST                (8 << 0)
 #define R300_PRIM_TYPE_3VRT_POINT_LIST          (9 << 0)
 #define R300_PRIM_TYPE_3VRT_LINE_LIST           (10 << 0)
-#define R300_PRIM_TYPE_POINT_SPRITES            (11 << 0) // GUESS (based on r200)
+	/* GUESS (based on r200) */
+#define R300_PRIM_TYPE_POINT_SPRITES            (11 << 0)
 #define R300_PRIM_TYPE_LINE_LOOP                (12 << 0)
 #define R300_PRIM_TYPE_QUADS                    (13 << 0)
 #define R300_PRIM_TYPE_QUAD_STRIP               (14 << 0)
@@ -1405,37 +1572,60 @@
 #define R300_PRIM_WALK_LIST                     (2 << 4)
 #define R300_PRIM_WALK_RING                     (3 << 4)
 #define R300_PRIM_WALK_MASK                     (3 << 4)
-#define R300_PRIM_COLOR_ORDER_BGRA              (0 << 6) // GUESS (based on r200)
-#define R300_PRIM_COLOR_ORDER_RGBA              (1 << 6) // GUESS
+	/* GUESS (based on r200) */
+#define R300_PRIM_COLOR_ORDER_BGRA              (0 << 6)
+#define R300_PRIM_COLOR_ORDER_RGBA              (1 << 6)
 #define R300_PRIM_NUM_VERTICES_SHIFT            16
+#define R300_PRIM_NUM_VERTICES_MASK             0xffff
 
-// Draw a primitive from vertex data in arrays loaded via 3D_LOAD_VBPNTR.
-// Two parameter dwords:
-// 0. The first parameter appears to be always 0
-// 1. The second parameter is a standard primitive emission dword.
+/* Draw a primitive from vertex data in arrays loaded via 3D_LOAD_VBPNTR.
+ * Two parameter dwords:
+ * 0. The first parameter appears to be always 0
+ * 1. The second parameter is a standard primitive emission dword.
+ */
 #define R300_PACKET3_3D_DRAW_VBUF           0x00002800
 
-// Specify the full set of vertex arrays as (address, stride).
-// The first parameter is the number of vertex arrays specified.
-// The rest of the command is a variable length list of blocks, where
-// each block is three dwords long and specifies two arrays.
-// The first dword of a block is split into two words, the lower significant
-// word refers to the first array, the more significant word to the second
-// array in the block.
-// The low byte of each word contains the size of an array entry in dwords,
-// the high byte contains the stride of the array.
-// The second dword of a block contains the pointer to the first array,
-// the third dword of a block contains the pointer to the second array.
-// Note that if the total number of arrays is odd, the third dword of
-// the last block is omitted.
+/* Specify the full set of vertex arrays as (address, stride).
+ * The first parameter is the number of vertex arrays specified.
+ * The rest of the command is a variable length list of blocks, where
+ * each block is three dwords long and specifies two arrays.
+ * The first dword of a block is split into two words, the lower significant
+ * word refers to the first array, the more significant word to the second
+ * array in the block.
+ * The low byte of each word contains the size of an array entry in dwords,
+ * the high byte contains the stride of the array.
+ * The second dword of a block contains the pointer to the first array,
+ * the third dword of a block contains the pointer to the second array.
+ * Note that if the total number of arrays is odd, the third dword of
+ * the last block is omitted.
+ */
 #define R300_PACKET3_3D_LOAD_VBPNTR         0x00002F00
 
 #define R300_PACKET3_INDX_BUFFER            0x00003300
 #    define R300_EB_UNK1_SHIFT                      24
 #    define R300_EB_UNK1                    (0x80<<24)
 #    define R300_EB_UNK2                        0x0810
+#define R300_PACKET3_3D_DRAW_VBUF_2         0x00003400
 #define R300_PACKET3_3D_DRAW_INDX_2         0x00003600
 
-//END
+/* END: Packet 3 commands */
+
+
+/* Color formats for 2d packets
+ */
+#define R300_CP_COLOR_FORMAT_CI8	2
+#define R300_CP_COLOR_FORMAT_ARGB1555	3
+#define R300_CP_COLOR_FORMAT_RGB565	4
+#define R300_CP_COLOR_FORMAT_ARGB8888	6
+#define R300_CP_COLOR_FORMAT_RGB332	7
+#define R300_CP_COLOR_FORMAT_RGB8	9
+#define R300_CP_COLOR_FORMAT_ARGB4444	15
+
+/*
+ * CP type-3 packets
+ */
+#define R300_CP_CMD_BITBLT_MULTI	0xC0009B00
 
 #endif /* _R300_REG_H */
+
+/* *INDENT-ON* */
Index: git/shared-core/radeon_cp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/radeon_cp.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,2316 @@
+/* radeon_cp.c -- CP support for Radeon -*- linux-c -*- */
+/*
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Kevin E. Martin <martin@valinux.com>
+ *    Gareth Hughes <gareth@valinux.com>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "radeon_drm.h"
+#include "radeon_drv.h"
+#include "r300_reg.h"
+
+#define RADEON_FIFO_DEBUG	0
+
+static int radeon_do_cleanup_cp(struct drm_device * dev);
+
+/* CP microcode (from ATI) */
+static const u32 R200_cp_microcode[][2] = {
+	{0x21007000, 0000000000},
+	{0x20007000, 0000000000},
+	{0x000000ab, 0x00000004},
+	{0x000000af, 0x00000004},
+	{0x66544a49, 0000000000},
+	{0x49494174, 0000000000},
+	{0x54517d83, 0000000000},
+	{0x498d8b64, 0000000000},
+	{0x49494949, 0000000000},
+	{0x49da493c, 0000000000},
+	{0x49989898, 0000000000},
+	{0xd34949d5, 0000000000},
+	{0x9dc90e11, 0000000000},
+	{0xce9b9b9b, 0000000000},
+	{0x000f0000, 0x00000016},
+	{0x352e232c, 0000000000},
+	{0x00000013, 0x00000004},
+	{0x000f0000, 0x00000016},
+	{0x352e272c, 0000000000},
+	{0x000f0001, 0x00000016},
+	{0x3239362f, 0000000000},
+	{0x000077ef, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x00000020, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00061000, 0x00000002},
+	{0x00000020, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00061000, 0x00000002},
+	{0x00000020, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00000016, 0x00000004},
+	{0x0003802a, 0x00000002},
+	{0x040067e0, 0x00000002},
+	{0x00000016, 0x00000004},
+	{0x000077e0, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x000037e1, 0x00000002},
+	{0x040067e1, 0x00000006},
+	{0x000077e0, 0x00000002},
+	{0x000077e1, 0x00000002},
+	{0x000077e1, 0x00000006},
+	{0xffffffff, 0000000000},
+	{0x10000000, 0000000000},
+	{0x0003802a, 0x00000002},
+	{0x040067e0, 0x00000006},
+	{0x00007675, 0x00000002},
+	{0x00007676, 0x00000002},
+	{0x00007677, 0x00000002},
+	{0x00007678, 0x00000006},
+	{0x0003802b, 0x00000002},
+	{0x04002676, 0x00000002},
+	{0x00007677, 0x00000002},
+	{0x00007678, 0x00000006},
+	{0x0000002e, 0x00000018},
+	{0x0000002e, 0x00000018},
+	{0000000000, 0x00000006},
+	{0x0000002f, 0x00000018},
+	{0x0000002f, 0x00000018},
+	{0000000000, 0x00000006},
+	{0x01605000, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x00098000, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x64c0603d, 0x00000004},
+	{0x00080000, 0x00000016},
+	{0000000000, 0000000000},
+	{0x0400251d, 0x00000002},
+	{0x00007580, 0x00000002},
+	{0x00067581, 0x00000002},
+	{0x04002580, 0x00000002},
+	{0x00067581, 0x00000002},
+	{0x00000046, 0x00000004},
+	{0x00005000, 0000000000},
+	{0x00061000, 0x00000002},
+	{0x0000750e, 0x00000002},
+	{0x00019000, 0x00000002},
+	{0x00011055, 0x00000014},
+	{0x00000055, 0x00000012},
+	{0x0400250f, 0x00000002},
+	{0x0000504a, 0x00000004},
+	{0x00007565, 0x00000002},
+	{0x00007566, 0x00000002},
+	{0x00000051, 0x00000004},
+	{0x01e655b4, 0x00000002},
+	{0x4401b0dc, 0x00000002},
+	{0x01c110dc, 0x00000002},
+	{0x2666705d, 0x00000018},
+	{0x040c2565, 0x00000002},
+	{0x0000005d, 0x00000018},
+	{0x04002564, 0x00000002},
+	{0x00007566, 0x00000002},
+	{0x00000054, 0x00000004},
+	{0x00401060, 0x00000008},
+	{0x00101000, 0x00000002},
+	{0x000d80ff, 0x00000002},
+	{0x00800063, 0x00000008},
+	{0x000f9000, 0x00000002},
+	{0x000e00ff, 0x00000002},
+	{0000000000, 0x00000006},
+	{0x00000080, 0x00000018},
+	{0x00000054, 0x00000004},
+	{0x00007576, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x00009000, 0x00000002},
+	{0x00041000, 0x00000002},
+	{0x0c00350e, 0x00000002},
+	{0x00049000, 0x00000002},
+	{0x00051000, 0x00000002},
+	{0x01e785f8, 0x00000002},
+	{0x00200000, 0x00000002},
+	{0x00600073, 0x0000000c},
+	{0x00007563, 0x00000002},
+	{0x006075f0, 0x00000021},
+	{0x20007068, 0x00000004},
+	{0x00005068, 0x00000004},
+	{0x00007576, 0x00000002},
+	{0x00007577, 0x00000002},
+	{0x0000750e, 0x00000002},
+	{0x0000750f, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00600076, 0x0000000c},
+	{0x006075f0, 0x00000021},
+	{0x000075f8, 0x00000002},
+	{0x00000076, 0x00000004},
+	{0x000a750e, 0x00000002},
+	{0x0020750f, 0x00000002},
+	{0x00600079, 0x00000004},
+	{0x00007570, 0x00000002},
+	{0x00007571, 0x00000002},
+	{0x00007572, 0x00000006},
+	{0x00005000, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00007568, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x00000084, 0x0000000c},
+	{0x00058000, 0x00000002},
+	{0x0c607562, 0x00000002},
+	{0x00000086, 0x00000004},
+	{0x00600085, 0x00000004},
+	{0x400070dd, 0000000000},
+	{0x000380dd, 0x00000002},
+	{0x00000093, 0x0000001c},
+	{0x00065095, 0x00000018},
+	{0x040025bb, 0x00000002},
+	{0x00061096, 0x00000018},
+	{0x040075bc, 0000000000},
+	{0x000075bb, 0x00000002},
+	{0x000075bc, 0000000000},
+	{0x00090000, 0x00000006},
+	{0x00090000, 0x00000002},
+	{0x000d8002, 0x00000006},
+	{0x00005000, 0x00000002},
+	{0x00007821, 0x00000002},
+	{0x00007800, 0000000000},
+	{0x00007821, 0x00000002},
+	{0x00007800, 0000000000},
+	{0x01665000, 0x00000002},
+	{0x000a0000, 0x00000002},
+	{0x000671cc, 0x00000002},
+	{0x0286f1cd, 0x00000002},
+	{0x000000a3, 0x00000010},
+	{0x21007000, 0000000000},
+	{0x000000aa, 0x0000001c},
+	{0x00065000, 0x00000002},
+	{0x000a0000, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x000b0000, 0x00000002},
+	{0x38067000, 0x00000002},
+	{0x000a00a6, 0x00000004},
+	{0x20007000, 0000000000},
+	{0x01200000, 0x00000002},
+	{0x20077000, 0x00000002},
+	{0x01200000, 0x00000002},
+	{0x20007000, 0000000000},
+	{0x00061000, 0x00000002},
+	{0x0120751b, 0x00000002},
+	{0x8040750a, 0x00000002},
+	{0x8040750b, 0x00000002},
+	{0x00110000, 0x00000002},
+	{0x000380dd, 0x00000002},
+	{0x000000bd, 0x0000001c},
+	{0x00061096, 0x00000018},
+	{0x844075bd, 0x00000002},
+	{0x00061095, 0x00000018},
+	{0x840075bb, 0x00000002},
+	{0x00061096, 0x00000018},
+	{0x844075bc, 0x00000002},
+	{0x000000c0, 0x00000004},
+	{0x804075bd, 0x00000002},
+	{0x800075bb, 0x00000002},
+	{0x804075bc, 0x00000002},
+	{0x00108000, 0x00000002},
+	{0x01400000, 0x00000002},
+	{0x006000c4, 0x0000000c},
+	{0x20c07000, 0x00000020},
+	{0x000000c6, 0x00000012},
+	{0x00800000, 0x00000006},
+	{0x0080751d, 0x00000006},
+	{0x000025bb, 0x00000002},
+	{0x000040c0, 0x00000004},
+	{0x0000775c, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00661000, 0x00000002},
+	{0x0460275d, 0x00000020},
+	{0x00004000, 0000000000},
+	{0x00007999, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00661000, 0x00000002},
+	{0x0460299b, 0x00000020},
+	{0x00004000, 0000000000},
+	{0x01e00830, 0x00000002},
+	{0x21007000, 0000000000},
+	{0x00005000, 0x00000002},
+	{0x00038042, 0x00000002},
+	{0x040025e0, 0x00000002},
+	{0x000075e1, 0000000000},
+	{0x00000001, 0000000000},
+	{0x000380d9, 0x00000002},
+	{0x04007394, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+};
+
+static const u32 radeon_cp_microcode[][2] = {
+	{0x21007000, 0000000000},
+	{0x20007000, 0000000000},
+	{0x000000b4, 0x00000004},
+	{0x000000b8, 0x00000004},
+	{0x6f5b4d4c, 0000000000},
+	{0x4c4c427f, 0000000000},
+	{0x5b568a92, 0000000000},
+	{0x4ca09c6d, 0000000000},
+	{0xad4c4c4c, 0000000000},
+	{0x4ce1af3d, 0000000000},
+	{0xd8afafaf, 0000000000},
+	{0xd64c4cdc, 0000000000},
+	{0x4cd10d10, 0000000000},
+	{0x000f0000, 0x00000016},
+	{0x362f242d, 0000000000},
+	{0x00000012, 0x00000004},
+	{0x000f0000, 0x00000016},
+	{0x362f282d, 0000000000},
+	{0x000380e7, 0x00000002},
+	{0x04002c97, 0x00000002},
+	{0x000f0001, 0x00000016},
+	{0x333a3730, 0000000000},
+	{0x000077ef, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x00000021, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00061000, 0x00000002},
+	{0x00000021, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00061000, 0x00000002},
+	{0x00000021, 0x0000001a},
+	{0x00004000, 0x0000001e},
+	{0x00000017, 0x00000004},
+	{0x0003802b, 0x00000002},
+	{0x040067e0, 0x00000002},
+	{0x00000017, 0x00000004},
+	{0x000077e0, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x000037e1, 0x00000002},
+	{0x040067e1, 0x00000006},
+	{0x000077e0, 0x00000002},
+	{0x000077e1, 0x00000002},
+	{0x000077e1, 0x00000006},
+	{0xffffffff, 0000000000},
+	{0x10000000, 0000000000},
+	{0x0003802b, 0x00000002},
+	{0x040067e0, 0x00000006},
+	{0x00007675, 0x00000002},
+	{0x00007676, 0x00000002},
+	{0x00007677, 0x00000002},
+	{0x00007678, 0x00000006},
+	{0x0003802c, 0x00000002},
+	{0x04002676, 0x00000002},
+	{0x00007677, 0x00000002},
+	{0x00007678, 0x00000006},
+	{0x0000002f, 0x00000018},
+	{0x0000002f, 0x00000018},
+	{0000000000, 0x00000006},
+	{0x00000030, 0x00000018},
+	{0x00000030, 0x00000018},
+	{0000000000, 0x00000006},
+	{0x01605000, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x00098000, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x64c0603e, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00080000, 0x00000016},
+	{0000000000, 0000000000},
+	{0x0400251d, 0x00000002},
+	{0x00007580, 0x00000002},
+	{0x00067581, 0x00000002},
+	{0x04002580, 0x00000002},
+	{0x00067581, 0x00000002},
+	{0x00000049, 0x00000004},
+	{0x00005000, 0000000000},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x0000750e, 0x00000002},
+	{0x00019000, 0x00000002},
+	{0x00011055, 0x00000014},
+	{0x00000055, 0x00000012},
+	{0x0400250f, 0x00000002},
+	{0x0000504f, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00007565, 0x00000002},
+	{0x00007566, 0x00000002},
+	{0x00000058, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x01e655b4, 0x00000002},
+	{0x4401b0e4, 0x00000002},
+	{0x01c110e4, 0x00000002},
+	{0x26667066, 0x00000018},
+	{0x040c2565, 0x00000002},
+	{0x00000066, 0x00000018},
+	{0x04002564, 0x00000002},
+	{0x00007566, 0x00000002},
+	{0x0000005d, 0x00000004},
+	{0x00401069, 0x00000008},
+	{0x00101000, 0x00000002},
+	{0x000d80ff, 0x00000002},
+	{0x0080006c, 0x00000008},
+	{0x000f9000, 0x00000002},
+	{0x000e00ff, 0x00000002},
+	{0000000000, 0x00000006},
+	{0x0000008f, 0x00000018},
+	{0x0000005b, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00007576, 0x00000002},
+	{0x00065000, 0x00000002},
+	{0x00009000, 0x00000002},
+	{0x00041000, 0x00000002},
+	{0x0c00350e, 0x00000002},
+	{0x00049000, 0x00000002},
+	{0x00051000, 0x00000002},
+	{0x01e785f8, 0x00000002},
+	{0x00200000, 0x00000002},
+	{0x0060007e, 0x0000000c},
+	{0x00007563, 0x00000002},
+	{0x006075f0, 0x00000021},
+	{0x20007073, 0x00000004},
+	{0x00005073, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00007576, 0x00000002},
+	{0x00007577, 0x00000002},
+	{0x0000750e, 0x00000002},
+	{0x0000750f, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00600083, 0x0000000c},
+	{0x006075f0, 0x00000021},
+	{0x000075f8, 0x00000002},
+	{0x00000083, 0x00000004},
+	{0x000a750e, 0x00000002},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x0020750f, 0x00000002},
+	{0x00600086, 0x00000004},
+	{0x00007570, 0x00000002},
+	{0x00007571, 0x00000002},
+	{0x00007572, 0x00000006},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00005000, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00007568, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x00000095, 0x0000000c},
+	{0x00058000, 0x00000002},
+	{0x0c607562, 0x00000002},
+	{0x00000097, 0x00000004},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x00600096, 0x00000004},
+	{0x400070e5, 0000000000},
+	{0x000380e6, 0x00000002},
+	{0x040025c5, 0x00000002},
+	{0x000380e5, 0x00000002},
+	{0x000000a8, 0x0000001c},
+	{0x000650aa, 0x00000018},
+	{0x040025bb, 0x00000002},
+	{0x000610ab, 0x00000018},
+	{0x040075bc, 0000000000},
+	{0x000075bb, 0x00000002},
+	{0x000075bc, 0000000000},
+	{0x00090000, 0x00000006},
+	{0x00090000, 0x00000002},
+	{0x000d8002, 0x00000006},
+	{0x00007832, 0x00000002},
+	{0x00005000, 0x00000002},
+	{0x000380e7, 0x00000002},
+	{0x04002c97, 0x00000002},
+	{0x00007820, 0x00000002},
+	{0x00007821, 0x00000002},
+	{0x00007800, 0000000000},
+	{0x01200000, 0x00000002},
+	{0x20077000, 0x00000002},
+	{0x01200000, 0x00000002},
+	{0x20007000, 0x00000002},
+	{0x00061000, 0x00000002},
+	{0x0120751b, 0x00000002},
+	{0x8040750a, 0x00000002},
+	{0x8040750b, 0x00000002},
+	{0x00110000, 0x00000002},
+	{0x000380e5, 0x00000002},
+	{0x000000c6, 0x0000001c},
+	{0x000610ab, 0x00000018},
+	{0x844075bd, 0x00000002},
+	{0x000610aa, 0x00000018},
+	{0x840075bb, 0x00000002},
+	{0x000610ab, 0x00000018},
+	{0x844075bc, 0x00000002},
+	{0x000000c9, 0x00000004},
+	{0x804075bd, 0x00000002},
+	{0x800075bb, 0x00000002},
+	{0x804075bc, 0x00000002},
+	{0x00108000, 0x00000002},
+	{0x01400000, 0x00000002},
+	{0x006000cd, 0x0000000c},
+	{0x20c07000, 0x00000020},
+	{0x000000cf, 0x00000012},
+	{0x00800000, 0x00000006},
+	{0x0080751d, 0x00000006},
+	{0000000000, 0000000000},
+	{0x0000775c, 0x00000002},
+	{0x00a05000, 0x00000002},
+	{0x00661000, 0x00000002},
+	{0x0460275d, 0x00000020},
+	{0x00004000, 0000000000},
+	{0x01e00830, 0x00000002},
+	{0x21007000, 0000000000},
+	{0x6464614d, 0000000000},
+	{0x69687420, 0000000000},
+	{0x00000073, 0000000000},
+	{0000000000, 0000000000},
+	{0x00005000, 0x00000002},
+	{0x000380d0, 0x00000002},
+	{0x040025e0, 0x00000002},
+	{0x000075e1, 0000000000},
+	{0x00000001, 0000000000},
+	{0x000380e0, 0x00000002},
+	{0x04002394, 0x00000002},
+	{0x00005000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0x00000008, 0000000000},
+	{0x00000004, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+	{0000000000, 0000000000},
+};
+
+static const u32 R300_cp_microcode[][2] = {
+	{ 0x4200e000, 0000000000 },
+	{ 0x4000e000, 0000000000 },
+	{ 0x000000af, 0x00000008 },
+	{ 0x000000b3, 0x00000008 },
+	{ 0x6c5a504f, 0000000000 },
+	{ 0x4f4f497a, 0000000000 },
+	{ 0x5a578288, 0000000000 },
+	{ 0x4f91906a, 0000000000 },
+	{ 0x4f4f4f4f, 0000000000 },
+	{ 0x4fe24f44, 0000000000 },
+	{ 0x4f9c9c9c, 0000000000 },
+	{ 0xdc4f4fde, 0000000000 },
+	{ 0xa1cd4f4f, 0000000000 },
+	{ 0xd29d9d9d, 0000000000 },
+	{ 0x4f0f9fd7, 0000000000 },
+	{ 0x000ca000, 0x00000004 },
+	{ 0x000d0012, 0x00000038 },
+	{ 0x0000e8b4, 0x00000004 },
+	{ 0x000d0014, 0x00000038 },
+	{ 0x0000e8b6, 0x00000004 },
+	{ 0x000d0016, 0x00000038 },
+	{ 0x0000e854, 0x00000004 },
+	{ 0x000d0018, 0x00000038 },
+	{ 0x0000e855, 0x00000004 },
+	{ 0x000d001a, 0x00000038 },
+	{ 0x0000e856, 0x00000004 },
+	{ 0x000d001c, 0x00000038 },
+	{ 0x0000e857, 0x00000004 },
+	{ 0x000d001e, 0x00000038 },
+	{ 0x0000e824, 0x00000004 },
+	{ 0x000d0020, 0x00000038 },
+	{ 0x0000e825, 0x00000004 },
+	{ 0x000d0022, 0x00000038 },
+	{ 0x0000e830, 0x00000004 },
+	{ 0x000d0024, 0x00000038 },
+	{ 0x0000f0c0, 0x00000004 },
+	{ 0x000d0026, 0x00000038 },
+	{ 0x0000f0c1, 0x00000004 },
+	{ 0x000d0028, 0x00000038 },
+	{ 0x0000f041, 0x00000004 },
+	{ 0x000d002a, 0x00000038 },
+	{ 0x0000f184, 0x00000004 },
+	{ 0x000d002c, 0x00000038 },
+	{ 0x0000f185, 0x00000004 },
+	{ 0x000d002e, 0x00000038 },
+	{ 0x0000f186, 0x00000004 },
+	{ 0x000d0030, 0x00000038 },
+	{ 0x0000f187, 0x00000004 },
+	{ 0x000d0032, 0x00000038 },
+	{ 0x0000f180, 0x00000004 },
+	{ 0x000d0034, 0x00000038 },
+	{ 0x0000f393, 0x00000004 },
+	{ 0x000d0036, 0x00000038 },
+	{ 0x0000f38a, 0x00000004 },
+	{ 0x000d0038, 0x00000038 },
+	{ 0x0000f38e, 0x00000004 },
+	{ 0x0000e821, 0x00000004 },
+	{ 0x0140a000, 0x00000004 },
+	{ 0x00000043, 0x00000018 },
+	{ 0x00cce800, 0x00000004 },
+	{ 0x001b0001, 0x00000004 },
+	{ 0x08004800, 0x00000004 },
+	{ 0x001b0001, 0x00000004 },
+	{ 0x08004800, 0x00000004 },
+	{ 0x001b0001, 0x00000004 },
+	{ 0x08004800, 0x00000004 },
+	{ 0x0000003a, 0x00000008 },
+	{ 0x0000a000, 0000000000 },
+	{ 0x02c0a000, 0x00000004 },
+	{ 0x000ca000, 0x00000004 },
+	{ 0x00130000, 0x00000004 },
+	{ 0x000c2000, 0x00000004 },
+	{ 0xc980c045, 0x00000008 },
+	{ 0x2000451d, 0x00000004 },
+	{ 0x0000e580, 0x00000004 },
+	{ 0x000ce581, 0x00000004 },
+	{ 0x08004580, 0x00000004 },
+	{ 0x000ce581, 0x00000004 },
+	{ 0x0000004c, 0x00000008 },
+	{ 0x0000a000, 0000000000 },
+	{ 0x000c2000, 0x00000004 },
+	{ 0x0000e50e, 0x00000004 },
+	{ 0x00032000, 0x00000004 },
+	{ 0x00022056, 0x00000028 },
+	{ 0x00000056, 0x00000024 },
+	{ 0x0800450f, 0x00000004 },
+	{ 0x0000a050, 0x00000008 },
+	{ 0x0000e565, 0x00000004 },
+	{ 0x0000e566, 0x00000004 },
+	{ 0x00000057, 0x00000008 },
+	{ 0x03cca5b4, 0x00000004 },
+	{ 0x05432000, 0x00000004 },
+	{ 0x00022000, 0x00000004 },
+	{ 0x4ccce063, 0x00000030 },
+	{ 0x08274565, 0x00000004 },
+	{ 0x00000063, 0x00000030 },
+	{ 0x08004564, 0x00000004 },
+	{ 0x0000e566, 0x00000004 },
+	{ 0x0000005a, 0x00000008 },
+	{ 0x00802066, 0x00000010 },
+	{ 0x00202000, 0x00000004 },
+	{ 0x001b00ff, 0x00000004 },
+	{ 0x01000069, 0x00000010 },
+	{ 0x001f2000, 0x00000004 },
+	{ 0x001c00ff, 0x00000004 },
+	{ 0000000000, 0x0000000c },
+	{ 0x00000085, 0x00000030 },
+	{ 0x0000005a, 0x00000008 },
+	{ 0x0000e576, 0x00000004 },
+	{ 0x000ca000, 0x00000004 },
+	{ 0x00012000, 0x00000004 },
+	{ 0x00082000, 0x00000004 },
+	{ 0x1800650e, 0x00000004 },
+	{ 0x00092000, 0x00000004 },
+	{ 0x000a2000, 0x00000004 },
+	{ 0x000f0000, 0x00000004 },
+	{ 0x00400000, 0x00000004 },
+	{ 0x00000079, 0x00000018 },
+	{ 0x0000e563, 0x00000004 },
+	{ 0x00c0e5f9, 0x000000c2 },
+	{ 0x0000006e, 0x00000008 },
+	{ 0x0000a06e, 0x00000008 },
+	{ 0x0000e576, 0x00000004 },
+	{ 0x0000e577, 0x00000004 },
+	{ 0x0000e50e, 0x00000004 },
+	{ 0x0000e50f, 0x00000004 },
+	{ 0x0140a000, 0x00000004 },
+	{ 0x0000007c, 0x00000018 },
+	{ 0x00c0e5f9, 0x000000c2 },
+	{ 0x0000007c, 0x00000008 },
+	{ 0x0014e50e, 0x00000004 },
+	{ 0x0040e50f, 0x00000004 },
+	{ 0x00c0007f, 0x00000008 },
+	{ 0x0000e570, 0x00000004 },
+	{ 0x0000e571, 0x00000004 },
+	{ 0x0000e572, 0x0000000c },
+	{ 0x0000a000, 0x00000004 },
+	{ 0x0140a000, 0x00000004 }, 
+	{ 0x0000e568, 0x00000004 },
+	{ 0x000c2000, 0x00000004 },
+	{ 0x00000089, 0x00000018 },
+	{ 0x000b0000, 0x00000004 },
+	{ 0x18c0e562, 0x00000004 },
+	{ 0x0000008b, 0x00000008 },
+	{ 0x00c0008a, 0x00000008 },
+	{ 0x000700e4, 0x00000004 },
+	{ 0x00000097, 0x00000038 },
+	{ 0x000ca099, 0x00000030 },
+	{ 0x080045bb, 0x00000004 },
+	{ 0x000c209a, 0x00000030 },
+	{ 0x0800e5bc, 0000000000 },
+	{ 0x0000e5bb, 0x00000004 },
+	{ 0x0000e5bc, 0000000000 },
+	{ 0x00120000, 0x0000000c },
+	{ 0x00120000, 0x00000004 },
+	{ 0x001b0002, 0x0000000c },
+	{ 0x0000a000, 0x00000004 },
+	{ 0x0000e821, 0x00000004 },
+	{ 0x0000e800, 0000000000 },
+	{ 0x0000e821, 0x00000004 },
+	{ 0x0000e82e, 0000000000 },
+	{ 0x02cca000, 0x00000004 },
+	{ 0x00140000, 0x00000004 },
+	{ 0x000ce1cc, 0x00000004 },
+	{ 0x050de1cd, 0x00000004 },
+	{ 0x000000a7, 0x00000020 },
+	{ 0x4200e000, 0000000000 },
+	{ 0x000000ae, 0x00000038 },
+	{ 0x000ca000, 0x00000004 },
+	{ 0x00140000, 0x00000004 },
+	{ 0x000c2000, 0x00000004 },
+	{ 0x00160000, 0x00000004 },
+	{ 0x700ce000, 0x00000004 },
+	{ 0x001400aa, 0x00000008 },
+	{ 0x4000e000, 0000000000 },
+	{ 0x02400000, 0x00000004 },
+	{ 0x400ee000, 0x00000004 },
+	{ 0x02400000, 0x00000004 },
+	{ 0x4000e000, 0000000000 },
+	{ 0x000c2000, 0x00000004 },
+	{ 0x0240e51b, 0x00000004 },
+	{ 0x0080e50a, 0x00000005 },
+	{ 0x0080e50b, 0x00000005 },
+	{ 0x00220000, 0x00000004 },
+	{ 0x000700e4, 0x00000004 },
+	{ 0x000000c1, 0x00000038 },
+	{ 0x000c209a, 0x00000030 },
+	{ 0x0880e5bd, 0x00000005 },
+	{ 0x000c2099, 0x00000030 },
+	{ 0x0800e5bb, 0x00000005 },
+	{ 0x000c209a, 0x00000030 },
+	{ 0x0880e5bc, 0x00000005 },
+	{ 0x000000c4, 0x00000008 },
+	{ 0x0080e5bd, 0x00000005 },
+	{ 0x0000e5bb, 0x00000005 },
+	{ 0x0080e5bc, 0x00000005 },
+	{ 0x00210000, 0x00000004 },
+	{ 0x02800000, 0x00000004 },
+	{ 0x00c000c8, 0x00000018 },
+	{ 0x4180e000, 0x00000040 },
+	{ 0x000000ca, 0x00000024 },
+	{ 0x01000000, 0x0000000c },
+	{ 0x0100e51d, 0x0000000c },
+	{ 0x000045bb, 0x00000004 },
+	{ 0x000080c4, 0x00000008 },
+	{ 0x0000f3ce, 0x00000004 },
+	{ 0x0140a000, 0x00000004 },
+	{ 0x00cc2000, 0x00000004 },
+	{ 0x08c053cf, 0x00000040 },
+	{ 0x00008000, 0000000000 },
+	{ 0x0000f3d2, 0x00000004 },
+	{ 0x0140a000, 0x00000004 },
+	{ 0x00cc2000, 0x00000004 },
+	{ 0x08c053d3, 0x00000040 },
+	{ 0x00008000, 0000000000 },
+	{ 0x0000f39d, 0x00000004 },
+	{ 0x0140a000, 0x00000004 },
+	{ 0x00cc2000, 0x00000004 },
+	{ 0x08c0539e, 0x00000040 },
+	{ 0x00008000, 0000000000 },
+	{ 0x03c00830, 0x00000004 },
+	{ 0x4200e000, 0000000000 },
+	{ 0x0000a000, 0x00000004 },
+	{ 0x200045e0, 0x00000004 },
+	{ 0x0000e5e1, 0000000000 },
+	{ 0x00000001, 0000000000 },
+	{ 0x000700e1, 0x00000004 },
+	{ 0x0800e394, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+};
+
+static int RADEON_READ_PLL(struct drm_device * dev, int addr)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+
+	RADEON_WRITE8(RADEON_CLOCK_CNTL_INDEX, addr & 0x1f);
+	return RADEON_READ(RADEON_CLOCK_CNTL_DATA);
+}
+
+static u32 RADEON_READ_PCIE(drm_radeon_private_t *dev_priv, int addr)
+{
+	RADEON_WRITE8(RADEON_PCIE_INDEX, addr & 0xff);
+	return RADEON_READ(RADEON_PCIE_DATA);
+}
+
+static u32 RADEON_READ_IGPGART(drm_radeon_private_t *dev_priv, int addr)
+{
+	u32 ret;
+	RADEON_WRITE(RADEON_IGPGART_INDEX, addr & 0x7f);
+	ret = RADEON_READ(RADEON_IGPGART_DATA);
+	RADEON_WRITE(RADEON_IGPGART_INDEX, 0x7f);
+	return ret;
+}
+
+#if RADEON_FIFO_DEBUG
+static void radeon_status(drm_radeon_private_t * dev_priv)
+{
+	printk("%s:\n", __FUNCTION__);
+	printk("RBBM_STATUS = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_RBBM_STATUS));
+	printk("CP_RB_RTPR = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_CP_RB_RPTR));
+	printk("CP_RB_WTPR = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_CP_RB_WPTR));
+	printk("AIC_CNTL = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_AIC_CNTL));
+	printk("AIC_STAT = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_AIC_STAT));
+	printk("AIC_PT_BASE = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_AIC_PT_BASE));
+	printk("TLB_ADDR = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_AIC_TLB_ADDR));
+	printk("TLB_DATA = 0x%08x\n",
+	       (unsigned int)RADEON_READ(RADEON_AIC_TLB_DATA));
+}
+#endif
+
+/* ================================================================
+ * Engine, FIFO control
+ */
+
+static int radeon_do_pixcache_flush(drm_radeon_private_t * dev_priv)
+{
+	u32 tmp;
+	int i;
+
+	dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
+
+	tmp = RADEON_READ(RADEON_RB3D_DSTCACHE_CTLSTAT);
+	tmp |= RADEON_RB3D_DC_FLUSH_ALL;
+	RADEON_WRITE(RADEON_RB3D_DSTCACHE_CTLSTAT, tmp);
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (!(RADEON_READ(RADEON_RB3D_DSTCACHE_CTLSTAT)
+		      & RADEON_RB3D_DC_BUSY)) {
+			return 0;
+		}
+		DRM_UDELAY(1);
+	}
+
+#if RADEON_FIFO_DEBUG
+	DRM_ERROR("failed!\n");
+	radeon_status(dev_priv);
+#endif
+	return -EBUSY;
+}
+
+static int radeon_do_wait_for_fifo(drm_radeon_private_t * dev_priv, int entries)
+{
+	int i;
+
+	dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		int slots = (RADEON_READ(RADEON_RBBM_STATUS)
+			     & RADEON_RBBM_FIFOCNT_MASK);
+		if (slots >= entries)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if RADEON_FIFO_DEBUG
+	DRM_ERROR("failed!\n");
+	radeon_status(dev_priv);
+#endif
+	return -EBUSY;
+}
+
+static int radeon_do_wait_for_idle(drm_radeon_private_t * dev_priv)
+{
+	int i, ret;
+
+	dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
+
+	ret = radeon_do_wait_for_fifo(dev_priv, 64);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		if (!(RADEON_READ(RADEON_RBBM_STATUS)
+		      & RADEON_RBBM_ACTIVE)) {
+			radeon_do_pixcache_flush(dev_priv);
+			return 0;
+		}
+		DRM_UDELAY(1);
+	}
+
+#if RADEON_FIFO_DEBUG
+	DRM_ERROR("failed!\n");
+	radeon_status(dev_priv);
+#endif
+	return -EBUSY;
+}
+
+/* ================================================================
+ * CP control, initialization
+ */
+
+/* Load the microcode for the CP */
+static void radeon_cp_load_microcode(drm_radeon_private_t * dev_priv)
+{
+	int i;
+	DRM_DEBUG("\n");
+
+	radeon_do_wait_for_idle(dev_priv);
+
+	RADEON_WRITE(RADEON_CP_ME_RAM_ADDR, 0);
+
+	if (dev_priv->microcode_version == UCODE_R200) {
+		DRM_INFO("Loading R200 Microcode\n");
+		for (i = 0; i < 256; i++) {
+			RADEON_WRITE(RADEON_CP_ME_RAM_DATAH,
+				     R200_cp_microcode[i][1]);
+			RADEON_WRITE(RADEON_CP_ME_RAM_DATAL,
+				     R200_cp_microcode[i][0]);
+		}
+	} else if (dev_priv->microcode_version == UCODE_R300) {
+		DRM_INFO("Loading R300 Microcode\n");
+		for (i = 0; i < 256; i++) {
+			RADEON_WRITE(RADEON_CP_ME_RAM_DATAH,
+				     R300_cp_microcode[i][1]);
+			RADEON_WRITE(RADEON_CP_ME_RAM_DATAL,
+				     R300_cp_microcode[i][0]);
+		}
+	} else {
+		for (i = 0; i < 256; i++) {
+			RADEON_WRITE(RADEON_CP_ME_RAM_DATAH,
+				     radeon_cp_microcode[i][1]);
+			RADEON_WRITE(RADEON_CP_ME_RAM_DATAL,
+				     radeon_cp_microcode[i][0]);
+		}
+	}
+}
+
+/* Flush any pending commands to the CP.  This should only be used just
+ * prior to a wait for idle, as it informs the engine that the command
+ * stream is ending.
+ */
+static void radeon_do_cp_flush(drm_radeon_private_t * dev_priv)
+{
+	DRM_DEBUG("\n");
+#if 0
+	u32 tmp;
+
+	tmp = RADEON_READ(RADEON_CP_RB_WPTR) | (1 << 31);
+	RADEON_WRITE(RADEON_CP_RB_WPTR, tmp);
+#endif
+}
+
+/* Wait for the CP to go idle.
+ */
+int radeon_do_cp_idle(drm_radeon_private_t * dev_priv)
+{
+	RING_LOCALS;
+	DRM_DEBUG("\n");
+
+	BEGIN_RING(6);
+
+	RADEON_PURGE_CACHE();
+	RADEON_PURGE_ZCACHE();
+	RADEON_WAIT_UNTIL_IDLE();
+
+	ADVANCE_RING();
+	COMMIT_RING();
+
+	return radeon_do_wait_for_idle(dev_priv);
+}
+
+/* Start the Command Processor.
+ */
+static void radeon_do_cp_start(drm_radeon_private_t * dev_priv)
+{
+	RING_LOCALS;
+	DRM_DEBUG("\n");
+
+	radeon_do_wait_for_idle(dev_priv);
+
+	RADEON_WRITE(RADEON_CP_CSQ_CNTL, dev_priv->cp_mode);
+
+	dev_priv->cp_running = 1;
+
+	BEGIN_RING(6);
+
+	RADEON_PURGE_CACHE();
+	RADEON_PURGE_ZCACHE();
+	RADEON_WAIT_UNTIL_IDLE();
+
+	ADVANCE_RING();
+	COMMIT_RING();
+}
+
+/* Reset the Command Processor.  This will not flush any pending
+ * commands, so you must wait for the CP command stream to complete
+ * before calling this routine.
+ */
+static void radeon_do_cp_reset(drm_radeon_private_t * dev_priv)
+{
+	u32 cur_read_ptr;
+	DRM_DEBUG("\n");
+
+	cur_read_ptr = RADEON_READ(RADEON_CP_RB_RPTR);
+	RADEON_WRITE(RADEON_CP_RB_WPTR, cur_read_ptr);
+	SET_RING_HEAD(dev_priv, cur_read_ptr);
+	dev_priv->ring.tail = cur_read_ptr;
+}
+
+/* Stop the Command Processor.  This will not flush any pending
+ * commands, so you must flush the command stream and wait for the CP
+ * to go idle before calling this routine.
+ */
+static void radeon_do_cp_stop(drm_radeon_private_t * dev_priv)
+{
+	DRM_DEBUG("\n");
+
+	RADEON_WRITE(RADEON_CP_CSQ_CNTL, RADEON_CSQ_PRIDIS_INDDIS);
+
+	dev_priv->cp_running = 0;
+}
+
+/* Reset the engine.  This will stop the CP if it is running.
+ */
+static int radeon_do_engine_reset(struct drm_device * dev)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	u32 clock_cntl_index, mclk_cntl, rbbm_soft_reset;
+	DRM_DEBUG("\n");
+
+	radeon_do_pixcache_flush(dev_priv);
+
+	clock_cntl_index = RADEON_READ(RADEON_CLOCK_CNTL_INDEX);
+	mclk_cntl = RADEON_READ_PLL(dev, RADEON_MCLK_CNTL);
+
+	RADEON_WRITE_PLL(RADEON_MCLK_CNTL, (mclk_cntl |
+					    RADEON_FORCEON_MCLKA |
+					    RADEON_FORCEON_MCLKB |
+					    RADEON_FORCEON_YCLKA |
+					    RADEON_FORCEON_YCLKB |
+					    RADEON_FORCEON_MC |
+					    RADEON_FORCEON_AIC));
+
+	rbbm_soft_reset = RADEON_READ(RADEON_RBBM_SOFT_RESET);
+
+	RADEON_WRITE(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |
+					      RADEON_SOFT_RESET_CP |
+					      RADEON_SOFT_RESET_HI |
+					      RADEON_SOFT_RESET_SE |
+					      RADEON_SOFT_RESET_RE |
+					      RADEON_SOFT_RESET_PP |
+					      RADEON_SOFT_RESET_E2 |
+					      RADEON_SOFT_RESET_RB));
+	RADEON_READ(RADEON_RBBM_SOFT_RESET);
+	RADEON_WRITE(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset &
+					      ~(RADEON_SOFT_RESET_CP |
+						RADEON_SOFT_RESET_HI |
+						RADEON_SOFT_RESET_SE |
+						RADEON_SOFT_RESET_RE |
+						RADEON_SOFT_RESET_PP |
+						RADEON_SOFT_RESET_E2 |
+						RADEON_SOFT_RESET_RB)));
+	RADEON_READ(RADEON_RBBM_SOFT_RESET);
+
+	RADEON_WRITE_PLL(RADEON_MCLK_CNTL, mclk_cntl);
+	RADEON_WRITE(RADEON_CLOCK_CNTL_INDEX, clock_cntl_index);
+	RADEON_WRITE(RADEON_RBBM_SOFT_RESET, rbbm_soft_reset);
+
+	/* Reset the CP ring */
+	radeon_do_cp_reset(dev_priv);
+
+	/* The CP is no longer running after an engine reset */
+	dev_priv->cp_running = 0;
+
+	/* Reset any pending vertex, indirect buffers */
+	radeon_freelist_reset(dev);
+
+	return 0;
+}
+
+static void radeon_cp_init_ring_buffer(struct drm_device * dev,
+				       drm_radeon_private_t * dev_priv)
+{
+	u32 ring_start, cur_read_ptr;
+	u32 tmp;
+	
+	/* Initialize the memory controller. With new memory map, the fb location
+	 * is not changed, it should have been properly initialized already. Part
+	 * of the problem is that the code below is bogus, assuming the GART is
+	 * always appended to the fb which is not necessarily the case
+	 */
+	if (!dev_priv->new_memmap)
+		RADEON_WRITE(RADEON_MC_FB_LOCATION,
+			     ((dev_priv->gart_vm_start - 1) & 0xffff0000)
+			     | (dev_priv->fb_location >> 16));
+
+#if __OS_HAS_AGP
+	if (dev_priv->flags & RADEON_IS_AGP) {
+		RADEON_WRITE(RADEON_AGP_BASE, (unsigned int)dev->agp->base);
+		RADEON_WRITE(RADEON_MC_AGP_LOCATION,
+			     (((dev_priv->gart_vm_start - 1 +
+				dev_priv->gart_size) & 0xffff0000) |
+			      (dev_priv->gart_vm_start >> 16)));
+
+		ring_start = (dev_priv->cp_ring->offset
+			      - dev->agp->base
+			      + dev_priv->gart_vm_start);
+	} else
+#endif
+		ring_start = (dev_priv->cp_ring->offset
+			      - (unsigned long)dev->sg->virtual
+			      + dev_priv->gart_vm_start);
+
+	RADEON_WRITE(RADEON_CP_RB_BASE, ring_start);
+
+	/* Set the write pointer delay */
+	RADEON_WRITE(RADEON_CP_RB_WPTR_DELAY, 0);
+
+	/* Initialize the ring buffer's read and write pointers */
+	cur_read_ptr = RADEON_READ(RADEON_CP_RB_RPTR);
+	RADEON_WRITE(RADEON_CP_RB_WPTR, cur_read_ptr);
+	SET_RING_HEAD(dev_priv, cur_read_ptr);
+	dev_priv->ring.tail = cur_read_ptr;
+
+#if __OS_HAS_AGP
+	if (dev_priv->flags & RADEON_IS_AGP) {
+		RADEON_WRITE(RADEON_CP_RB_RPTR_ADDR,
+			     dev_priv->ring_rptr->offset
+			     - dev->agp->base + dev_priv->gart_vm_start);
+	} else
+#endif
+	{
+		struct drm_sg_mem *entry = dev->sg;
+		unsigned long tmp_ofs, page_ofs;
+
+		tmp_ofs = dev_priv->ring_rptr->offset -
+				(unsigned long)dev->sg->virtual;
+		page_ofs = tmp_ofs >> PAGE_SHIFT;
+
+		RADEON_WRITE(RADEON_CP_RB_RPTR_ADDR, entry->busaddr[page_ofs]);
+		DRM_DEBUG("ring rptr: offset=0x%08lx handle=0x%08lx\n",
+			  (unsigned long)entry->busaddr[page_ofs],
+			  entry->handle + tmp_ofs);
+	}
+
+	/* Set ring buffer size */
+#ifdef __BIG_ENDIAN
+	RADEON_WRITE(RADEON_CP_RB_CNTL,
+		     RADEON_BUF_SWAP_32BIT |
+		     (dev_priv->ring.fetch_size_l2ow << 18) |
+		     (dev_priv->ring.rptr_update_l2qw << 8) |
+		     dev_priv->ring.size_l2qw);
+#else
+	RADEON_WRITE(RADEON_CP_RB_CNTL,
+		     (dev_priv->ring.fetch_size_l2ow << 18) |
+		     (dev_priv->ring.rptr_update_l2qw << 8) |
+		     dev_priv->ring.size_l2qw);
+#endif
+
+	/* Start with assuming that writeback doesn't work */
+	dev_priv->writeback_works = 0;
+
+	/* Initialize the scratch register pointer.  This will cause
+	 * the scratch register values to be written out to memory
+	 * whenever they are updated.
+	 *
+	 * We simply put this behind the ring read pointer, this works
+	 * with PCI GART as well as (whatever kind of) AGP GART
+	 */
+	RADEON_WRITE(RADEON_SCRATCH_ADDR, RADEON_READ(RADEON_CP_RB_RPTR_ADDR)
+		     + RADEON_SCRATCH_REG_OFFSET);
+
+	dev_priv->scratch = ((__volatile__ u32 *)
+			     dev_priv->ring_rptr->handle +
+			     (RADEON_SCRATCH_REG_OFFSET / sizeof(u32)));
+
+	RADEON_WRITE(RADEON_SCRATCH_UMSK, 0x7);
+
+	/* Turn on bus mastering */
+	tmp = RADEON_READ(RADEON_BUS_CNTL) & ~RADEON_BUS_MASTER_DIS;
+	RADEON_WRITE(RADEON_BUS_CNTL, tmp);
+
+	dev_priv->sarea_priv->last_frame = dev_priv->scratch[0] = 0;
+	RADEON_WRITE(RADEON_LAST_FRAME_REG, dev_priv->sarea_priv->last_frame);
+
+	dev_priv->sarea_priv->last_dispatch = dev_priv->scratch[1] = 0;
+	RADEON_WRITE(RADEON_LAST_DISPATCH_REG,
+		     dev_priv->sarea_priv->last_dispatch);
+
+	dev_priv->sarea_priv->last_clear = dev_priv->scratch[2] = 0;
+	RADEON_WRITE(RADEON_LAST_CLEAR_REG, dev_priv->sarea_priv->last_clear);
+
+	radeon_do_wait_for_idle(dev_priv);
+
+	/* Sync everything up */
+	RADEON_WRITE(RADEON_ISYNC_CNTL,
+		     (RADEON_ISYNC_ANY2D_IDLE3D |
+		      RADEON_ISYNC_ANY3D_IDLE2D |
+		      RADEON_ISYNC_WAIT_IDLEGUI |
+		      RADEON_ISYNC_CPSCRATCH_IDLEGUI));
+
+}
+
+static void radeon_test_writeback(drm_radeon_private_t * dev_priv)
+{
+	u32 tmp;
+
+	/* Writeback doesn't seem to work everywhere, test it here and possibly
+	 * enable it if it appears to work
+	 */
+	DRM_WRITE32(dev_priv->ring_rptr, RADEON_SCRATCHOFF(1), 0);
+	RADEON_WRITE(RADEON_SCRATCH_REG1, 0xdeadbeef);
+
+	for (tmp = 0; tmp < dev_priv->usec_timeout; tmp++) {
+		if (DRM_READ32(dev_priv->ring_rptr, RADEON_SCRATCHOFF(1)) ==
+		    0xdeadbeef)
+			break;
+		DRM_UDELAY(1);
+	}
+
+	if (tmp < dev_priv->usec_timeout) {
+		dev_priv->writeback_works = 1;
+		DRM_INFO("writeback test succeeded in %d usecs\n", tmp);
+	} else {
+		dev_priv->writeback_works = 0;
+		DRM_INFO("writeback test failed\n");
+	}
+	if (radeon_no_wb == 1) {
+		dev_priv->writeback_works = 0;
+		DRM_INFO("writeback forced off\n");
+	}
+
+	if (!dev_priv->writeback_works) {
+		/* Disable writeback to avoid unnecessary bus master transfers */
+		RADEON_WRITE(RADEON_CP_RB_CNTL, RADEON_READ(RADEON_CP_RB_CNTL) | RADEON_RB_NO_UPDATE);
+		RADEON_WRITE(RADEON_SCRATCH_UMSK, 0);
+	}
+}
+
+/* Enable or disable IGP GART on the chip */
+static void radeon_set_igpgart(drm_radeon_private_t * dev_priv, int on)
+{
+	u32 temp, tmp;
+
+	tmp = RADEON_READ(RADEON_AIC_CNTL);
+	DRM_DEBUG("setting igpgart AIC CNTL is %08X\n", tmp);
+	if (on) {
+		DRM_DEBUG("programming igpgart %08X %08lX %08X\n",
+			 dev_priv->gart_vm_start,
+			 (long)dev_priv->gart_info.bus_addr,
+			 dev_priv->gart_size);
+
+		RADEON_WRITE_IGPGART(RADEON_IGPGART_UNK_18, 0x1000);
+		RADEON_WRITE_IGPGART(RADEON_IGPGART_ENABLE, 0x1);
+		RADEON_WRITE_IGPGART(RADEON_IGPGART_CTRL, 0x42040800);
+		RADEON_WRITE_IGPGART(RADEON_IGPGART_BASE_ADDR,
+				     dev_priv->gart_info.bus_addr);
+
+		temp = RADEON_READ_IGPGART(dev_priv, RADEON_IGPGART_UNK_39);
+		RADEON_WRITE_IGPGART(RADEON_IGPGART_UNK_39, temp);
+
+		RADEON_WRITE(RADEON_AGP_BASE, (unsigned int)dev_priv->gart_vm_start);
+		dev_priv->gart_size = 32*1024*1024;
+		RADEON_WRITE(RADEON_MC_AGP_LOCATION,
+			     (((dev_priv->gart_vm_start - 1 +
+			       dev_priv->gart_size) & 0xffff0000) |
+			     (dev_priv->gart_vm_start >> 16)));
+
+		temp = RADEON_READ_IGPGART(dev_priv, RADEON_IGPGART_ENABLE);
+		RADEON_WRITE_IGPGART(RADEON_IGPGART_ENABLE, temp);
+
+		RADEON_READ_IGPGART(dev_priv, RADEON_IGPGART_FLUSH);
+		RADEON_WRITE_IGPGART(RADEON_IGPGART_FLUSH, 0x1);
+		RADEON_READ_IGPGART(dev_priv, RADEON_IGPGART_FLUSH);
+		RADEON_WRITE_IGPGART(RADEON_IGPGART_FLUSH, 0x0);
+       }
+}
+
+static void radeon_set_pciegart(drm_radeon_private_t * dev_priv, int on)
+{
+	u32 tmp = RADEON_READ_PCIE(dev_priv, RADEON_PCIE_TX_GART_CNTL);
+	if (on) {
+
+		DRM_DEBUG("programming pcie %08X %08lX %08X\n",
+			  dev_priv->gart_vm_start,
+			  (long)dev_priv->gart_info.bus_addr,
+			  dev_priv->gart_size);
+		RADEON_WRITE_PCIE(RADEON_PCIE_TX_DISCARD_RD_ADDR_LO,
+				  dev_priv->gart_vm_start);
+		RADEON_WRITE_PCIE(RADEON_PCIE_TX_GART_BASE,
+				  dev_priv->gart_info.bus_addr);
+		RADEON_WRITE_PCIE(RADEON_PCIE_TX_GART_START_LO,
+				  dev_priv->gart_vm_start);
+		RADEON_WRITE_PCIE(RADEON_PCIE_TX_GART_END_LO,
+				  dev_priv->gart_vm_start +
+				  dev_priv->gart_size - 1);
+
+		RADEON_WRITE(RADEON_MC_AGP_LOCATION, 0xffffffc0);	/* ?? */
+
+		RADEON_WRITE_PCIE(RADEON_PCIE_TX_GART_CNTL,
+				  RADEON_PCIE_TX_GART_EN);
+	} else {
+		RADEON_WRITE_PCIE(RADEON_PCIE_TX_GART_CNTL,
+				  tmp & ~RADEON_PCIE_TX_GART_EN);
+	}
+}
+
+/* Enable or disable PCI GART on the chip */
+static void radeon_set_pcigart(drm_radeon_private_t * dev_priv, int on)
+{
+	u32 tmp;
+
+	if (dev_priv->flags & RADEON_IS_IGPGART) {
+		radeon_set_igpgart(dev_priv, on);
+		return;
+	}
+
+	if (dev_priv->flags & RADEON_IS_PCIE) {
+		radeon_set_pciegart(dev_priv, on);
+		return;
+	}
+
+ 	tmp = RADEON_READ(RADEON_AIC_CNTL);
+
+	if (on) {
+		RADEON_WRITE(RADEON_AIC_CNTL,
+			     tmp | RADEON_PCIGART_TRANSLATE_EN);
+
+		/* set PCI GART page-table base address
+		 */
+		RADEON_WRITE(RADEON_AIC_PT_BASE, dev_priv->gart_info.bus_addr);
+
+		/* set address range for PCI address translate
+		 */
+		RADEON_WRITE(RADEON_AIC_LO_ADDR, dev_priv->gart_vm_start);
+		RADEON_WRITE(RADEON_AIC_HI_ADDR, dev_priv->gart_vm_start
+			     + dev_priv->gart_size - 1);
+
+		/* Turn off AGP aperture -- is this required for PCI GART?
+		 */
+		RADEON_WRITE(RADEON_MC_AGP_LOCATION, 0xffffffc0);	/* ?? */
+		RADEON_WRITE(RADEON_AGP_COMMAND, 0);	/* clear AGP_COMMAND */
+	} else {
+		RADEON_WRITE(RADEON_AIC_CNTL,
+			     tmp & ~RADEON_PCIGART_TRANSLATE_EN);
+	}
+}
+
+static int radeon_do_init_cp(struct drm_device * dev, drm_radeon_init_t * init)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("\n");
+
+	/* if we require new memory map but we don't have it fail */
+	if ((dev_priv->flags & RADEON_NEW_MEMMAP) && !dev_priv->new_memmap) {
+		DRM_ERROR("Cannot initialise DRM on this card\nThis card requires a new X.org DDX for 3D\n");
+		radeon_do_cleanup_cp(dev);
+		return -EINVAL;
+	}
+
+	if (init->is_pci && (dev_priv->flags & RADEON_IS_AGP))
+	{
+		DRM_DEBUG("Forcing AGP card to PCI mode\n");
+		dev_priv->flags &= ~RADEON_IS_AGP;
+	}
+	else if (!(dev_priv->flags & (RADEON_IS_AGP | RADEON_IS_PCI | RADEON_IS_PCIE))
+		 && !init->is_pci)
+	{
+		DRM_DEBUG("Restoring AGP flag\n");
+		dev_priv->flags |= RADEON_IS_AGP;
+	}
+
+	if ((!(dev_priv->flags & RADEON_IS_AGP)) && !dev->sg) {
+		DRM_ERROR("PCI GART memory not allocated!\n");
+		radeon_do_cleanup_cp(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->usec_timeout = init->usec_timeout;
+	if (dev_priv->usec_timeout < 1 ||
+	    dev_priv->usec_timeout > RADEON_MAX_USEC_TIMEOUT) {
+		DRM_DEBUG("TIMEOUT problem!\n");
+		radeon_do_cleanup_cp(dev);
+		return -EINVAL;
+	}
+
+	/* Enable vblank on CRTC1 for older X servers
+	 */
+	dev_priv->vblank_crtc = DRM_RADEON_VBLANK_CRTC1;
+
+	switch(init->func) {
+	case RADEON_INIT_R200_CP:
+		dev_priv->microcode_version = UCODE_R200;
+		break;
+	case RADEON_INIT_R300_CP:
+		dev_priv->microcode_version = UCODE_R300;
+		break;
+	default:
+		dev_priv->microcode_version = UCODE_R100;
+	}
+
+	dev_priv->do_boxes = 0;
+	dev_priv->cp_mode = init->cp_mode;
+
+	/* We don't support anything other than bus-mastering ring mode,
+	 * but the ring can be in either AGP or PCI space for the ring
+	 * read pointer.
+	 */
+	if ((init->cp_mode != RADEON_CSQ_PRIBM_INDDIS) &&
+	    (init->cp_mode != RADEON_CSQ_PRIBM_INDBM)) {
+		DRM_DEBUG("BAD cp_mode (%x)!\n", init->cp_mode);
+		radeon_do_cleanup_cp(dev);
+		return -EINVAL;
+	}
+
+	switch (init->fb_bpp) {
+	case 16:
+		dev_priv->color_fmt = RADEON_COLOR_FORMAT_RGB565;
+		break;
+	case 32:
+	default:
+		dev_priv->color_fmt = RADEON_COLOR_FORMAT_ARGB8888;
+		break;
+	}
+	dev_priv->front_offset = init->front_offset;
+	dev_priv->front_pitch = init->front_pitch;
+	dev_priv->back_offset = init->back_offset;
+	dev_priv->back_pitch = init->back_pitch;
+
+	switch (init->depth_bpp) {
+	case 16:
+		dev_priv->depth_fmt = RADEON_DEPTH_FORMAT_16BIT_INT_Z;
+		break;
+	case 32:
+	default:
+		dev_priv->depth_fmt = RADEON_DEPTH_FORMAT_24BIT_INT_Z;
+		break;
+	}
+	dev_priv->depth_offset = init->depth_offset;
+	dev_priv->depth_pitch = init->depth_pitch;
+
+	/* Hardware state for depth clears.  Remove this if/when we no
+	 * longer clear the depth buffer with a 3D rectangle.  Hard-code
+	 * all values to prevent unwanted 3D state from slipping through
+	 * and screwing with the clear operation.
+	 */
+	dev_priv->depth_clear.rb3d_cntl = (RADEON_PLANE_MASK_ENABLE |
+					   (dev_priv->color_fmt << 10) |
+					   (dev_priv->microcode_version ==
+					    UCODE_R100 ? RADEON_ZBLOCK16 : 0));
+
+	dev_priv->depth_clear.rb3d_zstencilcntl =
+	    (dev_priv->depth_fmt |
+	     RADEON_Z_TEST_ALWAYS |
+	     RADEON_STENCIL_TEST_ALWAYS |
+	     RADEON_STENCIL_S_FAIL_REPLACE |
+	     RADEON_STENCIL_ZPASS_REPLACE |
+	     RADEON_STENCIL_ZFAIL_REPLACE | RADEON_Z_WRITE_ENABLE);
+
+	dev_priv->depth_clear.se_cntl = (RADEON_FFACE_CULL_CW |
+					 RADEON_BFACE_SOLID |
+					 RADEON_FFACE_SOLID |
+					 RADEON_FLAT_SHADE_VTX_LAST |
+					 RADEON_DIFFUSE_SHADE_FLAT |
+					 RADEON_ALPHA_SHADE_FLAT |
+					 RADEON_SPECULAR_SHADE_FLAT |
+					 RADEON_FOG_SHADE_FLAT |
+					 RADEON_VTX_PIX_CENTER_OGL |
+					 RADEON_ROUND_MODE_TRUNC |
+					 RADEON_ROUND_PREC_8TH_PIX);
+
+
+	dev_priv->ring_offset = init->ring_offset;
+	dev_priv->ring_rptr_offset = init->ring_rptr_offset;
+	dev_priv->buffers_offset = init->buffers_offset;
+	dev_priv->gart_textures_offset = init->gart_textures_offset;
+
+	dev_priv->sarea = drm_getsarea(dev);
+	if (!dev_priv->sarea) {
+		DRM_ERROR("could not find sarea!\n");
+		radeon_do_cleanup_cp(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->cp_ring = drm_core_findmap(dev, init->ring_offset);
+	if (!dev_priv->cp_ring) {
+		DRM_ERROR("could not find cp ring region!\n");
+		radeon_do_cleanup_cp(dev);
+		return -EINVAL;
+	}
+	dev_priv->ring_rptr = drm_core_findmap(dev, init->ring_rptr_offset);
+	if (!dev_priv->ring_rptr) {
+		DRM_ERROR("could not find ring read pointer!\n");
+		radeon_do_cleanup_cp(dev);
+		return -EINVAL;
+	}
+	dev->agp_buffer_token = init->buffers_offset;
+	dev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);
+	if (!dev->agp_buffer_map) {
+		DRM_ERROR("could not find dma buffer region!\n");
+		radeon_do_cleanup_cp(dev);
+		return -EINVAL;
+	}
+
+	if (init->gart_textures_offset) {
+		dev_priv->gart_textures =
+		    drm_core_findmap(dev, init->gart_textures_offset);
+		if (!dev_priv->gart_textures) {
+			DRM_ERROR("could not find GART texture region!\n");
+			radeon_do_cleanup_cp(dev);
+			return -EINVAL;
+		}
+	}
+
+	dev_priv->sarea_priv =
+	    (drm_radeon_sarea_t *) ((u8 *) dev_priv->sarea->handle +
+				    init->sarea_priv_offset);
+
+#if __OS_HAS_AGP
+	if (dev_priv->flags & RADEON_IS_AGP) {
+		drm_core_ioremap(dev_priv->cp_ring, dev);
+		drm_core_ioremap(dev_priv->ring_rptr, dev);
+		drm_core_ioremap(dev->agp_buffer_map, dev);
+		if (!dev_priv->cp_ring->handle ||
+		    !dev_priv->ring_rptr->handle ||
+		    !dev->agp_buffer_map->handle) {
+			DRM_ERROR("could not find ioremap agp regions!\n");
+			radeon_do_cleanup_cp(dev);
+			return -EINVAL;
+		}
+	} else
+#endif
+	{
+		dev_priv->cp_ring->handle = (void *)dev_priv->cp_ring->offset;
+		dev_priv->ring_rptr->handle =
+		    (void *)dev_priv->ring_rptr->offset;
+		dev->agp_buffer_map->handle =
+		    (void *)dev->agp_buffer_map->offset;
+
+		DRM_DEBUG("dev_priv->cp_ring->handle %p\n",
+			  dev_priv->cp_ring->handle);
+		DRM_DEBUG("dev_priv->ring_rptr->handle %p\n",
+			  dev_priv->ring_rptr->handle);
+		DRM_DEBUG("dev->agp_buffer_map->handle %p\n",
+			  dev->agp_buffer_map->handle);
+	}
+
+	dev_priv->fb_location = (RADEON_READ(RADEON_MC_FB_LOCATION)
+				 & 0xffff) << 16;
+	dev_priv->fb_size = 
+		((RADEON_READ(RADEON_MC_FB_LOCATION) & 0xffff0000u) + 0x10000)
+		- dev_priv->fb_location;
+
+	dev_priv->front_pitch_offset = (((dev_priv->front_pitch / 64) << 22) |
+					((dev_priv->front_offset
+					  + dev_priv->fb_location) >> 10));
+
+	dev_priv->back_pitch_offset = (((dev_priv->back_pitch / 64) << 22) |
+				       ((dev_priv->back_offset
+					 + dev_priv->fb_location) >> 10));
+
+	dev_priv->depth_pitch_offset = (((dev_priv->depth_pitch / 64) << 22) |
+					((dev_priv->depth_offset
+					  + dev_priv->fb_location) >> 10));
+
+	dev_priv->gart_size = init->gart_size;
+
+	/* New let's set the memory map ... */
+	if (dev_priv->new_memmap) {
+		u32 base = 0;
+
+		DRM_INFO("Setting GART location based on new memory map\n");
+
+		/* If using AGP, try to locate the AGP aperture at the same
+		 * location in the card and on the bus, though we have to
+		 * align it down.
+		 */
+#if __OS_HAS_AGP
+		if (dev_priv->flags & RADEON_IS_AGP) {
+			base = dev->agp->base;
+			/* Check if valid */
+			if ((base + dev_priv->gart_size - 1) >= dev_priv->fb_location &&
+			    base < (dev_priv->fb_location + dev_priv->fb_size - 1)) {
+				DRM_INFO("Can't use AGP base @0x%08lx, won't fit\n",
+					 dev->agp->base);
+				base = 0;
+			}
+		}
+#endif
+		/* If not or if AGP is at 0 (Macs), try to put it elsewhere */
+		if (base == 0) {
+			base = dev_priv->fb_location + dev_priv->fb_size;
+			if (base < dev_priv->fb_location ||
+			    ((base + dev_priv->gart_size) & 0xfffffffful) < base)
+				base = dev_priv->fb_location
+					- dev_priv->gart_size;
+		}		
+		dev_priv->gart_vm_start = base & 0xffc00000u;
+		if (dev_priv->gart_vm_start != base)
+			DRM_INFO("GART aligned down from 0x%08x to 0x%08x\n",
+				 base, dev_priv->gart_vm_start);
+	} else {
+		DRM_INFO("Setting GART location based on old memory map\n");
+		dev_priv->gart_vm_start = dev_priv->fb_location +
+			RADEON_READ(RADEON_CONFIG_APER_SIZE);
+	}
+
+#if __OS_HAS_AGP
+	if (dev_priv->flags & RADEON_IS_AGP)
+		dev_priv->gart_buffers_offset = (dev->agp_buffer_map->offset
+						 - dev->agp->base
+						 + dev_priv->gart_vm_start);
+	else
+#endif
+		dev_priv->gart_buffers_offset = (dev->agp_buffer_map->offset
+					- (unsigned long)dev->sg->virtual
+					+ dev_priv->gart_vm_start);
+
+	DRM_DEBUG("dev_priv->gart_size %d\n", dev_priv->gart_size);
+	DRM_DEBUG("dev_priv->gart_vm_start 0x%x\n", dev_priv->gart_vm_start);
+	DRM_DEBUG("dev_priv->gart_buffers_offset 0x%lx\n",
+		  dev_priv->gart_buffers_offset);
+
+	dev_priv->ring.start = (u32 *) dev_priv->cp_ring->handle;
+	dev_priv->ring.end = ((u32 *) dev_priv->cp_ring->handle
+			      + init->ring_size / sizeof(u32));
+	dev_priv->ring.size = init->ring_size;
+	dev_priv->ring.size_l2qw = drm_order(init->ring_size / 8);
+
+	dev_priv->ring.rptr_update = /* init->rptr_update */ 4096;
+	dev_priv->ring.rptr_update_l2qw = drm_order( /* init->rptr_update */ 4096 / 8);
+
+	dev_priv->ring.fetch_size = /* init->fetch_size */ 32;
+	dev_priv->ring.fetch_size_l2ow = drm_order( /* init->fetch_size */ 32 / 16);
+
+	dev_priv->ring.tail_mask = (dev_priv->ring.size / sizeof(u32)) - 1;
+
+	dev_priv->ring.high_mark = RADEON_RING_HIGH_MARK;
+
+#if __OS_HAS_AGP
+	if (dev_priv->flags & RADEON_IS_AGP) {
+		/* Turn off PCI GART */
+		radeon_set_pcigart(dev_priv, 0);
+	} else
+#endif
+	{
+		/* if we have an offset set from userspace */
+		if (dev_priv->pcigart_offset_set) {
+			dev_priv->gart_info.bus_addr =
+			    dev_priv->pcigart_offset + dev_priv->fb_location;
+			dev_priv->gart_info.mapping.offset =
+			    dev_priv->gart_info.bus_addr;
+			dev_priv->gart_info.mapping.size =
+			    dev_priv->gart_info.table_size;
+
+			drm_core_ioremap(&dev_priv->gart_info.mapping, dev);
+			dev_priv->gart_info.addr =
+			    dev_priv->gart_info.mapping.handle;
+
+			if (dev_priv->flags & RADEON_IS_PCIE)
+				dev_priv->gart_info.gart_reg_if = DRM_ATI_GART_PCIE;
+			else
+				dev_priv->gart_info.gart_reg_if = DRM_ATI_GART_PCI;
+			dev_priv->gart_info.gart_table_location =
+			    DRM_ATI_GART_FB;
+
+			DRM_DEBUG("Setting phys_pci_gart to %p %08lX\n",
+				  dev_priv->gart_info.addr,
+				  dev_priv->pcigart_offset);
+		} else {
+			if (dev_priv->flags & RADEON_IS_IGPGART)
+				dev_priv->gart_info.gart_reg_if = DRM_ATI_GART_IGP;
+			else
+				dev_priv->gart_info.gart_reg_if = DRM_ATI_GART_PCI;
+			dev_priv->gart_info.gart_table_location =
+			    DRM_ATI_GART_MAIN;
+			dev_priv->gart_info.addr = NULL;
+			dev_priv->gart_info.bus_addr = 0;
+			if (dev_priv->flags & RADEON_IS_PCIE) {
+				DRM_ERROR
+				    ("Cannot use PCI Express without GART in FB memory\n");
+				radeon_do_cleanup_cp(dev);
+				return -EINVAL;
+			}
+		}
+
+		if (!drm_ati_pcigart_init(dev, &dev_priv->gart_info)) {
+			DRM_ERROR("failed to init PCI GART!\n");
+			radeon_do_cleanup_cp(dev);
+			return -ENOMEM;
+		}
+
+		/* Turn on PCI GART */
+		radeon_set_pcigart(dev_priv, 1);
+	}
+
+	radeon_cp_load_microcode(dev_priv);
+	radeon_cp_init_ring_buffer(dev, dev_priv);
+
+	dev_priv->last_buf = 0;
+
+	radeon_do_engine_reset(dev);
+	radeon_test_writeback(dev_priv);
+
+	return 0;
+}
+
+static int radeon_do_cleanup_cp(struct drm_device * dev)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("\n");
+
+	/* Make sure interrupts are disabled here because the uninstall ioctl
+	 * may not have been called from userspace and after dev_private
+	 * is freed, it's too late.
+	 */
+	if (dev->irq_enabled)
+		drm_irq_uninstall(dev);
+
+#if __OS_HAS_AGP
+	if (dev_priv->flags & RADEON_IS_AGP) {
+		if (dev_priv->cp_ring != NULL) {
+			drm_core_ioremapfree(dev_priv->cp_ring, dev);
+			dev_priv->cp_ring = NULL;
+		}
+		if (dev_priv->ring_rptr != NULL) {
+			drm_core_ioremapfree(dev_priv->ring_rptr, dev);
+			dev_priv->ring_rptr = NULL;
+		}
+		if (dev->agp_buffer_map != NULL) {
+			drm_core_ioremapfree(dev->agp_buffer_map, dev);
+			dev->agp_buffer_map = NULL;
+		}
+	} else
+#endif
+	{
+
+		if (dev_priv->gart_info.bus_addr) {
+			/* Turn off PCI GART */
+			radeon_set_pcigart(dev_priv, 0);
+			if (!drm_ati_pcigart_cleanup(dev, &dev_priv->gart_info))
+				DRM_ERROR("failed to cleanup PCI GART!\n");
+		}
+
+		if (dev_priv->gart_info.gart_table_location == DRM_ATI_GART_FB)
+		{
+			drm_core_ioremapfree(&dev_priv->gart_info.mapping, dev);
+			dev_priv->gart_info.addr = 0;
+		}
+	}
+	/* only clear to the start of flags */
+	memset(dev_priv, 0, offsetof(drm_radeon_private_t, flags));
+
+	return 0;
+}
+
+/* This code will reinit the Radeon CP hardware after a resume from disc.
+ * AFAIK, it would be very difficult to pickle the state at suspend time, so
+ * here we make sure that all Radeon hardware initialisation is re-done without
+ * affecting running applications.
+ *
+ * Charl P. Botha <http://cpbotha.net>
+ */
+static int radeon_do_resume_cp(struct drm_device * dev)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+
+	if (!dev_priv) {
+		DRM_ERROR("Called with no initialization\n");
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("Starting radeon_do_resume_cp()\n");
+
+#if __OS_HAS_AGP
+	if (dev_priv->flags & RADEON_IS_AGP) {
+		/* Turn off PCI GART */
+		radeon_set_pcigart(dev_priv, 0);
+	} else
+#endif
+	{
+		/* Turn on PCI GART */
+		radeon_set_pcigart(dev_priv, 1);
+	}
+
+	radeon_cp_load_microcode(dev_priv);
+	radeon_cp_init_ring_buffer(dev, dev_priv);
+
+	radeon_do_engine_reset(dev);
+
+	DRM_DEBUG("radeon_do_resume_cp() complete\n");
+
+	return 0;
+}
+
+int radeon_cp_init(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_init_t *init = data;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (init->func == RADEON_INIT_R300_CP)
+		r300_init_reg_flags();
+
+	switch (init->func) {
+	case RADEON_INIT_CP:
+	case RADEON_INIT_R200_CP:
+	case RADEON_INIT_R300_CP:
+		return radeon_do_init_cp(dev, init);
+	case RADEON_CLEANUP_CP:
+		return radeon_do_cleanup_cp(dev);
+	}
+
+	return -EINVAL;
+}
+
+int radeon_cp_start(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (dev_priv->cp_running) {
+		DRM_DEBUG("%s while CP running\n", __FUNCTION__);
+		return 0;
+	}
+	if (dev_priv->cp_mode == RADEON_CSQ_PRIDIS_INDDIS) {
+		DRM_DEBUG("%s called with bogus CP mode (%d)\n",
+			  __FUNCTION__, dev_priv->cp_mode);
+		return 0;
+	}
+
+	radeon_do_cp_start(dev_priv);
+
+	return 0;
+}
+
+/* Stop the CP.  The engine must have been idled before calling this
+ * routine.
+ */
+int radeon_cp_stop(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_cp_stop_t *stop = data;
+	int ret;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv->cp_running)
+		return 0;
+
+	/* Flush any pending CP commands.  This ensures any outstanding
+	 * commands are exectuted by the engine before we turn it off.
+	 */
+	if (stop->flush) {
+		radeon_do_cp_flush(dev_priv);
+	}
+
+	/* If we fail to make the engine go idle, we return an error
+	 * code so that the DRM ioctl wrapper can try again.
+	 */
+	if (stop->idle) {
+		ret = radeon_do_cp_idle(dev_priv);
+		if (ret)
+			return ret;
+	}
+
+	/* Finally, we can turn off the CP.  If the engine isn't idle,
+	 * we will get some dropped triangles as they won't be fully
+	 * rendered before the CP is shut down.
+	 */
+	radeon_do_cp_stop(dev_priv);
+
+	/* Reset the engine */
+	radeon_do_engine_reset(dev);
+
+	return 0;
+}
+
+void radeon_do_release(struct drm_device * dev)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	int i, ret;
+
+	if (dev_priv) {
+		if (dev_priv->cp_running) {
+			/* Stop the cp */
+			while ((ret = radeon_do_cp_idle(dev_priv)) != 0) {
+				DRM_DEBUG("radeon_do_cp_idle %d\n", ret);
+#ifdef __linux__
+				schedule();
+#else
+#if defined(__FreeBSD__) && __FreeBSD_version > 500000
+				msleep(&ret, &dev->dev_lock, PZERO, "rdnrel",
+				       1);
+#else
+				tsleep(&ret, PZERO, "rdnrel", 1);
+#endif
+#endif
+			}
+			radeon_do_cp_stop(dev_priv);
+			radeon_do_engine_reset(dev);
+		}
+
+		/* Disable *all* interrupts */
+		if (dev_priv->mmio)	/* remove this after permanent addmaps */
+			RADEON_WRITE(RADEON_GEN_INT_CNTL, 0);
+
+		if (dev_priv->mmio) {	/* remove all surfaces */
+			for (i = 0; i < RADEON_MAX_SURFACES; i++) {
+				RADEON_WRITE(RADEON_SURFACE0_INFO + 16 * i, 0);
+				RADEON_WRITE(RADEON_SURFACE0_LOWER_BOUND +
+					     16 * i, 0);
+				RADEON_WRITE(RADEON_SURFACE0_UPPER_BOUND +
+					     16 * i, 0);
+			}
+		}
+
+		/* Free memory heap structures */
+		radeon_mem_takedown(&(dev_priv->gart_heap));
+		radeon_mem_takedown(&(dev_priv->fb_heap));
+
+		/* deallocate kernel resources */
+		radeon_do_cleanup_cp(dev);
+	}
+}
+
+/* Just reset the CP ring.  Called as part of an X Server engine reset.
+ */
+int radeon_cp_reset(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_DEBUG("%s called before init done\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	radeon_do_cp_reset(dev_priv);
+
+	/* The CP is no longer running after an engine reset */
+	dev_priv->cp_running = 0;
+
+	return 0;
+}
+
+int radeon_cp_idle(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	return radeon_do_cp_idle(dev_priv);
+}
+
+/* Added by Charl P. Botha to call radeon_do_resume_cp().
+ */
+int radeon_cp_resume(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+
+	return radeon_do_resume_cp(dev);
+}
+
+int radeon_engine_reset(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	return radeon_do_engine_reset(dev);
+}
+
+/* ================================================================
+ * Fullscreen mode
+ */
+
+/* KW: Deprecated to say the least:
+ */
+int radeon_fullscreen(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	return 0;
+}
+
+/* ================================================================
+ * Freelist management
+ */
+
+/* Original comment: FIXME: ROTATE_BUFS is a hack to cycle through
+ *   bufs until freelist code is used.  Note this hides a problem with
+ *   the scratch register * (used to keep track of last buffer
+ *   completed) being written to before * the last buffer has actually
+ *   completed rendering.
+ *
+ * KW:  It's also a good way to find free buffers quickly.
+ *
+ * KW: Ideally this loop wouldn't exist, and freelist_get wouldn't
+ * sleep.  However, bugs in older versions of radeon_accel.c mean that
+ * we essentially have to do this, else old clients will break.
+ *
+ * However, it does leave open a potential deadlock where all the
+ * buffers are held by other clients, which can't release them because
+ * they can't get the lock.
+ */
+
+struct drm_buf *radeon_freelist_get(struct drm_device * dev)
+{
+	struct drm_device_dma *dma = dev->dma;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_buf_priv_t *buf_priv;
+	struct drm_buf *buf;
+	int i, t;
+	int start;
+
+	if (++dev_priv->last_buf >= dma->buf_count)
+		dev_priv->last_buf = 0;
+
+	start = dev_priv->last_buf;
+
+	for (t = 0; t < dev_priv->usec_timeout; t++) {
+		u32 done_age = GET_SCRATCH(1);
+		DRM_DEBUG("done_age = %d\n", done_age);
+		for (i = start; i < dma->buf_count; i++) {
+			buf = dma->buflist[i];
+			buf_priv = buf->dev_private;
+			if (buf->file_priv == NULL || (buf->pending &&
+						       buf_priv->age <=
+						       done_age)) {
+				dev_priv->stats.requested_bufs++;
+				buf->pending = 0;
+				return buf;
+			}
+			start = 0;
+		}
+
+		if (t) {
+			DRM_UDELAY(1);
+			dev_priv->stats.freelist_loops++;
+		}
+	}
+
+	DRM_DEBUG("returning NULL!\n");
+	return NULL;
+}
+
+#if 0
+struct drm_buf *radeon_freelist_get(struct drm_device * dev)
+{
+	struct drm_device_dma *dma = dev->dma;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_buf_priv_t *buf_priv;
+	struct drm_buf *buf;
+	int i, t;
+	int start;
+	u32 done_age = DRM_READ32(dev_priv->ring_rptr, RADEON_SCRATCHOFF(1));
+
+	if (++dev_priv->last_buf >= dma->buf_count)
+		dev_priv->last_buf = 0;
+
+	start = dev_priv->last_buf;
+	dev_priv->stats.freelist_loops++;
+
+	for (t = 0; t < 2; t++) {
+		for (i = start; i < dma->buf_count; i++) {
+			buf = dma->buflist[i];
+			buf_priv = buf->dev_private;
+			if (buf->file_priv == 0 || (buf->pending &&
+						    buf_priv->age <=
+						    done_age)) {
+				dev_priv->stats.requested_bufs++;
+				buf->pending = 0;
+				return buf;
+			}
+		}
+		start = 0;
+	}
+
+	return NULL;
+}
+#endif
+
+void radeon_freelist_reset(struct drm_device * dev)
+{
+	struct drm_device_dma *dma = dev->dma;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	int i;
+
+	dev_priv->last_buf = 0;
+	for (i = 0; i < dma->buf_count; i++) {
+		struct drm_buf *buf = dma->buflist[i];
+		drm_radeon_buf_priv_t *buf_priv = buf->dev_private;
+		buf_priv->age = 0;
+	}
+}
+
+/* ================================================================
+ * CP command submission
+ */
+
+int radeon_wait_ring(drm_radeon_private_t * dev_priv, int n)
+{
+	drm_radeon_ring_buffer_t *ring = &dev_priv->ring;
+	int i;
+	u32 last_head = GET_RING_HEAD(dev_priv);
+
+	for (i = 0; i < dev_priv->usec_timeout; i++) {
+		u32 head = GET_RING_HEAD(dev_priv);
+
+		ring->space = (head - ring->tail) * sizeof(u32);
+		if (ring->space <= 0)
+			ring->space += ring->size;
+		if (ring->space > n)
+			return 0;
+
+		dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
+
+		if (head != last_head)
+			i = 0;
+		last_head = head;
+
+		DRM_UDELAY(1);
+	}
+
+	/* FIXME: This return value is ignored in the BEGIN_RING macro! */
+#if RADEON_FIFO_DEBUG
+	radeon_status(dev_priv);
+	DRM_ERROR("failed!\n");
+#endif
+	return -EBUSY;
+}
+
+static int radeon_cp_get_buffers(struct drm_device *dev,
+				 struct drm_file *file_priv,
+				 struct drm_dma * d)
+{
+	int i;
+	struct drm_buf *buf;
+
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = radeon_freelist_get(dev);
+		if (!buf)
+			return -EBUSY;	/* NOTE: broken client */
+
+		buf->file_priv = file_priv;
+
+		if (DRM_COPY_TO_USER(&d->request_indices[i], &buf->idx,
+				     sizeof(buf->idx)))
+			return -EFAULT;
+		if (DRM_COPY_TO_USER(&d->request_sizes[i], &buf->total,
+				     sizeof(buf->total)))
+			return -EFAULT;
+
+		d->granted_count++;
+	}
+	return 0;
+}
+
+int radeon_cp_buffers(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	struct drm_device_dma *dma = dev->dma;
+	int ret = 0;
+	struct drm_dma *d = data;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	/* Please don't send us buffers.
+	 */
+	if (d->send_count != 0) {
+		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
+			  DRM_CURRENTPID, d->send_count);
+		return -EINVAL;
+	}
+
+	/* We'll send you buffers.
+	 */
+	if (d->request_count < 0 || d->request_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
+			  DRM_CURRENTPID, d->request_count, dma->buf_count);
+		return -EINVAL;
+	}
+
+	d->granted_count = 0;
+
+	if (d->request_count) {
+		ret = radeon_cp_get_buffers(dev, file_priv, d);
+	}
+
+	return ret;
+}
+
+int radeon_driver_load(struct drm_device *dev, unsigned long flags)
+{
+	drm_radeon_private_t *dev_priv;
+	int ret = 0;
+
+	dev_priv = drm_alloc(sizeof(drm_radeon_private_t), DRM_MEM_DRIVER);
+	if (dev_priv == NULL)
+		return -ENOMEM;
+
+	memset(dev_priv, 0, sizeof(drm_radeon_private_t));
+	dev->dev_private = (void *)dev_priv;
+	dev_priv->flags = flags;
+
+	switch (flags & RADEON_FAMILY_MASK) {
+	case CHIP_R100:
+	case CHIP_RV200:
+	case CHIP_R200:
+	case CHIP_R300:
+	case CHIP_R350:
+	case CHIP_R420:
+	case CHIP_RV410:
+		dev_priv->flags |= RADEON_HAS_HIERZ;
+		break;
+	default:
+		/* all other chips have no hierarchical z buffer */
+		break;
+	}
+
+	if (drm_device_is_agp(dev))
+		dev_priv->flags |= RADEON_IS_AGP;
+	else if (drm_device_is_pcie(dev))
+		dev_priv->flags |= RADEON_IS_PCIE;
+	else
+		dev_priv->flags |= RADEON_IS_PCI;
+
+	DRM_DEBUG("%s card detected\n",
+		  ((dev_priv->flags & RADEON_IS_AGP) ? "AGP" : (((dev_priv->flags & RADEON_IS_PCIE) ? "PCIE" : "PCI"))));
+	return ret;
+}
+
+/* Create mappings for registers and framebuffer so userland doesn't necessarily
+ * have to find them.
+ */
+int radeon_driver_firstopen(struct drm_device *dev)
+{
+	int ret;
+	drm_local_map_t *map;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+
+	dev_priv->gart_info.table_size = RADEON_PCIGART_TABLE_SIZE;
+
+	ret = drm_addmap(dev, drm_get_resource_start(dev, 2),
+			 drm_get_resource_len(dev, 2), _DRM_REGISTERS,
+			 _DRM_READ_ONLY, &dev_priv->mmio);
+	if (ret != 0)
+		return ret;
+
+	ret = drm_addmap(dev, drm_get_resource_start(dev, 0),
+			 drm_get_resource_len(dev, 0), _DRM_FRAME_BUFFER,
+			 _DRM_WRITE_COMBINING, &map);
+	if (ret != 0)
+		return ret;
+
+	return 0;
+}
+
+int radeon_driver_unload(struct drm_device *dev)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("\n");
+	drm_free(dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER);
+
+	dev->dev_private = NULL;
+	return 0;
+}
Index: git/shared-core/radeon_drm.h
===================================================================
--- git.orig/shared-core/radeon_drm.h	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/radeon_drm.h	2008-12-12 17:35:22.000000000 +0000
@@ -223,10 +223,10 @@
 #define R300_CMD_CP_DELAY		5
 #define R300_CMD_DMA_DISCARD		6
 #define R300_CMD_WAIT			7
-#	define R300_WAIT_2D  		0x1
-#	define R300_WAIT_3D  		0x2
-#	define R300_WAIT_2D_CLEAN  	0x3
-#	define R300_WAIT_3D_CLEAN  	0x4
+#	define R300_WAIT_2D		0x1
+#	define R300_WAIT_3D		0x2
+#	define R300_WAIT_2D_CLEAN	0x3
+#	define R300_WAIT_3D_CLEAN	0x4
 #define R300_CMD_SCRATCH		8
 
 typedef union {
@@ -417,7 +417,7 @@
 
 	/* The current cliprects, or a subset thereof.
 	 */
-	drm_clip_rect_t boxes[RADEON_NR_SAREA_CLIPRECTS];
+	struct drm_clip_rect boxes[RADEON_NR_SAREA_CLIPRECTS];
 	unsigned int nbox;
 
 	/* Counters for client-side throttling of rendering clients.
@@ -426,7 +426,7 @@
 	unsigned int last_dispatch;
 	unsigned int last_clear;
 
-	drm_tex_region_t tex_list[RADEON_NR_TEX_HEAPS][RADEON_NR_TEX_REGIONS +
+	struct drm_tex_region tex_list[RADEON_NR_TEX_HEAPS][RADEON_NR_TEX_REGIONS +
 						       1];
 	unsigned int tex_age[RADEON_NR_TEX_HEAPS];
 	int ctx_owner;
@@ -434,8 +434,17 @@
 	int pfCurrentPage;	/* which buffer is being displayed? */
 	int crtc2_base;		/* CRTC2 frame offset */
 	int tiling_enabled;	/* set by drm, read by 2d + 3d clients */
+
+	unsigned int last_fence;
 } drm_radeon_sarea_t;
 
+/* The only fence class we support */
+#define DRM_RADEON_FENCE_CLASS_ACCEL 0
+/* Fence type that guarantees read-write flush */
+#define DRM_RADEON_FENCE_TYPE_RW 2
+/* cache flushes programmed just before the fence */
+#define DRM_RADEON_FENCE_FLAG_FLUSHED 0x01000000
+
 /* WARNING: If you change any of these defines, make sure to change the
  * defines in the Xserver file (xf86drmRadeon.h)
  *
@@ -604,7 +613,7 @@
 	int bufsz;
 	char __user *buf;
 	int nbox;
-	drm_clip_rect_t __user *boxes;
+	struct drm_clip_rect __user *boxes;
 } drm_radeon_cmd_buffer_t;
 
 typedef struct drm_radeon_tex_image {
@@ -655,6 +664,7 @@
 #define RADEON_PARAM_GART_TEX_HANDLE       10
 #define RADEON_PARAM_SCRATCH_OFFSET        11
 #define RADEON_PARAM_CARD_TYPE             12
+#define RADEON_PARAM_VBLANK_CRTC           13   /* VBLANK CRTC */
 
 typedef struct drm_radeon_getparam {
 	int param;
@@ -708,7 +718,8 @@
 #define RADEON_SETPARAM_PCIGART_LOCATION 3	/* PCI Gart Location */
 
 #define RADEON_SETPARAM_NEW_MEMMAP 4		/* Use new memory map */
-
+#define RADEON_SETPARAM_PCIGART_TABLE_SIZE 5    /* PCI GART Table Size */
+#define RADEON_SETPARAM_VBLANK_CRTC 6           /* VBLANK CRTC */
 /* 1.14: Clients can allocate/free a surface
  */
 typedef struct drm_radeon_surface_alloc {
@@ -721,5 +732,7 @@
 	unsigned int address;
 } drm_radeon_surface_free_t;
 
+#define	DRM_RADEON_VBLANK_CRTC1		1
+#define	DRM_RADEON_VBLANK_CRTC2		2
 
 #endif
Index: git/shared-core/radeon_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/radeon_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,1269 @@
+/* radeon_drv.h -- Private header for radeon driver -*- linux-c -*-
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Kevin E. Martin <martin@valinux.com>
+ *    Gareth Hughes <gareth@valinux.com>
+ */
+
+#ifndef __RADEON_DRV_H__
+#define __RADEON_DRV_H__
+
+/* General customization:
+ */
+
+#define DRIVER_AUTHOR		"Gareth Hughes, Keith Whitwell, others."
+
+#define DRIVER_NAME		"radeon"
+#define DRIVER_DESC		"ATI Radeon"
+#define DRIVER_DATE		"20060524"
+
+/* Interface history:
+ *
+ * 1.1 - ??
+ * 1.2 - Add vertex2 ioctl (keith)
+ *     - Add stencil capability to clear ioctl (gareth, keith)
+ *     - Increase MAX_TEXTURE_LEVELS (brian)
+ * 1.3 - Add cmdbuf ioctl (keith)
+ *     - Add support for new radeon packets (keith)
+ *     - Add getparam ioctl (keith)
+ *     - Add flip-buffers ioctl, deprecate fullscreen foo (keith).
+ * 1.4 - Add scratch registers to get_param ioctl.
+ * 1.5 - Add r200 packets to cmdbuf ioctl
+ *     - Add r200 function to init ioctl
+ *     - Add 'scalar2' instruction to cmdbuf
+ * 1.6 - Add static GART memory manager
+ *       Add irq handler (won't be turned on unless X server knows to)
+ *       Add irq ioctls and irq_active getparam.
+ *       Add wait command for cmdbuf ioctl
+ *       Add GART offset query for getparam
+ * 1.7 - Add support for cube map registers: R200_PP_CUBIC_FACES_[0..5]
+ *       and R200_PP_CUBIC_OFFSET_F1_[0..5].
+ *       Added packets R200_EMIT_PP_CUBIC_FACES_[0..5] and
+ *       R200_EMIT_PP_CUBIC_OFFSETS_[0..5].  (brian)
+ * 1.8 - Remove need to call cleanup ioctls on last client exit (keith)
+ *       Add 'GET' queries for starting additional clients on different VT's.
+ * 1.9 - Add DRM_IOCTL_RADEON_CP_RESUME ioctl.
+ *       Add texture rectangle support for r100.
+ * 1.10- Add SETPARAM ioctl; first parameter to set is FB_LOCATION, which
+ *       clients use to tell the DRM where they think the framebuffer is
+ *       located in the card's address space
+ * 1.11- Add packet R200_EMIT_RB3D_BLENDCOLOR to support GL_EXT_blend_color
+ *       and GL_EXT_blend_[func|equation]_separate on r200
+ * 1.12- Add R300 CP microcode support - this just loads the CP on r300
+ *       (No 3D support yet - just microcode loading).
+ * 1.13- Add packet R200_EMIT_TCL_POINT_SPRITE_CNTL for ARB_point_parameters
+ *     - Add hyperz support, add hyperz flags to clear ioctl.
+ * 1.14- Add support for color tiling
+ *     - Add R100/R200 surface allocation/free support
+ * 1.15- Add support for texture micro tiling
+ *     - Add support for r100 cube maps
+ * 1.16- Add R200_EMIT_PP_TRI_PERF_CNTL packet to support brilinear
+ *       texture filtering on r200
+ * 1.17- Add initial support for R300 (3D).
+ * 1.18- Add support for GL_ATI_fragment_shader, new packets
+ *       R200_EMIT_PP_AFS_0/1, R200_EMIT_PP_TXCTLALL_0-5 (replaces
+ *       R200_EMIT_PP_TXFILTER_0-5, 2 more regs) and R200_EMIT_ATF_TFACTOR
+ *       (replaces R200_EMIT_TFACTOR_0 (8 consts instead of 6)
+ * 1.19- Add support for gart table in FB memory and PCIE r300
+ * 1.20- Add support for r300 texrect
+ * 1.21- Add support for card type getparam
+ * 1.22- Add support for texture cache flushes (R300_TX_CNTL)
+ * 1.23- Add new radeon memory map work from benh
+ * 1.24- Add general-purpose packet for manipulating scratch registers (r300)
+ * 1.25- Add support for r200 vertex programs (R200_EMIT_VAP_PVS_CNTL,
+ *       new packet type)
+ * 1.26- Add support for variable size PCI(E) gart aperture
+ * 1.27- Add support for IGP GART
+ * 1.28- Add support for VBL on CRTC2
+ */
+
+#define DRIVER_MAJOR		1
+#define DRIVER_MINOR		28
+#define DRIVER_PATCHLEVEL	0
+
+/*
+ * Radeon chip families
+ */
+enum radeon_family {
+	CHIP_R100,
+	CHIP_RV100,
+	CHIP_RS100,
+	CHIP_RV200,
+	CHIP_RS200,
+	CHIP_R200,
+	CHIP_RV250,
+	CHIP_RS300,
+	CHIP_RV280,
+	CHIP_R300,
+	CHIP_R350,
+	CHIP_RV350,
+	CHIP_RV380,
+	CHIP_R420,
+	CHIP_RV410,
+	CHIP_RS400,
+	CHIP_LAST,
+};
+
+enum radeon_cp_microcode_version {
+	UCODE_R100,
+	UCODE_R200,
+	UCODE_R300,
+};
+
+/*
+ * Chip flags
+ */
+enum radeon_chip_flags {
+	RADEON_FAMILY_MASK = 0x0000ffffUL,
+	RADEON_FLAGS_MASK = 0xffff0000UL,
+	RADEON_IS_MOBILITY = 0x00010000UL,
+	RADEON_IS_IGP = 0x00020000UL,
+	RADEON_SINGLE_CRTC = 0x00040000UL,
+	RADEON_IS_AGP = 0x00080000UL,
+	RADEON_HAS_HIERZ = 0x00100000UL,
+	RADEON_IS_PCIE = 0x00200000UL,
+	RADEON_NEW_MEMMAP = 0x00400000UL,
+	RADEON_IS_PCI = 0x00800000UL,
+	RADEON_IS_IGPGART = 0x01000000UL,
+};
+
+#define GET_RING_HEAD(dev_priv)	(dev_priv->writeback_works ? \
+        DRM_READ32(  (dev_priv)->ring_rptr, 0 ) : RADEON_READ(RADEON_CP_RB_RPTR))
+#define SET_RING_HEAD(dev_priv,val)	DRM_WRITE32( (dev_priv)->ring_rptr, 0, (val) )
+
+typedef struct drm_radeon_freelist {
+	unsigned int age;
+	struct drm_buf *buf;
+	struct drm_radeon_freelist *next;
+	struct drm_radeon_freelist *prev;
+} drm_radeon_freelist_t;
+
+typedef struct drm_radeon_ring_buffer {
+	u32 *start;
+	u32 *end;
+	int size; /* Double Words */
+	int size_l2qw; /* log2 Quad Words */
+
+	int rptr_update; /* Double Words */
+	int rptr_update_l2qw; /* log2 Quad Words */
+
+	int fetch_size; /* Double Words */
+	int fetch_size_l2ow; /* log2 Oct Words */
+
+	u32 tail;
+	u32 tail_mask;
+	int space;
+
+	int high_mark;
+} drm_radeon_ring_buffer_t;
+
+typedef struct drm_radeon_depth_clear_t {
+	u32 rb3d_cntl;
+	u32 rb3d_zstencilcntl;
+	u32 se_cntl;
+} drm_radeon_depth_clear_t;
+
+struct drm_radeon_driver_file_fields {
+	int64_t radeon_fb_delta;
+};
+
+struct mem_block {
+	struct mem_block *next;
+	struct mem_block *prev;
+	int start;
+	int size;
+	struct drm_file *file_priv; /* NULL: free, -1: heap, other: real files */
+};
+
+struct radeon_surface {
+	int refcount;
+	u32 lower;
+	u32 upper;
+	u32 flags;
+};
+
+struct radeon_virt_surface {
+	int surface_index;
+	u32 lower;
+	u32 upper;
+	u32 flags;
+	struct drm_file *file_priv;
+};
+
+typedef struct drm_radeon_private {
+
+	drm_radeon_ring_buffer_t ring;
+	drm_radeon_sarea_t *sarea_priv;
+
+	u32 fb_location;
+	u32 fb_size;
+	int new_memmap;
+
+	int gart_size;
+	u32 gart_vm_start;
+	unsigned long gart_buffers_offset;
+
+	int cp_mode;
+	int cp_running;
+
+	drm_radeon_freelist_t *head;
+	drm_radeon_freelist_t *tail;
+	int last_buf;
+	volatile u32 *scratch;
+	int writeback_works;
+
+	int usec_timeout;
+
+	int microcode_version;
+
+	struct {
+		u32 boxes;
+		int freelist_timeouts;
+		int freelist_loops;
+		int requested_bufs;
+		int last_frame_reads;
+		int last_clear_reads;
+		int clears;
+		int texture_uploads;
+	} stats;
+
+	int do_boxes;
+	int page_flipping;
+
+	u32 color_fmt;
+	unsigned int front_offset;
+	unsigned int front_pitch;
+	unsigned int back_offset;
+	unsigned int back_pitch;
+
+	u32 depth_fmt;
+	unsigned int depth_offset;
+	unsigned int depth_pitch;
+
+	u32 front_pitch_offset;
+	u32 back_pitch_offset;
+	u32 depth_pitch_offset;
+
+	drm_radeon_depth_clear_t depth_clear;
+
+	unsigned long ring_offset;
+	unsigned long ring_rptr_offset;
+	unsigned long buffers_offset;
+	unsigned long gart_textures_offset;
+
+	drm_local_map_t *sarea;
+	drm_local_map_t *mmio;
+	drm_local_map_t *cp_ring;
+	drm_local_map_t *ring_rptr;
+	drm_local_map_t *gart_textures;
+
+	struct mem_block *gart_heap;
+	struct mem_block *fb_heap;
+
+	/* SW interrupt */
+	wait_queue_head_t swi_queue;
+	atomic_t swi_emitted;
+	int vblank_crtc;
+	uint32_t irq_enable_reg;
+	int irq_enabled;
+
+	struct radeon_surface surfaces[RADEON_MAX_SURFACES];
+	struct radeon_virt_surface virt_surfaces[2*RADEON_MAX_SURFACES];
+
+	unsigned long pcigart_offset;
+	unsigned int pcigart_offset_set;
+	struct ati_pcigart_info gart_info;
+
+	u32 scratch_ages[5];
+
+	/* starting from here on, data is preserved accross an open */
+	uint32_t flags;		/* see radeon_chip_flags */
+
+} drm_radeon_private_t;
+
+typedef struct drm_radeon_buf_priv {
+	u32 age;
+} drm_radeon_buf_priv_t;
+
+typedef struct drm_radeon_kcmd_buffer {
+	int bufsz;
+	char *buf;
+	int nbox;
+	struct drm_clip_rect __user *boxes;
+} drm_radeon_kcmd_buffer_t;
+
+extern int radeon_no_wb;
+extern struct drm_ioctl_desc radeon_ioctls[];
+extern int radeon_max_ioctl;
+
+/* Check whether the given hardware address is inside the framebuffer or the
+ * GART area.
+ */
+static __inline__ int radeon_check_offset(drm_radeon_private_t *dev_priv,
+					  u64 off)
+{
+	u32 fb_start = dev_priv->fb_location;
+	u32 fb_end = fb_start + dev_priv->fb_size - 1;
+	u32 gart_start = dev_priv->gart_vm_start;
+	u32 gart_end = gart_start + dev_priv->gart_size - 1;
+
+	return ((off >= fb_start && off <= fb_end) ||
+		(off >= gart_start && off <= gart_end));
+}
+
+				/* radeon_cp.c */
+extern int radeon_cp_init(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int radeon_cp_start(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int radeon_cp_stop(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int radeon_cp_reset(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int radeon_cp_idle(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int radeon_cp_resume(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int radeon_engine_reset(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int radeon_fullscreen(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int radeon_cp_buffers(struct drm_device *dev, void *data, struct drm_file *file_priv);
+
+extern void radeon_freelist_reset(struct drm_device * dev);
+extern struct drm_buf *radeon_freelist_get(struct drm_device * dev);
+
+extern int radeon_wait_ring(drm_radeon_private_t * dev_priv, int n);
+
+extern int radeon_do_cp_idle(drm_radeon_private_t * dev_priv);
+
+extern int radeon_mem_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int radeon_mem_free(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int radeon_mem_init_heap(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern void radeon_mem_takedown(struct mem_block **heap);
+extern void radeon_mem_release(struct drm_file *file_priv,
+			       struct mem_block *heap);
+
+				/* radeon_irq.c */
+extern int radeon_irq_emit(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int radeon_irq_wait(struct drm_device *dev, void *data, struct drm_file *file_priv);
+
+extern void radeon_do_release(struct drm_device * dev);
+extern int radeon_driver_vblank_wait(struct drm_device * dev,
+				     unsigned int *sequence);
+extern int radeon_driver_vblank_wait2(struct drm_device * dev,
+				      unsigned int *sequence);
+extern irqreturn_t radeon_driver_irq_handler(DRM_IRQ_ARGS);
+extern void radeon_driver_irq_preinstall(struct drm_device * dev);
+extern void radeon_driver_irq_postinstall(struct drm_device * dev);
+extern void radeon_driver_irq_uninstall(struct drm_device * dev);
+extern int radeon_vblank_crtc_get(struct drm_device *dev);
+extern int radeon_vblank_crtc_set(struct drm_device *dev, int64_t value);
+
+extern int radeon_driver_load(struct drm_device *dev, unsigned long flags);
+extern int radeon_driver_unload(struct drm_device *dev);
+extern int radeon_driver_firstopen(struct drm_device *dev);
+extern void radeon_driver_preclose(struct drm_device * dev,
+				   struct drm_file *file_priv);
+extern void radeon_driver_postclose(struct drm_device * dev,
+				    struct drm_file *file_priv);
+extern void radeon_driver_lastclose(struct drm_device * dev);
+extern int radeon_driver_open(struct drm_device * dev,
+			      struct drm_file * file_priv);
+extern long radeon_compat_ioctl(struct file *filp, unsigned int cmd,
+					 unsigned long arg);
+
+/* r300_cmdbuf.c */
+extern void r300_init_reg_flags(void);
+
+extern int r300_do_cp_cmdbuf(struct drm_device *dev,
+			     struct drm_file *file_priv,
+			     drm_radeon_kcmd_buffer_t* cmdbuf);
+
+/* Flags for stats.boxes
+ */
+#define RADEON_BOX_DMA_IDLE      0x1
+#define RADEON_BOX_RING_FULL     0x2
+#define RADEON_BOX_FLIP          0x4
+#define RADEON_BOX_WAIT_IDLE     0x8
+#define RADEON_BOX_TEXTURE_LOAD  0x10
+
+/* Register definitions, register access macros and drmAddMap constants
+ * for Radeon kernel driver.
+ */
+#define RADEON_AGP_COMMAND		0x0f60
+#define RADEON_AGP_COMMAND_PCI_CONFIG	0x0060	/* offset in PCI config */
+#       define RADEON_AGP_ENABLE            (1<<8)
+#define RADEON_AUX_SCISSOR_CNTL		0x26f0
+#	define RADEON_EXCLUSIVE_SCISSOR_0	(1 << 24)
+#	define RADEON_EXCLUSIVE_SCISSOR_1	(1 << 25)
+#	define RADEON_EXCLUSIVE_SCISSOR_2	(1 << 26)
+#	define RADEON_SCISSOR_0_ENABLE		(1 << 28)
+#	define RADEON_SCISSOR_1_ENABLE		(1 << 29)
+#	define RADEON_SCISSOR_2_ENABLE		(1 << 30)
+
+#define RADEON_BUS_CNTL			0x0030
+#	define RADEON_BUS_MASTER_DIS		(1 << 6)
+
+#define RADEON_CLOCK_CNTL_DATA		0x000c
+#	define RADEON_PLL_WR_EN			(1 << 7)
+#define RADEON_CLOCK_CNTL_INDEX		0x0008
+#define RADEON_CONFIG_APER_SIZE		0x0108
+#define RADEON_CONFIG_MEMSIZE           0x00f8
+#define RADEON_CRTC_OFFSET		0x0224
+#define RADEON_CRTC_OFFSET_CNTL		0x0228
+#	define RADEON_CRTC_TILE_EN		(1 << 15)
+#	define RADEON_CRTC_OFFSET_FLIP_CNTL	(1 << 16)
+#define RADEON_CRTC2_OFFSET		0x0324
+#define RADEON_CRTC2_OFFSET_CNTL	0x0328
+
+#define RADEON_PCIE_INDEX               0x0030
+#define RADEON_PCIE_DATA                0x0034
+#define RADEON_PCIE_TX_GART_CNTL	0x10
+#	define RADEON_PCIE_TX_GART_EN   	(1 << 0)
+#	define RADEON_PCIE_TX_GART_UNMAPPED_ACCESS_PASS_THRU (0<<1)
+#	define RADEON_PCIE_TX_GART_UNMAPPED_ACCESS_CLAMP_LO  (1<<1)
+#	define RADEON_PCIE_TX_GART_UNMAPPED_ACCESS_DISCARD   (3<<1)
+#	define RADEON_PCIE_TX_GART_MODE_32_128_CACHE	(0<<3)
+#	define RADEON_PCIE_TX_GART_MODE_8_4_128_CACHE	(1<<3)
+#	define RADEON_PCIE_TX_GART_CHK_RW_VALID_EN      (1<<5)
+#	define RADEON_PCIE_TX_GART_INVALIDATE_TLB	(1<<8)
+#define RADEON_PCIE_TX_DISCARD_RD_ADDR_LO 0x11
+#define RADEON_PCIE_TX_DISCARD_RD_ADDR_HI 0x12
+#define RADEON_PCIE_TX_GART_BASE  	0x13
+#define RADEON_PCIE_TX_GART_START_LO	0x14
+#define RADEON_PCIE_TX_GART_START_HI	0x15
+#define RADEON_PCIE_TX_GART_END_LO	0x16
+#define RADEON_PCIE_TX_GART_END_HI	0x17
+
+#define RADEON_IGPGART_INDEX            0x168
+#define RADEON_IGPGART_DATA             0x16c
+#define RADEON_IGPGART_UNK_18           0x18
+#define RADEON_IGPGART_CTRL             0x2b
+#define RADEON_IGPGART_BASE_ADDR        0x2c
+#define RADEON_IGPGART_FLUSH            0x2e
+#define RADEON_IGPGART_ENABLE           0x38
+#define RADEON_IGPGART_UNK_39           0x39
+
+
+#define RADEON_MPP_TB_CONFIG		0x01c0
+#define RADEON_MEM_CNTL			0x0140
+#define RADEON_MEM_SDRAM_MODE_REG	0x0158
+#define RADEON_AGP_BASE			0x0170
+
+#define RADEON_RB3D_COLOROFFSET		0x1c40
+#define RADEON_RB3D_COLORPITCH		0x1c48
+
+#define	RADEON_SRC_X_Y			0x1590
+
+#define RADEON_DP_GUI_MASTER_CNTL	0x146c
+#	define RADEON_GMC_SRC_PITCH_OFFSET_CNTL	(1 << 0)
+#	define RADEON_GMC_DST_PITCH_OFFSET_CNTL	(1 << 1)
+#	define RADEON_GMC_BRUSH_SOLID_COLOR	(13 << 4)
+#	define RADEON_GMC_BRUSH_NONE		(15 << 4)
+#	define RADEON_GMC_DST_16BPP		(4 << 8)
+#	define RADEON_GMC_DST_24BPP		(5 << 8)
+#	define RADEON_GMC_DST_32BPP		(6 << 8)
+#	define RADEON_GMC_DST_DATATYPE_SHIFT	8
+#	define RADEON_GMC_SRC_DATATYPE_COLOR	(3 << 12)
+#	define RADEON_DP_SRC_SOURCE_MEMORY	(2 << 24)
+#	define RADEON_DP_SRC_SOURCE_HOST_DATA	(3 << 24)
+#	define RADEON_GMC_CLR_CMP_CNTL_DIS	(1 << 28)
+#	define RADEON_GMC_WR_MSK_DIS		(1 << 30)
+#	define RADEON_ROP3_S			0x00cc0000
+#	define RADEON_ROP3_P			0x00f00000
+#define RADEON_DP_WRITE_MASK		0x16cc
+#define RADEON_SRC_PITCH_OFFSET		0x1428
+#define RADEON_DST_PITCH_OFFSET		0x142c
+#define RADEON_DST_PITCH_OFFSET_C	0x1c80
+#	define RADEON_DST_TILE_LINEAR		(0 << 30)
+#	define RADEON_DST_TILE_MACRO		(1 << 30)
+#	define RADEON_DST_TILE_MICRO		(2 << 30)
+#	define RADEON_DST_TILE_BOTH		(3 << 30)
+
+#define RADEON_SCRATCH_REG0		0x15e0
+#define RADEON_SCRATCH_REG1		0x15e4
+#define RADEON_SCRATCH_REG2		0x15e8
+#define RADEON_SCRATCH_REG3		0x15ec
+#define RADEON_SCRATCH_REG4		0x15f0
+#define RADEON_SCRATCH_REG5		0x15f4
+#define RADEON_SCRATCH_UMSK		0x0770
+#define RADEON_SCRATCH_ADDR		0x0774
+
+#define RADEON_SCRATCHOFF( x )		(RADEON_SCRATCH_REG_OFFSET + 4*(x))
+
+#define GET_SCRATCH( x )	(dev_priv->writeback_works			\
+				? DRM_READ32( dev_priv->ring_rptr, RADEON_SCRATCHOFF(x) ) \
+				: RADEON_READ( RADEON_SCRATCH_REG0 + 4*(x) ) )
+
+#define RADEON_GEN_INT_CNTL		0x0040
+#	define RADEON_CRTC_VBLANK_MASK		(1 << 0)
+#	define RADEON_CRTC2_VBLANK_MASK		(1 << 9)
+#	define RADEON_GUI_IDLE_INT_ENABLE	(1 << 19)
+#	define RADEON_SW_INT_ENABLE		(1 << 25)
+
+#define RADEON_GEN_INT_STATUS		0x0044
+#	define RADEON_CRTC_VBLANK_STAT		(1 << 0)
+#	define RADEON_CRTC_VBLANK_STAT_ACK   	(1 << 0)
+#	define RADEON_CRTC2_VBLANK_STAT		(1 << 9)
+#	define RADEON_CRTC2_VBLANK_STAT_ACK   	(1 << 9)
+#	define RADEON_GUI_IDLE_INT_TEST_ACK     (1 << 19)
+#	define RADEON_SW_INT_TEST		(1 << 25)
+#	define RADEON_SW_INT_TEST_ACK   	(1 << 25)
+#	define RADEON_SW_INT_FIRE		(1 << 26)
+
+#define RADEON_HOST_PATH_CNTL		0x0130
+#	define RADEON_HDP_SOFT_RESET		(1 << 26)
+#	define RADEON_HDP_WC_TIMEOUT_MASK	(7 << 28)
+#	define RADEON_HDP_WC_TIMEOUT_28BCLK	(7 << 28)
+
+#define RADEON_ISYNC_CNTL		0x1724
+#	define RADEON_ISYNC_ANY2D_IDLE3D	(1 << 0)
+#	define RADEON_ISYNC_ANY3D_IDLE2D	(1 << 1)
+#	define RADEON_ISYNC_TRIG2D_IDLE3D	(1 << 2)
+#	define RADEON_ISYNC_TRIG3D_IDLE2D	(1 << 3)
+#	define RADEON_ISYNC_WAIT_IDLEGUI	(1 << 4)
+#	define RADEON_ISYNC_CPSCRATCH_IDLEGUI	(1 << 5)
+
+#define RADEON_RBBM_GUICNTL		0x172c
+#	define RADEON_HOST_DATA_SWAP_NONE	(0 << 0)
+#	define RADEON_HOST_DATA_SWAP_16BIT	(1 << 0)
+#	define RADEON_HOST_DATA_SWAP_32BIT	(2 << 0)
+#	define RADEON_HOST_DATA_SWAP_HDW	(3 << 0)
+
+#define RADEON_MC_AGP_LOCATION		0x014c
+#define RADEON_MC_FB_LOCATION		0x0148
+#define RADEON_MCLK_CNTL		0x0012
+#	define RADEON_FORCEON_MCLKA		(1 << 16)
+#	define RADEON_FORCEON_MCLKB		(1 << 17)
+#	define RADEON_FORCEON_YCLKA		(1 << 18)
+#	define RADEON_FORCEON_YCLKB		(1 << 19)
+#	define RADEON_FORCEON_MC		(1 << 20)
+#	define RADEON_FORCEON_AIC		(1 << 21)
+
+#define RADEON_PP_BORDER_COLOR_0	0x1d40
+#define RADEON_PP_BORDER_COLOR_1	0x1d44
+#define RADEON_PP_BORDER_COLOR_2	0x1d48
+#define RADEON_PP_CNTL			0x1c38
+#	define RADEON_SCISSOR_ENABLE		(1 <<  1)
+#define RADEON_PP_LUM_MATRIX		0x1d00
+#define RADEON_PP_MISC			0x1c14
+#define RADEON_PP_ROT_MATRIX_0		0x1d58
+#define RADEON_PP_TXFILTER_0		0x1c54
+#define RADEON_PP_TXOFFSET_0		0x1c5c
+#define RADEON_PP_TXFILTER_1		0x1c6c
+#define RADEON_PP_TXFILTER_2		0x1c84
+
+#define RADEON_RB2D_DSTCACHE_CTLSTAT	0x342c
+#	define RADEON_RB2D_DC_FLUSH		(3 << 0)
+#	define RADEON_RB2D_DC_FREE		(3 << 2)
+#	define RADEON_RB2D_DC_FLUSH_ALL		0xf
+#	define RADEON_RB2D_DC_BUSY		(1 << 31)
+#define RADEON_RB3D_CNTL		0x1c3c
+#	define RADEON_ALPHA_BLEND_ENABLE	(1 << 0)
+#	define RADEON_PLANE_MASK_ENABLE		(1 << 1)
+#	define RADEON_DITHER_ENABLE		(1 << 2)
+#	define RADEON_ROUND_ENABLE		(1 << 3)
+#	define RADEON_SCALE_DITHER_ENABLE	(1 << 4)
+#	define RADEON_DITHER_INIT		(1 << 5)
+#	define RADEON_ROP_ENABLE		(1 << 6)
+#	define RADEON_STENCIL_ENABLE		(1 << 7)
+#	define RADEON_Z_ENABLE			(1 << 8)
+#	define RADEON_ZBLOCK16			(1 << 15)
+#define RADEON_RB3D_DEPTHOFFSET		0x1c24
+#define RADEON_RB3D_DEPTHCLEARVALUE	0x3230
+#define RADEON_RB3D_DEPTHPITCH		0x1c28
+#define RADEON_RB3D_PLANEMASK		0x1d84
+#define RADEON_RB3D_STENCILREFMASK	0x1d7c
+#define RADEON_RB3D_ZCACHE_MODE		0x3250
+#define RADEON_RB3D_ZCACHE_CTLSTAT	0x3254
+#	define RADEON_RB3D_ZC_FLUSH		(1 << 0)
+#	define RADEON_RB3D_ZC_FREE		(1 << 2)
+#	define RADEON_RB3D_ZC_FLUSH_ALL		0x5
+#	define RADEON_RB3D_ZC_BUSY		(1 << 31)
+#define RADEON_RB3D_DSTCACHE_CTLSTAT            0x325c
+#	define RADEON_RB3D_DC_FLUSH		(3 << 0)
+#	define RADEON_RB3D_DC_FREE		(3 << 2)
+#	define RADEON_RB3D_DC_FLUSH_ALL		0xf
+#	define RADEON_RB3D_DC_BUSY		(1 << 31)
+#define RADEON_RB3D_ZSTENCILCNTL	0x1c2c
+#	define RADEON_Z_TEST_MASK		(7 << 4)
+#	define RADEON_Z_TEST_ALWAYS		(7 << 4)
+#	define RADEON_Z_HIERARCHY_ENABLE        (1 << 8)
+#	define RADEON_STENCIL_TEST_ALWAYS	(7 << 12)
+#	define RADEON_STENCIL_S_FAIL_REPLACE	(2 << 16)
+#	define RADEON_STENCIL_ZPASS_REPLACE	(2 << 20)
+#	define RADEON_STENCIL_ZFAIL_REPLACE	(2 << 24)
+#	define RADEON_Z_COMPRESSION_ENABLE      (1 << 28)
+#	define RADEON_FORCE_Z_DIRTY             (1 << 29)
+#	define RADEON_Z_WRITE_ENABLE		(1 << 30)
+#	define RADEON_Z_DECOMPRESSION_ENABLE    (1 << 31)
+#define RADEON_RBBM_SOFT_RESET		0x00f0
+#	define RADEON_SOFT_RESET_CP		(1 <<  0)
+#	define RADEON_SOFT_RESET_HI		(1 <<  1)
+#	define RADEON_SOFT_RESET_SE		(1 <<  2)
+#	define RADEON_SOFT_RESET_RE		(1 <<  3)
+#	define RADEON_SOFT_RESET_PP		(1 <<  4)
+#	define RADEON_SOFT_RESET_E2		(1 <<  5)
+#	define RADEON_SOFT_RESET_RB		(1 <<  6)
+#	define RADEON_SOFT_RESET_HDP		(1 <<  7)
+/*
+ *   6:0  Available slots in the FIFO
+ *   8    Host Interface active
+ *   9    CP request active
+ *   10   FIFO request active
+ *   11   Host Interface retry active
+ *   12   CP retry active
+ *   13   FIFO retry active
+ *   14   FIFO pipeline busy
+ *   15   Event engine busy
+ *   16   CP command stream busy
+ *   17   2D engine busy
+ *   18   2D portion of render backend busy
+ *   20   3D setup engine busy
+ *   26   GA engine busy
+ *   27   CBA 2D engine busy
+ *   31   2D engine busy or 3D engine busy or FIFO not empty or CP busy or
+ *           command stream queue not empty or Ring Buffer not empty
+ */
+#define RADEON_RBBM_STATUS		0x0e40
+/* Same as the previous RADEON_RBBM_STATUS; this is a mirror of that register.  */
+/* #define RADEON_RBBM_STATUS 		0x1740 */
+/* bits 6:0 are dword slots available in the cmd fifo */
+#	define RADEON_RBBM_FIFOCNT_MASK		0x007f
+#	define RADEON_HIRQ_ON_RBB 	(1 <<  8)
+#	define RADEON_CPRQ_ON_RBB 	(1 <<  9)
+#	define RADEON_CFRQ_ON_RBB 	(1 << 10)
+#	define RADEON_HIRQ_IN_RTBUF 	(1 << 11)
+#	define RADEON_CPRQ_IN_RTBUF 	(1 << 12)
+#	define RADEON_CFRQ_IN_RTBUF 	(1 << 13)
+#	define RADEON_PIPE_BUSY 	(1 << 14)
+#	define RADEON_ENG_EV_BUSY 	(1 << 15)
+#	define RADEON_CP_CMDSTRM_BUSY 	(1 << 16)
+#	define RADEON_E2_BUSY 		(1 << 17)
+#	define RADEON_RB2D_BUSY 	(1 << 18)
+#	define RADEON_RB3D_BUSY 	(1 << 19) /* not used on r300 */
+#	define RADEON_VAP_BUSY 		(1 << 20)
+#	define RADEON_RE_BUSY 		(1 << 21) /* not used on r300 */
+#	define RADEON_TAM_BUSY 		(1 << 22) /* not used on r300 */
+#	define RADEON_TDM_BUSY 		(1 << 23) /* not used on r300 */
+#	define RADEON_PB_BUSY 		(1 << 24) /* not used on r300 */
+#	define RADEON_TIM_BUSY 		(1 << 25) /* not used on r300 */
+#	define RADEON_GA_BUSY 		(1 << 26)
+#	define RADEON_CBA2D_BUSY 	(1 << 27)
+#	define RADEON_RBBM_ACTIVE 	(1 << 31)
+#define RADEON_RE_LINE_PATTERN		0x1cd0
+#define RADEON_RE_MISC			0x26c4
+#define RADEON_RE_TOP_LEFT		0x26c0
+#define RADEON_RE_WIDTH_HEIGHT		0x1c44
+#define RADEON_RE_STIPPLE_ADDR		0x1cc8
+#define RADEON_RE_STIPPLE_DATA		0x1ccc
+
+#define RADEON_SCISSOR_TL_0		0x1cd8
+#define RADEON_SCISSOR_BR_0		0x1cdc
+#define RADEON_SCISSOR_TL_1		0x1ce0
+#define RADEON_SCISSOR_BR_1		0x1ce4
+#define RADEON_SCISSOR_TL_2		0x1ce8
+#define RADEON_SCISSOR_BR_2		0x1cec
+#define RADEON_SE_COORD_FMT		0x1c50
+#define RADEON_SE_CNTL			0x1c4c
+#	define RADEON_FFACE_CULL_CW		(0 << 0)
+#	define RADEON_BFACE_SOLID		(3 << 1)
+#	define RADEON_FFACE_SOLID		(3 << 3)
+#	define RADEON_FLAT_SHADE_VTX_LAST	(3 << 6)
+#	define RADEON_DIFFUSE_SHADE_FLAT	(1 << 8)
+#	define RADEON_DIFFUSE_SHADE_GOURAUD	(2 << 8)
+#	define RADEON_ALPHA_SHADE_FLAT		(1 << 10)
+#	define RADEON_ALPHA_SHADE_GOURAUD	(2 << 10)
+#	define RADEON_SPECULAR_SHADE_FLAT	(1 << 12)
+#	define RADEON_SPECULAR_SHADE_GOURAUD	(2 << 12)
+#	define RADEON_FOG_SHADE_FLAT		(1 << 14)
+#	define RADEON_FOG_SHADE_GOURAUD		(2 << 14)
+#	define RADEON_VPORT_XY_XFORM_ENABLE	(1 << 24)
+#	define RADEON_VPORT_Z_XFORM_ENABLE	(1 << 25)
+#	define RADEON_VTX_PIX_CENTER_OGL	(1 << 27)
+#	define RADEON_ROUND_MODE_TRUNC		(0 << 28)
+#	define RADEON_ROUND_PREC_8TH_PIX	(1 << 30)
+#define RADEON_SE_CNTL_STATUS		0x2140
+#define RADEON_SE_LINE_WIDTH		0x1db8
+#define RADEON_SE_VPORT_XSCALE		0x1d98
+#define RADEON_SE_ZBIAS_FACTOR		0x1db0
+#define RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED 0x2210
+#define RADEON_SE_TCL_OUTPUT_VTX_FMT         0x2254
+#define RADEON_SE_TCL_VECTOR_INDX_REG        0x2200
+#       define RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT  16
+#       define RADEON_VEC_INDX_DWORD_COUNT_SHIFT     28
+#define RADEON_SE_TCL_VECTOR_DATA_REG       0x2204
+#define RADEON_SE_TCL_SCALAR_INDX_REG       0x2208
+#       define RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT  16
+#define RADEON_SE_TCL_SCALAR_DATA_REG       0x220C
+#define RADEON_SURFACE_ACCESS_FLAGS	0x0bf8
+#define RADEON_SURFACE_ACCESS_CLR	0x0bfc
+#define RADEON_SURFACE_CNTL		0x0b00
+#	define RADEON_SURF_TRANSLATION_DIS	(1 << 8)
+#	define RADEON_NONSURF_AP0_SWP_MASK	(3 << 20)
+#	define RADEON_NONSURF_AP0_SWP_LITTLE	(0 << 20)
+#	define RADEON_NONSURF_AP0_SWP_BIG16	(1 << 20)
+#	define RADEON_NONSURF_AP0_SWP_BIG32	(2 << 20)
+#	define RADEON_NONSURF_AP1_SWP_MASK	(3 << 22)
+#	define RADEON_NONSURF_AP1_SWP_LITTLE	(0 << 22)
+#	define RADEON_NONSURF_AP1_SWP_BIG16	(1 << 22)
+#	define RADEON_NONSURF_AP1_SWP_BIG32	(2 << 22)
+#define RADEON_SURFACE0_INFO		0x0b0c
+#	define RADEON_SURF_PITCHSEL_MASK	(0x1ff << 0)
+#	define RADEON_SURF_TILE_MODE_MASK	(3 << 16)
+#	define RADEON_SURF_TILE_MODE_MACRO	(0 << 16)
+#	define RADEON_SURF_TILE_MODE_MICRO	(1 << 16)
+#	define RADEON_SURF_TILE_MODE_32BIT_Z	(2 << 16)
+#	define RADEON_SURF_TILE_MODE_16BIT_Z	(3 << 16)
+#define RADEON_SURFACE0_LOWER_BOUND	0x0b04
+#define RADEON_SURFACE0_UPPER_BOUND	0x0b08
+#	define RADEON_SURF_ADDRESS_FIXED_MASK	(0x3ff << 0)
+#define RADEON_SURFACE1_INFO		0x0b1c
+#define RADEON_SURFACE1_LOWER_BOUND	0x0b14
+#define RADEON_SURFACE1_UPPER_BOUND	0x0b18
+#define RADEON_SURFACE2_INFO		0x0b2c
+#define RADEON_SURFACE2_LOWER_BOUND	0x0b24
+#define RADEON_SURFACE2_UPPER_BOUND	0x0b28
+#define RADEON_SURFACE3_INFO		0x0b3c
+#define RADEON_SURFACE3_LOWER_BOUND	0x0b34
+#define RADEON_SURFACE3_UPPER_BOUND	0x0b38
+#define RADEON_SURFACE4_INFO		0x0b4c
+#define RADEON_SURFACE4_LOWER_BOUND	0x0b44
+#define RADEON_SURFACE4_UPPER_BOUND	0x0b48
+#define RADEON_SURFACE5_INFO		0x0b5c
+#define RADEON_SURFACE5_LOWER_BOUND	0x0b54
+#define RADEON_SURFACE5_UPPER_BOUND	0x0b58
+#define RADEON_SURFACE6_INFO		0x0b6c
+#define RADEON_SURFACE6_LOWER_BOUND	0x0b64
+#define RADEON_SURFACE6_UPPER_BOUND	0x0b68
+#define RADEON_SURFACE7_INFO		0x0b7c
+#define RADEON_SURFACE7_LOWER_BOUND	0x0b74
+#define RADEON_SURFACE7_UPPER_BOUND	0x0b78
+#define RADEON_SW_SEMAPHORE		0x013c
+
+#define RADEON_WAIT_UNTIL		0x1720
+#	define RADEON_WAIT_CRTC_PFLIP		(1 << 0)
+#	define RADEON_WAIT_2D_IDLE		(1 << 14)
+#	define RADEON_WAIT_3D_IDLE		(1 << 15)
+#	define RADEON_WAIT_2D_IDLECLEAN		(1 << 16)
+#	define RADEON_WAIT_3D_IDLECLEAN		(1 << 17)
+#	define RADEON_WAIT_HOST_IDLECLEAN	(1 << 18)
+
+#define RADEON_RB3D_ZMASKOFFSET		0x3234
+#define RADEON_RB3D_ZSTENCILCNTL	0x1c2c
+#	define RADEON_DEPTH_FORMAT_16BIT_INT_Z	(0 << 0)
+#	define RADEON_DEPTH_FORMAT_24BIT_INT_Z	(2 << 0)
+
+/* CP registers */
+#define RADEON_CP_ME_RAM_ADDR		0x07d4
+#define RADEON_CP_ME_RAM_RADDR		0x07d8
+#define RADEON_CP_ME_RAM_DATAH		0x07dc
+#define RADEON_CP_ME_RAM_DATAL		0x07e0
+
+#define RADEON_CP_RB_BASE		0x0700
+#define RADEON_CP_RB_CNTL		0x0704
+#	define RADEON_BUF_SWAP_32BIT		(2 << 16)
+#	define RADEON_RB_NO_UPDATE		(1 << 27)
+#define RADEON_CP_RB_RPTR_ADDR		0x070c
+#define RADEON_CP_RB_RPTR		0x0710
+#define RADEON_CP_RB_WPTR		0x0714
+
+#define RADEON_CP_RB_WPTR_DELAY		0x0718
+#	define RADEON_PRE_WRITE_TIMER_SHIFT	0
+#	define RADEON_PRE_WRITE_LIMIT_SHIFT	23
+
+#define RADEON_CP_IB_BASE		0x0738
+
+#define RADEON_CP_CSQ_CNTL		0x0740
+#	define RADEON_CSQ_CNT_PRIMARY_MASK	(0xff << 0)
+#	define RADEON_CSQ_PRIDIS_INDDIS		(0 << 28)
+#	define RADEON_CSQ_PRIPIO_INDDIS		(1 << 28)
+#	define RADEON_CSQ_PRIBM_INDDIS		(2 << 28)
+#	define RADEON_CSQ_PRIPIO_INDBM		(3 << 28)
+#	define RADEON_CSQ_PRIBM_INDBM		(4 << 28)
+#	define RADEON_CSQ_PRIPIO_INDPIO		(15 << 28)
+
+#define RADEON_AIC_CNTL			0x01d0
+#	define RADEON_PCIGART_TRANSLATE_EN	(1 << 0)
+#define RADEON_AIC_STAT			0x01d4
+#define RADEON_AIC_PT_BASE		0x01d8
+#define RADEON_AIC_LO_ADDR		0x01dc
+#define RADEON_AIC_HI_ADDR		0x01e0
+#define RADEON_AIC_TLB_ADDR		0x01e4
+#define RADEON_AIC_TLB_DATA		0x01e8
+
+/* CP command packets */
+#define RADEON_CP_PACKET0		0x00000000
+#	define RADEON_ONE_REG_WR		(1 << 15)
+#define RADEON_CP_PACKET1		0x40000000
+#define RADEON_CP_PACKET2		0x80000000
+#define RADEON_CP_PACKET3		0xC0000000
+#       define RADEON_CP_NOP                    0x00001000
+#       define RADEON_CP_NEXT_CHAR              0x00001900
+#       define RADEON_CP_PLY_NEXTSCAN           0x00001D00
+#       define RADEON_CP_SET_SCISSORS           0x00001E00
+             /* GEN_INDX_PRIM is unsupported starting with R300 */
+#	define RADEON_3D_RNDR_GEN_INDX_PRIM	0x00002300
+#	define RADEON_WAIT_FOR_IDLE		0x00002600
+#	define RADEON_3D_DRAW_VBUF		0x00002800
+#	define RADEON_3D_DRAW_IMMD		0x00002900
+#	define RADEON_3D_DRAW_INDX		0x00002A00
+#       define RADEON_CP_LOAD_PALETTE           0x00002C00
+#	define RADEON_3D_LOAD_VBPNTR		0x00002F00
+#	define RADEON_MPEG_IDCT_MACROBLOCK	0x00003000
+#	define RADEON_MPEG_IDCT_MACROBLOCK_REV	0x00003100
+#	define RADEON_3D_CLEAR_ZMASK		0x00003200
+#	define RADEON_CP_INDX_BUFFER		0x00003300
+#       define RADEON_CP_3D_DRAW_VBUF_2         0x00003400
+#       define RADEON_CP_3D_DRAW_IMMD_2         0x00003500
+#       define RADEON_CP_3D_DRAW_INDX_2         0x00003600
+#	define RADEON_3D_CLEAR_HIZ		0x00003700
+#       define RADEON_CP_3D_CLEAR_CMASK         0x00003802
+#	define RADEON_CNTL_HOSTDATA_BLT		0x00009400
+#	define RADEON_CNTL_PAINT_MULTI		0x00009A00
+#	define RADEON_CNTL_BITBLT_MULTI		0x00009B00
+#	define RADEON_CNTL_SET_SCISSORS		0xC0001E00
+
+#define RADEON_CP_PACKET_MASK		0xC0000000
+#define RADEON_CP_PACKET_COUNT_MASK	0x3fff0000
+#define RADEON_CP_PACKET0_REG_MASK	0x000007ff
+#define RADEON_CP_PACKET1_REG0_MASK	0x000007ff
+#define RADEON_CP_PACKET1_REG1_MASK	0x003ff800
+
+#define RADEON_VTX_Z_PRESENT			(1 << 31)
+#define RADEON_VTX_PKCOLOR_PRESENT		(1 << 3)
+
+#define RADEON_PRIM_TYPE_NONE			(0 << 0)
+#define RADEON_PRIM_TYPE_POINT			(1 << 0)
+#define RADEON_PRIM_TYPE_LINE			(2 << 0)
+#define RADEON_PRIM_TYPE_LINE_STRIP		(3 << 0)
+#define RADEON_PRIM_TYPE_TRI_LIST		(4 << 0)
+#define RADEON_PRIM_TYPE_TRI_FAN		(5 << 0)
+#define RADEON_PRIM_TYPE_TRI_STRIP		(6 << 0)
+#define RADEON_PRIM_TYPE_TRI_TYPE2		(7 << 0)
+#define RADEON_PRIM_TYPE_RECT_LIST		(8 << 0)
+#define RADEON_PRIM_TYPE_3VRT_POINT_LIST	(9 << 0)
+#define RADEON_PRIM_TYPE_3VRT_LINE_LIST		(10 << 0)
+#define RADEON_PRIM_TYPE_MASK                   0xf
+#define RADEON_PRIM_WALK_IND			(1 << 4)
+#define RADEON_PRIM_WALK_LIST			(2 << 4)
+#define RADEON_PRIM_WALK_RING			(3 << 4)
+#define RADEON_COLOR_ORDER_BGRA			(0 << 6)
+#define RADEON_COLOR_ORDER_RGBA			(1 << 6)
+#define RADEON_MAOS_ENABLE			(1 << 7)
+#define RADEON_VTX_FMT_R128_MODE		(0 << 8)
+#define RADEON_VTX_FMT_RADEON_MODE		(1 << 8)
+#define RADEON_NUM_VERTICES_SHIFT		16
+
+#define RADEON_COLOR_FORMAT_CI8		2
+#define RADEON_COLOR_FORMAT_ARGB1555	3
+#define RADEON_COLOR_FORMAT_RGB565	4
+#define RADEON_COLOR_FORMAT_ARGB8888	6
+#define RADEON_COLOR_FORMAT_RGB332	7
+#define RADEON_COLOR_FORMAT_RGB8	9
+#define RADEON_COLOR_FORMAT_ARGB4444	15
+
+#define RADEON_TXFORMAT_I8		0
+#define RADEON_TXFORMAT_AI88		1
+#define RADEON_TXFORMAT_RGB332		2
+#define RADEON_TXFORMAT_ARGB1555	3
+#define RADEON_TXFORMAT_RGB565		4
+#define RADEON_TXFORMAT_ARGB4444	5
+#define RADEON_TXFORMAT_ARGB8888	6
+#define RADEON_TXFORMAT_RGBA8888	7
+#define RADEON_TXFORMAT_Y8		8
+#define RADEON_TXFORMAT_VYUY422         10
+#define RADEON_TXFORMAT_YVYU422         11
+#define RADEON_TXFORMAT_DXT1            12
+#define RADEON_TXFORMAT_DXT23           14
+#define RADEON_TXFORMAT_DXT45           15
+
+#define R200_PP_TXCBLEND_0                0x2f00
+#define R200_PP_TXCBLEND_1                0x2f10
+#define R200_PP_TXCBLEND_2                0x2f20
+#define R200_PP_TXCBLEND_3                0x2f30
+#define R200_PP_TXCBLEND_4                0x2f40
+#define R200_PP_TXCBLEND_5                0x2f50
+#define R200_PP_TXCBLEND_6                0x2f60
+#define R200_PP_TXCBLEND_7                0x2f70
+#define R200_SE_TCL_LIGHT_MODEL_CTL_0     0x2268
+#define R200_PP_TFACTOR_0                 0x2ee0
+#define R200_SE_VTX_FMT_0                 0x2088
+#define R200_SE_VAP_CNTL                  0x2080
+#define R200_SE_TCL_MATRIX_SEL_0          0x2230
+#define R200_SE_TCL_TEX_PROC_CTL_2        0x22a8
+#define R200_SE_TCL_UCP_VERT_BLEND_CTL    0x22c0
+#define R200_PP_TXFILTER_5                0x2ca0
+#define R200_PP_TXFILTER_4                0x2c80
+#define R200_PP_TXFILTER_3                0x2c60
+#define R200_PP_TXFILTER_2                0x2c40
+#define R200_PP_TXFILTER_1                0x2c20
+#define R200_PP_TXFILTER_0                0x2c00
+#define R200_PP_TXOFFSET_5                0x2d78
+#define R200_PP_TXOFFSET_4                0x2d60
+#define R200_PP_TXOFFSET_3                0x2d48
+#define R200_PP_TXOFFSET_2                0x2d30
+#define R200_PP_TXOFFSET_1                0x2d18
+#define R200_PP_TXOFFSET_0                0x2d00
+
+#define R200_PP_CUBIC_FACES_0             0x2c18
+#define R200_PP_CUBIC_FACES_1             0x2c38
+#define R200_PP_CUBIC_FACES_2             0x2c58
+#define R200_PP_CUBIC_FACES_3             0x2c78
+#define R200_PP_CUBIC_FACES_4             0x2c98
+#define R200_PP_CUBIC_FACES_5             0x2cb8
+#define R200_PP_CUBIC_OFFSET_F1_0         0x2d04
+#define R200_PP_CUBIC_OFFSET_F2_0         0x2d08
+#define R200_PP_CUBIC_OFFSET_F3_0         0x2d0c
+#define R200_PP_CUBIC_OFFSET_F4_0         0x2d10
+#define R200_PP_CUBIC_OFFSET_F5_0         0x2d14
+#define R200_PP_CUBIC_OFFSET_F1_1         0x2d1c
+#define R200_PP_CUBIC_OFFSET_F2_1         0x2d20
+#define R200_PP_CUBIC_OFFSET_F3_1         0x2d24
+#define R200_PP_CUBIC_OFFSET_F4_1         0x2d28
+#define R200_PP_CUBIC_OFFSET_F5_1         0x2d2c
+#define R200_PP_CUBIC_OFFSET_F1_2         0x2d34
+#define R200_PP_CUBIC_OFFSET_F2_2         0x2d38
+#define R200_PP_CUBIC_OFFSET_F3_2         0x2d3c
+#define R200_PP_CUBIC_OFFSET_F4_2         0x2d40
+#define R200_PP_CUBIC_OFFSET_F5_2         0x2d44
+#define R200_PP_CUBIC_OFFSET_F1_3         0x2d4c
+#define R200_PP_CUBIC_OFFSET_F2_3         0x2d50
+#define R200_PP_CUBIC_OFFSET_F3_3         0x2d54
+#define R200_PP_CUBIC_OFFSET_F4_3         0x2d58
+#define R200_PP_CUBIC_OFFSET_F5_3         0x2d5c
+#define R200_PP_CUBIC_OFFSET_F1_4         0x2d64
+#define R200_PP_CUBIC_OFFSET_F2_4         0x2d68
+#define R200_PP_CUBIC_OFFSET_F3_4         0x2d6c
+#define R200_PP_CUBIC_OFFSET_F4_4         0x2d70
+#define R200_PP_CUBIC_OFFSET_F5_4         0x2d74
+#define R200_PP_CUBIC_OFFSET_F1_5         0x2d7c
+#define R200_PP_CUBIC_OFFSET_F2_5         0x2d80
+#define R200_PP_CUBIC_OFFSET_F3_5         0x2d84
+#define R200_PP_CUBIC_OFFSET_F4_5         0x2d88
+#define R200_PP_CUBIC_OFFSET_F5_5         0x2d8c
+
+#define R200_RE_AUX_SCISSOR_CNTL          0x26f0
+#define R200_SE_VTE_CNTL                  0x20b0
+#define R200_SE_TCL_OUTPUT_VTX_COMP_SEL   0x2250
+#define R200_PP_TAM_DEBUG3                0x2d9c
+#define R200_PP_CNTL_X                    0x2cc4
+#define R200_SE_VAP_CNTL_STATUS           0x2140
+#define R200_RE_SCISSOR_TL_0              0x1cd8
+#define R200_RE_SCISSOR_TL_1              0x1ce0
+#define R200_RE_SCISSOR_TL_2              0x1ce8
+#define R200_RB3D_DEPTHXY_OFFSET          0x1d60
+#define R200_RE_AUX_SCISSOR_CNTL          0x26f0
+#define R200_SE_VTX_STATE_CNTL            0x2180
+#define R200_RE_POINTSIZE                 0x2648
+#define R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0 0x2254
+
+#define RADEON_PP_TEX_SIZE_0                0x1d04	/* NPOT */
+#define RADEON_PP_TEX_SIZE_1                0x1d0c
+#define RADEON_PP_TEX_SIZE_2                0x1d14
+
+#define RADEON_PP_CUBIC_FACES_0             0x1d24
+#define RADEON_PP_CUBIC_FACES_1             0x1d28
+#define RADEON_PP_CUBIC_FACES_2             0x1d2c
+#define RADEON_PP_CUBIC_OFFSET_T0_0         0x1dd0	/* bits [31:5] */
+#define RADEON_PP_CUBIC_OFFSET_T1_0         0x1e00
+#define RADEON_PP_CUBIC_OFFSET_T2_0         0x1e14
+
+#define RADEON_SE_TCL_STATE_FLUSH           0x2284
+
+#define SE_VAP_CNTL__TCL_ENA_MASK                          0x00000001
+#define SE_VAP_CNTL__FORCE_W_TO_ONE_MASK                   0x00010000
+#define SE_VAP_CNTL__VF_MAX_VTX_NUM__SHIFT                 0x00000012
+#define SE_VTE_CNTL__VTX_XY_FMT_MASK                       0x00000100
+#define SE_VTE_CNTL__VTX_Z_FMT_MASK                        0x00000200
+#define SE_VTX_FMT_0__VTX_Z0_PRESENT_MASK                  0x00000001
+#define SE_VTX_FMT_0__VTX_W0_PRESENT_MASK                  0x00000002
+#define SE_VTX_FMT_0__VTX_COLOR_0_FMT__SHIFT               0x0000000b
+#define R200_3D_DRAW_IMMD_2      0xC0003500
+#define R200_SE_VTX_FMT_1                 0x208c
+#define R200_RE_CNTL                      0x1c50
+
+#define R200_RB3D_BLENDCOLOR              0x3218
+
+#define R200_SE_TCL_POINT_SPRITE_CNTL     0x22c4
+
+#define R200_PP_TRI_PERF                  0x2cf8
+
+#define R200_PP_AFS_0                     0x2f80
+#define R200_PP_AFS_1                     0x2f00 /* same as txcblend_0 */
+
+#define R200_VAP_PVS_CNTL_1               0x22D0
+
+/* MPEG settings from VHA code */
+#define RADEON_VHA_SETTO16_1                       0x2694
+#define RADEON_VHA_SETTO16_2                       0x2680
+#define RADEON_VHA_SETTO0_1                        0x1840
+#define RADEON_VHA_FB_OFFSET                       0x19e4
+#define RADEON_VHA_SETTO1AND70S                    0x19d8
+#define RADEON_VHA_DST_PITCH                       0x1408
+
+// set as reference header
+#define RADEON_VHA_BACKFRAME0_OFF_Y              0x1840
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_Y        0x1844
+#define RADEON_VHA_BACKFRAME0_OFF_U              0x1848
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_U        0x184c
+#define RADOEN_VHA_BACKFRAME0_OFF_V              0x1850
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_V        0x1854
+#define RADEON_VHA_FORWFRAME0_OFF_Y              0x1858
+#define RADEON_VHA_FORWFRAME1_OFF_PITCH_Y        0x185c
+#define RADEON_VHA_FORWFRAME0_OFF_U              0x1860
+#define RADEON_VHA_FORWFRAME1_OFF_PITCH_U        0x1864
+#define RADEON_VHA_FORWFRAME0_OFF_V              0x1868
+#define RADEON_VHA_FORWFRAME0_OFF_PITCH_V        0x1880
+#define RADEON_VHA_BACKFRAME0_OFF_Y_2            0x1884
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_Y_2      0x1888
+#define RADEON_VHA_BACKFRAME0_OFF_U_2            0x188c
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_U_2      0x1890
+#define RADEON_VHA_BACKFRAME0_OFF_V_2            0x1894
+#define RADEON_VHA_BACKFRAME1_OFF_PITCH_V_2      0x1898
+
+
+
+/* Constants */
+#define RADEON_MAX_USEC_TIMEOUT		100000	/* 100 ms */
+
+#define RADEON_LAST_FRAME_REG		RADEON_SCRATCH_REG0
+#define RADEON_LAST_DISPATCH_REG	RADEON_SCRATCH_REG1
+#define RADEON_LAST_CLEAR_REG		RADEON_SCRATCH_REG2
+#define RADEON_LAST_SWI_REG		RADEON_SCRATCH_REG3
+#define RADEON_LAST_DISPATCH		1
+
+#define RADEON_MAX_VB_AGE		0x7fffffff
+#define RADEON_MAX_VB_VERTS		(0xffff)
+
+#define RADEON_RING_HIGH_MARK		128
+
+#define RADEON_PCIGART_TABLE_SIZE      (32*1024)
+
+#define RADEON_READ(reg)	DRM_READ32(  dev_priv->mmio, (reg) )
+#define RADEON_WRITE(reg,val)	DRM_WRITE32( dev_priv->mmio, (reg), (val) )
+#define RADEON_READ8(reg)	DRM_READ8(  dev_priv->mmio, (reg) )
+#define RADEON_WRITE8(reg,val)	DRM_WRITE8( dev_priv->mmio, (reg), (val) )
+
+#define RADEON_WRITE_PLL( addr, val )					\
+do {									\
+	RADEON_WRITE8( RADEON_CLOCK_CNTL_INDEX,				\
+		       ((addr) & 0x1f) | RADEON_PLL_WR_EN );		\
+	RADEON_WRITE( RADEON_CLOCK_CNTL_DATA, (val) );			\
+} while (0)
+
+#define RADEON_WRITE_IGPGART( addr, val )				\
+do {									\
+	RADEON_WRITE( RADEON_IGPGART_INDEX,				\
+			((addr) & 0x7f) | (1 << 8));			\
+	RADEON_WRITE( RADEON_IGPGART_DATA, (val) );			\
+	RADEON_WRITE( RADEON_IGPGART_INDEX, 0x7f );			\
+} while (0)
+
+#define RADEON_WRITE_PCIE( addr, val )					\
+do {									\
+	RADEON_WRITE8( RADEON_PCIE_INDEX,				\
+			((addr) & 0xff));				\
+	RADEON_WRITE( RADEON_PCIE_DATA, (val) );			\
+} while (0)
+
+#define CP_PACKET0( reg, n )						\
+	(RADEON_CP_PACKET0 | ((n) << 16) | ((reg) >> 2))
+#define CP_PACKET0_TABLE( reg, n )					\
+	(RADEON_CP_PACKET0 | RADEON_ONE_REG_WR | ((n) << 16) | ((reg) >> 2))
+#define CP_PACKET1( reg0, reg1 )					\
+	(RADEON_CP_PACKET1 | (((reg1) >> 2) << 15) | ((reg0) >> 2))
+#define CP_PACKET2()							\
+	(RADEON_CP_PACKET2)
+#define CP_PACKET3( pkt, n )						\
+	(RADEON_CP_PACKET3 | (pkt) | ((n) << 16))
+
+/* ================================================================
+ * Engine control helper macros
+ */
+
+#define RADEON_WAIT_UNTIL_2D_IDLE() do {				\
+	OUT_RING( CP_PACKET0( RADEON_WAIT_UNTIL, 0 ) );			\
+	OUT_RING( (RADEON_WAIT_2D_IDLECLEAN |				\
+		   RADEON_WAIT_HOST_IDLECLEAN) );			\
+} while (0)
+
+#define RADEON_WAIT_UNTIL_3D_IDLE() do {				\
+	OUT_RING( CP_PACKET0( RADEON_WAIT_UNTIL, 0 ) );			\
+	OUT_RING( (RADEON_WAIT_3D_IDLECLEAN |				\
+		   RADEON_WAIT_HOST_IDLECLEAN) );			\
+} while (0)
+
+#define RADEON_WAIT_UNTIL_IDLE() do {					\
+	OUT_RING( CP_PACKET0( RADEON_WAIT_UNTIL, 0 ) );			\
+	OUT_RING( (RADEON_WAIT_2D_IDLECLEAN |				\
+		   RADEON_WAIT_3D_IDLECLEAN |				\
+		   RADEON_WAIT_HOST_IDLECLEAN) );			\
+} while (0)
+
+#define RADEON_WAIT_UNTIL_PAGE_FLIPPED() do {				\
+	OUT_RING( CP_PACKET0( RADEON_WAIT_UNTIL, 0 ) );			\
+	OUT_RING( RADEON_WAIT_CRTC_PFLIP );				\
+} while (0)
+
+#define RADEON_FLUSH_CACHE() do {					\
+	OUT_RING( CP_PACKET0( RADEON_RB3D_DSTCACHE_CTLSTAT, 0 ) );	\
+	OUT_RING( RADEON_RB3D_DC_FLUSH );				\
+} while (0)
+
+#define RADEON_PURGE_CACHE() do {					\
+	OUT_RING( CP_PACKET0( RADEON_RB3D_DSTCACHE_CTLSTAT, 0 ) );	\
+	OUT_RING( RADEON_RB3D_DC_FLUSH_ALL );				\
+} while (0)
+
+#define RADEON_FLUSH_ZCACHE() do {					\
+	OUT_RING( CP_PACKET0( RADEON_RB3D_ZCACHE_CTLSTAT, 0 ) );	\
+	OUT_RING( RADEON_RB3D_ZC_FLUSH );				\
+} while (0)
+
+#define RADEON_PURGE_ZCACHE() do {					\
+	OUT_RING( CP_PACKET0( RADEON_RB3D_ZCACHE_CTLSTAT, 0 ) );	\
+	OUT_RING( RADEON_RB3D_ZC_FLUSH_ALL );				\
+} while (0)
+
+/* ================================================================
+ * Misc helper macros
+ */
+
+/* Perfbox functionality only.
+ */
+#define RING_SPACE_TEST_WITH_RETURN( dev_priv )				\
+do {									\
+	if (!(dev_priv->stats.boxes & RADEON_BOX_DMA_IDLE)) {		\
+		u32 head = GET_RING_HEAD( dev_priv );			\
+		if (head == dev_priv->ring.tail)			\
+			dev_priv->stats.boxes |= RADEON_BOX_DMA_IDLE;	\
+	}								\
+} while (0)
+
+#define VB_AGE_TEST_WITH_RETURN( dev_priv )				\
+do {									\
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;		\
+	if ( sarea_priv->last_dispatch >= RADEON_MAX_VB_AGE ) {		\
+		int __ret = radeon_do_cp_idle( dev_priv );		\
+		if ( __ret ) return __ret;				\
+		sarea_priv->last_dispatch = 0;				\
+		radeon_freelist_reset( dev );				\
+	}								\
+} while (0)
+
+#define RADEON_DISPATCH_AGE( age ) do {					\
+	OUT_RING( CP_PACKET0( RADEON_LAST_DISPATCH_REG, 0 ) );		\
+	OUT_RING( age );						\
+} while (0)
+
+#define RADEON_FRAME_AGE( age ) do {					\
+	OUT_RING( CP_PACKET0( RADEON_LAST_FRAME_REG, 0 ) );		\
+	OUT_RING( age );						\
+} while (0)
+
+#define RADEON_CLEAR_AGE( age ) do {					\
+	OUT_RING( CP_PACKET0( RADEON_LAST_CLEAR_REG, 0 ) );		\
+	OUT_RING( age );						\
+} while (0)
+
+/* ================================================================
+ * Ring control
+ */
+
+#define RADEON_VERBOSE	0
+
+#define RING_LOCALS	int write, _nr; unsigned int mask; u32 *ring;
+
+#define BEGIN_RING( n ) do {						\
+	if ( RADEON_VERBOSE ) {						\
+		DRM_INFO( "BEGIN_RING( %d ) in %s\n",			\
+			   n, __FUNCTION__ );				\
+	}								\
+	if ( dev_priv->ring.space <= (n) * sizeof(u32) ) {		\
+		COMMIT_RING();						\
+		radeon_wait_ring( dev_priv, (n) * sizeof(u32) );	\
+	}								\
+	_nr = n; dev_priv->ring.space -= (n) * sizeof(u32);		\
+	ring = dev_priv->ring.start;					\
+	write = dev_priv->ring.tail;					\
+	mask = dev_priv->ring.tail_mask;				\
+} while (0)
+
+#define ADVANCE_RING() do {						\
+	if ( RADEON_VERBOSE ) {						\
+		DRM_INFO( "ADVANCE_RING() wr=0x%06x tail=0x%06x\n",	\
+			  write, dev_priv->ring.tail );			\
+	}								\
+	if (((dev_priv->ring.tail + _nr) & mask) != write) {		\
+		DRM_ERROR( 						\
+			"ADVANCE_RING(): mismatch: nr: %x write: %x line: %d\n",	\
+			((dev_priv->ring.tail + _nr) & mask),		\
+			write, __LINE__);						\
+	} else								\
+		dev_priv->ring.tail = write;				\
+} while (0)
+
+#define COMMIT_RING() do {						\
+	/* Flush writes to ring */					\
+	DRM_MEMORYBARRIER();						\
+	GET_RING_HEAD( dev_priv );					\
+	RADEON_WRITE( RADEON_CP_RB_WPTR, dev_priv->ring.tail );		\
+	/* read from PCI bus to ensure correct posting */		\
+	RADEON_READ( RADEON_CP_RB_RPTR );				\
+} while (0)
+
+#define OUT_RING( x ) do {						\
+	if ( RADEON_VERBOSE ) {						\
+		DRM_INFO( "   OUT_RING( 0x%08x ) at 0x%x\n",		\
+			   (unsigned int)(x), write );			\
+	}								\
+	ring[write++] = (x);						\
+	write &= mask;							\
+} while (0)
+
+#define OUT_RING_REG( reg, val ) do {					\
+	OUT_RING( CP_PACKET0( reg, 0 ) );				\
+	OUT_RING( val );						\
+} while (0)
+
+#define OUT_RING_TABLE( tab, sz ) do {				\
+	int _size = (sz);					\
+	int *_tab = (int *)(tab);				\
+								\
+	if (write + _size > mask) {				\
+		int _i = (mask+1) - write;			\
+		_size -= _i;					\
+		while (_i > 0) {				\
+			*(int *)(ring + write) = *_tab++;	\
+			write++;				\
+			_i--;					\
+		}						\
+		write = 0;					\
+		_tab += _i;					\
+	}							\
+	while (_size > 0) {					\
+		*(ring + write) = *_tab++;			\
+		write++;					\
+		_size--;					\
+	}							\
+	write &= mask;						\
+} while (0)
+
+#endif				/* __RADEON_DRV_H__ */
Index: git/shared-core/radeon_irq.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/radeon_irq.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,321 @@
+/* radeon_irq.c -- IRQ handling for radeon -*- linux-c -*- */
+/*
+ * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
+ *
+ * The Weather Channel (TM) funded Tungsten Graphics to develop the
+ * initial release of the Radeon 8500 driver under the XFree86 license.
+ * This notice must be preserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ *    Michel Dzer <michel@daenzer.net>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "radeon_drm.h"
+#include "radeon_drv.h"
+
+static __inline__ u32 radeon_acknowledge_irqs(drm_radeon_private_t * dev_priv,
+					      u32 mask)
+{
+	u32 irqs = RADEON_READ(RADEON_GEN_INT_STATUS) & mask;
+	if (irqs)
+		RADEON_WRITE(RADEON_GEN_INT_STATUS, irqs);
+	return irqs;
+}
+
+/* Interrupts - Used for device synchronization and flushing in the
+ * following circumstances:
+ *
+ * - Exclusive FB access with hw idle:
+ *    - Wait for GUI Idle (?) interrupt, then do normal flush.
+ *
+ * - Frame throttling, NV_fence:
+ *    - Drop marker irq's into command stream ahead of time.
+ *    - Wait on irq's with lock *not held*
+ *    - Check each for termination condition
+ *
+ * - Internally in cp_getbuffer, etc:
+ *    - as above, but wait with lock held???
+ *
+ * NOTE: These functions are misleadingly named -- the irq's aren't
+ * tied to dma at all, this is just a hangover from dri prehistory.
+ */
+
+irqreturn_t radeon_driver_irq_handler(DRM_IRQ_ARGS)
+{
+	struct drm_device *dev = (struct drm_device *) arg;
+	drm_radeon_private_t *dev_priv =
+	    (drm_radeon_private_t *) dev->dev_private;
+	u32 stat;
+
+	/* Only consider the bits we're interested in - others could be used
+	 * outside the DRM
+	 */
+	stat = radeon_acknowledge_irqs(dev_priv, (RADEON_SW_INT_TEST_ACK |
+						  RADEON_CRTC_VBLANK_STAT |
+						  RADEON_CRTC2_VBLANK_STAT));
+	if (!stat)
+		return IRQ_NONE;
+
+	stat &= dev_priv->irq_enable_reg;
+
+	/* SW interrupt */
+	if (stat & RADEON_SW_INT_TEST) {
+		DRM_WAKEUP(&dev_priv->swi_queue);
+	}
+
+	/* VBLANK interrupt */
+	if (stat & (RADEON_CRTC_VBLANK_STAT|RADEON_CRTC2_VBLANK_STAT)) {
+		int vblank_crtc = dev_priv->vblank_crtc;
+
+		if ((vblank_crtc &
+		     (DRM_RADEON_VBLANK_CRTC1 | DRM_RADEON_VBLANK_CRTC2)) ==
+		    (DRM_RADEON_VBLANK_CRTC1 | DRM_RADEON_VBLANK_CRTC2)) {
+			if (stat & RADEON_CRTC_VBLANK_STAT)
+				atomic_inc(&dev->vbl_received);
+			if (stat & RADEON_CRTC2_VBLANK_STAT)
+				atomic_inc(&dev->vbl_received2);
+		} else if (((stat & RADEON_CRTC_VBLANK_STAT) &&
+			   (vblank_crtc & DRM_RADEON_VBLANK_CRTC1)) ||
+			   ((stat & RADEON_CRTC2_VBLANK_STAT) &&
+			    (vblank_crtc & DRM_RADEON_VBLANK_CRTC2)))
+			atomic_inc(&dev->vbl_received);
+
+		DRM_WAKEUP(&dev->vbl_queue);
+		drm_vbl_send_signals(dev);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int radeon_emit_irq(struct drm_device * dev)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	unsigned int ret;
+	RING_LOCALS;
+
+	atomic_inc(&dev_priv->swi_emitted);
+	ret = atomic_read(&dev_priv->swi_emitted);
+
+	BEGIN_RING(4);
+	OUT_RING_REG(RADEON_LAST_SWI_REG, ret);
+	OUT_RING_REG(RADEON_GEN_INT_STATUS, RADEON_SW_INT_FIRE);
+	ADVANCE_RING();
+	COMMIT_RING();
+
+	return ret;
+}
+
+static int radeon_wait_irq(struct drm_device * dev, int swi_nr)
+{
+	drm_radeon_private_t *dev_priv =
+	    (drm_radeon_private_t *) dev->dev_private;
+	int ret = 0;
+
+	if (RADEON_READ(RADEON_LAST_SWI_REG) >= swi_nr)
+		return 0;
+
+	dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
+
+	DRM_WAIT_ON(ret, dev_priv->swi_queue, 3 * DRM_HZ,
+		    RADEON_READ(RADEON_LAST_SWI_REG) >= swi_nr);
+
+	return ret;
+}
+
+static int radeon_driver_vblank_do_wait(struct drm_device * dev,
+					unsigned int *sequence,
+					int crtc)
+{
+	drm_radeon_private_t *dev_priv =
+	    (drm_radeon_private_t *) dev->dev_private;
+	unsigned int cur_vblank;
+	int ret = 0;
+	int ack = 0;
+	atomic_t *counter;
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (crtc == DRM_RADEON_VBLANK_CRTC1) {
+		counter = &dev->vbl_received;
+		ack |= RADEON_CRTC_VBLANK_STAT;
+	} else if (crtc == DRM_RADEON_VBLANK_CRTC2) {
+		counter = &dev->vbl_received2;
+		ack |= RADEON_CRTC2_VBLANK_STAT;
+	} else
+		return -EINVAL;
+
+	radeon_acknowledge_irqs(dev_priv, ack);
+
+	dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
+
+	/* Assume that the user has missed the current sequence number
+	 * by about a day rather than she wants to wait for years
+	 * using vertical blanks...
+	 */
+	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
+		    (((cur_vblank = atomic_read(counter))
+		      - *sequence) <= (1 << 23)));
+
+	*sequence = cur_vblank;
+
+	return ret;
+}
+
+int radeon_driver_vblank_wait(struct drm_device *dev, unsigned int *sequence)
+{
+	return radeon_driver_vblank_do_wait(dev, sequence, DRM_RADEON_VBLANK_CRTC1);
+}
+
+int radeon_driver_vblank_wait2(struct drm_device *dev, unsigned int *sequence)
+{
+	return radeon_driver_vblank_do_wait(dev, sequence, DRM_RADEON_VBLANK_CRTC2);
+}
+
+/* Needs the lock as it touches the ring.
+ */
+int radeon_irq_emit(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_irq_emit_t *emit = data;
+	int result;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	result = radeon_emit_irq(dev);
+
+	if (DRM_COPY_TO_USER(emit->irq_seq, &result, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/* Doesn't need the hardware lock.
+ */
+int radeon_irq_wait(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_irq_wait_t *irqwait = data;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	return radeon_wait_irq(dev, irqwait->irq_seq);
+}
+
+static void radeon_enable_interrupt(struct drm_device *dev)
+{
+	drm_radeon_private_t *dev_priv = (drm_radeon_private_t *) dev->dev_private;
+
+	dev_priv->irq_enable_reg = RADEON_SW_INT_ENABLE;
+	if (dev_priv->vblank_crtc & DRM_RADEON_VBLANK_CRTC1)
+		dev_priv->irq_enable_reg |= RADEON_CRTC_VBLANK_MASK;
+
+	if (dev_priv->vblank_crtc & DRM_RADEON_VBLANK_CRTC2)
+		dev_priv->irq_enable_reg |= RADEON_CRTC2_VBLANK_MASK;
+
+	RADEON_WRITE(RADEON_GEN_INT_CNTL, dev_priv->irq_enable_reg);
+	dev_priv->irq_enabled = 1;
+}
+
+/* drm_dma.h hooks
+*/
+void radeon_driver_irq_preinstall(struct drm_device * dev)
+{
+	drm_radeon_private_t *dev_priv =
+	    (drm_radeon_private_t *) dev->dev_private;
+
+	/* Disable *all* interrupts */
+	RADEON_WRITE(RADEON_GEN_INT_CNTL, 0);
+
+	/* Clear bits if they're already high */
+	radeon_acknowledge_irqs(dev_priv, (RADEON_SW_INT_TEST_ACK |
+					   RADEON_CRTC_VBLANK_STAT |
+					   RADEON_CRTC2_VBLANK_STAT));
+}
+
+void radeon_driver_irq_postinstall(struct drm_device * dev)
+{
+	drm_radeon_private_t *dev_priv =
+	    (drm_radeon_private_t *) dev->dev_private;
+
+	atomic_set(&dev_priv->swi_emitted, 0);
+	DRM_INIT_WAITQUEUE(&dev_priv->swi_queue);
+
+	radeon_enable_interrupt(dev);
+}
+
+void radeon_driver_irq_uninstall(struct drm_device * dev)
+{
+	drm_radeon_private_t *dev_priv =
+	    (drm_radeon_private_t *) dev->dev_private;
+	if (!dev_priv)
+		return;
+
+	dev_priv->irq_enabled = 0;
+
+	/* Disable *all* interrupts */
+	RADEON_WRITE(RADEON_GEN_INT_CNTL, 0);
+}
+
+
+int radeon_vblank_crtc_get(struct drm_device *dev)
+{
+	drm_radeon_private_t *dev_priv = (drm_radeon_private_t *) dev->dev_private;
+	u32 flag;
+	u32 value;
+
+	flag = RADEON_READ(RADEON_GEN_INT_CNTL);
+	value = 0;
+
+	if (flag & RADEON_CRTC_VBLANK_MASK)
+		value |= DRM_RADEON_VBLANK_CRTC1;
+
+	if (flag & RADEON_CRTC2_VBLANK_MASK)
+		value |= DRM_RADEON_VBLANK_CRTC2;
+	return value;
+}
+
+int radeon_vblank_crtc_set(struct drm_device *dev, int64_t value)
+{
+	drm_radeon_private_t *dev_priv = (drm_radeon_private_t *) dev->dev_private;
+	if (value & ~(DRM_RADEON_VBLANK_CRTC1 | DRM_RADEON_VBLANK_CRTC2)) {
+		DRM_ERROR("called with invalid crtc 0x%x\n", (unsigned int)value);
+		return -EINVAL;
+	}
+	dev_priv->vblank_crtc = (unsigned int)value;
+	radeon_enable_interrupt(dev);
+	return 0;
+}
Index: git/shared-core/radeon_mem.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/radeon_mem.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,302 @@
+/* radeon_mem.c -- Simple GART/fb memory manager for radeon -*- linux-c -*- */
+/*
+ * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
+ *
+ * The Weather Channel (TM) funded Tungsten Graphics to develop the
+ * initial release of the Radeon 8500 driver under the XFree86 license.
+ * This notice must be preserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "radeon_drm.h"
+#include "radeon_drv.h"
+
+/* Very simple allocator for GART memory, working on a static range
+ * already mapped into each client's address space.
+ */
+
+static struct mem_block *split_block(struct mem_block *p, int start, int size,
+				     struct drm_file *file_priv)
+{
+	/* Maybe cut off the start of an existing block */
+	if (start > p->start) {
+		struct mem_block *newblock =
+		    drm_alloc(sizeof(*newblock), DRM_MEM_BUFS);
+		if (!newblock)
+			goto out;
+		newblock->start = start;
+		newblock->size = p->size - (start - p->start);
+		newblock->file_priv = NULL;
+		newblock->next = p->next;
+		newblock->prev = p;
+		p->next->prev = newblock;
+		p->next = newblock;
+		p->size -= newblock->size;
+		p = newblock;
+	}
+
+	/* Maybe cut off the end of an existing block */
+	if (size < p->size) {
+		struct mem_block *newblock =
+		    drm_alloc(sizeof(*newblock), DRM_MEM_BUFS);
+		if (!newblock)
+			goto out;
+		newblock->start = start + size;
+		newblock->size = p->size - size;
+		newblock->file_priv = NULL;
+		newblock->next = p->next;
+		newblock->prev = p;
+		p->next->prev = newblock;
+		p->next = newblock;
+		p->size = size;
+	}
+
+      out:
+	/* Our block is in the middle */
+	p->file_priv = file_priv;
+	return p;
+}
+
+static struct mem_block *alloc_block(struct mem_block *heap, int size,
+				     int align2, struct drm_file *file_priv)
+{
+	struct mem_block *p;
+	int mask = (1 << align2) - 1;
+
+	list_for_each(p, heap) {
+		int start = (p->start + mask) & ~mask;
+		if (p->file_priv == 0 && start + size <= p->start + p->size)
+			return split_block(p, start, size, file_priv);
+	}
+
+	return NULL;
+}
+
+static struct mem_block *find_block(struct mem_block *heap, int start)
+{
+	struct mem_block *p;
+
+	list_for_each(p, heap)
+		if (p->start == start)
+			return p;
+
+	return NULL;
+}
+
+static void free_block(struct mem_block *p)
+{
+	p->file_priv = NULL;
+
+	/* Assumes a single contiguous range.  Needs a special file_priv in
+	 * 'heap' to stop it being subsumed.
+	 */
+	if (p->next->file_priv == 0) {
+		struct mem_block *q = p->next;
+		p->size += q->size;
+		p->next = q->next;
+		p->next->prev = p;
+		drm_free(q, sizeof(*q), DRM_MEM_BUFS);
+	}
+
+	if (p->prev->file_priv == 0) {
+		struct mem_block *q = p->prev;
+		q->size += p->size;
+		q->next = p->next;
+		q->next->prev = q;
+		drm_free(p, sizeof(*q), DRM_MEM_BUFS);
+	}
+}
+
+/* Initialize.  How to check for an uninitialized heap?
+ */
+static int init_heap(struct mem_block **heap, int start, int size)
+{
+	struct mem_block *blocks = drm_alloc(sizeof(*blocks), DRM_MEM_BUFS);
+
+	if (!blocks)
+		return -ENOMEM;
+
+	*heap = drm_alloc(sizeof(**heap), DRM_MEM_BUFS);
+	if (!*heap) {
+		drm_free(blocks, sizeof(*blocks), DRM_MEM_BUFS);
+		return -ENOMEM;
+	}
+
+	blocks->start = start;
+	blocks->size = size;
+	blocks->file_priv = NULL;
+	blocks->next = blocks->prev = *heap;
+
+	memset(*heap, 0, sizeof(**heap));
+	(*heap)->file_priv = (struct drm_file *) - 1;
+	(*heap)->next = (*heap)->prev = blocks;
+	return 0;
+}
+
+/* Free all blocks associated with the releasing file.
+ */
+void radeon_mem_release(struct drm_file *file_priv, struct mem_block *heap)
+{
+	struct mem_block *p;
+
+	if (!heap || !heap->next)
+		return;
+
+	list_for_each(p, heap) {
+		if (p->file_priv == file_priv)
+			p->file_priv = NULL;
+	}
+
+	/* Assumes a single contiguous range.  Needs a special file_priv in
+	 * 'heap' to stop it being subsumed.
+	 */
+	list_for_each(p, heap) {
+		while (p->file_priv == 0 && p->next->file_priv == 0) {
+			struct mem_block *q = p->next;
+			p->size += q->size;
+			p->next = q->next;
+			p->next->prev = p;
+			drm_free(q, sizeof(*q), DRM_MEM_DRIVER);
+		}
+	}
+}
+
+/* Shutdown.
+ */
+void radeon_mem_takedown(struct mem_block **heap)
+{
+	struct mem_block *p;
+
+	if (!*heap)
+		return;
+
+	for (p = (*heap)->next; p != *heap;) {
+		struct mem_block *q = p;
+		p = p->next;
+		drm_free(q, sizeof(*q), DRM_MEM_DRIVER);
+	}
+
+	drm_free(*heap, sizeof(**heap), DRM_MEM_DRIVER);
+	*heap = NULL;
+}
+
+/* IOCTL HANDLERS */
+
+static struct mem_block **get_heap(drm_radeon_private_t * dev_priv, int region)
+{
+	switch (region) {
+	case RADEON_MEM_REGION_GART:
+		return &dev_priv->gart_heap;
+	case RADEON_MEM_REGION_FB:
+		return &dev_priv->fb_heap;
+	default:
+		return NULL;
+	}
+}
+
+int radeon_mem_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_mem_alloc_t *alloc = data;
+	struct mem_block *block, **heap;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	heap = get_heap(dev_priv, alloc->region);
+	if (!heap || !*heap)
+		return -EFAULT;
+
+	/* Make things easier on ourselves: all allocations at least
+	 * 4k aligned.
+	 */
+	if (alloc->alignment < 12)
+		alloc->alignment = 12;
+
+	block = alloc_block(*heap, alloc->size, alloc->alignment, file_priv);
+
+	if (!block)
+		return -ENOMEM;
+
+	if (DRM_COPY_TO_USER(alloc->region_offset, &block->start,
+			     sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+int radeon_mem_free(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_mem_free_t *memfree = data;
+	struct mem_block *block, **heap;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	heap = get_heap(dev_priv, memfree->region);
+	if (!heap || !*heap)
+		return -EFAULT;
+
+	block = find_block(*heap, memfree->region_offset);
+	if (!block)
+		return -EFAULT;
+
+	if (block->file_priv != file_priv)
+		return -EPERM;
+
+	free_block(block);
+	return 0;
+}
+
+int radeon_mem_init_heap(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_mem_init_heap_t *initheap = data;
+	struct mem_block **heap;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	heap = get_heap(dev_priv, initheap->region);
+	if (!heap)
+		return -EFAULT;
+
+	if (*heap) {
+		DRM_ERROR("heap already initialized?");
+		return -EFAULT;
+	}
+
+	return init_heap(heap, initheap->start, initheap->size);
+}
Index: git/shared-core/radeon_state.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/radeon_state.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,3240 @@
+/* radeon_state.c -- State support for Radeon -*- linux-c -*- */
+/*
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Kevin E. Martin <martin@valinux.com>
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "drm_sarea.h"
+#include "radeon_drm.h"
+#include "radeon_drv.h"
+
+/* ================================================================
+ * Helper functions for client state checking and fixup
+ */
+
+static __inline__ int radeon_check_and_fixup_offset(drm_radeon_private_t *
+						    dev_priv,
+						    struct drm_file *file_priv,
+						    u32 * offset)
+{
+	u64 off = *offset;
+	u32 fb_end = dev_priv->fb_location + dev_priv->fb_size - 1;
+	struct drm_radeon_driver_file_fields *radeon_priv;
+
+	/* Hrm ... the story of the offset ... So this function converts
+	 * the various ideas of what userland clients might have for an
+	 * offset in the card address space into an offset into the card
+	 * address space :) So with a sane client, it should just keep
+	 * the value intact and just do some boundary checking. However,
+	 * not all clients are sane. Some older clients pass us 0 based
+	 * offsets relative to the start of the framebuffer and some may
+	 * assume the AGP aperture it appended to the framebuffer, so we
+	 * try to detect those cases and fix them up.
+	 *
+	 * Note: It might be a good idea here to make sure the offset lands
+	 * in some "allowed" area to protect things like the PCIE GART...
+	 */
+
+	/* First, the best case, the offset already lands in either the
+	 * framebuffer or the GART mapped space
+	 */
+	if (radeon_check_offset(dev_priv, off))
+		return 0;
+
+	/* Ok, that didn't happen... now check if we have a zero based
+	 * offset that fits in the framebuffer + gart space, apply the
+	 * magic offset we get from SETPARAM or calculated from fb_location
+	 */
+	if (off < (dev_priv->fb_size + dev_priv->gart_size)) {
+		radeon_priv = file_priv->driver_priv;
+		off += radeon_priv->radeon_fb_delta;
+	}
+
+	/* Finally, assume we aimed at a GART offset if beyond the fb */
+	if (off > fb_end)
+		off = off - fb_end - 1 + dev_priv->gart_vm_start;
+
+	/* Now recheck and fail if out of bounds */
+	if (radeon_check_offset(dev_priv, off)) {
+		DRM_DEBUG("offset fixed up to 0x%x\n", (unsigned int)off);
+		*offset = off;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static __inline__ int radeon_check_and_fixup_packets(drm_radeon_private_t *
+						     dev_priv,
+						     struct drm_file *file_priv,
+						     int id, u32 *data)
+{
+	switch (id) {
+
+	case RADEON_EMIT_PP_MISC:
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
+		    &data[(RADEON_RB3D_DEPTHOFFSET - RADEON_PP_MISC) / 4])) {
+			DRM_ERROR("Invalid depth buffer offset\n");
+			return -EINVAL;
+		}
+		break;
+
+	case RADEON_EMIT_PP_CNTL:
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
+		    &data[(RADEON_RB3D_COLOROFFSET - RADEON_PP_CNTL) / 4])) {
+			DRM_ERROR("Invalid colour buffer offset\n");
+			return -EINVAL;
+		}
+		break;
+
+	case R200_EMIT_PP_TXOFFSET_0:
+	case R200_EMIT_PP_TXOFFSET_1:
+	case R200_EMIT_PP_TXOFFSET_2:
+	case R200_EMIT_PP_TXOFFSET_3:
+	case R200_EMIT_PP_TXOFFSET_4:
+	case R200_EMIT_PP_TXOFFSET_5:
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
+						  &data[0])) {
+			DRM_ERROR("Invalid R200 texture offset\n");
+			return -EINVAL;
+		}
+		break;
+
+	case RADEON_EMIT_PP_TXFILTER_0:
+	case RADEON_EMIT_PP_TXFILTER_1:
+	case RADEON_EMIT_PP_TXFILTER_2:
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
+		    &data[(RADEON_PP_TXOFFSET_0 - RADEON_PP_TXFILTER_0) / 4])) {
+			DRM_ERROR("Invalid R100 texture offset\n");
+			return -EINVAL;
+		}
+		break;
+
+	case R200_EMIT_PP_CUBIC_OFFSETS_0:
+	case R200_EMIT_PP_CUBIC_OFFSETS_1:
+	case R200_EMIT_PP_CUBIC_OFFSETS_2:
+	case R200_EMIT_PP_CUBIC_OFFSETS_3:
+	case R200_EMIT_PP_CUBIC_OFFSETS_4:
+	case R200_EMIT_PP_CUBIC_OFFSETS_5:{
+			int i;
+			for (i = 0; i < 5; i++) {
+				if (radeon_check_and_fixup_offset(dev_priv,
+								  file_priv,
+								  &data[i])) {
+					DRM_ERROR
+					    ("Invalid R200 cubic texture offset\n");
+					return -EINVAL;
+				}
+			}
+			break;
+		}
+
+	case RADEON_EMIT_PP_CUBIC_OFFSETS_T0:
+	case RADEON_EMIT_PP_CUBIC_OFFSETS_T1:
+	case RADEON_EMIT_PP_CUBIC_OFFSETS_T2:{
+			int i;
+			for (i = 0; i < 5; i++) {
+				if (radeon_check_and_fixup_offset(dev_priv,
+								  file_priv,
+								  &data[i])) {
+					DRM_ERROR
+					    ("Invalid R100 cubic texture offset\n");
+					return -EINVAL;
+				}
+			}
+		}
+		break;
+
+	case R200_EMIT_VAP_CTL: {
+			RING_LOCALS;
+			BEGIN_RING(2);
+			OUT_RING_REG(RADEON_SE_TCL_STATE_FLUSH, 0);
+			ADVANCE_RING();
+		}
+		break;
+
+	case RADEON_EMIT_RB3D_COLORPITCH:
+	case RADEON_EMIT_RE_LINE_PATTERN:
+	case RADEON_EMIT_SE_LINE_WIDTH:
+	case RADEON_EMIT_PP_LUM_MATRIX:
+	case RADEON_EMIT_PP_ROT_MATRIX_0:
+	case RADEON_EMIT_RB3D_STENCILREFMASK:
+	case RADEON_EMIT_SE_VPORT_XSCALE:
+	case RADEON_EMIT_SE_CNTL:
+	case RADEON_EMIT_SE_CNTL_STATUS:
+	case RADEON_EMIT_RE_MISC:
+	case RADEON_EMIT_PP_BORDER_COLOR_0:
+	case RADEON_EMIT_PP_BORDER_COLOR_1:
+	case RADEON_EMIT_PP_BORDER_COLOR_2:
+	case RADEON_EMIT_SE_ZBIAS_FACTOR:
+	case RADEON_EMIT_SE_TCL_OUTPUT_VTX_FMT:
+	case RADEON_EMIT_SE_TCL_MATERIAL_EMMISSIVE_RED:
+	case R200_EMIT_PP_TXCBLEND_0:
+	case R200_EMIT_PP_TXCBLEND_1:
+	case R200_EMIT_PP_TXCBLEND_2:
+	case R200_EMIT_PP_TXCBLEND_3:
+	case R200_EMIT_PP_TXCBLEND_4:
+	case R200_EMIT_PP_TXCBLEND_5:
+	case R200_EMIT_PP_TXCBLEND_6:
+	case R200_EMIT_PP_TXCBLEND_7:
+	case R200_EMIT_TCL_LIGHT_MODEL_CTL_0:
+	case R200_EMIT_TFACTOR_0:
+	case R200_EMIT_VTX_FMT_0:
+	case R200_EMIT_MATRIX_SELECT_0:
+	case R200_EMIT_TEX_PROC_CTL_2:
+	case R200_EMIT_TCL_UCP_VERT_BLEND_CTL:
+	case R200_EMIT_PP_TXFILTER_0:
+	case R200_EMIT_PP_TXFILTER_1:
+	case R200_EMIT_PP_TXFILTER_2:
+	case R200_EMIT_PP_TXFILTER_3:
+	case R200_EMIT_PP_TXFILTER_4:
+	case R200_EMIT_PP_TXFILTER_5:
+	case R200_EMIT_VTE_CNTL:
+	case R200_EMIT_OUTPUT_VTX_COMP_SEL:
+	case R200_EMIT_PP_TAM_DEBUG3:
+	case R200_EMIT_PP_CNTL_X:
+	case R200_EMIT_RB3D_DEPTHXY_OFFSET:
+	case R200_EMIT_RE_AUX_SCISSOR_CNTL:
+	case R200_EMIT_RE_SCISSOR_TL_0:
+	case R200_EMIT_RE_SCISSOR_TL_1:
+	case R200_EMIT_RE_SCISSOR_TL_2:
+	case R200_EMIT_SE_VAP_CNTL_STATUS:
+	case R200_EMIT_SE_VTX_STATE_CNTL:
+	case R200_EMIT_RE_POINTSIZE:
+	case R200_EMIT_TCL_INPUT_VTX_VECTOR_ADDR_0:
+	case R200_EMIT_PP_CUBIC_FACES_0:
+	case R200_EMIT_PP_CUBIC_FACES_1:
+	case R200_EMIT_PP_CUBIC_FACES_2:
+	case R200_EMIT_PP_CUBIC_FACES_3:
+	case R200_EMIT_PP_CUBIC_FACES_4:
+	case R200_EMIT_PP_CUBIC_FACES_5:
+	case RADEON_EMIT_PP_TEX_SIZE_0:
+	case RADEON_EMIT_PP_TEX_SIZE_1:
+	case RADEON_EMIT_PP_TEX_SIZE_2:
+	case R200_EMIT_RB3D_BLENDCOLOR:
+	case R200_EMIT_TCL_POINT_SPRITE_CNTL:
+	case RADEON_EMIT_PP_CUBIC_FACES_0:
+	case RADEON_EMIT_PP_CUBIC_FACES_1:
+	case RADEON_EMIT_PP_CUBIC_FACES_2:
+	case R200_EMIT_PP_TRI_PERF_CNTL:
+	case R200_EMIT_PP_AFS_0:
+	case R200_EMIT_PP_AFS_1:
+	case R200_EMIT_ATF_TFACTOR:
+	case R200_EMIT_PP_TXCTLALL_0:
+	case R200_EMIT_PP_TXCTLALL_1:
+	case R200_EMIT_PP_TXCTLALL_2:
+	case R200_EMIT_PP_TXCTLALL_3:
+	case R200_EMIT_PP_TXCTLALL_4:
+	case R200_EMIT_PP_TXCTLALL_5:
+	case R200_EMIT_VAP_PVS_CNTL:
+		/* These packets don't contain memory offsets */
+		break;
+
+	default:
+		DRM_ERROR("Unknown state packet ID %d\n", id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static __inline__ int radeon_check_and_fixup_packet3(drm_radeon_private_t *
+						     dev_priv,
+						     struct drm_file *file_priv,
+						     drm_radeon_kcmd_buffer_t *
+						     cmdbuf,
+						     unsigned int *cmdsz)
+{
+	u32 *cmd = (u32 *) cmdbuf->buf;
+	u32 offset, narrays;
+	int count, i, k;
+
+	*cmdsz = 2 + ((cmd[0] & RADEON_CP_PACKET_COUNT_MASK) >> 16);
+
+	if ((cmd[0] & 0xc0000000) != RADEON_CP_PACKET3) {
+		DRM_ERROR("Not a type 3 packet\n");
+		return -EINVAL;
+	}
+
+	if (4 * *cmdsz > cmdbuf->bufsz) {
+		DRM_ERROR("Packet size larger than size of data provided\n");
+		return -EINVAL;
+	}
+
+	switch(cmd[0] & 0xff00) {
+	/* XXX Are there old drivers needing other packets? */
+
+	case RADEON_3D_DRAW_IMMD:
+	case RADEON_3D_DRAW_VBUF:
+	case RADEON_3D_DRAW_INDX:
+	case RADEON_WAIT_FOR_IDLE:
+	case RADEON_CP_NOP:
+	case RADEON_3D_CLEAR_ZMASK:
+/*	case RADEON_CP_NEXT_CHAR:
+	case RADEON_CP_PLY_NEXTSCAN:
+	case RADEON_CP_SET_SCISSORS: */ /* probably safe but will never need them? */
+		/* these packets are safe */
+		break;
+
+	case RADEON_CP_3D_DRAW_IMMD_2:
+	case RADEON_CP_3D_DRAW_VBUF_2:
+	case RADEON_CP_3D_DRAW_INDX_2:
+	case RADEON_3D_CLEAR_HIZ:
+		/* safe but r200 only */
+		if (dev_priv->microcode_version != UCODE_R200) {
+			DRM_ERROR("Invalid 3d packet for r100-class chip\n");
+			return -EINVAL;
+		}
+		break;
+
+	case RADEON_3D_LOAD_VBPNTR:
+		count = (cmd[0] >> 16) & 0x3fff;
+
+		if (count > 18) { /* 12 arrays max */
+			DRM_ERROR("Too large payload in 3D_LOAD_VBPNTR (count=%d)\n",
+				  count);
+			return -EINVAL;
+		}
+
+		/* carefully check packet contents */
+		narrays = cmd[1] & ~0xc000;
+		k = 0;
+		i = 2;
+		while ((k < narrays) && (i < (count + 2))) {
+			i++;		/* skip attribute field */
+			if (radeon_check_and_fixup_offset(dev_priv, file_priv,
+							  &cmd[i])) {
+				DRM_ERROR
+				    ("Invalid offset (k=%d i=%d) in 3D_LOAD_VBPNTR packet.\n",
+				     k, i);
+				return -EINVAL;
+			}
+			k++;
+			i++;
+			if (k == narrays)
+				break;
+			/* have one more to process, they come in pairs */
+			if (radeon_check_and_fixup_offset(dev_priv,
+							  file_priv, &cmd[i]))
+			{
+				DRM_ERROR
+				    ("Invalid offset (k=%d i=%d) in 3D_LOAD_VBPNTR packet.\n",
+				     k, i);
+				return -EINVAL;
+			}
+			k++;
+			i++;
+		}
+		/* do the counts match what we expect ? */
+		if ((k != narrays) || (i != (count + 2))) {
+			DRM_ERROR
+			    ("Malformed 3D_LOAD_VBPNTR packet (k=%d i=%d narrays=%d count+1=%d).\n",
+			      k, i, narrays, count + 1);
+			return -EINVAL;
+		}
+		break;
+
+	case RADEON_3D_RNDR_GEN_INDX_PRIM:
+		if (dev_priv->microcode_version != UCODE_R100) {
+			DRM_ERROR("Invalid 3d packet for r200-class chip\n");
+			return -EINVAL;
+		}
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv, &cmd[1])) {
+				DRM_ERROR("Invalid rndr_gen_indx offset\n");
+				return -EINVAL;
+		}
+		break;
+
+	case RADEON_CP_INDX_BUFFER:
+		if (dev_priv->microcode_version != UCODE_R200) {
+			DRM_ERROR("Invalid 3d packet for r100-class chip\n");
+			return -EINVAL;
+		}
+		if ((cmd[1] & 0x8000ffff) != 0x80000810) {
+			DRM_ERROR("Invalid indx_buffer reg address %08X\n", cmd[1]);
+			return -EINVAL;
+		}
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv, &cmd[2])) {
+			DRM_ERROR("Invalid indx_buffer offset is %08X\n", cmd[2]);
+			return -EINVAL;
+		}
+		break;
+
+	case RADEON_CNTL_HOSTDATA_BLT:
+	case RADEON_CNTL_PAINT_MULTI:
+	case RADEON_CNTL_BITBLT_MULTI:
+		/* MSB of opcode: next DWORD GUI_CNTL */
+		if (cmd[1] & (RADEON_GMC_SRC_PITCH_OFFSET_CNTL
+			      | RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {
+			offset = cmd[2] << 10;
+			if (radeon_check_and_fixup_offset
+			    (dev_priv, file_priv, &offset)) {
+				DRM_ERROR("Invalid first packet offset\n");
+				return -EINVAL;
+			}
+			cmd[2] = (cmd[2] & 0xffc00000) | offset >> 10;
+		}
+
+		if ((cmd[1] & RADEON_GMC_SRC_PITCH_OFFSET_CNTL) &&
+		    (cmd[1] & RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {
+			offset = cmd[3] << 10;
+			if (radeon_check_and_fixup_offset
+			    (dev_priv, file_priv, &offset)) {
+				DRM_ERROR("Invalid second packet offset\n");
+				return -EINVAL;
+			}
+			cmd[3] = (cmd[3] & 0xffc00000) | offset >> 10;
+		}
+		break;
+
+	default:
+		DRM_ERROR("Invalid packet type %x\n", cmd[0] & 0xff00);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* ================================================================
+ * CP hardware state programming functions
+ */
+
+static __inline__ void radeon_emit_clip_rect(drm_radeon_private_t * dev_priv,
+					     struct drm_clip_rect * box)
+{
+	RING_LOCALS;
+
+	DRM_DEBUG("   box:  x1=%d y1=%d  x2=%d y2=%d\n",
+		  box->x1, box->y1, box->x2, box->y2);
+
+	BEGIN_RING(4);
+	OUT_RING(CP_PACKET0(RADEON_RE_TOP_LEFT, 0));
+	OUT_RING((box->y1 << 16) | box->x1);
+	OUT_RING(CP_PACKET0(RADEON_RE_WIDTH_HEIGHT, 0));
+	OUT_RING(((box->y2 - 1) << 16) | (box->x2 - 1));
+	ADVANCE_RING();
+}
+
+/* Emit 1.1 state
+ */
+static int radeon_emit_state(drm_radeon_private_t * dev_priv,
+			     struct drm_file *file_priv,
+			     drm_radeon_context_regs_t * ctx,
+			     drm_radeon_texture_regs_t * tex,
+			     unsigned int dirty)
+{
+	RING_LOCALS;
+	DRM_DEBUG("dirty=0x%08x\n", dirty);
+
+	if (dirty & RADEON_UPLOAD_CONTEXT) {
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
+						  &ctx->rb3d_depthoffset)) {
+			DRM_ERROR("Invalid depth buffer offset\n");
+			return -EINVAL;
+		}
+
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
+						  &ctx->rb3d_coloroffset)) {
+			DRM_ERROR("Invalid depth buffer offset\n");
+			return -EINVAL;
+		}
+
+		BEGIN_RING(14);
+		OUT_RING(CP_PACKET0(RADEON_PP_MISC, 6));
+		OUT_RING(ctx->pp_misc);
+		OUT_RING(ctx->pp_fog_color);
+		OUT_RING(ctx->re_solid_color);
+		OUT_RING(ctx->rb3d_blendcntl);
+		OUT_RING(ctx->rb3d_depthoffset);
+		OUT_RING(ctx->rb3d_depthpitch);
+		OUT_RING(ctx->rb3d_zstencilcntl);
+		OUT_RING(CP_PACKET0(RADEON_PP_CNTL, 2));
+		OUT_RING(ctx->pp_cntl);
+		OUT_RING(ctx->rb3d_cntl);
+		OUT_RING(ctx->rb3d_coloroffset);
+		OUT_RING(CP_PACKET0(RADEON_RB3D_COLORPITCH, 0));
+		OUT_RING(ctx->rb3d_colorpitch);
+		ADVANCE_RING();
+	}
+
+	if (dirty & RADEON_UPLOAD_VERTFMT) {
+		BEGIN_RING(2);
+		OUT_RING(CP_PACKET0(RADEON_SE_COORD_FMT, 0));
+		OUT_RING(ctx->se_coord_fmt);
+		ADVANCE_RING();
+	}
+
+	if (dirty & RADEON_UPLOAD_LINE) {
+		BEGIN_RING(5);
+		OUT_RING(CP_PACKET0(RADEON_RE_LINE_PATTERN, 1));
+		OUT_RING(ctx->re_line_pattern);
+		OUT_RING(ctx->re_line_state);
+		OUT_RING(CP_PACKET0(RADEON_SE_LINE_WIDTH, 0));
+		OUT_RING(ctx->se_line_width);
+		ADVANCE_RING();
+	}
+
+	if (dirty & RADEON_UPLOAD_BUMPMAP) {
+		BEGIN_RING(5);
+		OUT_RING(CP_PACKET0(RADEON_PP_LUM_MATRIX, 0));
+		OUT_RING(ctx->pp_lum_matrix);
+		OUT_RING(CP_PACKET0(RADEON_PP_ROT_MATRIX_0, 1));
+		OUT_RING(ctx->pp_rot_matrix_0);
+		OUT_RING(ctx->pp_rot_matrix_1);
+		ADVANCE_RING();
+	}
+
+	if (dirty & RADEON_UPLOAD_MASKS) {
+		BEGIN_RING(4);
+		OUT_RING(CP_PACKET0(RADEON_RB3D_STENCILREFMASK, 2));
+		OUT_RING(ctx->rb3d_stencilrefmask);
+		OUT_RING(ctx->rb3d_ropcntl);
+		OUT_RING(ctx->rb3d_planemask);
+		ADVANCE_RING();
+	}
+
+	if (dirty & RADEON_UPLOAD_VIEWPORT) {
+		BEGIN_RING(7);
+		OUT_RING(CP_PACKET0(RADEON_SE_VPORT_XSCALE, 5));
+		OUT_RING(ctx->se_vport_xscale);
+		OUT_RING(ctx->se_vport_xoffset);
+		OUT_RING(ctx->se_vport_yscale);
+		OUT_RING(ctx->se_vport_yoffset);
+		OUT_RING(ctx->se_vport_zscale);
+		OUT_RING(ctx->se_vport_zoffset);
+		ADVANCE_RING();
+	}
+
+	if (dirty & RADEON_UPLOAD_SETUP) {
+		BEGIN_RING(4);
+		OUT_RING(CP_PACKET0(RADEON_SE_CNTL, 0));
+		OUT_RING(ctx->se_cntl);
+		OUT_RING(CP_PACKET0(RADEON_SE_CNTL_STATUS, 0));
+		OUT_RING(ctx->se_cntl_status);
+		ADVANCE_RING();
+	}
+
+	if (dirty & RADEON_UPLOAD_MISC) {
+		BEGIN_RING(2);
+		OUT_RING(CP_PACKET0(RADEON_RE_MISC, 0));
+		OUT_RING(ctx->re_misc);
+		ADVANCE_RING();
+	}
+
+	if (dirty & RADEON_UPLOAD_TEX0) {
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
+						  &tex[0].pp_txoffset)) {
+			DRM_ERROR("Invalid texture offset for unit 0\n");
+			return -EINVAL;
+		}
+
+		BEGIN_RING(9);
+		OUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_0, 5));
+		OUT_RING(tex[0].pp_txfilter);
+		OUT_RING(tex[0].pp_txformat);
+		OUT_RING(tex[0].pp_txoffset);
+		OUT_RING(tex[0].pp_txcblend);
+		OUT_RING(tex[0].pp_txablend);
+		OUT_RING(tex[0].pp_tfactor);
+		OUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_0, 0));
+		OUT_RING(tex[0].pp_border_color);
+		ADVANCE_RING();
+	}
+
+	if (dirty & RADEON_UPLOAD_TEX1) {
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
+						  &tex[1].pp_txoffset)) {
+			DRM_ERROR("Invalid texture offset for unit 1\n");
+			return -EINVAL;
+		}
+
+		BEGIN_RING(9);
+		OUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_1, 5));
+		OUT_RING(tex[1].pp_txfilter);
+		OUT_RING(tex[1].pp_txformat);
+		OUT_RING(tex[1].pp_txoffset);
+		OUT_RING(tex[1].pp_txcblend);
+		OUT_RING(tex[1].pp_txablend);
+		OUT_RING(tex[1].pp_tfactor);
+		OUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_1, 0));
+		OUT_RING(tex[1].pp_border_color);
+		ADVANCE_RING();
+	}
+
+	if (dirty & RADEON_UPLOAD_TEX2) {
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
+						  &tex[2].pp_txoffset)) {
+			DRM_ERROR("Invalid texture offset for unit 2\n");
+			return -EINVAL;
+		}
+
+		BEGIN_RING(9);
+		OUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_2, 5));
+		OUT_RING(tex[2].pp_txfilter);
+		OUT_RING(tex[2].pp_txformat);
+		OUT_RING(tex[2].pp_txoffset);
+		OUT_RING(tex[2].pp_txcblend);
+		OUT_RING(tex[2].pp_txablend);
+		OUT_RING(tex[2].pp_tfactor);
+		OUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_2, 0));
+		OUT_RING(tex[2].pp_border_color);
+		ADVANCE_RING();
+	}
+
+	return 0;
+}
+
+/* Emit 1.2 state
+ */
+static int radeon_emit_state2(drm_radeon_private_t * dev_priv,
+			      struct drm_file *file_priv,
+			      drm_radeon_state_t * state)
+{
+	RING_LOCALS;
+
+	if (state->dirty & RADEON_UPLOAD_ZBIAS) {
+		BEGIN_RING(3);
+		OUT_RING(CP_PACKET0(RADEON_SE_ZBIAS_FACTOR, 1));
+		OUT_RING(state->context2.se_zbias_factor);
+		OUT_RING(state->context2.se_zbias_constant);
+		ADVANCE_RING();
+	}
+
+	return radeon_emit_state(dev_priv, file_priv, &state->context,
+				 state->tex, state->dirty);
+}
+
+/* New (1.3) state mechanism.  3 commands (packet, scalar, vector) in
+ * 1.3 cmdbuffers allow all previous state to be updated as well as
+ * the tcl scalar and vector areas.
+ */
+static struct {
+	int start;
+	int len;
+	const char *name;
+} packet[RADEON_MAX_STATE_PACKETS] = {
+	{RADEON_PP_MISC, 7, "RADEON_PP_MISC"},
+	{RADEON_PP_CNTL, 3, "RADEON_PP_CNTL"},
+	{RADEON_RB3D_COLORPITCH, 1, "RADEON_RB3D_COLORPITCH"},
+	{RADEON_RE_LINE_PATTERN, 2, "RADEON_RE_LINE_PATTERN"},
+	{RADEON_SE_LINE_WIDTH, 1, "RADEON_SE_LINE_WIDTH"},
+	{RADEON_PP_LUM_MATRIX, 1, "RADEON_PP_LUM_MATRIX"},
+	{RADEON_PP_ROT_MATRIX_0, 2, "RADEON_PP_ROT_MATRIX_0"},
+	{RADEON_RB3D_STENCILREFMASK, 3, "RADEON_RB3D_STENCILREFMASK"},
+	{RADEON_SE_VPORT_XSCALE, 6, "RADEON_SE_VPORT_XSCALE"},
+	{RADEON_SE_CNTL, 2, "RADEON_SE_CNTL"},
+	{RADEON_SE_CNTL_STATUS, 1, "RADEON_SE_CNTL_STATUS"},
+	{RADEON_RE_MISC, 1, "RADEON_RE_MISC"},
+	{RADEON_PP_TXFILTER_0, 6, "RADEON_PP_TXFILTER_0"},
+	{RADEON_PP_BORDER_COLOR_0, 1, "RADEON_PP_BORDER_COLOR_0"},
+	{RADEON_PP_TXFILTER_1, 6, "RADEON_PP_TXFILTER_1"},
+	{RADEON_PP_BORDER_COLOR_1, 1, "RADEON_PP_BORDER_COLOR_1"},
+	{RADEON_PP_TXFILTER_2, 6, "RADEON_PP_TXFILTER_2"},
+	{RADEON_PP_BORDER_COLOR_2, 1, "RADEON_PP_BORDER_COLOR_2"},
+	{RADEON_SE_ZBIAS_FACTOR, 2, "RADEON_SE_ZBIAS_FACTOR"},
+	{RADEON_SE_TCL_OUTPUT_VTX_FMT, 11, "RADEON_SE_TCL_OUTPUT_VTX_FMT"},
+	{RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED, 17,
+		    "RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED"},
+	{R200_PP_TXCBLEND_0, 4, "R200_PP_TXCBLEND_0"},
+	{R200_PP_TXCBLEND_1, 4, "R200_PP_TXCBLEND_1"},
+	{R200_PP_TXCBLEND_2, 4, "R200_PP_TXCBLEND_2"},
+	{R200_PP_TXCBLEND_3, 4, "R200_PP_TXCBLEND_3"},
+	{R200_PP_TXCBLEND_4, 4, "R200_PP_TXCBLEND_4"},
+	{R200_PP_TXCBLEND_5, 4, "R200_PP_TXCBLEND_5"},
+	{R200_PP_TXCBLEND_6, 4, "R200_PP_TXCBLEND_6"},
+	{R200_PP_TXCBLEND_7, 4, "R200_PP_TXCBLEND_7"},
+	{R200_SE_TCL_LIGHT_MODEL_CTL_0, 6, "R200_SE_TCL_LIGHT_MODEL_CTL_0"},
+	{R200_PP_TFACTOR_0, 6, "R200_PP_TFACTOR_0"},
+	{R200_SE_VTX_FMT_0, 4, "R200_SE_VTX_FMT_0"},
+	{R200_SE_VAP_CNTL, 1, "R200_SE_VAP_CNTL"},
+	{R200_SE_TCL_MATRIX_SEL_0, 5, "R200_SE_TCL_MATRIX_SEL_0"},
+	{R200_SE_TCL_TEX_PROC_CTL_2, 5, "R200_SE_TCL_TEX_PROC_CTL_2"},
+	{R200_SE_TCL_UCP_VERT_BLEND_CTL, 1, "R200_SE_TCL_UCP_VERT_BLEND_CTL"},
+	{R200_PP_TXFILTER_0, 6, "R200_PP_TXFILTER_0"},
+	{R200_PP_TXFILTER_1, 6, "R200_PP_TXFILTER_1"},
+	{R200_PP_TXFILTER_2, 6, "R200_PP_TXFILTER_2"},
+	{R200_PP_TXFILTER_3, 6, "R200_PP_TXFILTER_3"},
+	{R200_PP_TXFILTER_4, 6, "R200_PP_TXFILTER_4"},
+	{R200_PP_TXFILTER_5, 6, "R200_PP_TXFILTER_5"},
+	{R200_PP_TXOFFSET_0, 1, "R200_PP_TXOFFSET_0"},
+	{R200_PP_TXOFFSET_1, 1, "R200_PP_TXOFFSET_1"},
+	{R200_PP_TXOFFSET_2, 1, "R200_PP_TXOFFSET_2"},
+	{R200_PP_TXOFFSET_3, 1, "R200_PP_TXOFFSET_3"},
+	{R200_PP_TXOFFSET_4, 1, "R200_PP_TXOFFSET_4"},
+	{R200_PP_TXOFFSET_5, 1, "R200_PP_TXOFFSET_5"},
+	{R200_SE_VTE_CNTL, 1, "R200_SE_VTE_CNTL"},
+	{R200_SE_TCL_OUTPUT_VTX_COMP_SEL, 1,
+	 "R200_SE_TCL_OUTPUT_VTX_COMP_SEL"},
+	{R200_PP_TAM_DEBUG3, 1, "R200_PP_TAM_DEBUG3"},
+	{R200_PP_CNTL_X, 1, "R200_PP_CNTL_X"},
+	{R200_RB3D_DEPTHXY_OFFSET, 1, "R200_RB3D_DEPTHXY_OFFSET"},
+	{R200_RE_AUX_SCISSOR_CNTL, 1, "R200_RE_AUX_SCISSOR_CNTL"},
+	{R200_RE_SCISSOR_TL_0, 2, "R200_RE_SCISSOR_TL_0"},
+	{R200_RE_SCISSOR_TL_1, 2, "R200_RE_SCISSOR_TL_1"},
+	{R200_RE_SCISSOR_TL_2, 2, "R200_RE_SCISSOR_TL_2"},
+	{R200_SE_VAP_CNTL_STATUS, 1, "R200_SE_VAP_CNTL_STATUS"},
+	{R200_SE_VTX_STATE_CNTL, 1, "R200_SE_VTX_STATE_CNTL"},
+	{R200_RE_POINTSIZE, 1, "R200_RE_POINTSIZE"},
+	{R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0, 4,
+		    "R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0"},
+	{R200_PP_CUBIC_FACES_0, 1, "R200_PP_CUBIC_FACES_0"},	/* 61 */
+	{R200_PP_CUBIC_OFFSET_F1_0, 5, "R200_PP_CUBIC_OFFSET_F1_0"}, /* 62 */
+	{R200_PP_CUBIC_FACES_1, 1, "R200_PP_CUBIC_FACES_1"},
+	{R200_PP_CUBIC_OFFSET_F1_1, 5, "R200_PP_CUBIC_OFFSET_F1_1"},
+	{R200_PP_CUBIC_FACES_2, 1, "R200_PP_CUBIC_FACES_2"},
+	{R200_PP_CUBIC_OFFSET_F1_2, 5, "R200_PP_CUBIC_OFFSET_F1_2"},
+	{R200_PP_CUBIC_FACES_3, 1, "R200_PP_CUBIC_FACES_3"},
+	{R200_PP_CUBIC_OFFSET_F1_3, 5, "R200_PP_CUBIC_OFFSET_F1_3"},
+	{R200_PP_CUBIC_FACES_4, 1, "R200_PP_CUBIC_FACES_4"},
+	{R200_PP_CUBIC_OFFSET_F1_4, 5, "R200_PP_CUBIC_OFFSET_F1_4"},
+	{R200_PP_CUBIC_FACES_5, 1, "R200_PP_CUBIC_FACES_5"},
+	{R200_PP_CUBIC_OFFSET_F1_5, 5, "R200_PP_CUBIC_OFFSET_F1_5"},
+	{RADEON_PP_TEX_SIZE_0, 2, "RADEON_PP_TEX_SIZE_0"},
+	{RADEON_PP_TEX_SIZE_1, 2, "RADEON_PP_TEX_SIZE_1"},
+	{RADEON_PP_TEX_SIZE_2, 2, "RADEON_PP_TEX_SIZE_2"},
+	{R200_RB3D_BLENDCOLOR, 3, "R200_RB3D_BLENDCOLOR"},
+	{R200_SE_TCL_POINT_SPRITE_CNTL, 1, "R200_SE_TCL_POINT_SPRITE_CNTL"},
+	{RADEON_PP_CUBIC_FACES_0, 1, "RADEON_PP_CUBIC_FACES_0"},
+	{RADEON_PP_CUBIC_OFFSET_T0_0, 5, "RADEON_PP_CUBIC_OFFSET_T0_0"},
+	{RADEON_PP_CUBIC_FACES_1, 1, "RADEON_PP_CUBIC_FACES_1"},
+	{RADEON_PP_CUBIC_OFFSET_T1_0, 5, "RADEON_PP_CUBIC_OFFSET_T1_0"},
+	{RADEON_PP_CUBIC_FACES_2, 1, "RADEON_PP_CUBIC_FACES_2"},
+	{RADEON_PP_CUBIC_OFFSET_T2_0, 5, "RADEON_PP_CUBIC_OFFSET_T2_0"},
+	{R200_PP_TRI_PERF, 2, "R200_PP_TRI_PERF"},
+	{R200_PP_AFS_0, 32, "R200_PP_AFS_0"},     /* 85 */
+	{R200_PP_AFS_1, 32, "R200_PP_AFS_1"},
+	{R200_PP_TFACTOR_0, 8, "R200_ATF_TFACTOR"},
+	{R200_PP_TXFILTER_0, 8, "R200_PP_TXCTLALL_0"},
+	{R200_PP_TXFILTER_1, 8, "R200_PP_TXCTLALL_1"},
+	{R200_PP_TXFILTER_2, 8, "R200_PP_TXCTLALL_2"},
+	{R200_PP_TXFILTER_3, 8, "R200_PP_TXCTLALL_3"},
+	{R200_PP_TXFILTER_4, 8, "R200_PP_TXCTLALL_4"},
+	{R200_PP_TXFILTER_5, 8, "R200_PP_TXCTLALL_5"},
+	{R200_VAP_PVS_CNTL_1, 2, "R200_VAP_PVS_CNTL"},
+};
+
+/* ================================================================
+ * Performance monitoring functions
+ */
+
+static void radeon_clear_box(drm_radeon_private_t * dev_priv,
+			     int x, int y, int w, int h, int r, int g, int b)
+{
+	u32 color;
+	RING_LOCALS;
+
+	x += dev_priv->sarea_priv->boxes[0].x1;
+	y += dev_priv->sarea_priv->boxes[0].y1;
+
+	switch (dev_priv->color_fmt) {
+	case RADEON_COLOR_FORMAT_RGB565:
+		color = (((r & 0xf8) << 8) |
+			 ((g & 0xfc) << 3) | ((b & 0xf8) >> 3));
+		break;
+	case RADEON_COLOR_FORMAT_ARGB8888:
+	default:
+		color = (((0xff) << 24) | (r << 16) | (g << 8) | b);
+		break;
+	}
+
+	BEGIN_RING(4);
+	RADEON_WAIT_UNTIL_3D_IDLE();
+	OUT_RING(CP_PACKET0(RADEON_DP_WRITE_MASK, 0));
+	OUT_RING(0xffffffff);
+	ADVANCE_RING();
+
+	BEGIN_RING(6);
+
+	OUT_RING(CP_PACKET3(RADEON_CNTL_PAINT_MULTI, 4));
+	OUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+		 RADEON_GMC_BRUSH_SOLID_COLOR |
+		 (dev_priv->color_fmt << 8) |
+		 RADEON_GMC_SRC_DATATYPE_COLOR |
+		 RADEON_ROP3_P | RADEON_GMC_CLR_CMP_CNTL_DIS);
+
+	if (dev_priv->sarea_priv->pfCurrentPage == 1) {
+		OUT_RING(dev_priv->front_pitch_offset);
+	} else {
+		OUT_RING(dev_priv->back_pitch_offset);
+	}
+
+	OUT_RING(color);
+
+	OUT_RING((x << 16) | y);
+	OUT_RING((w << 16) | h);
+
+	ADVANCE_RING();
+}
+
+static void radeon_cp_performance_boxes(drm_radeon_private_t * dev_priv)
+{
+	/* Collapse various things into a wait flag -- trying to
+	 * guess if userspase slept -- better just to have them tell us.
+	 */
+	if (dev_priv->stats.last_frame_reads > 1 ||
+	    dev_priv->stats.last_clear_reads > dev_priv->stats.clears) {
+		dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
+	}
+
+	if (dev_priv->stats.freelist_loops) {
+		dev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;
+	}
+
+	/* Purple box for page flipping
+	 */
+	if (dev_priv->stats.boxes & RADEON_BOX_FLIP)
+		radeon_clear_box(dev_priv, 4, 4, 8, 8, 255, 0, 255);
+
+	/* Red box if we have to wait for idle at any point
+	 */
+	if (dev_priv->stats.boxes & RADEON_BOX_WAIT_IDLE)
+		radeon_clear_box(dev_priv, 16, 4, 8, 8, 255, 0, 0);
+
+	/* Blue box: lost context?
+	 */
+
+	/* Yellow box for texture swaps
+	 */
+	if (dev_priv->stats.boxes & RADEON_BOX_TEXTURE_LOAD)
+		radeon_clear_box(dev_priv, 40, 4, 8, 8, 255, 255, 0);
+
+	/* Green box if hardware never idles (as far as we can tell)
+	 */
+	if (!(dev_priv->stats.boxes & RADEON_BOX_DMA_IDLE))
+		radeon_clear_box(dev_priv, 64, 4, 8, 8, 0, 255, 0);
+
+	/* Draw bars indicating number of buffers allocated
+	 * (not a great measure, easily confused)
+	 */
+	if (dev_priv->stats.requested_bufs) {
+		if (dev_priv->stats.requested_bufs > 100)
+			dev_priv->stats.requested_bufs = 100;
+
+		radeon_clear_box(dev_priv, 4, 16,
+				 dev_priv->stats.requested_bufs, 4,
+				 196, 128, 128);
+	}
+
+	memset(&dev_priv->stats, 0, sizeof(dev_priv->stats));
+
+}
+
+/* ================================================================
+ * CP command dispatch functions
+ */
+
+static void radeon_cp_dispatch_clear(struct drm_device * dev,
+				     drm_radeon_clear_t * clear,
+				     drm_radeon_clear_rect_t * depth_boxes)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_depth_clear_t *depth_clear = &dev_priv->depth_clear;
+	int nbox = sarea_priv->nbox;
+	struct drm_clip_rect *pbox = sarea_priv->boxes;
+	unsigned int flags = clear->flags;
+	u32 rb3d_cntl = 0, rb3d_stencilrefmask = 0;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG("flags = 0x%x\n", flags);
+
+	dev_priv->stats.clears++;
+
+	if (dev_priv->sarea_priv->pfCurrentPage == 1) {
+		unsigned int tmp = flags;
+
+		flags &= ~(RADEON_FRONT | RADEON_BACK);
+		if (tmp & RADEON_FRONT)
+			flags |= RADEON_BACK;
+		if (tmp & RADEON_BACK)
+			flags |= RADEON_FRONT;
+	}
+
+	if (flags & (RADEON_FRONT | RADEON_BACK)) {
+
+		BEGIN_RING(4);
+
+		/* Ensure the 3D stream is idle before doing a
+		 * 2D fill to clear the front or back buffer.
+		 */
+		RADEON_WAIT_UNTIL_3D_IDLE();
+
+		OUT_RING(CP_PACKET0(RADEON_DP_WRITE_MASK, 0));
+		OUT_RING(clear->color_mask);
+
+		ADVANCE_RING();
+
+		/* Make sure we restore the 3D state next time.
+		 */
+		dev_priv->sarea_priv->ctx_owner = 0;
+
+		for (i = 0; i < nbox; i++) {
+			int x = pbox[i].x1;
+			int y = pbox[i].y1;
+			int w = pbox[i].x2 - x;
+			int h = pbox[i].y2 - y;
+
+			DRM_DEBUG("dispatch clear %d,%d-%d,%d flags 0x%x\n",
+				  x, y, w, h, flags);
+
+			if (flags & RADEON_FRONT) {
+				BEGIN_RING(6);
+
+				OUT_RING(CP_PACKET3
+					 (RADEON_CNTL_PAINT_MULTI, 4));
+				OUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+					 RADEON_GMC_BRUSH_SOLID_COLOR |
+					 (dev_priv->
+					  color_fmt << 8) |
+					 RADEON_GMC_SRC_DATATYPE_COLOR |
+					 RADEON_ROP3_P |
+					 RADEON_GMC_CLR_CMP_CNTL_DIS);
+
+				OUT_RING(dev_priv->front_pitch_offset);
+				OUT_RING(clear->clear_color);
+
+				OUT_RING((x << 16) | y);
+				OUT_RING((w << 16) | h);
+
+				ADVANCE_RING();
+			}
+
+			if (flags & RADEON_BACK) {
+				BEGIN_RING(6);
+
+				OUT_RING(CP_PACKET3
+					 (RADEON_CNTL_PAINT_MULTI, 4));
+				OUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+					 RADEON_GMC_BRUSH_SOLID_COLOR |
+					 (dev_priv->
+					  color_fmt << 8) |
+					 RADEON_GMC_SRC_DATATYPE_COLOR |
+					 RADEON_ROP3_P |
+					 RADEON_GMC_CLR_CMP_CNTL_DIS);
+
+				OUT_RING(dev_priv->back_pitch_offset);
+				OUT_RING(clear->clear_color);
+
+				OUT_RING((x << 16) | y);
+				OUT_RING((w << 16) | h);
+
+				ADVANCE_RING();
+			}
+		}
+	}
+
+	/* hyper z clear */
+	/* no docs available, based on reverse engeneering by Stephane Marchesin */
+	if ((flags & (RADEON_DEPTH | RADEON_STENCIL))
+	    && (flags & RADEON_CLEAR_FASTZ)) {
+
+		int i;
+		int depthpixperline =
+		    dev_priv->depth_fmt ==
+		    RADEON_DEPTH_FORMAT_16BIT_INT_Z ? (dev_priv->depth_pitch /
+						       2) : (dev_priv->
+							     depth_pitch / 4);
+
+		u32 clearmask;
+
+		u32 tempRB3D_DEPTHCLEARVALUE = clear->clear_depth |
+		    ((clear->depth_mask & 0xff) << 24);
+
+		/* Make sure we restore the 3D state next time.
+		 * we haven't touched any "normal" state - still need this?
+		 */
+		dev_priv->sarea_priv->ctx_owner = 0;
+
+		if ((dev_priv->flags & RADEON_HAS_HIERZ)
+		    && (flags & RADEON_USE_HIERZ)) {
+			/* FIXME : reverse engineer that for Rx00 cards */
+			/* FIXME : the mask supposedly contains low-res z values. So can't set
+			   just to the max (0xff? or actually 0x3fff?), need to take z clear
+			   value into account? */
+			/* pattern seems to work for r100, though get slight
+			   rendering errors with glxgears. If hierz is not enabled for r100,
+			   only 4 bits which indicate clear (15,16,31,32, all zero) matter, the
+			   other ones are ignored, and the same clear mask can be used. That's
+			   very different behaviour than R200 which needs different clear mask
+			   and different number of tiles to clear if hierz is enabled or not !?!
+			 */
+			clearmask = (0xff << 22) | (0xff << 6) | 0x003f003f;
+		} else {
+			/* clear mask : chooses the clearing pattern.
+			   rv250: could be used to clear only parts of macrotiles
+			   (but that would get really complicated...)?
+			   bit 0 and 1 (either or both of them ?!?!) are used to
+			   not clear tile (or maybe one of the bits indicates if the tile is
+			   compressed or not), bit 2 and 3 to not clear tile 1,...,.
+			   Pattern is as follows:
+			   | 0,1 | 4,5 | 8,9 |12,13|16,17|20,21|24,25|28,29|
+			   bits -------------------------------------------------
+			   | 2,3 | 6,7 |10,11|14,15|18,19|22,23|26,27|30,31|
+			   rv100: clearmask covers 2x8 4x1 tiles, but one clear still
+			   covers 256 pixels ?!?
+			 */
+			clearmask = 0x0;
+		}
+
+		BEGIN_RING(8);
+		RADEON_WAIT_UNTIL_2D_IDLE();
+		OUT_RING_REG(RADEON_RB3D_DEPTHCLEARVALUE,
+			     tempRB3D_DEPTHCLEARVALUE);
+		/* what offset is this exactly ? */
+		OUT_RING_REG(RADEON_RB3D_ZMASKOFFSET, 0);
+		/* need ctlstat, otherwise get some strange black flickering */
+		OUT_RING_REG(RADEON_RB3D_ZCACHE_CTLSTAT,
+			     RADEON_RB3D_ZC_FLUSH_ALL);
+		ADVANCE_RING();
+
+		for (i = 0; i < nbox; i++) {
+			int tileoffset, nrtilesx, nrtilesy, j;
+			/* it looks like r200 needs rv-style clears, at least if hierz is not enabled? */
+			if ((dev_priv->flags & RADEON_HAS_HIERZ)
+			    && !(dev_priv->microcode_version == UCODE_R200)) {
+				/* FIXME : figure this out for r200 (when hierz is enabled). Or
+				   maybe r200 actually doesn't need to put the low-res z value into
+				   the tile cache like r100, but just needs to clear the hi-level z-buffer?
+				   Works for R100, both with hierz and without.
+				   R100 seems to operate on 2x1 8x8 tiles, but...
+				   odd: offset/nrtiles need to be 64 pix (4 block) aligned? Potentially
+				   problematic with resolutions which are not 64 pix aligned? */
+				tileoffset =
+				    ((pbox[i].y1 >> 3) * depthpixperline +
+				     pbox[i].x1) >> 6;
+				nrtilesx =
+				    ((pbox[i].x2 & ~63) -
+				     (pbox[i].x1 & ~63)) >> 4;
+				nrtilesy =
+				    (pbox[i].y2 >> 3) - (pbox[i].y1 >> 3);
+				for (j = 0; j <= nrtilesy; j++) {
+					BEGIN_RING(4);
+					OUT_RING(CP_PACKET3
+						 (RADEON_3D_CLEAR_ZMASK, 2));
+					/* first tile */
+					OUT_RING(tileoffset * 8);
+					/* the number of tiles to clear */
+					OUT_RING(nrtilesx + 4);
+					/* clear mask : chooses the clearing pattern. */
+					OUT_RING(clearmask);
+					ADVANCE_RING();
+					tileoffset += depthpixperline >> 6;
+				}
+			} else if (dev_priv->microcode_version == UCODE_R200) {
+				/* works for rv250. */
+				/* find first macro tile (8x2 4x4 z-pixels on rv250) */
+				tileoffset =
+				    ((pbox[i].y1 >> 3) * depthpixperline +
+				     pbox[i].x1) >> 5;
+				nrtilesx =
+				    (pbox[i].x2 >> 5) - (pbox[i].x1 >> 5);
+				nrtilesy =
+				    (pbox[i].y2 >> 3) - (pbox[i].y1 >> 3);
+				for (j = 0; j <= nrtilesy; j++) {
+					BEGIN_RING(4);
+					OUT_RING(CP_PACKET3
+						 (RADEON_3D_CLEAR_ZMASK, 2));
+					/* first tile */
+					/* judging by the first tile offset needed, could possibly
+					   directly address/clear 4x4 tiles instead of 8x2 * 4x4
+					   macro tiles, though would still need clear mask for
+					   right/bottom if truely 4x4 granularity is desired ? */
+					OUT_RING(tileoffset * 16);
+					/* the number of tiles to clear */
+					OUT_RING(nrtilesx + 1);
+					/* clear mask : chooses the clearing pattern. */
+					OUT_RING(clearmask);
+					ADVANCE_RING();
+					tileoffset += depthpixperline >> 5;
+				}
+			} else {	/* rv 100 */
+				/* rv100 might not need 64 pix alignment, who knows */
+				/* offsets are, hmm, weird */
+				tileoffset =
+				    ((pbox[i].y1 >> 4) * depthpixperline +
+				     pbox[i].x1) >> 6;
+				nrtilesx =
+				    ((pbox[i].x2 & ~63) -
+				     (pbox[i].x1 & ~63)) >> 4;
+				nrtilesy =
+				    (pbox[i].y2 >> 4) - (pbox[i].y1 >> 4);
+				for (j = 0; j <= nrtilesy; j++) {
+					BEGIN_RING(4);
+					OUT_RING(CP_PACKET3
+						 (RADEON_3D_CLEAR_ZMASK, 2));
+					OUT_RING(tileoffset * 128);
+					/* the number of tiles to clear */
+					OUT_RING(nrtilesx + 4);
+					/* clear mask : chooses the clearing pattern. */
+					OUT_RING(clearmask);
+					ADVANCE_RING();
+					tileoffset += depthpixperline >> 6;
+				}
+			}
+		}
+
+		/* TODO don't always clear all hi-level z tiles */
+		if ((dev_priv->flags & RADEON_HAS_HIERZ)
+		    && (dev_priv->microcode_version == UCODE_R200)
+		    && (flags & RADEON_USE_HIERZ))
+			/* r100 and cards without hierarchical z-buffer have no high-level z-buffer */
+			/* FIXME : the mask supposedly contains low-res z values. So can't set
+			   just to the max (0xff? or actually 0x3fff?), need to take z clear
+			   value into account? */
+		{
+			BEGIN_RING(4);
+			OUT_RING(CP_PACKET3(RADEON_3D_CLEAR_HIZ, 2));
+			OUT_RING(0x0);	/* First tile */
+			OUT_RING(0x3cc0);
+			OUT_RING((0xff << 22) | (0xff << 6) | 0x003f003f);
+			ADVANCE_RING();
+		}
+	}
+
+	/* We have to clear the depth and/or stencil buffers by
+	 * rendering a quad into just those buffers.  Thus, we have to
+	 * make sure the 3D engine is configured correctly.
+	 */
+	else if ((dev_priv->microcode_version == UCODE_R200) &&
+		(flags & (RADEON_DEPTH | RADEON_STENCIL))) {
+
+		int tempPP_CNTL;
+		int tempRE_CNTL;
+		int tempRB3D_CNTL;
+		int tempRB3D_ZSTENCILCNTL;
+		int tempRB3D_STENCILREFMASK;
+		int tempRB3D_PLANEMASK;
+		int tempSE_CNTL;
+		int tempSE_VTE_CNTL;
+		int tempSE_VTX_FMT_0;
+		int tempSE_VTX_FMT_1;
+		int tempSE_VAP_CNTL;
+		int tempRE_AUX_SCISSOR_CNTL;
+
+		tempPP_CNTL = 0;
+		tempRE_CNTL = 0;
+
+		tempRB3D_CNTL = depth_clear->rb3d_cntl;
+
+		tempRB3D_ZSTENCILCNTL = depth_clear->rb3d_zstencilcntl;
+		tempRB3D_STENCILREFMASK = 0x0;
+
+		tempSE_CNTL = depth_clear->se_cntl;
+
+		/* Disable TCL */
+
+		tempSE_VAP_CNTL = (	/* SE_VAP_CNTL__FORCE_W_TO_ONE_MASK |  */
+					  (0x9 <<
+					   SE_VAP_CNTL__VF_MAX_VTX_NUM__SHIFT));
+
+		tempRB3D_PLANEMASK = 0x0;
+
+		tempRE_AUX_SCISSOR_CNTL = 0x0;
+
+		tempSE_VTE_CNTL =
+		    SE_VTE_CNTL__VTX_XY_FMT_MASK | SE_VTE_CNTL__VTX_Z_FMT_MASK;
+
+		/* Vertex format (X, Y, Z, W) */
+		tempSE_VTX_FMT_0 =
+		    SE_VTX_FMT_0__VTX_Z0_PRESENT_MASK |
+		    SE_VTX_FMT_0__VTX_W0_PRESENT_MASK;
+		tempSE_VTX_FMT_1 = 0x0;
+
+		/*
+		 * Depth buffer specific enables
+		 */
+		if (flags & RADEON_DEPTH) {
+			/* Enable depth buffer */
+			tempRB3D_CNTL |= RADEON_Z_ENABLE;
+		} else {
+			/* Disable depth buffer */
+			tempRB3D_CNTL &= ~RADEON_Z_ENABLE;
+		}
+
+		/*
+		 * Stencil buffer specific enables
+		 */
+		if (flags & RADEON_STENCIL) {
+			tempRB3D_CNTL |= RADEON_STENCIL_ENABLE;
+			tempRB3D_STENCILREFMASK = clear->depth_mask;
+		} else {
+			tempRB3D_CNTL &= ~RADEON_STENCIL_ENABLE;
+			tempRB3D_STENCILREFMASK = 0x00000000;
+		}
+
+		if (flags & RADEON_USE_COMP_ZBUF) {
+			tempRB3D_ZSTENCILCNTL |= RADEON_Z_COMPRESSION_ENABLE |
+			    RADEON_Z_DECOMPRESSION_ENABLE;
+		}
+		if (flags & RADEON_USE_HIERZ) {
+			tempRB3D_ZSTENCILCNTL |= RADEON_Z_HIERARCHY_ENABLE;
+		}
+
+		BEGIN_RING(26);
+		RADEON_WAIT_UNTIL_2D_IDLE();
+
+		OUT_RING_REG(RADEON_PP_CNTL, tempPP_CNTL);
+		OUT_RING_REG(R200_RE_CNTL, tempRE_CNTL);
+		OUT_RING_REG(RADEON_RB3D_CNTL, tempRB3D_CNTL);
+		OUT_RING_REG(RADEON_RB3D_ZSTENCILCNTL, tempRB3D_ZSTENCILCNTL);
+		OUT_RING_REG(RADEON_RB3D_STENCILREFMASK,
+			     tempRB3D_STENCILREFMASK);
+		OUT_RING_REG(RADEON_RB3D_PLANEMASK, tempRB3D_PLANEMASK);
+		OUT_RING_REG(RADEON_SE_CNTL, tempSE_CNTL);
+		OUT_RING_REG(R200_SE_VTE_CNTL, tempSE_VTE_CNTL);
+		OUT_RING_REG(R200_SE_VTX_FMT_0, tempSE_VTX_FMT_0);
+		OUT_RING_REG(R200_SE_VTX_FMT_1, tempSE_VTX_FMT_1);
+		OUT_RING_REG(R200_SE_VAP_CNTL, tempSE_VAP_CNTL);
+		OUT_RING_REG(R200_RE_AUX_SCISSOR_CNTL, tempRE_AUX_SCISSOR_CNTL);
+		ADVANCE_RING();
+
+		/* Make sure we restore the 3D state next time.
+		 */
+		dev_priv->sarea_priv->ctx_owner = 0;
+
+		for (i = 0; i < nbox; i++) {
+
+			/* Funny that this should be required --
+			 *  sets top-left?
+			 */
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
+
+			BEGIN_RING(14);
+			OUT_RING(CP_PACKET3(R200_3D_DRAW_IMMD_2, 12));
+			OUT_RING((RADEON_PRIM_TYPE_RECT_LIST |
+				  RADEON_PRIM_WALK_RING |
+				  (3 << RADEON_NUM_VERTICES_SHIFT)));
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x3f800000);
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x3f800000);
+			OUT_RING(depth_boxes[i].ui[CLEAR_X2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x3f800000);
+			ADVANCE_RING();
+		}
+	} else if ((flags & (RADEON_DEPTH | RADEON_STENCIL))) {
+
+		int tempRB3D_ZSTENCILCNTL = depth_clear->rb3d_zstencilcntl;
+
+		rb3d_cntl = depth_clear->rb3d_cntl;
+
+		if (flags & RADEON_DEPTH) {
+			rb3d_cntl |= RADEON_Z_ENABLE;
+		} else {
+			rb3d_cntl &= ~RADEON_Z_ENABLE;
+		}
+
+		if (flags & RADEON_STENCIL) {
+			rb3d_cntl |= RADEON_STENCIL_ENABLE;
+			rb3d_stencilrefmask = clear->depth_mask;	/* misnamed field */
+		} else {
+			rb3d_cntl &= ~RADEON_STENCIL_ENABLE;
+			rb3d_stencilrefmask = 0x00000000;
+		}
+
+		if (flags & RADEON_USE_COMP_ZBUF) {
+			tempRB3D_ZSTENCILCNTL |= RADEON_Z_COMPRESSION_ENABLE |
+			    RADEON_Z_DECOMPRESSION_ENABLE;
+		}
+		if (flags & RADEON_USE_HIERZ) {
+			tempRB3D_ZSTENCILCNTL |= RADEON_Z_HIERARCHY_ENABLE;
+		}
+
+		BEGIN_RING(13);
+		RADEON_WAIT_UNTIL_2D_IDLE();
+
+		OUT_RING(CP_PACKET0(RADEON_PP_CNTL, 1));
+		OUT_RING(0x00000000);
+		OUT_RING(rb3d_cntl);
+
+		OUT_RING_REG(RADEON_RB3D_ZSTENCILCNTL, tempRB3D_ZSTENCILCNTL);
+		OUT_RING_REG(RADEON_RB3D_STENCILREFMASK, rb3d_stencilrefmask);
+		OUT_RING_REG(RADEON_RB3D_PLANEMASK, 0x00000000);
+		OUT_RING_REG(RADEON_SE_CNTL, depth_clear->se_cntl);
+		ADVANCE_RING();
+
+		/* Make sure we restore the 3D state next time.
+		 */
+		dev_priv->sarea_priv->ctx_owner = 0;
+
+		for (i = 0; i < nbox; i++) {
+
+			/* Funny that this should be required --
+			 *  sets top-left?
+			 */
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
+
+			BEGIN_RING(15);
+
+			OUT_RING(CP_PACKET3(RADEON_3D_DRAW_IMMD, 13));
+			OUT_RING(RADEON_VTX_Z_PRESENT |
+				 RADEON_VTX_PKCOLOR_PRESENT);
+			OUT_RING((RADEON_PRIM_TYPE_RECT_LIST |
+				  RADEON_PRIM_WALK_RING |
+				  RADEON_MAOS_ENABLE |
+				  RADEON_VTX_FMT_RADEON_MODE |
+				  (3 << RADEON_NUM_VERTICES_SHIFT)));
+
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x0);
+
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x0);
+
+			OUT_RING(depth_boxes[i].ui[CLEAR_X2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x0);
+
+			ADVANCE_RING();
+		}
+	}
+
+	/* Increment the clear counter.  The client-side 3D driver must
+	 * wait on this value before performing the clear ioctl.  We
+	 * need this because the card's so damned fast...
+	 */
+	dev_priv->sarea_priv->last_clear++;
+
+	BEGIN_RING(4);
+
+	RADEON_CLEAR_AGE(dev_priv->sarea_priv->last_clear);
+	RADEON_WAIT_UNTIL_IDLE();
+
+	ADVANCE_RING();
+}
+
+static void radeon_cp_dispatch_swap(struct drm_device * dev)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int nbox = sarea_priv->nbox;
+	struct drm_clip_rect *pbox = sarea_priv->boxes;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG("\n");
+
+	/* Do some trivial performance monitoring...
+	 */
+	if (dev_priv->do_boxes)
+		radeon_cp_performance_boxes(dev_priv);
+
+	/* Wait for the 3D stream to idle before dispatching the bitblt.
+	 * This will prevent data corruption between the two streams.
+	 */
+	BEGIN_RING(2);
+
+	RADEON_WAIT_UNTIL_3D_IDLE();
+
+	ADVANCE_RING();
+
+	for (i = 0; i < nbox; i++) {
+		int x = pbox[i].x1;
+		int y = pbox[i].y1;
+		int w = pbox[i].x2 - x;
+		int h = pbox[i].y2 - y;
+
+		DRM_DEBUG("dispatch swap %d,%d-%d,%d\n", x, y, w, h);
+
+		BEGIN_RING(9);
+
+		OUT_RING(CP_PACKET0(RADEON_DP_GUI_MASTER_CNTL, 0));
+		OUT_RING(RADEON_GMC_SRC_PITCH_OFFSET_CNTL |
+			 RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+			 RADEON_GMC_BRUSH_NONE |
+			 (dev_priv->color_fmt << 8) |
+			 RADEON_GMC_SRC_DATATYPE_COLOR |
+			 RADEON_ROP3_S |
+			 RADEON_DP_SRC_SOURCE_MEMORY |
+			 RADEON_GMC_CLR_CMP_CNTL_DIS | RADEON_GMC_WR_MSK_DIS);
+
+		/* Make this work even if front & back are flipped:
+		 */
+		OUT_RING(CP_PACKET0(RADEON_SRC_PITCH_OFFSET, 1));
+		if (dev_priv->sarea_priv->pfCurrentPage == 0) {
+			OUT_RING(dev_priv->back_pitch_offset);
+			OUT_RING(dev_priv->front_pitch_offset);
+		} else {
+			OUT_RING(dev_priv->front_pitch_offset);
+			OUT_RING(dev_priv->back_pitch_offset);
+		}
+
+		OUT_RING(CP_PACKET0(RADEON_SRC_X_Y, 2));
+		OUT_RING((x << 16) | y);
+		OUT_RING((x << 16) | y);
+		OUT_RING((w << 16) | h);
+
+		ADVANCE_RING();
+	}
+
+	/* Increment the frame counter.  The client-side 3D driver must
+	 * throttle the framerate by waiting for this value before
+	 * performing the swapbuffer ioctl.
+	 */
+	dev_priv->sarea_priv->last_frame++;
+
+	BEGIN_RING(4);
+
+	RADEON_FRAME_AGE(dev_priv->sarea_priv->last_frame);
+	RADEON_WAIT_UNTIL_2D_IDLE();
+
+	ADVANCE_RING();
+}
+
+static void radeon_cp_dispatch_flip(struct drm_device * dev)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	struct drm_sarea *sarea = (struct drm_sarea *) dev_priv->sarea->handle;
+	int offset = (dev_priv->sarea_priv->pfCurrentPage == 1)
+	    ? dev_priv->front_offset : dev_priv->back_offset;
+	RING_LOCALS;
+	DRM_DEBUG("%s: pfCurrentPage=%d\n",
+		  __FUNCTION__,
+		  dev_priv->sarea_priv->pfCurrentPage);
+
+	/* Do some trivial performance monitoring...
+	 */
+	if (dev_priv->do_boxes) {
+		dev_priv->stats.boxes |= RADEON_BOX_FLIP;
+		radeon_cp_performance_boxes(dev_priv);
+	}
+
+	/* Update the frame offsets for both CRTCs
+	 */
+	BEGIN_RING(6);
+
+	RADEON_WAIT_UNTIL_3D_IDLE();
+	OUT_RING_REG(RADEON_CRTC_OFFSET,
+		     ((sarea->frame.y * dev_priv->front_pitch +
+		       sarea->frame.x * (dev_priv->color_fmt - 2)) & ~7)
+		     + offset);
+	OUT_RING_REG(RADEON_CRTC2_OFFSET, dev_priv->sarea_priv->crtc2_base
+		     + offset);
+
+	ADVANCE_RING();
+
+	/* Increment the frame counter.  The client-side 3D driver must
+	 * throttle the framerate by waiting for this value before
+	 * performing the swapbuffer ioctl.
+	 */
+	dev_priv->sarea_priv->last_frame++;
+	dev_priv->sarea_priv->pfCurrentPage =
+		1 - dev_priv->sarea_priv->pfCurrentPage;
+
+	BEGIN_RING(2);
+
+	RADEON_FRAME_AGE(dev_priv->sarea_priv->last_frame);
+
+	ADVANCE_RING();
+}
+
+static int bad_prim_vertex_nr(int primitive, int nr)
+{
+	switch (primitive & RADEON_PRIM_TYPE_MASK) {
+	case RADEON_PRIM_TYPE_NONE:
+	case RADEON_PRIM_TYPE_POINT:
+		return nr < 1;
+	case RADEON_PRIM_TYPE_LINE:
+		return (nr & 1) || nr == 0;
+	case RADEON_PRIM_TYPE_LINE_STRIP:
+		return nr < 2;
+	case RADEON_PRIM_TYPE_TRI_LIST:
+	case RADEON_PRIM_TYPE_3VRT_POINT_LIST:
+	case RADEON_PRIM_TYPE_3VRT_LINE_LIST:
+	case RADEON_PRIM_TYPE_RECT_LIST:
+		return nr % 3 || nr == 0;
+	case RADEON_PRIM_TYPE_TRI_FAN:
+	case RADEON_PRIM_TYPE_TRI_STRIP:
+		return nr < 3;
+	default:
+		return 1;
+	}
+}
+
+typedef struct {
+	unsigned int start;
+	unsigned int finish;
+	unsigned int prim;
+	unsigned int numverts;
+	unsigned int offset;
+	unsigned int vc_format;
+} drm_radeon_tcl_prim_t;
+
+static void radeon_cp_dispatch_vertex(struct drm_device * dev,
+				      struct drm_buf * buf,
+				      drm_radeon_tcl_prim_t * prim)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int offset = dev_priv->gart_buffers_offset + buf->offset + prim->start;
+	int numverts = (int)prim->numverts;
+	int nbox = sarea_priv->nbox;
+	int i = 0;
+	RING_LOCALS;
+
+	DRM_DEBUG("hwprim 0x%x vfmt 0x%x %d..%d %d verts\n",
+		  prim->prim,
+		  prim->vc_format, prim->start, prim->finish, prim->numverts);
+
+	if (bad_prim_vertex_nr(prim->prim, prim->numverts)) {
+		DRM_ERROR("bad prim %x numverts %d\n",
+			  prim->prim, prim->numverts);
+		return;
+	}
+
+	do {
+		/* Emit the next cliprect */
+		if (i < nbox) {
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
+		}
+
+		/* Emit the vertex buffer rendering commands */
+		BEGIN_RING(5);
+
+		OUT_RING(CP_PACKET3(RADEON_3D_RNDR_GEN_INDX_PRIM, 3));
+		OUT_RING(offset);
+		OUT_RING(numverts);
+		OUT_RING(prim->vc_format);
+		OUT_RING(prim->prim | RADEON_PRIM_WALK_LIST |
+			 RADEON_COLOR_ORDER_RGBA |
+			 RADEON_VTX_FMT_RADEON_MODE |
+			 (numverts << RADEON_NUM_VERTICES_SHIFT));
+
+		ADVANCE_RING();
+
+		i++;
+	} while (i < nbox);
+}
+
+static void radeon_cp_discard_buffer(struct drm_device * dev, struct drm_buf * buf)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_buf_priv_t *buf_priv = buf->dev_private;
+	RING_LOCALS;
+
+	buf_priv->age = ++dev_priv->sarea_priv->last_dispatch;
+
+	/* Emit the vertex buffer age */
+	BEGIN_RING(2);
+	RADEON_DISPATCH_AGE(buf_priv->age);
+	ADVANCE_RING();
+
+	buf->pending = 1;
+	buf->used = 0;
+}
+
+static void radeon_cp_dispatch_indirect(struct drm_device * dev,
+					struct drm_buf * buf, int start, int end)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	RING_LOCALS;
+	DRM_DEBUG("indirect: buf=%d s=0x%x e=0x%x\n", buf->idx, start, end);
+
+	if (start != end) {
+		int offset = (dev_priv->gart_buffers_offset
+			      + buf->offset + start);
+		int dwords = (end - start + 3) / sizeof(u32);
+
+		/* Indirect buffer data must be an even number of
+		 * dwords, so if we've been given an odd number we must
+		 * pad the data with a Type-2 CP packet.
+		 */
+		if (dwords & 1) {
+			u32 *data = (u32 *)
+			    ((char *)dev->agp_buffer_map->handle
+			     + buf->offset + start);
+			data[dwords++] = RADEON_CP_PACKET2;
+		}
+
+		/* Fire off the indirect buffer */
+		BEGIN_RING(3);
+
+		OUT_RING(CP_PACKET0(RADEON_CP_IB_BASE, 1));
+		OUT_RING(offset);
+		OUT_RING(dwords);
+
+		ADVANCE_RING();
+	}
+}
+
+static void radeon_cp_dispatch_indices(struct drm_device * dev,
+				       struct drm_buf * elt_buf,
+				       drm_radeon_tcl_prim_t * prim)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int offset = dev_priv->gart_buffers_offset + prim->offset;
+	u32 *data;
+	int dwords;
+	int i = 0;
+	int start = prim->start + RADEON_INDEX_PRIM_OFFSET;
+	int count = (prim->finish - start) / sizeof(u16);
+	int nbox = sarea_priv->nbox;
+
+	DRM_DEBUG("hwprim 0x%x vfmt 0x%x %d..%d offset: %x nr %d\n",
+		  prim->prim,
+		  prim->vc_format,
+		  prim->start, prim->finish, prim->offset, prim->numverts);
+
+	if (bad_prim_vertex_nr(prim->prim, count)) {
+		DRM_ERROR("bad prim %x count %d\n", prim->prim, count);
+		return;
+	}
+
+	if (start >= prim->finish || (prim->start & 0x7)) {
+		DRM_ERROR("buffer prim %d\n", prim->prim);
+		return;
+	}
+
+	dwords = (prim->finish - prim->start + 3) / sizeof(u32);
+
+	data = (u32 *) ((char *)dev->agp_buffer_map->handle +
+			elt_buf->offset + prim->start);
+
+	data[0] = CP_PACKET3(RADEON_3D_RNDR_GEN_INDX_PRIM, dwords - 2);
+	data[1] = offset;
+	data[2] = prim->numverts;
+	data[3] = prim->vc_format;
+	data[4] = (prim->prim |
+		   RADEON_PRIM_WALK_IND |
+		   RADEON_COLOR_ORDER_RGBA |
+		   RADEON_VTX_FMT_RADEON_MODE |
+		   (count << RADEON_NUM_VERTICES_SHIFT));
+
+	do {
+		if (i < nbox)
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
+
+		radeon_cp_dispatch_indirect(dev, elt_buf,
+					    prim->start, prim->finish);
+
+		i++;
+	} while (i < nbox);
+
+}
+
+#define RADEON_MAX_TEXTURE_SIZE RADEON_BUFFER_SIZE
+
+static int radeon_cp_dispatch_texture(struct drm_device * dev,
+				      struct drm_file *file_priv,
+				      drm_radeon_texture_t * tex,
+				      drm_radeon_tex_image_t * image)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	struct drm_buf *buf;
+	u32 format;
+	u32 *buffer;
+	const u8 __user *data;
+	int size, dwords, tex_width, blit_width, spitch;
+	u32 height;
+	int i;
+	u32 texpitch, microtile;
+	u32 offset;
+	RING_LOCALS;
+
+	if (radeon_check_and_fixup_offset(dev_priv, file_priv, &tex->offset)) {
+		DRM_ERROR("Invalid destination offset\n");
+		return -EINVAL;
+	}
+
+	dev_priv->stats.boxes |= RADEON_BOX_TEXTURE_LOAD;
+
+	/* Flush the pixel cache.  This ensures no pixel data gets mixed
+	 * up with the texture data from the host data blit, otherwise
+	 * part of the texture image may be corrupted.
+	 */
+	BEGIN_RING(4);
+	RADEON_FLUSH_CACHE();
+	RADEON_WAIT_UNTIL_IDLE();
+	ADVANCE_RING();
+
+	/* The compiler won't optimize away a division by a variable,
+	 * even if the only legal values are powers of two.  Thus, we'll
+	 * use a shift instead.
+	 */
+	switch (tex->format) {
+	case RADEON_TXFORMAT_ARGB8888:
+	case RADEON_TXFORMAT_RGBA8888:
+		format = RADEON_COLOR_FORMAT_ARGB8888;
+		tex_width = tex->width * 4;
+		blit_width = image->width * 4;
+		break;
+	case RADEON_TXFORMAT_AI88:
+	case RADEON_TXFORMAT_ARGB1555:
+	case RADEON_TXFORMAT_RGB565:
+	case RADEON_TXFORMAT_ARGB4444:
+	case RADEON_TXFORMAT_VYUY422:
+	case RADEON_TXFORMAT_YVYU422:
+		format = RADEON_COLOR_FORMAT_RGB565;
+		tex_width = tex->width * 2;
+		blit_width = image->width * 2;
+		break;
+	case RADEON_TXFORMAT_I8:
+	case RADEON_TXFORMAT_RGB332:
+		format = RADEON_COLOR_FORMAT_CI8;
+		tex_width = tex->width * 1;
+		blit_width = image->width * 1;
+		break;
+	default:
+		DRM_ERROR("invalid texture format %d\n", tex->format);
+		return -EINVAL;
+	}
+	spitch = blit_width >> 6;
+	if (spitch == 0 && image->height > 1)
+		return -EINVAL;
+
+	texpitch = tex->pitch;
+	if ((texpitch << 22) & RADEON_DST_TILE_MICRO) {
+		microtile = 1;
+		if (tex_width < 64) {
+			texpitch &= ~(RADEON_DST_TILE_MICRO >> 22);
+			/* we got tiled coordinates, untile them */
+			image->x *= 2;
+		}
+	} else
+		microtile = 0;
+
+	DRM_DEBUG("tex=%dx%d blit=%d\n", tex_width, tex->height, blit_width);
+
+	do {
+		DRM_DEBUG("tex: ofs=0x%x p=%d f=%d x=%hd y=%hd w=%hd h=%hd\n",
+			  tex->offset >> 10, tex->pitch, tex->format,
+			  image->x, image->y, image->width, image->height);
+
+		/* Make a copy of some parameters in case we have to
+		 * update them for a multi-pass texture blit.
+		 */
+		height = image->height;
+		data = (const u8 __user *)image->data;
+
+		size = height * blit_width;
+
+		if (size > RADEON_MAX_TEXTURE_SIZE) {
+			height = RADEON_MAX_TEXTURE_SIZE / blit_width;
+			size = height * blit_width;
+		} else if (size < 4 && size > 0) {
+			size = 4;
+		} else if (size == 0) {
+			return 0;
+		}
+
+		buf = radeon_freelist_get(dev);
+		if (0 && !buf) {
+			radeon_do_cp_idle(dev_priv);
+			buf = radeon_freelist_get(dev);
+		}
+		if (!buf) {
+			DRM_DEBUG("radeon_cp_dispatch_texture: EAGAIN\n");
+			if (DRM_COPY_TO_USER(tex->image, image, sizeof(*image)))
+				return -EFAULT;
+			return -EAGAIN;
+		}
+
+		/* Dispatch the indirect buffer.
+		 */
+		buffer =
+		    (u32 *) ((char *)dev->agp_buffer_map->handle + buf->offset);
+		dwords = size / 4;
+
+#define RADEON_COPY_MT(_buf, _data, _width) \
+	do { \
+		if (DRM_COPY_FROM_USER(_buf, _data, (_width))) {\
+			DRM_ERROR("EFAULT on pad, %d bytes\n", (_width)); \
+			return -EFAULT; \
+		} \
+	} while(0)
+
+		if (microtile) {
+			/* texture micro tiling in use, minimum texture width is thus 16 bytes.
+			   however, we cannot use blitter directly for texture width < 64 bytes,
+			   since minimum tex pitch is 64 bytes and we need this to match
+			   the texture width, otherwise the blitter will tile it wrong.
+			   Thus, tiling manually in this case. Additionally, need to special
+			   case tex height = 1, since our actual image will have height 2
+			   and we need to ensure we don't read beyond the texture size
+			   from user space. */
+			if (tex->height == 1) {
+				if (tex_width >= 64 || tex_width <= 16) {
+					RADEON_COPY_MT(buffer, data,
+						(int)(tex_width * sizeof(u32)));
+				} else if (tex_width == 32) {
+					RADEON_COPY_MT(buffer, data, 16);
+					RADEON_COPY_MT(buffer + 8,
+						       data + 16, 16);
+				}
+			} else if (tex_width >= 64 || tex_width == 16) {
+				RADEON_COPY_MT(buffer, data,
+					       (int)(dwords * sizeof(u32)));
+			} else if (tex_width < 16) {
+				for (i = 0; i < tex->height; i++) {
+					RADEON_COPY_MT(buffer, data, tex_width);
+					buffer += 4;
+					data += tex_width;
+				}
+			} else if (tex_width == 32) {
+				/* TODO: make sure this works when not fitting in one buffer
+				   (i.e. 32bytes x 2048...) */
+				for (i = 0; i < tex->height; i += 2) {
+					RADEON_COPY_MT(buffer, data, 16);
+					data += 16;
+					RADEON_COPY_MT(buffer + 8, data, 16);
+					data += 16;
+					RADEON_COPY_MT(buffer + 4, data, 16);
+					data += 16;
+					RADEON_COPY_MT(buffer + 12, data, 16);
+					data += 16;
+					buffer += 16;
+				}
+			}
+		} else {
+			if (tex_width >= 32) {
+				/* Texture image width is larger than the minimum, so we
+				 * can upload it directly.
+				 */
+				RADEON_COPY_MT(buffer, data,
+					       (int)(dwords * sizeof(u32)));
+			} else {
+				/* Texture image width is less than the minimum, so we
+				 * need to pad out each image scanline to the minimum
+				 * width.
+				 */
+				for (i = 0; i < tex->height; i++) {
+					RADEON_COPY_MT(buffer, data, tex_width);
+					buffer += 8;
+					data += tex_width;
+				}
+			}
+		}
+
+#undef RADEON_COPY_MT
+		buf->file_priv = file_priv;
+		buf->used = size;
+		offset = dev_priv->gart_buffers_offset + buf->offset;
+		BEGIN_RING(9);
+		OUT_RING(CP_PACKET3(RADEON_CNTL_BITBLT_MULTI, 5));
+		OUT_RING(RADEON_GMC_SRC_PITCH_OFFSET_CNTL |
+			 RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+			 RADEON_GMC_BRUSH_NONE |
+			 (format << 8) |
+			 RADEON_GMC_SRC_DATATYPE_COLOR |
+			 RADEON_ROP3_S |
+			 RADEON_DP_SRC_SOURCE_MEMORY |
+			 RADEON_GMC_CLR_CMP_CNTL_DIS | RADEON_GMC_WR_MSK_DIS);
+		OUT_RING((spitch << 22) | (offset >> 10));
+		OUT_RING((texpitch << 22) | (tex->offset >> 10));
+		OUT_RING(0);
+		OUT_RING((image->x << 16) | image->y);
+		OUT_RING((image->width << 16) | height);
+		RADEON_WAIT_UNTIL_2D_IDLE();
+		ADVANCE_RING();
+
+		radeon_cp_discard_buffer(dev, buf);
+
+		/* Update the input parameters for next time */
+		image->y += height;
+		image->height -= height;
+		image->data = (const u8 __user *)image->data + size;
+	} while (image->height > 0);
+
+	/* Flush the pixel cache after the blit completes.  This ensures
+	 * the texture data is written out to memory before rendering
+	 * continues.
+	 */
+	BEGIN_RING(4);
+	RADEON_FLUSH_CACHE();
+	RADEON_WAIT_UNTIL_2D_IDLE();
+	ADVANCE_RING();
+	return 0;
+}
+
+static void radeon_cp_dispatch_stipple(struct drm_device * dev, u32 * stipple)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG("\n");
+
+	BEGIN_RING(35);
+
+	OUT_RING(CP_PACKET0(RADEON_RE_STIPPLE_ADDR, 0));
+	OUT_RING(0x00000000);
+
+	OUT_RING(CP_PACKET0_TABLE(RADEON_RE_STIPPLE_DATA, 31));
+	for (i = 0; i < 32; i++) {
+		OUT_RING(stipple[i]);
+	}
+
+	ADVANCE_RING();
+}
+
+static void radeon_apply_surface_regs(int surf_index,
+				      drm_radeon_private_t *dev_priv)
+{
+	if (!dev_priv->mmio)
+		return;
+
+	radeon_do_cp_idle(dev_priv);
+
+	RADEON_WRITE(RADEON_SURFACE0_INFO + 16 * surf_index,
+		     dev_priv->surfaces[surf_index].flags);
+	RADEON_WRITE(RADEON_SURFACE0_LOWER_BOUND + 16 * surf_index,
+		     dev_priv->surfaces[surf_index].lower);
+	RADEON_WRITE(RADEON_SURFACE0_UPPER_BOUND + 16 * surf_index,
+		     dev_priv->surfaces[surf_index].upper);
+}
+
+/* Allocates a virtual surface
+ * doesn't always allocate a real surface, will stretch an existing
+ * surface when possible.
+ *
+ * Note that refcount can be at most 2, since during a free refcount=3
+ * might mean we have to allocate a new surface which might not always
+ * be available.
+ * For example : we allocate three contigous surfaces ABC. If B is
+ * freed, we suddenly need two surfaces to store A and C, which might
+ * not always be available.
+ */
+static int alloc_surface(drm_radeon_surface_alloc_t *new,
+			 drm_radeon_private_t *dev_priv,
+			 struct drm_file *file_priv)
+{
+	struct radeon_virt_surface *s;
+	int i;
+	int virt_surface_index;
+	uint32_t new_upper, new_lower;
+
+	new_lower = new->address;
+	new_upper = new_lower + new->size - 1;
+
+	/* sanity check */
+	if ((new_lower >= new_upper) || (new->flags == 0) || (new->size == 0) ||
+	    ((new_upper & RADEON_SURF_ADDRESS_FIXED_MASK) !=
+	     RADEON_SURF_ADDRESS_FIXED_MASK)
+	    || ((new_lower & RADEON_SURF_ADDRESS_FIXED_MASK) != 0))
+		return -1;
+
+	/* make sure there is no overlap with existing surfaces */
+	for (i = 0; i < RADEON_MAX_SURFACES; i++) {
+		if ((dev_priv->surfaces[i].refcount != 0) &&
+		    (((new_lower >= dev_priv->surfaces[i].lower) &&
+		      (new_lower < dev_priv->surfaces[i].upper)) ||
+		     ((new_lower < dev_priv->surfaces[i].lower) &&
+		      (new_upper > dev_priv->surfaces[i].lower)))) {
+			return -1;
+		}
+	}
+
+	/* find a virtual surface */
+	for (i = 0; i < 2 * RADEON_MAX_SURFACES; i++)
+		if (dev_priv->virt_surfaces[i].file_priv == 0)
+			break;
+	if (i == 2 * RADEON_MAX_SURFACES) {
+		return -1;
+	}
+	virt_surface_index = i;
+
+	/* try to reuse an existing surface */
+	for (i = 0; i < RADEON_MAX_SURFACES; i++) {
+		/* extend before */
+		if ((dev_priv->surfaces[i].refcount == 1) &&
+		    (new->flags == dev_priv->surfaces[i].flags) &&
+		    (new_upper + 1 == dev_priv->surfaces[i].lower)) {
+			s = &(dev_priv->virt_surfaces[virt_surface_index]);
+			s->surface_index = i;
+			s->lower = new_lower;
+			s->upper = new_upper;
+			s->flags = new->flags;
+			s->file_priv = file_priv;
+			dev_priv->surfaces[i].refcount++;
+			dev_priv->surfaces[i].lower = s->lower;
+			radeon_apply_surface_regs(s->surface_index, dev_priv);
+			return virt_surface_index;
+		}
+
+		/* extend after */
+		if ((dev_priv->surfaces[i].refcount == 1) &&
+		    (new->flags == dev_priv->surfaces[i].flags) &&
+		    (new_lower == dev_priv->surfaces[i].upper + 1)) {
+			s = &(dev_priv->virt_surfaces[virt_surface_index]);
+			s->surface_index = i;
+			s->lower = new_lower;
+			s->upper = new_upper;
+			s->flags = new->flags;
+			s->file_priv = file_priv;
+			dev_priv->surfaces[i].refcount++;
+			dev_priv->surfaces[i].upper = s->upper;
+			radeon_apply_surface_regs(s->surface_index, dev_priv);
+			return virt_surface_index;
+		}
+	}
+
+	/* okay, we need a new one */
+	for (i = 0; i < RADEON_MAX_SURFACES; i++) {
+		if (dev_priv->surfaces[i].refcount == 0) {
+			s = &(dev_priv->virt_surfaces[virt_surface_index]);
+			s->surface_index = i;
+			s->lower = new_lower;
+			s->upper = new_upper;
+			s->flags = new->flags;
+			s->file_priv = file_priv;
+			dev_priv->surfaces[i].refcount = 1;
+			dev_priv->surfaces[i].lower = s->lower;
+			dev_priv->surfaces[i].upper = s->upper;
+			dev_priv->surfaces[i].flags = s->flags;
+			radeon_apply_surface_regs(s->surface_index, dev_priv);
+			return virt_surface_index;
+		}
+	}
+
+	/* we didn't find anything */
+	return -1;
+}
+
+static int free_surface(struct drm_file *file_priv,
+			drm_radeon_private_t * dev_priv,
+			int lower)
+{
+	struct radeon_virt_surface *s;
+	int i;
+	/* find the virtual surface */
+	for (i = 0; i < 2 * RADEON_MAX_SURFACES; i++) {
+		s = &(dev_priv->virt_surfaces[i]);
+		if (s->file_priv) {
+			if ((lower == s->lower) && (file_priv == s->file_priv))
+			{
+				if (dev_priv->surfaces[s->surface_index].
+				    lower == s->lower)
+					dev_priv->surfaces[s->surface_index].
+					    lower = s->upper;
+
+				if (dev_priv->surfaces[s->surface_index].
+				    upper == s->upper)
+					dev_priv->surfaces[s->surface_index].
+					    upper = s->lower;
+
+				dev_priv->surfaces[s->surface_index].refcount--;
+				if (dev_priv->surfaces[s->surface_index].
+				    refcount == 0)
+					dev_priv->surfaces[s->surface_index].
+					    flags = 0;
+				s->file_priv = NULL;
+				radeon_apply_surface_regs(s->surface_index,
+							  dev_priv);
+				return 0;
+			}
+		}
+	}
+	return 1;
+}
+
+static void radeon_surfaces_release(struct drm_file *file_priv,
+				    drm_radeon_private_t * dev_priv)
+{
+	int i;
+	for (i = 0; i < 2 * RADEON_MAX_SURFACES; i++) {
+		if (dev_priv->virt_surfaces[i].file_priv == file_priv)
+			free_surface(file_priv, dev_priv,
+				     dev_priv->virt_surfaces[i].lower);
+	}
+}
+
+/* ================================================================
+ * IOCTL functions
+ */
+static int radeon_surface_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_surface_alloc_t *alloc = data;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (alloc_surface(alloc, dev_priv, file_priv) == -1)
+		return -EINVAL;
+	else
+		return 0;
+}
+
+static int radeon_surface_free(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_surface_free_t *memfree = data;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (free_surface(file_priv, dev_priv, memfree->address))
+		return -EINVAL;
+	else
+		return 0;
+}
+
+static int radeon_cp_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_clear_t *clear = data;
+	drm_radeon_clear_rect_t depth_boxes[RADEON_NR_SAREA_CLIPRECTS];
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+
+	if (sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = RADEON_NR_SAREA_CLIPRECTS;
+
+	if (DRM_COPY_FROM_USER(&depth_boxes, clear->depth_boxes,
+			       sarea_priv->nbox * sizeof(depth_boxes[0])))
+		return -EFAULT;
+
+	radeon_cp_dispatch_clear(dev, clear, depth_boxes);
+
+	COMMIT_RING();
+	return 0;
+}
+
+/* Not sure why this isn't set all the time:
+ */
+static int radeon_do_init_pageflip(struct drm_device * dev)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	RING_LOCALS;
+
+	DRM_DEBUG("\n");
+
+	BEGIN_RING(6);
+	RADEON_WAIT_UNTIL_3D_IDLE();
+	OUT_RING(CP_PACKET0(RADEON_CRTC_OFFSET_CNTL, 0));
+	OUT_RING(RADEON_READ(RADEON_CRTC_OFFSET_CNTL) |
+		 RADEON_CRTC_OFFSET_FLIP_CNTL);
+	OUT_RING(CP_PACKET0(RADEON_CRTC2_OFFSET_CNTL, 0));
+	OUT_RING(RADEON_READ(RADEON_CRTC2_OFFSET_CNTL) |
+		 RADEON_CRTC_OFFSET_FLIP_CNTL);
+	ADVANCE_RING();
+
+	dev_priv->page_flipping = 1;
+
+	if (dev_priv->sarea_priv->pfCurrentPage != 1)
+		dev_priv->sarea_priv->pfCurrentPage = 0;
+
+	return 0;
+}
+
+/* Swapping and flipping are different operations, need different ioctls.
+ * They can & should be intermixed to support multiple 3d windows.
+ */
+static int radeon_cp_flip(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+
+	if (!dev_priv->page_flipping)
+		radeon_do_init_pageflip(dev);
+
+	radeon_cp_dispatch_flip(dev);
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int radeon_cp_swap(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+
+	if (sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = RADEON_NR_SAREA_CLIPRECTS;
+
+	radeon_cp_dispatch_swap(dev);
+	dev_priv->sarea_priv->ctx_owner = 0;
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int radeon_cp_vertex(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_radeon_vertex_t *vertex = data;
+	drm_radeon_tcl_prim_t prim;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	sarea_priv = dev_priv->sarea_priv;
+
+	DRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",
+		  DRM_CURRENTPID, vertex->idx, vertex->count, vertex->discard);
+
+	if (vertex->idx < 0 || vertex->idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  vertex->idx, dma->buf_count - 1);
+		return -EINVAL;
+	}
+	if (vertex->prim < 0 || vertex->prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {
+		DRM_ERROR("buffer prim %d\n", vertex->prim);
+		return -EINVAL;
+	}
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
+
+	buf = dma->buflist[vertex->idx];
+
+	if (buf->file_priv != file_priv) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
+	}
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", vertex->idx);
+		return -EINVAL;
+	}
+
+	/* Build up a prim_t record:
+	 */
+	if (vertex->count) {
+		buf->used = vertex->count;	/* not used? */
+
+		if (sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS) {
+			if (radeon_emit_state(dev_priv, file_priv,
+					      &sarea_priv->context_state,
+					      sarea_priv->tex_state,
+					      sarea_priv->dirty)) {
+				DRM_ERROR("radeon_emit_state failed\n");
+				return -EINVAL;
+			}
+
+			sarea_priv->dirty &= ~(RADEON_UPLOAD_TEX0IMAGES |
+					       RADEON_UPLOAD_TEX1IMAGES |
+					       RADEON_UPLOAD_TEX2IMAGES |
+					       RADEON_REQUIRE_QUIESCENCE);
+		}
+
+		prim.start = 0;
+		prim.finish = vertex->count;	/* unused */
+		prim.prim = vertex->prim;
+		prim.numverts = vertex->count;
+		prim.vc_format = dev_priv->sarea_priv->vc_format;
+
+		radeon_cp_dispatch_vertex(dev, buf, &prim);
+	}
+
+	if (vertex->discard) {
+		radeon_cp_discard_buffer(dev, buf);
+	}
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int radeon_cp_indices(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_radeon_indices_t *elts = data;
+	drm_radeon_tcl_prim_t prim;
+	int count;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+	sarea_priv = dev_priv->sarea_priv;
+
+	DRM_DEBUG("pid=%d index=%d start=%d end=%d discard=%d\n",
+		  DRM_CURRENTPID, elts->idx, elts->start, elts->end,
+		  elts->discard);
+
+	if (elts->idx < 0 || elts->idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  elts->idx, dma->buf_count - 1);
+		return -EINVAL;
+	}
+	if (elts->prim < 0 || elts->prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {
+		DRM_ERROR("buffer prim %d\n", elts->prim);
+		return -EINVAL;
+	}
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
+
+	buf = dma->buflist[elts->idx];
+
+	if (buf->file_priv != file_priv) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
+	}
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", elts->idx);
+		return -EINVAL;
+	}
+
+	count = (elts->end - elts->start) / sizeof(u16);
+	elts->start -= RADEON_INDEX_PRIM_OFFSET;
+
+	if (elts->start & 0x7) {
+		DRM_ERROR("misaligned buffer 0x%x\n", elts->start);
+		return -EINVAL;
+	}
+	if (elts->start < buf->used) {
+		DRM_ERROR("no header 0x%x - 0x%x\n", elts->start, buf->used);
+		return -EINVAL;
+	}
+
+	buf->used = elts->end;
+
+	if (sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS) {
+		if (radeon_emit_state(dev_priv, file_priv,
+				      &sarea_priv->context_state,
+				      sarea_priv->tex_state,
+				      sarea_priv->dirty)) {
+			DRM_ERROR("radeon_emit_state failed\n");
+			return -EINVAL;
+		}
+
+		sarea_priv->dirty &= ~(RADEON_UPLOAD_TEX0IMAGES |
+				       RADEON_UPLOAD_TEX1IMAGES |
+				       RADEON_UPLOAD_TEX2IMAGES |
+				       RADEON_REQUIRE_QUIESCENCE);
+	}
+
+	/* Build up a prim_t record:
+	 */
+	prim.start = elts->start;
+	prim.finish = elts->end;
+	prim.prim = elts->prim;
+	prim.offset = 0;	/* offset from start of dma buffers */
+	prim.numverts = RADEON_MAX_VB_VERTS;	/* duh */
+	prim.vc_format = dev_priv->sarea_priv->vc_format;
+
+	radeon_cp_dispatch_indices(dev, buf, &prim);
+	if (elts->discard) {
+		radeon_cp_discard_buffer(dev, buf);
+	}
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int radeon_cp_texture(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_texture_t *tex = data;
+	drm_radeon_tex_image_t image;
+	int ret;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (tex->image == NULL) {
+		DRM_ERROR("null texture image!\n");
+		return -EINVAL;
+	}
+
+	if (DRM_COPY_FROM_USER(&image,
+			       (drm_radeon_tex_image_t __user *) tex->image,
+			       sizeof(image)))
+		return -EFAULT;
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
+
+	ret = radeon_cp_dispatch_texture(dev, file_priv, tex, &image);
+
+	COMMIT_RING();
+	return ret;
+}
+
+static int radeon_cp_stipple(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_stipple_t *stipple = data;
+	u32 mask[32];
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (DRM_COPY_FROM_USER(&mask, stipple->mask, 32 * sizeof(u32)))
+		return -EFAULT;
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+
+	radeon_cp_dispatch_stipple(dev, mask);
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int radeon_cp_indirect(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_radeon_indirect_t *indirect = data;
+	RING_LOCALS;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("indirect: idx=%d s=%d e=%d d=%d\n",
+		  indirect->idx, indirect->start, indirect->end,
+		  indirect->discard);
+
+	if (indirect->idx < 0 || indirect->idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  indirect->idx, dma->buf_count - 1);
+		return -EINVAL;
+	}
+
+	buf = dma->buflist[indirect->idx];
+
+	if (buf->file_priv != file_priv) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
+	}
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", indirect->idx);
+		return -EINVAL;
+	}
+
+	if (indirect->start < buf->used) {
+		DRM_ERROR("reusing indirect: start=0x%x actual=0x%x\n",
+			  indirect->start, buf->used);
+		return -EINVAL;
+	}
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
+
+	buf->used = indirect->end;
+
+	/* Wait for the 3D stream to idle before the indirect buffer
+	 * containing 2D acceleration commands is processed.
+	 */
+	BEGIN_RING(2);
+
+	RADEON_WAIT_UNTIL_3D_IDLE();
+
+	ADVANCE_RING();
+
+	/* Dispatch the indirect buffer full of commands from the
+	 * X server.  This is insecure and is thus only available to
+	 * privileged clients.
+	 */
+	radeon_cp_dispatch_indirect(dev, buf, indirect->start, indirect->end);
+	if (indirect->discard) {
+		radeon_cp_discard_buffer(dev, buf);
+	}
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int radeon_cp_vertex2(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_radeon_vertex2_t *vertex = data;
+	int i;
+	unsigned char laststate;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	sarea_priv = dev_priv->sarea_priv;
+
+	DRM_DEBUG("pid=%d index=%d discard=%d\n",
+		  DRM_CURRENTPID, vertex->idx, vertex->discard);
+
+	if (vertex->idx < 0 || vertex->idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  vertex->idx, dma->buf_count - 1);
+		return -EINVAL;
+	}
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
+
+	buf = dma->buflist[vertex->idx];
+
+	if (buf->file_priv != file_priv) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
+	}
+
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", vertex->idx);
+		return -EINVAL;
+	}
+
+	if (sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS)
+		return -EINVAL;
+
+	for (laststate = 0xff, i = 0; i < vertex->nr_prims; i++) {
+		drm_radeon_prim_t prim;
+		drm_radeon_tcl_prim_t tclprim;
+
+		if (DRM_COPY_FROM_USER(&prim, &vertex->prim[i], sizeof(prim)))
+			return -EFAULT;
+
+		if (prim.stateidx != laststate) {
+			drm_radeon_state_t state;
+
+			if (DRM_COPY_FROM_USER(&state,
+					       &vertex->state[prim.stateidx],
+					       sizeof(state)))
+				return -EFAULT;
+
+			if (radeon_emit_state2(dev_priv, file_priv, &state)) {
+				DRM_ERROR("radeon_emit_state2 failed\n");
+				return -EINVAL;
+			}
+
+			laststate = prim.stateidx;
+		}
+
+		tclprim.start = prim.start;
+		tclprim.finish = prim.finish;
+		tclprim.prim = prim.prim;
+		tclprim.vc_format = prim.vc_format;
+
+		if (prim.prim & RADEON_PRIM_WALK_IND) {
+			tclprim.offset = prim.numverts * 64;
+			tclprim.numverts = RADEON_MAX_VB_VERTS;	/* duh */
+
+			radeon_cp_dispatch_indices(dev, buf, &tclprim);
+		} else {
+			tclprim.numverts = prim.numverts;
+			tclprim.offset = 0;	/* not used */
+
+			radeon_cp_dispatch_vertex(dev, buf, &tclprim);
+		}
+
+		if (sarea_priv->nbox == 1)
+			sarea_priv->nbox = 0;
+	}
+
+	if (vertex->discard) {
+		radeon_cp_discard_buffer(dev, buf);
+	}
+
+	COMMIT_RING();
+	return 0;
+}
+
+static int radeon_emit_packets(drm_radeon_private_t * dev_priv,
+			       struct drm_file *file_priv,
+			       drm_radeon_cmd_header_t header,
+			       drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	int id = (int)header.packet.packet_id;
+	int sz, reg;
+	int *data = (int *)cmdbuf->buf;
+	RING_LOCALS;
+
+	if (id >= RADEON_MAX_STATE_PACKETS)
+		return -EINVAL;
+
+	sz = packet[id].len;
+	reg = packet[id].start;
+
+	if (sz * sizeof(int) > cmdbuf->bufsz) {
+		DRM_ERROR("Packet size provided larger than data provided\n");
+		return -EINVAL;
+	}
+
+	if (radeon_check_and_fixup_packets(dev_priv, file_priv, id, data)) {
+		DRM_ERROR("Packet verification failed\n");
+		return -EINVAL;
+	}
+
+	BEGIN_RING(sz + 1);
+	OUT_RING(CP_PACKET0(reg, (sz - 1)));
+	OUT_RING_TABLE(data, sz);
+	ADVANCE_RING();
+
+	cmdbuf->buf += sz * sizeof(int);
+	cmdbuf->bufsz -= sz * sizeof(int);
+	return 0;
+}
+
+static __inline__ int radeon_emit_scalars(drm_radeon_private_t *dev_priv,
+					  drm_radeon_cmd_header_t header,
+					  drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	int sz = header.scalars.count;
+	int start = header.scalars.offset;
+	int stride = header.scalars.stride;
+	RING_LOCALS;
+
+	BEGIN_RING(3 + sz);
+	OUT_RING(CP_PACKET0(RADEON_SE_TCL_SCALAR_INDX_REG, 0));
+	OUT_RING(start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));
+	OUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_SCALAR_DATA_REG, sz - 1));
+	OUT_RING_TABLE(cmdbuf->buf, sz);
+	ADVANCE_RING();
+	cmdbuf->buf += sz * sizeof(int);
+	cmdbuf->bufsz -= sz * sizeof(int);
+	return 0;
+}
+
+/* God this is ugly
+ */
+static __inline__ int radeon_emit_scalars2(drm_radeon_private_t *dev_priv,
+					   drm_radeon_cmd_header_t header,
+					   drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	int sz = header.scalars.count;
+	int start = ((unsigned int)header.scalars.offset) + 0x100;
+	int stride = header.scalars.stride;
+	RING_LOCALS;
+
+	BEGIN_RING(3 + sz);
+	OUT_RING(CP_PACKET0(RADEON_SE_TCL_SCALAR_INDX_REG, 0));
+	OUT_RING(start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));
+	OUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_SCALAR_DATA_REG, sz - 1));
+	OUT_RING_TABLE(cmdbuf->buf, sz);
+	ADVANCE_RING();
+	cmdbuf->buf += sz * sizeof(int);
+	cmdbuf->bufsz -= sz * sizeof(int);
+	return 0;
+}
+
+static __inline__ int radeon_emit_vectors(drm_radeon_private_t *dev_priv,
+					  drm_radeon_cmd_header_t header,
+					  drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	int sz = header.vectors.count;
+	int start = header.vectors.offset;
+	int stride = header.vectors.stride;
+	RING_LOCALS;
+
+	BEGIN_RING(5 + sz);
+	OUT_RING_REG(RADEON_SE_TCL_STATE_FLUSH, 0);
+	OUT_RING(CP_PACKET0(RADEON_SE_TCL_VECTOR_INDX_REG, 0));
+	OUT_RING(start | (stride << RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT));
+	OUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_VECTOR_DATA_REG, (sz - 1)));
+	OUT_RING_TABLE(cmdbuf->buf, sz);
+	ADVANCE_RING();
+
+	cmdbuf->buf += sz * sizeof(int);
+	cmdbuf->bufsz -= sz * sizeof(int);
+	return 0;
+}
+
+static __inline__ int radeon_emit_veclinear(drm_radeon_private_t *dev_priv,
+					  drm_radeon_cmd_header_t header,
+					  drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	int sz = header.veclinear.count * 4;
+	int start = header.veclinear.addr_lo | (header.veclinear.addr_hi << 8);
+	RING_LOCALS;
+
+	if (!sz)
+		return 0;
+	if (sz * 4 > cmdbuf->bufsz)
+		return -EINVAL;
+
+	BEGIN_RING(5 + sz);
+	OUT_RING_REG(RADEON_SE_TCL_STATE_FLUSH, 0);
+	OUT_RING(CP_PACKET0(RADEON_SE_TCL_VECTOR_INDX_REG, 0));
+	OUT_RING(start | (1 << RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT));
+	OUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_VECTOR_DATA_REG, (sz - 1)));
+	OUT_RING_TABLE(cmdbuf->buf, sz);
+	ADVANCE_RING();
+
+	cmdbuf->buf += sz * sizeof(int);
+	cmdbuf->bufsz -= sz * sizeof(int);
+	return 0;
+}
+
+static int radeon_emit_packet3(struct drm_device * dev,
+			       struct drm_file *file_priv,
+			       drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	unsigned int cmdsz;
+	int ret;
+	RING_LOCALS;
+
+	DRM_DEBUG("\n");
+
+	if ((ret = radeon_check_and_fixup_packet3(dev_priv, file_priv,
+						  cmdbuf, &cmdsz))) {
+		DRM_ERROR("Packet verification failed\n");
+		return ret;
+	}
+
+	BEGIN_RING(cmdsz);
+	OUT_RING_TABLE(cmdbuf->buf, cmdsz);
+	ADVANCE_RING();
+
+	cmdbuf->buf += cmdsz * 4;
+	cmdbuf->bufsz -= cmdsz * 4;
+	return 0;
+}
+
+static int radeon_emit_packet3_cliprect(struct drm_device *dev,
+					struct drm_file *file_priv,
+					drm_radeon_kcmd_buffer_t *cmdbuf,
+					int orig_nbox)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	struct drm_clip_rect box;
+	unsigned int cmdsz;
+	int ret;
+	struct drm_clip_rect __user *boxes = cmdbuf->boxes;
+	int i = 0;
+	RING_LOCALS;
+
+	DRM_DEBUG("\n");
+
+	if ((ret = radeon_check_and_fixup_packet3(dev_priv, file_priv,
+						  cmdbuf, &cmdsz))) {
+		DRM_ERROR("Packet verification failed\n");
+		return ret;
+	}
+
+	if (!orig_nbox)
+		goto out;
+
+	do {
+		if (i < cmdbuf->nbox) {
+			if (DRM_COPY_FROM_USER(&box, &boxes[i], sizeof(box)))
+				return -EFAULT;
+			/* FIXME The second and subsequent times round
+			 * this loop, send a WAIT_UNTIL_3D_IDLE before
+			 * calling emit_clip_rect(). This fixes a
+			 * lockup on fast machines when sending
+			 * several cliprects with a cmdbuf, as when
+			 * waving a 2D window over a 3D
+			 * window. Something in the commands from user
+			 * space seems to hang the card when they're
+			 * sent several times in a row. That would be
+			 * the correct place to fix it but this works
+			 * around it until I can figure that out - Tim
+			 * Smith */
+			if (i) {
+				BEGIN_RING(2);
+				RADEON_WAIT_UNTIL_3D_IDLE();
+				ADVANCE_RING();
+			}
+			radeon_emit_clip_rect(dev_priv, &box);
+		}
+
+		BEGIN_RING(cmdsz);
+		OUT_RING_TABLE(cmdbuf->buf, cmdsz);
+		ADVANCE_RING();
+
+	} while (++i < cmdbuf->nbox);
+	if (cmdbuf->nbox == 1)
+		cmdbuf->nbox = 0;
+
+      out:
+	cmdbuf->buf += cmdsz * 4;
+	cmdbuf->bufsz -= cmdsz * 4;
+	return 0;
+}
+
+static int radeon_emit_wait(struct drm_device * dev, int flags)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	RING_LOCALS;
+
+	DRM_DEBUG("%s: %x\n", __FUNCTION__, flags);
+	switch (flags) {
+	case RADEON_WAIT_2D:
+		BEGIN_RING(2);
+		RADEON_WAIT_UNTIL_2D_IDLE();
+		ADVANCE_RING();
+		break;
+	case RADEON_WAIT_3D:
+		BEGIN_RING(2);
+		RADEON_WAIT_UNTIL_3D_IDLE();
+		ADVANCE_RING();
+		break;
+	case RADEON_WAIT_2D | RADEON_WAIT_3D:
+		BEGIN_RING(2);
+		RADEON_WAIT_UNTIL_IDLE();
+		ADVANCE_RING();
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int radeon_cp_cmdbuf(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf = NULL;
+	int idx;
+	drm_radeon_kcmd_buffer_t *cmdbuf = data;
+	drm_radeon_cmd_header_t header;
+	int orig_nbox, orig_bufsz;
+	char *kbuf = NULL;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
+
+	if (cmdbuf->bufsz > 64 * 1024 || cmdbuf->bufsz < 0) {
+		return -EINVAL;
+	}
+
+	/* Allocate an in-kernel area and copy in the cmdbuf.  Do this to avoid
+	 * races between checking values and using those values in other code,
+	 * and simply to avoid a lot of function calls to copy in data.
+	 */
+	orig_bufsz = cmdbuf->bufsz;
+	if (orig_bufsz != 0) {
+		kbuf = drm_alloc(cmdbuf->bufsz, DRM_MEM_DRIVER);
+		if (kbuf == NULL)
+			return -ENOMEM;
+		if (DRM_COPY_FROM_USER(kbuf, (void __user *)cmdbuf->buf,
+				       cmdbuf->bufsz)) {
+			drm_free(kbuf, orig_bufsz, DRM_MEM_DRIVER);
+			return -EFAULT;
+		}
+		cmdbuf->buf = kbuf;
+	}
+
+	orig_nbox = cmdbuf->nbox;
+
+	if (dev_priv->microcode_version == UCODE_R300) {
+		int temp;
+		temp = r300_do_cp_cmdbuf(dev, file_priv, cmdbuf);
+
+		if (orig_bufsz != 0)
+			drm_free(kbuf, orig_bufsz, DRM_MEM_DRIVER);
+
+		return temp;
+	}
+
+	/* microcode_version != r300 */
+	while (cmdbuf->bufsz >= sizeof(header)) {
+
+		header.i = *(int *)cmdbuf->buf;
+		cmdbuf->buf += sizeof(header);
+		cmdbuf->bufsz -= sizeof(header);
+
+		switch (header.header.cmd_type) {
+		case RADEON_CMD_PACKET:
+			DRM_DEBUG("RADEON_CMD_PACKET\n");
+			if (radeon_emit_packets
+			    (dev_priv, file_priv, header, cmdbuf)) {
+				DRM_ERROR("radeon_emit_packets failed\n");
+				goto err;
+			}
+			break;
+
+		case RADEON_CMD_SCALARS:
+			DRM_DEBUG("RADEON_CMD_SCALARS\n");
+			if (radeon_emit_scalars(dev_priv, header, cmdbuf)) {
+				DRM_ERROR("radeon_emit_scalars failed\n");
+				goto err;
+			}
+			break;
+
+		case RADEON_CMD_VECTORS:
+			DRM_DEBUG("RADEON_CMD_VECTORS\n");
+			if (radeon_emit_vectors(dev_priv, header, cmdbuf)) {
+				DRM_ERROR("radeon_emit_vectors failed\n");
+				goto err;
+			}
+			break;
+
+		case RADEON_CMD_DMA_DISCARD:
+			DRM_DEBUG("RADEON_CMD_DMA_DISCARD\n");
+			idx = header.dma.buf_idx;
+			if (idx < 0 || idx >= dma->buf_count) {
+				DRM_ERROR("buffer index %d (of %d max)\n",
+					  idx, dma->buf_count - 1);
+				goto err;
+			}
+
+			buf = dma->buflist[idx];
+			if (buf->file_priv != file_priv || buf->pending) {
+				DRM_ERROR("bad buffer %p %p %d\n",
+					  buf->file_priv, file_priv,
+					  buf->pending);
+				goto err;
+			}
+
+			radeon_cp_discard_buffer(dev, buf);
+			break;
+
+		case RADEON_CMD_PACKET3:
+			DRM_DEBUG("RADEON_CMD_PACKET3\n");
+			if (radeon_emit_packet3(dev, file_priv, cmdbuf)) {
+				DRM_ERROR("radeon_emit_packet3 failed\n");
+				goto err;
+			}
+			break;
+
+		case RADEON_CMD_PACKET3_CLIP:
+			DRM_DEBUG("RADEON_CMD_PACKET3_CLIP\n");
+			if (radeon_emit_packet3_cliprect
+			    (dev, file_priv, cmdbuf, orig_nbox)) {
+				DRM_ERROR("radeon_emit_packet3_clip failed\n");
+				goto err;
+			}
+			break;
+
+		case RADEON_CMD_SCALARS2:
+			DRM_DEBUG("RADEON_CMD_SCALARS2\n");
+			if (radeon_emit_scalars2(dev_priv, header, cmdbuf)) {
+				DRM_ERROR("radeon_emit_scalars2 failed\n");
+				goto err;
+			}
+			break;
+
+		case RADEON_CMD_WAIT:
+			DRM_DEBUG("RADEON_CMD_WAIT\n");
+			if (radeon_emit_wait(dev, header.wait.flags)) {
+				DRM_ERROR("radeon_emit_wait failed\n");
+				goto err;
+			}
+			break;
+		case RADEON_CMD_VECLINEAR:
+			DRM_DEBUG("RADEON_CMD_VECLINEAR\n");
+			if (radeon_emit_veclinear(dev_priv, header, cmdbuf)) {
+				DRM_ERROR("radeon_emit_veclinear failed\n");
+				goto err;
+			}
+			break;
+
+		default:
+			DRM_ERROR("bad cmd_type %d at %p\n",
+				  header.header.cmd_type,
+				  cmdbuf->buf - sizeof(header));
+			goto err;
+		}
+	}
+
+	if (orig_bufsz != 0)
+		drm_free(kbuf, orig_bufsz, DRM_MEM_DRIVER);
+
+	DRM_DEBUG("DONE\n");
+	COMMIT_RING();
+	return 0;
+
+      err:
+	if (orig_bufsz != 0)
+		drm_free(kbuf, orig_bufsz, DRM_MEM_DRIVER);
+	return -EINVAL;
+}
+
+static int radeon_cp_getparam(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_getparam_t *param = data;
+	int value;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
+
+	switch (param->param) {
+	case RADEON_PARAM_GART_BUFFER_OFFSET:
+		value = dev_priv->gart_buffers_offset;
+		break;
+	case RADEON_PARAM_LAST_FRAME:
+		dev_priv->stats.last_frame_reads++;
+		value = GET_SCRATCH(0);
+		break;
+	case RADEON_PARAM_LAST_DISPATCH:
+		value = GET_SCRATCH(1);
+		break;
+	case RADEON_PARAM_LAST_CLEAR:
+		dev_priv->stats.last_clear_reads++;
+		value = GET_SCRATCH(2);
+		break;
+	case RADEON_PARAM_IRQ_NR:
+		value = dev->irq;
+		break;
+	case RADEON_PARAM_GART_BASE:
+		value = dev_priv->gart_vm_start;
+		break;
+	case RADEON_PARAM_REGISTER_HANDLE:
+		value = dev_priv->mmio->offset;
+		break;
+	case RADEON_PARAM_STATUS_HANDLE:
+		value = dev_priv->ring_rptr_offset;
+		break;
+#ifndef __LP64__
+		/*
+		 * This ioctl() doesn't work on 64-bit platforms because hw_lock is a
+		 * pointer which can't fit into an int-sized variable.  According to
+		 * Michel Dnzer, the ioctl() is only used on embedded platforms, so
+		 * not supporting it shouldn't be a problem.  If the same functionality
+		 * is needed on 64-bit platforms, a new ioctl() would have to be added,
+		 * so backwards-compatibility for the embedded platforms can be
+		 * maintained.  --davidm 4-Feb-2004.
+		 */
+	case RADEON_PARAM_SAREA_HANDLE:
+		/* The lock is the first dword in the sarea. */
+		value = (long)dev->lock.hw_lock;
+		break;
+#endif
+	case RADEON_PARAM_GART_TEX_HANDLE:
+		value = dev_priv->gart_textures_offset;
+		break;
+	case RADEON_PARAM_SCRATCH_OFFSET:
+		if (!dev_priv->writeback_works)
+			return -EINVAL;
+		value = RADEON_SCRATCH_REG_OFFSET;
+		break;
+	
+	case RADEON_PARAM_CARD_TYPE:
+		if (dev_priv->flags & RADEON_IS_PCIE)
+			value = RADEON_CARD_PCIE;
+		else if (dev_priv->flags & RADEON_IS_AGP)
+			value = RADEON_CARD_AGP;
+		else
+			value = RADEON_CARD_PCI;
+		break;
+	case RADEON_PARAM_VBLANK_CRTC:
+		value = radeon_vblank_crtc_get(dev);
+		break;
+	default:
+		DRM_DEBUG( "Invalid parameter %d\n", param->param );
+		return -EINVAL;
+	}
+
+	if (DRM_COPY_TO_USER(param->value, &value, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int radeon_cp_setparam(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_setparam_t *sp = data;
+	struct drm_radeon_driver_file_fields *radeon_priv;
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	switch (sp->param) {
+	case RADEON_SETPARAM_FB_LOCATION:
+		radeon_priv = file_priv->driver_priv;
+		radeon_priv->radeon_fb_delta = dev_priv->fb_location -
+		    sp->value;
+		break;
+	case RADEON_SETPARAM_SWITCH_TILING:
+		if (sp->value == 0) {
+			DRM_DEBUG("color tiling disabled\n");
+			dev_priv->front_pitch_offset &= ~RADEON_DST_TILE_MACRO;
+			dev_priv->back_pitch_offset &= ~RADEON_DST_TILE_MACRO;
+			dev_priv->sarea_priv->tiling_enabled = 0;
+		} else if (sp->value == 1) {
+			DRM_DEBUG("color tiling enabled\n");
+			dev_priv->front_pitch_offset |= RADEON_DST_TILE_MACRO;
+			dev_priv->back_pitch_offset |= RADEON_DST_TILE_MACRO;
+			dev_priv->sarea_priv->tiling_enabled = 1;
+		}
+		break;
+	case RADEON_SETPARAM_PCIGART_LOCATION:
+		dev_priv->pcigart_offset = sp->value;
+		dev_priv->pcigart_offset_set = 1;
+		break;
+	case RADEON_SETPARAM_NEW_MEMMAP:
+		dev_priv->new_memmap = sp->value;
+		break;
+	case RADEON_SETPARAM_PCIGART_TABLE_SIZE:
+		dev_priv->gart_info.table_size = sp->value;
+		if (dev_priv->gart_info.table_size < RADEON_PCIGART_TABLE_SIZE)
+			dev_priv->gart_info.table_size = RADEON_PCIGART_TABLE_SIZE;
+		break;
+	case RADEON_SETPARAM_VBLANK_CRTC:
+		return radeon_vblank_crtc_set(dev, sp->value);
+		break;
+	default:
+		DRM_DEBUG("Invalid parameter %d\n", sp->param);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* When a client dies:
+ *    - Check for and clean up flipped page state
+ *    - Free any alloced GART memory.
+ *    - Free any alloced radeon surfaces.
+ *
+ * DRM infrastructure takes care of reclaiming dma buffers.
+ */
+void radeon_driver_preclose(struct drm_device * dev,
+			    struct drm_file *file_priv)
+{
+	if (dev->dev_private) {
+		drm_radeon_private_t *dev_priv = dev->dev_private;
+		dev_priv->page_flipping = 0;
+		radeon_mem_release(file_priv, dev_priv->gart_heap);
+		radeon_mem_release(file_priv, dev_priv->fb_heap);
+		radeon_surfaces_release(file_priv, dev_priv);
+	}
+}
+
+void radeon_driver_lastclose(struct drm_device * dev)
+{
+	if (dev->dev_private) {
+		drm_radeon_private_t *dev_priv = dev->dev_private;
+
+		if (dev_priv->sarea_priv &&
+		    dev_priv->sarea_priv->pfCurrentPage != 0)
+			radeon_cp_dispatch_flip(dev);
+	}
+
+	radeon_do_release(dev);
+}
+
+int radeon_driver_open(struct drm_device * dev, struct drm_file *file_priv)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	struct drm_radeon_driver_file_fields *radeon_priv;
+
+	DRM_DEBUG("\n");
+	radeon_priv =
+	    (struct drm_radeon_driver_file_fields *)
+	    drm_alloc(sizeof(*radeon_priv), DRM_MEM_FILES);
+
+	if (!radeon_priv)
+		return -ENOMEM;
+
+	file_priv->driver_priv = radeon_priv;
+
+	if (dev_priv)
+		radeon_priv->radeon_fb_delta = dev_priv->fb_location;
+	else
+		radeon_priv->radeon_fb_delta = 0;
+	return 0;
+}
+
+void radeon_driver_postclose(struct drm_device * dev, struct drm_file *file_priv)
+{
+	struct drm_radeon_driver_file_fields *radeon_priv =
+	    file_priv->driver_priv;
+
+	drm_free(radeon_priv, sizeof(*radeon_priv), DRM_MEM_FILES);
+}
+
+struct drm_ioctl_desc radeon_ioctls[] = {
+	DRM_IOCTL_DEF(DRM_RADEON_CP_INIT, radeon_cp_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_CP_START, radeon_cp_start, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_CP_STOP, radeon_cp_stop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_CP_RESET, radeon_cp_reset, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_CP_IDLE, radeon_cp_idle, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_CP_RESUME, radeon_cp_resume, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_RESET, radeon_engine_reset, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_FULLSCREEN, radeon_fullscreen, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_SWAP, radeon_cp_swap, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_CLEAR, radeon_cp_clear, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_VERTEX, radeon_cp_vertex, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_INDICES, radeon_cp_indices, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_TEXTURE, radeon_cp_texture, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_STIPPLE, radeon_cp_stipple, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_INDIRECT, radeon_cp_indirect, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_VERTEX2, radeon_cp_vertex2, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_CMDBUF, radeon_cp_cmdbuf, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_GETPARAM, radeon_cp_getparam, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_FLIP, radeon_cp_flip, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_ALLOC, radeon_mem_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_FREE, radeon_mem_free, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_INIT_HEAP, radeon_mem_init_heap, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_IRQ_EMIT, radeon_irq_emit, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_IRQ_WAIT, radeon_irq_wait, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_SETPARAM, radeon_cp_setparam, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_SURF_ALLOC, radeon_surface_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_SURF_FREE, radeon_surface_free, DRM_AUTH)
+};
+
+int radeon_max_ioctl = DRM_ARRAY_SIZE(radeon_ioctls);
Index: git/shared-core/savage_bci.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/savage_bci.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,1095 @@
+/* savage_bci.c -- BCI support for Savage
+ *
+ * Copyright 2004  Felix Kuehling
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL FELIX KUEHLING BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "drmP.h"
+#include "savage_drm.h"
+#include "savage_drv.h"
+
+/* Need a long timeout for shadow status updates can take a while
+ * and so can waiting for events when the queue is full. */
+#define SAVAGE_DEFAULT_USEC_TIMEOUT	1000000 /* 1s */
+#define SAVAGE_EVENT_USEC_TIMEOUT	5000000 /* 5s */
+#define SAVAGE_FREELIST_DEBUG		0
+
+static int savage_do_cleanup_bci(struct drm_device *dev);
+
+static int
+savage_bci_wait_fifo_shadow(drm_savage_private_t *dev_priv, unsigned int n)
+{
+	uint32_t mask = dev_priv->status_used_mask;
+	uint32_t threshold = dev_priv->bci_threshold_hi;
+	uint32_t status;
+	int i;
+
+#if SAVAGE_BCI_DEBUG
+	if (n > dev_priv->cob_size + SAVAGE_BCI_FIFO_SIZE - threshold)
+		DRM_ERROR("Trying to emit %d words "
+			  "(more than guaranteed space in COB)\n", n);
+#endif
+
+	for (i = 0; i < SAVAGE_DEFAULT_USEC_TIMEOUT; i++) {
+		DRM_MEMORYBARRIER();
+		status = dev_priv->status_ptr[0];
+		if ((status & mask) < threshold)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if SAVAGE_BCI_DEBUG
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x, threshold=0x%08x\n", status, threshold);
+#endif
+	return -EBUSY;
+}
+
+static int
+savage_bci_wait_fifo_s3d(drm_savage_private_t *dev_priv, unsigned int n)
+{
+	uint32_t maxUsed = dev_priv->cob_size + SAVAGE_BCI_FIFO_SIZE - n;
+	uint32_t status;
+	int i;
+
+	for (i = 0; i < SAVAGE_DEFAULT_USEC_TIMEOUT; i++) {
+		status = SAVAGE_READ(SAVAGE_STATUS_WORD0);
+		if ((status & SAVAGE_FIFO_USED_MASK_S3D) <= maxUsed)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if SAVAGE_BCI_DEBUG
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x\n", status);
+#endif
+	return -EBUSY;
+}
+
+static int
+savage_bci_wait_fifo_s4(drm_savage_private_t *dev_priv, unsigned int n)
+{
+	uint32_t maxUsed = dev_priv->cob_size + SAVAGE_BCI_FIFO_SIZE - n;
+	uint32_t status;
+	int i;
+
+	for (i = 0; i < SAVAGE_DEFAULT_USEC_TIMEOUT; i++) {
+		status = SAVAGE_READ(SAVAGE_ALT_STATUS_WORD0);
+		if ((status & SAVAGE_FIFO_USED_MASK_S4) <= maxUsed)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if SAVAGE_BCI_DEBUG
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x\n", status);
+#endif
+	return -EBUSY;
+}
+
+/*
+ * Waiting for events.
+ *
+ * The BIOSresets the event tag to 0 on mode changes. Therefore we
+ * never emit 0 to the event tag. If we find a 0 event tag we know the
+ * BIOS stomped on it and return success assuming that the BIOS waited
+ * for engine idle.
+ *
+ * Note: if the Xserver uses the event tag it has to follow the same
+ * rule. Otherwise there may be glitches every 2^16 events.
+ */
+static int
+savage_bci_wait_event_shadow(drm_savage_private_t *dev_priv, uint16_t e)
+{
+	uint32_t status;
+	int i;
+
+	for (i = 0; i < SAVAGE_EVENT_USEC_TIMEOUT; i++) {
+		DRM_MEMORYBARRIER();
+		status = dev_priv->status_ptr[1];
+		if ((((status & 0xffff) - e) & 0xffff) <= 0x7fff ||
+		    (status & 0xffff) == 0)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if SAVAGE_BCI_DEBUG
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x, e=0x%04x\n", status, e);
+#endif
+
+	return -EBUSY;
+}
+
+static int
+savage_bci_wait_event_reg(drm_savage_private_t *dev_priv, uint16_t e)
+{
+	uint32_t status;
+	int i;
+
+	for (i = 0; i < SAVAGE_EVENT_USEC_TIMEOUT; i++) {
+		status = SAVAGE_READ(SAVAGE_STATUS_WORD1);
+		if ((((status & 0xffff) - e) & 0xffff) <= 0x7fff ||
+		    (status & 0xffff) == 0)
+			return 0;
+		DRM_UDELAY(1);
+	}
+
+#if SAVAGE_BCI_DEBUG
+	DRM_ERROR("failed!\n");
+	DRM_INFO("   status=0x%08x, e=0x%04x\n", status, e);
+#endif
+
+	return -EBUSY;
+}
+
+uint16_t savage_bci_emit_event(drm_savage_private_t *dev_priv,
+			       unsigned int flags)
+{
+	uint16_t count;
+	BCI_LOCALS;
+
+	if (dev_priv->status_ptr) {
+		/* coordinate with Xserver */
+		count = dev_priv->status_ptr[1023];
+		if (count < dev_priv->event_counter)
+			dev_priv->event_wrap++;
+	} else {
+		count = dev_priv->event_counter;
+	}
+	count = (count + 1) & 0xffff;
+	if (count == 0) {
+		count++; /* See the comment above savage_wait_event_*. */
+		dev_priv->event_wrap++;
+	}
+	dev_priv->event_counter = count;
+	if (dev_priv->status_ptr)
+		dev_priv->status_ptr[1023] = (uint32_t)count;
+
+	if ((flags & (SAVAGE_WAIT_2D | SAVAGE_WAIT_3D))) {
+		unsigned int wait_cmd = BCI_CMD_WAIT;
+		if ((flags & SAVAGE_WAIT_2D))
+			wait_cmd |= BCI_CMD_WAIT_2D;
+		if ((flags & SAVAGE_WAIT_3D))
+			wait_cmd |= BCI_CMD_WAIT_3D;
+		BEGIN_BCI(2);
+		BCI_WRITE(wait_cmd);
+	} else {
+		BEGIN_BCI(1);
+	}
+	BCI_WRITE(BCI_CMD_UPDATE_EVENT_TAG | (uint32_t)count);
+
+	return count;
+}
+
+/*
+ * Freelist management
+ */
+static int savage_freelist_init(struct drm_device *dev)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
+	drm_savage_buf_priv_t *entry;
+	int i;
+	DRM_DEBUG("count=%d\n", dma->buf_count);
+
+	dev_priv->head.next = &dev_priv->tail;
+	dev_priv->head.prev = NULL;
+	dev_priv->head.buf = NULL;
+
+	dev_priv->tail.next = NULL;
+	dev_priv->tail.prev = &dev_priv->head;
+	dev_priv->tail.buf = NULL;
+
+	for (i = 0; i < dma->buf_count; i++) {
+		buf = dma->buflist[i];
+		entry = buf->dev_private;
+
+		SET_AGE(&entry->age, 0, 0);
+		entry->buf = buf;
+
+		entry->next = dev_priv->head.next;
+		entry->prev = &dev_priv->head;
+		dev_priv->head.next->prev = entry;
+		dev_priv->head.next = entry;
+	}
+
+	return 0;
+}
+
+static struct drm_buf *savage_freelist_get(struct drm_device *dev)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	drm_savage_buf_priv_t *tail = dev_priv->tail.prev;
+	uint16_t event;
+	unsigned int wrap;
+	DRM_DEBUG("\n");
+
+	UPDATE_EVENT_COUNTER();
+	if (dev_priv->status_ptr)
+		event = dev_priv->status_ptr[1] & 0xffff;
+	else
+		event = SAVAGE_READ(SAVAGE_STATUS_WORD1) & 0xffff;
+	wrap = dev_priv->event_wrap;
+	if (event > dev_priv->event_counter)
+		wrap--; /* hardware hasn't passed the last wrap yet */
+
+	DRM_DEBUG("   tail=0x%04x %d\n", tail->age.event, tail->age.wrap);
+	DRM_DEBUG("   head=0x%04x %d\n", event, wrap);
+
+	if (tail->buf && (TEST_AGE(&tail->age, event, wrap) || event == 0)) {
+		drm_savage_buf_priv_t *next = tail->next;
+		drm_savage_buf_priv_t *prev = tail->prev;
+		prev->next = next;
+		next->prev = prev;
+		tail->next = tail->prev = NULL;
+		return tail->buf;
+	}
+
+	DRM_DEBUG("returning NULL, tail->buf=%p!\n", tail->buf);
+	return NULL;
+}
+
+void savage_freelist_put(struct drm_device *dev, struct drm_buf *buf)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	drm_savage_buf_priv_t *entry = buf->dev_private, *prev, *next;
+
+	DRM_DEBUG("age=0x%04x wrap=%d\n", entry->age.event, entry->age.wrap);
+
+	if (entry->next != NULL || entry->prev != NULL) {
+		DRM_ERROR("entry already on freelist.\n");
+		return;
+	}
+
+	prev = &dev_priv->head;
+	next = prev->next;
+	prev->next = entry;
+	next->prev = entry;
+	entry->prev = prev;
+	entry->next = next;
+}
+
+/*
+ * Command DMA
+ */
+static int savage_dma_init(drm_savage_private_t *dev_priv)
+{
+	unsigned int i;
+
+	dev_priv->nr_dma_pages = dev_priv->cmd_dma->size /
+		(SAVAGE_DMA_PAGE_SIZE*4);
+	dev_priv->dma_pages = drm_alloc(sizeof(drm_savage_dma_page_t) *
+					dev_priv->nr_dma_pages, DRM_MEM_DRIVER);
+	if (dev_priv->dma_pages == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < dev_priv->nr_dma_pages; ++i) {
+		SET_AGE(&dev_priv->dma_pages[i].age, 0, 0);
+		dev_priv->dma_pages[i].used = 0;
+		dev_priv->dma_pages[i].flushed = 0;
+	}
+	SET_AGE(&dev_priv->last_dma_age, 0, 0);
+
+	dev_priv->first_dma_page = 0;
+	dev_priv->current_dma_page = 0;
+
+	return 0;
+}
+
+void savage_dma_reset(drm_savage_private_t *dev_priv)
+{
+	uint16_t event;
+	unsigned int wrap, i;
+	event = savage_bci_emit_event(dev_priv, 0);
+	wrap = dev_priv->event_wrap;
+	for (i = 0; i < dev_priv->nr_dma_pages; ++i) {
+		SET_AGE(&dev_priv->dma_pages[i].age, event, wrap);
+		dev_priv->dma_pages[i].used = 0;
+		dev_priv->dma_pages[i].flushed = 0;
+	}
+	SET_AGE(&dev_priv->last_dma_age, event, wrap);
+	dev_priv->first_dma_page = dev_priv->current_dma_page = 0;
+}
+
+void savage_dma_wait(drm_savage_private_t *dev_priv, unsigned int page)
+{
+	uint16_t event;
+	unsigned int wrap;
+
+	/* Faked DMA buffer pages don't age. */
+	if (dev_priv->cmd_dma == &dev_priv->fake_dma)
+		return;
+
+	UPDATE_EVENT_COUNTER();
+	if (dev_priv->status_ptr)
+		event = dev_priv->status_ptr[1] & 0xffff;
+	else
+		event = SAVAGE_READ(SAVAGE_STATUS_WORD1) & 0xffff;
+	wrap = dev_priv->event_wrap;
+	if (event > dev_priv->event_counter)
+		wrap--; /* hardware hasn't passed the last wrap yet */
+
+	if (dev_priv->dma_pages[page].age.wrap > wrap ||
+	    (dev_priv->dma_pages[page].age.wrap == wrap &&
+	     dev_priv->dma_pages[page].age.event > event)) {
+		if (dev_priv->wait_evnt(dev_priv,
+					dev_priv->dma_pages[page].age.event)
+		    < 0)
+			DRM_ERROR("wait_evnt failed!\n");
+	}
+}
+
+uint32_t *savage_dma_alloc(drm_savage_private_t *dev_priv, unsigned int n)
+{
+	unsigned int cur = dev_priv->current_dma_page;
+	unsigned int rest = SAVAGE_DMA_PAGE_SIZE -
+		dev_priv->dma_pages[cur].used;
+	unsigned int nr_pages = (n - rest + SAVAGE_DMA_PAGE_SIZE-1) /
+		SAVAGE_DMA_PAGE_SIZE;
+	uint32_t *dma_ptr;
+	unsigned int i;
+
+	DRM_DEBUG("cur=%u, cur->used=%u, n=%u, rest=%u, nr_pages=%u\n",
+		  cur, dev_priv->dma_pages[cur].used, n, rest, nr_pages);
+
+	if (cur + nr_pages < dev_priv->nr_dma_pages) {
+		dma_ptr = (uint32_t *)dev_priv->cmd_dma->handle +
+		    cur*SAVAGE_DMA_PAGE_SIZE + dev_priv->dma_pages[cur].used;
+		if (n < rest)
+			rest = n;
+		dev_priv->dma_pages[cur].used += rest;
+		n -= rest;
+		cur++;
+	} else {
+		dev_priv->dma_flush(dev_priv);
+		nr_pages =
+		    (n + SAVAGE_DMA_PAGE_SIZE-1) / SAVAGE_DMA_PAGE_SIZE;
+		for (i = cur; i < dev_priv->nr_dma_pages; ++i) {
+			dev_priv->dma_pages[i].age = dev_priv->last_dma_age;
+			dev_priv->dma_pages[i].used = 0;
+			dev_priv->dma_pages[i].flushed = 0;
+		}
+		dma_ptr = (uint32_t *)dev_priv->cmd_dma->handle;
+		dev_priv->first_dma_page = cur = 0;
+	}
+	for (i = cur; nr_pages > 0; ++i, --nr_pages) {
+#if SAVAGE_DMA_DEBUG
+		if (dev_priv->dma_pages[i].used) {
+			DRM_ERROR("unflushed page %u: used=%u\n",
+				  i, dev_priv->dma_pages[i].used);
+		}
+#endif
+		if (n > SAVAGE_DMA_PAGE_SIZE)
+			dev_priv->dma_pages[i].used = SAVAGE_DMA_PAGE_SIZE;
+		else
+			dev_priv->dma_pages[i].used = n;
+		n -= SAVAGE_DMA_PAGE_SIZE;
+	}
+	dev_priv->current_dma_page = --i;
+
+	DRM_DEBUG("cur=%u, cur->used=%u, n=%u\n",
+		  i, dev_priv->dma_pages[i].used, n);
+
+	savage_dma_wait(dev_priv, dev_priv->current_dma_page);
+
+	return dma_ptr;
+}
+
+static void savage_dma_flush(drm_savage_private_t *dev_priv)
+{
+	unsigned int first = dev_priv->first_dma_page;
+	unsigned int cur = dev_priv->current_dma_page;
+	uint16_t event;
+	unsigned int wrap, pad, align, len, i;
+	unsigned long phys_addr;
+	BCI_LOCALS;
+
+	if (first == cur &&
+	    dev_priv->dma_pages[cur].used == dev_priv->dma_pages[cur].flushed)
+		return;
+
+	/* pad length to multiples of 2 entries
+	 * align start of next DMA block to multiles of 8 entries */
+	pad = -dev_priv->dma_pages[cur].used & 1;
+	align = -(dev_priv->dma_pages[cur].used + pad) & 7;
+
+	DRM_DEBUG("first=%u, cur=%u, first->flushed=%u, cur->used=%u, "
+		  "pad=%u, align=%u\n",
+		  first, cur, dev_priv->dma_pages[first].flushed,
+		  dev_priv->dma_pages[cur].used, pad, align);
+
+	/* pad with noops */
+	if (pad) {
+		uint32_t *dma_ptr = (uint32_t *)dev_priv->cmd_dma->handle +
+		    cur * SAVAGE_DMA_PAGE_SIZE + dev_priv->dma_pages[cur].used;
+		dev_priv->dma_pages[cur].used += pad;
+		while(pad != 0) {
+			*dma_ptr++ = BCI_CMD_WAIT;
+			pad--;
+		}
+	}
+
+	DRM_MEMORYBARRIER();
+
+	/* do flush ... */
+	phys_addr = dev_priv->cmd_dma->offset +
+		(first * SAVAGE_DMA_PAGE_SIZE +
+		 dev_priv->dma_pages[first].flushed) * 4;
+	len = (cur - first) * SAVAGE_DMA_PAGE_SIZE +
+	    dev_priv->dma_pages[cur].used - dev_priv->dma_pages[first].flushed;
+
+	DRM_DEBUG("phys_addr=%lx, len=%u\n",
+		  phys_addr | dev_priv->dma_type, len);
+
+	BEGIN_BCI(3);
+	BCI_SET_REGISTERS(SAVAGE_DMABUFADDR, 1);
+	BCI_WRITE(phys_addr | dev_priv->dma_type);
+	BCI_DMA(len);
+
+	/* fix alignment of the start of the next block */
+	dev_priv->dma_pages[cur].used += align;
+
+	/* age DMA pages */
+	event = savage_bci_emit_event(dev_priv, 0);
+	wrap = dev_priv->event_wrap;
+	for (i = first; i < cur; ++i) {
+		SET_AGE(&dev_priv->dma_pages[i].age, event, wrap);
+		dev_priv->dma_pages[i].used = 0;
+		dev_priv->dma_pages[i].flushed = 0;
+	}
+	/* age the current page only when it's full */
+	if (dev_priv->dma_pages[cur].used == SAVAGE_DMA_PAGE_SIZE) {
+		SET_AGE(&dev_priv->dma_pages[cur].age, event, wrap);
+		dev_priv->dma_pages[cur].used = 0;
+		dev_priv->dma_pages[cur].flushed = 0;
+		/* advance to next page */
+		cur++;
+		if (cur == dev_priv->nr_dma_pages)
+			cur = 0;
+		dev_priv->first_dma_page = dev_priv->current_dma_page = cur;
+	} else {
+		dev_priv->first_dma_page = cur;
+		dev_priv->dma_pages[cur].flushed = dev_priv->dma_pages[i].used;
+	}
+	SET_AGE(&dev_priv->last_dma_age, event, wrap);
+
+	DRM_DEBUG("first=cur=%u, cur->used=%u, cur->flushed=%u\n", cur,
+		  dev_priv->dma_pages[cur].used,
+		  dev_priv->dma_pages[cur].flushed);
+}
+
+static void savage_fake_dma_flush(drm_savage_private_t *dev_priv)
+{
+	unsigned int i, j;
+	BCI_LOCALS;
+
+	if (dev_priv->first_dma_page == dev_priv->current_dma_page &&
+	    dev_priv->dma_pages[dev_priv->current_dma_page].used == 0)
+		return;
+
+	DRM_DEBUG("first=%u, cur=%u, cur->used=%u\n",
+		  dev_priv->first_dma_page, dev_priv->current_dma_page,
+		  dev_priv->dma_pages[dev_priv->current_dma_page].used);
+
+	for (i = dev_priv->first_dma_page;
+	     i <= dev_priv->current_dma_page && dev_priv->dma_pages[i].used;
+	     ++i) {
+		uint32_t *dma_ptr = (uint32_t *)dev_priv->cmd_dma->handle +
+			i * SAVAGE_DMA_PAGE_SIZE;
+#if SAVAGE_DMA_DEBUG
+		/* Sanity check: all pages except the last one must be full. */
+		if (i < dev_priv->current_dma_page &&
+		    dev_priv->dma_pages[i].used != SAVAGE_DMA_PAGE_SIZE) {
+			DRM_ERROR("partial DMA page %u: used=%u",
+				  i, dev_priv->dma_pages[i].used);
+		}
+#endif
+		BEGIN_BCI(dev_priv->dma_pages[i].used);
+		for (j = 0; j < dev_priv->dma_pages[i].used; ++j) {
+			BCI_WRITE(dma_ptr[j]);
+		}
+		dev_priv->dma_pages[i].used = 0;
+	}
+
+	/* reset to first page */
+	dev_priv->first_dma_page = dev_priv->current_dma_page = 0;
+}
+
+int savage_driver_load(struct drm_device *dev, unsigned long chipset)
+{
+	drm_savage_private_t *dev_priv;
+
+	dev_priv = drm_alloc(sizeof(drm_savage_private_t), DRM_MEM_DRIVER);
+	if (dev_priv == NULL)
+		return -ENOMEM;
+
+	memset(dev_priv, 0, sizeof(drm_savage_private_t));
+	dev->dev_private = (void *)dev_priv;
+
+	dev_priv->chipset = (enum savage_family)chipset;
+
+	return 0;
+}
+
+/*
+ * Initalize mappings. On Savage4 and SavageIX the alignment
+ * and size of the aperture is not suitable for automatic MTRR setup
+ * in drm_addmap. Therefore we add them manually before the maps are
+ * initialized, and tear them down on last close.
+ */
+int savage_driver_firstopen(struct drm_device *dev)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	unsigned long mmio_base, fb_base, fb_size, aperture_base;
+	/* fb_rsrc and aper_rsrc aren't really used currently, but still exist
+	 * in case we decide we need information on the BAR for BSD in the
+	 * future.
+	 */
+	unsigned int fb_rsrc, aper_rsrc;
+	int ret = 0;
+
+	dev_priv->mtrr[0].handle = -1;
+	dev_priv->mtrr[1].handle = -1;
+	dev_priv->mtrr[2].handle = -1;
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		fb_rsrc = 0;
+		fb_base = drm_get_resource_start(dev, 0);
+		fb_size = SAVAGE_FB_SIZE_S3;
+		mmio_base = fb_base + SAVAGE_FB_SIZE_S3;
+		aper_rsrc = 0;
+		aperture_base = fb_base + SAVAGE_APERTURE_OFFSET;
+		/* this should always be true */
+		if (drm_get_resource_len(dev, 0) == 0x08000000) {
+			/* Don't make MMIO write-cobining! We need 3
+			 * MTRRs. */
+			dev_priv->mtrr[0].base = fb_base;
+			dev_priv->mtrr[0].size = 0x01000000;
+			dev_priv->mtrr[0].handle = 
+			    drm_mtrr_add(dev_priv->mtrr[0].base,
+					 dev_priv->mtrr[0].size, DRM_MTRR_WC);
+			dev_priv->mtrr[1].base = fb_base+0x02000000;
+			dev_priv->mtrr[1].size = 0x02000000;
+			dev_priv->mtrr[1].handle =
+			    drm_mtrr_add(dev_priv->mtrr[1].base,
+					 dev_priv->mtrr[1].size, DRM_MTRR_WC);
+			dev_priv->mtrr[2].base = fb_base+0x04000000;
+			dev_priv->mtrr[2].size = 0x04000000;
+			dev_priv->mtrr[2].handle =
+			    drm_mtrr_add(dev_priv->mtrr[2].base, 
+				         dev_priv->mtrr[2].size, DRM_MTRR_WC);
+		} else {
+			DRM_ERROR("strange pci_resource_len %08lx\n",
+				  drm_get_resource_len(dev, 0));
+		}
+	} else if (dev_priv->chipset != S3_SUPERSAVAGE &&
+		   dev_priv->chipset != S3_SAVAGE2000) {
+		mmio_base = drm_get_resource_start(dev, 0);
+		fb_rsrc = 1;
+		fb_base = drm_get_resource_start(dev, 1);
+		fb_size = SAVAGE_FB_SIZE_S4;
+		aper_rsrc = 1;
+		aperture_base = fb_base + SAVAGE_APERTURE_OFFSET;
+		/* this should always be true */
+		if (drm_get_resource_len(dev, 1) == 0x08000000) {
+			/* Can use one MTRR to cover both fb and
+			 * aperture. */
+			dev_priv->mtrr[0].base = fb_base;
+			dev_priv->mtrr[0].size = 0x08000000;
+			dev_priv->mtrr[0].handle = 
+			    drm_mtrr_add(dev_priv->mtrr[0].base,
+					 dev_priv->mtrr[0].size, DRM_MTRR_WC);
+		} else {
+			DRM_ERROR("strange pci_resource_len %08lx\n",
+				  drm_get_resource_len(dev, 1));
+		}
+	} else {
+		mmio_base = drm_get_resource_start(dev, 0);
+		fb_rsrc = 1;
+		fb_base = drm_get_resource_start(dev, 1);
+		fb_size = drm_get_resource_len(dev, 1);
+		aper_rsrc = 2;
+		aperture_base = drm_get_resource_start(dev, 2);
+		/* Automatic MTRR setup will do the right thing. */
+	}
+
+	ret = drm_addmap(dev, mmio_base, SAVAGE_MMIO_SIZE, _DRM_REGISTERS,
+			 _DRM_READ_ONLY, &dev_priv->mmio);
+	if (ret)
+		return ret;
+
+	ret = drm_addmap(dev, fb_base, fb_size, _DRM_FRAME_BUFFER,
+			 _DRM_WRITE_COMBINING, &dev_priv->fb);
+	if (ret)
+		return ret;
+
+	ret = drm_addmap(dev, aperture_base, SAVAGE_APERTURE_SIZE,
+			 _DRM_FRAME_BUFFER, _DRM_WRITE_COMBINING,
+			 &dev_priv->aperture);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+/*
+ * Delete MTRRs and free device-private data.
+ */
+void savage_driver_lastclose(struct drm_device *dev)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	int i;
+
+	for (i = 0; i < 3; ++i)
+		if (dev_priv->mtrr[i].handle >= 0)
+			drm_mtrr_del(dev_priv->mtrr[i].handle,
+				     dev_priv->mtrr[i].base,
+				     dev_priv->mtrr[i].size, DRM_MTRR_WC);
+}
+
+int savage_driver_unload(struct drm_device *dev)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+
+	drm_free(dev_priv, sizeof(drm_savage_private_t), DRM_MEM_DRIVER);
+
+	return 0;
+}
+
+static int savage_do_init_bci(struct drm_device *dev, drm_savage_init_t *init)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+
+	if (init->fb_bpp != 16 && init->fb_bpp != 32) {
+		DRM_ERROR("invalid frame buffer bpp %d!\n", init->fb_bpp);
+		return -EINVAL;
+	}
+	if (init->depth_bpp != 16 && init->depth_bpp != 32) {
+		DRM_ERROR("invalid depth buffer bpp %d!\n", init->fb_bpp);
+		return -EINVAL;
+	}
+	if (init->dma_type != SAVAGE_DMA_AGP &&
+	    init->dma_type != SAVAGE_DMA_PCI) {
+		DRM_ERROR("invalid dma memory type %d!\n", init->dma_type);
+		return -EINVAL;
+	}
+
+	dev_priv->cob_size = init->cob_size;
+	dev_priv->bci_threshold_lo = init->bci_threshold_lo;
+	dev_priv->bci_threshold_hi = init->bci_threshold_hi;
+	dev_priv->dma_type = init->dma_type;
+
+	dev_priv->fb_bpp = init->fb_bpp;
+	dev_priv->front_offset = init->front_offset;
+	dev_priv->front_pitch = init->front_pitch;
+	dev_priv->back_offset = init->back_offset;
+	dev_priv->back_pitch = init->back_pitch;
+	dev_priv->depth_bpp = init->depth_bpp;
+	dev_priv->depth_offset = init->depth_offset;
+	dev_priv->depth_pitch = init->depth_pitch;
+
+	dev_priv->texture_offset = init->texture_offset;
+	dev_priv->texture_size = init->texture_size;
+
+	dev_priv->sarea = drm_getsarea(dev);
+	if (!dev_priv->sarea) {
+		DRM_ERROR("could not find sarea!\n");
+		savage_do_cleanup_bci(dev);
+		return -EINVAL;
+	}
+	if (init->status_offset != 0) {
+		dev_priv->status = drm_core_findmap(dev, init->status_offset);
+		if (!dev_priv->status) {
+			DRM_ERROR("could not find shadow status region!\n");
+			savage_do_cleanup_bci(dev);
+			return -EINVAL;
+		}
+	} else {
+		dev_priv->status = NULL;
+	}
+	if (dev_priv->dma_type == SAVAGE_DMA_AGP && init->buffers_offset) {
+		dev->agp_buffer_token = init->buffers_offset;
+		dev->agp_buffer_map = drm_core_findmap(dev,
+						       init->buffers_offset);
+		if (!dev->agp_buffer_map) {
+			DRM_ERROR("could not find DMA buffer region!\n");
+			savage_do_cleanup_bci(dev);
+			return -EINVAL;
+		}
+		drm_core_ioremap(dev->agp_buffer_map, dev);
+		if (!dev->agp_buffer_map) {
+			DRM_ERROR("failed to ioremap DMA buffer region!\n");
+			savage_do_cleanup_bci(dev);
+			return -ENOMEM;
+		}
+	}
+	if (init->agp_textures_offset) {
+		dev_priv->agp_textures =
+			drm_core_findmap(dev, init->agp_textures_offset);
+		if (!dev_priv->agp_textures) {
+			DRM_ERROR("could not find agp texture region!\n");
+			savage_do_cleanup_bci(dev);
+			return -EINVAL;
+		}
+	} else {
+		dev_priv->agp_textures = NULL;
+	}
+
+	if (init->cmd_dma_offset) {
+		if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+			DRM_ERROR("command DMA not supported on "
+				  "Savage3D/MX/IX.\n");
+			savage_do_cleanup_bci(dev);
+			return -EINVAL;
+		}
+		if (dev->dma && dev->dma->buflist) {
+			DRM_ERROR("command and vertex DMA not supported "
+				  "at the same time.\n");
+			savage_do_cleanup_bci(dev);
+			return -EINVAL;
+		}
+		dev_priv->cmd_dma = drm_core_findmap(dev, init->cmd_dma_offset);
+		if (!dev_priv->cmd_dma) {
+			DRM_ERROR("could not find command DMA region!\n");
+			savage_do_cleanup_bci(dev);
+			return -EINVAL;
+		}
+		if (dev_priv->dma_type == SAVAGE_DMA_AGP) {
+			if (dev_priv->cmd_dma->type != _DRM_AGP) {
+				DRM_ERROR("AGP command DMA region is not a "
+					  "_DRM_AGP map!\n");
+				savage_do_cleanup_bci(dev);
+				return -EINVAL;
+			}
+			drm_core_ioremap(dev_priv->cmd_dma, dev);
+			if (!dev_priv->cmd_dma->handle) {
+				DRM_ERROR("failed to ioremap command "
+					  "DMA region!\n");
+				savage_do_cleanup_bci(dev);
+				return -ENOMEM;
+			}
+		} else if (dev_priv->cmd_dma->type != _DRM_CONSISTENT) {
+			DRM_ERROR("PCI command DMA region is not a "
+				  "_DRM_CONSISTENT map!\n");
+			savage_do_cleanup_bci(dev);
+			return -EINVAL;
+		}
+	} else {
+		dev_priv->cmd_dma = NULL;
+	}
+
+	dev_priv->dma_flush = savage_dma_flush;
+	if (!dev_priv->cmd_dma) {
+		DRM_DEBUG("falling back to faked command DMA.\n");
+		dev_priv->fake_dma.offset = 0;
+		dev_priv->fake_dma.size = SAVAGE_FAKE_DMA_SIZE;
+		dev_priv->fake_dma.type = _DRM_SHM;
+		dev_priv->fake_dma.handle = drm_alloc(SAVAGE_FAKE_DMA_SIZE,
+						      DRM_MEM_DRIVER);
+		if (!dev_priv->fake_dma.handle) {
+			DRM_ERROR("could not allocate faked DMA buffer!\n");
+			savage_do_cleanup_bci(dev);
+			return -ENOMEM;
+		}
+		dev_priv->cmd_dma = &dev_priv->fake_dma;
+		dev_priv->dma_flush = savage_fake_dma_flush;
+	}
+
+	dev_priv->sarea_priv =
+		(drm_savage_sarea_t *)((uint8_t *)dev_priv->sarea->handle +
+				       init->sarea_priv_offset);
+
+	/* setup bitmap descriptors */
+	{
+		unsigned int color_tile_format;
+		unsigned int depth_tile_format;
+		unsigned int front_stride, back_stride, depth_stride;
+		if (dev_priv->chipset <= S3_SAVAGE4) {
+			color_tile_format = dev_priv->fb_bpp == 16 ?
+				SAVAGE_BD_TILE_16BPP : SAVAGE_BD_TILE_32BPP;
+			depth_tile_format = dev_priv->depth_bpp == 16 ?
+				SAVAGE_BD_TILE_16BPP : SAVAGE_BD_TILE_32BPP;
+		} else {
+			color_tile_format = SAVAGE_BD_TILE_DEST;
+			depth_tile_format = SAVAGE_BD_TILE_DEST;
+		}
+		front_stride = dev_priv->front_pitch / (dev_priv->fb_bpp / 8);
+		back_stride  = dev_priv->back_pitch / (dev_priv->fb_bpp / 8);
+		depth_stride = 
+		    dev_priv->depth_pitch / (dev_priv->depth_bpp / 8);
+
+		dev_priv->front_bd = front_stride | SAVAGE_BD_BW_DISABLE |
+			(dev_priv->fb_bpp << SAVAGE_BD_BPP_SHIFT) |
+			(color_tile_format << SAVAGE_BD_TILE_SHIFT);
+
+		dev_priv-> back_bd =  back_stride | SAVAGE_BD_BW_DISABLE |
+			(dev_priv->fb_bpp << SAVAGE_BD_BPP_SHIFT) |
+			(color_tile_format << SAVAGE_BD_TILE_SHIFT);
+
+		dev_priv->depth_bd = depth_stride | SAVAGE_BD_BW_DISABLE |
+			(dev_priv->depth_bpp << SAVAGE_BD_BPP_SHIFT) |
+			(depth_tile_format << SAVAGE_BD_TILE_SHIFT);
+	}
+
+	/* setup status and bci ptr */
+	dev_priv->event_counter = 0;
+	dev_priv->event_wrap = 0;
+	dev_priv->bci_ptr = (volatile uint32_t *)
+	    ((uint8_t *)dev_priv->mmio->handle + SAVAGE_BCI_OFFSET);
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		dev_priv->status_used_mask = SAVAGE_FIFO_USED_MASK_S3D;
+	} else {
+		dev_priv->status_used_mask = SAVAGE_FIFO_USED_MASK_S4;
+	}
+	if (dev_priv->status != NULL) {
+		dev_priv->status_ptr =
+			(volatile uint32_t *)dev_priv->status->handle;
+		dev_priv->wait_fifo = savage_bci_wait_fifo_shadow;
+		dev_priv->wait_evnt = savage_bci_wait_event_shadow;
+		dev_priv->status_ptr[1023] = dev_priv->event_counter;
+	} else {
+		dev_priv->status_ptr = NULL;
+		if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+			dev_priv->wait_fifo = savage_bci_wait_fifo_s3d;
+		} else {
+			dev_priv->wait_fifo = savage_bci_wait_fifo_s4;
+		}
+		dev_priv->wait_evnt = savage_bci_wait_event_reg;
+	}
+
+	/* cliprect functions */
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset))
+		dev_priv->emit_clip_rect = savage_emit_clip_rect_s3d;
+	else
+		dev_priv->emit_clip_rect = savage_emit_clip_rect_s4;
+
+	if (savage_freelist_init(dev) < 0) {
+		DRM_ERROR("could not initialize freelist\n");
+		savage_do_cleanup_bci(dev);
+		return -ENOMEM;
+	}
+
+	if (savage_dma_init(dev_priv) <  0) {
+		DRM_ERROR("could not initialize command DMA\n");
+		savage_do_cleanup_bci(dev);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int savage_do_cleanup_bci(struct drm_device *dev)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+
+	if (dev_priv->cmd_dma == &dev_priv->fake_dma) {
+		if (dev_priv->fake_dma.handle)
+			drm_free(dev_priv->fake_dma.handle,
+				 SAVAGE_FAKE_DMA_SIZE, DRM_MEM_DRIVER);
+	} else if (dev_priv->cmd_dma && dev_priv->cmd_dma->handle &&
+		   dev_priv->cmd_dma->type == _DRM_AGP &&
+		   dev_priv->dma_type == SAVAGE_DMA_AGP)
+		drm_core_ioremapfree(dev_priv->cmd_dma, dev);
+
+	if (dev_priv->dma_type == SAVAGE_DMA_AGP &&
+	    dev->agp_buffer_map && dev->agp_buffer_map->handle) {
+		drm_core_ioremapfree(dev->agp_buffer_map, dev);
+		/* make sure the next instance (which may be running
+		 * in PCI mode) doesn't try to use an old
+		 * agp_buffer_map. */
+		dev->agp_buffer_map = NULL;
+	}
+
+	if (dev_priv->dma_pages)
+		drm_free(dev_priv->dma_pages,
+			 sizeof(drm_savage_dma_page_t)*dev_priv->nr_dma_pages,
+			 DRM_MEM_DRIVER);
+
+	return 0;
+}
+
+static int savage_bci_init(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_savage_init_t *init = data;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	switch (init->func) {
+	case SAVAGE_INIT_BCI:
+		return savage_do_init_bci(dev, init);
+	case SAVAGE_CLEANUP_BCI:
+		return savage_do_cleanup_bci(dev);
+	}
+
+	return -EINVAL;
+}
+
+static int savage_bci_event_emit(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	drm_savage_event_emit_t *event = data;
+
+	DRM_DEBUG("\n");
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	event->count = savage_bci_emit_event(dev_priv, event->flags);
+	event->count |= dev_priv->event_wrap << 16;
+
+	return 0;
+}
+
+static int savage_bci_event_wait(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	drm_savage_event_wait_t *event = data;
+	unsigned int event_e, hw_e;
+	unsigned int event_w, hw_w;
+
+	DRM_DEBUG("\n");
+
+	UPDATE_EVENT_COUNTER();
+	if (dev_priv->status_ptr)
+		hw_e = dev_priv->status_ptr[1] & 0xffff;
+	else
+		hw_e = SAVAGE_READ(SAVAGE_STATUS_WORD1) & 0xffff;
+	hw_w = dev_priv->event_wrap;
+	if (hw_e > dev_priv->event_counter)
+		hw_w--; /* hardware hasn't passed the last wrap yet */
+
+	event_e = event->count & 0xffff;
+	event_w = event->count >> 16;
+
+	/* Don't need to wait if
+	 * - event counter wrapped since the event was emitted or
+	 * - the hardware has advanced up to or over the event to wait for.
+	 */
+	if (event_w < hw_w || (event_w == hw_w && event_e <= hw_e) )
+		return 0;
+	else
+		return dev_priv->wait_evnt(dev_priv, event_e);
+}
+
+/*
+ * DMA buffer management
+ */
+
+static int savage_bci_get_buffers(struct drm_device *dev,
+				  struct drm_file *file_priv,
+				  struct drm_dma *d)
+{
+	struct drm_buf *buf;
+	int i;
+
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = savage_freelist_get(dev);
+		if (!buf)
+			return -EAGAIN;
+
+		buf->file_priv = file_priv;
+
+		if (DRM_COPY_TO_USER(&d->request_indices[i],
+				     &buf->idx, sizeof(buf->idx)))
+			return -EFAULT;
+		if (DRM_COPY_TO_USER(&d->request_sizes[i],
+				     &buf->total, sizeof(buf->total)))
+			return -EFAULT;
+
+		d->granted_count++;
+	}
+	return 0;
+}
+
+int savage_bci_buffers(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_dma *d = data;
+	int ret = 0;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	/* Please don't send us buffers.
+	 */
+	if (d->send_count != 0) {
+		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
+			  DRM_CURRENTPID, d->send_count);
+		return -EINVAL;
+	}
+
+	/* We'll send you buffers.
+	 */
+	if (d->request_count < 0 || d->request_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
+			  DRM_CURRENTPID, d->request_count, dma->buf_count);
+		return -EINVAL;
+	}
+
+	d->granted_count = 0;
+
+	if (d->request_count) {
+		ret = savage_bci_get_buffers(dev, file_priv, d);
+	}
+
+	return ret;
+}
+
+void savage_reclaim_buffers(struct drm_device *dev, struct drm_file *file_priv)
+{
+	struct drm_device_dma *dma = dev->dma;
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	int i;
+
+	if (!dma)
+		return;
+	if (!dev_priv)
+		return;
+	if (!dma->buflist)
+		return;
+
+	/*i830_flush_queue(dev);*/
+
+	for (i = 0; i < dma->buf_count; i++) {
+		struct drm_buf *buf = dma->buflist[i];
+		drm_savage_buf_priv_t *buf_priv = buf->dev_private;
+
+		if (buf->file_priv == file_priv && buf_priv &&
+		    buf_priv->next == NULL && buf_priv->prev == NULL) {
+			uint16_t event;
+			DRM_DEBUG("reclaimed from client\n");
+			event = savage_bci_emit_event(dev_priv, SAVAGE_WAIT_3D);
+			SET_AGE(&buf_priv->age, event, dev_priv->event_wrap);
+			savage_freelist_put(dev, buf);
+		}
+	}
+
+	drm_core_reclaim_buffers(dev, file_priv);
+}
+
+struct drm_ioctl_desc savage_ioctls[] = {
+	DRM_IOCTL_DEF(DRM_SAVAGE_BCI_INIT, savage_bci_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_SAVAGE_BCI_CMDBUF, savage_bci_cmdbuf, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_SAVAGE_BCI_EVENT_EMIT, savage_bci_event_emit, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_SAVAGE_BCI_EVENT_WAIT, savage_bci_event_wait, DRM_AUTH),
+};
+
+int savage_max_ioctl = DRM_ARRAY_SIZE(savage_ioctls);
+
Index: git/shared-core/savage_drm.h
===================================================================
--- git.orig/shared-core/savage_drm.h	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/savage_drm.h	2008-12-12 17:35:22.000000000 +0000
@@ -47,7 +47,7 @@
 typedef struct _drm_savage_sarea {
 	/* LRU lists for texture memory in agp space and on the card.
 	 */
-	drm_tex_region_t texList[SAVAGE_NR_TEX_HEAPS][SAVAGE_NR_TEX_REGIONS+1];
+	struct drm_tex_region texList[SAVAGE_NR_TEX_HEAPS][SAVAGE_NR_TEX_REGIONS+1];
 	unsigned int texAge[SAVAGE_NR_TEX_HEAPS];
 
 	/* Mechanism to validate card state.
@@ -112,7 +112,7 @@
 	unsigned int vb_size;	/* size of client vertex buffer in bytes */
 	unsigned int vb_stride;	/* stride of vertices in 32bit words */
 				/* boxes in client's address space */
-	drm_clip_rect_t __user *box_addr;
+	struct drm_clip_rect __user *box_addr;
 	unsigned int nbox;	/* number of clipping boxes */
 } drm_savage_cmdbuf_t;
 
Index: git/shared-core/savage_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/savage_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,575 @@
+/* savage_drv.h -- Private header for the savage driver */
+/*
+ * Copyright 2004  Felix Kuehling
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL FELIX KUEHLING BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __SAVAGE_DRV_H__
+#define __SAVAGE_DRV_H__
+
+#define DRIVER_AUTHOR	"Felix Kuehling"
+
+#define DRIVER_NAME	"savage"
+#define DRIVER_DESC	"Savage3D/MX/IX, Savage4, SuperSavage, Twister, ProSavage[DDR]"
+#define DRIVER_DATE	"20050313"
+
+#define DRIVER_MAJOR		2
+#define DRIVER_MINOR		4
+#define DRIVER_PATCHLEVEL	1
+/* Interface history:
+ *
+ * 1.x   The DRM driver from the VIA/S3 code drop, basically a dummy
+ * 2.0   The first real DRM
+ * 2.1   Scissors registers managed by the DRM, 3D operations clipped by
+ *       cliprects of the cmdbuf ioctl
+ * 2.2   Implemented SAVAGE_CMD_DMA_IDX and SAVAGE_CMD_VB_IDX
+ * 2.3   Event counters used by BCI_EVENT_EMIT/WAIT ioctls are now 32 bits
+ *       wide and thus very long lived (unlikely to ever wrap). The size
+ *       in the struct was 32 bits before, but only 16 bits were used
+ * 2.4   Implemented command DMA. Now drm_savage_init_t.cmd_dma_offset is
+ *       actually used
+ */
+
+typedef struct drm_savage_age {
+	uint16_t event;
+	unsigned int wrap;
+} drm_savage_age_t;
+
+typedef struct drm_savage_buf_priv {
+	struct drm_savage_buf_priv *next;
+	struct drm_savage_buf_priv *prev;
+	drm_savage_age_t age;
+	struct drm_buf *buf;
+} drm_savage_buf_priv_t;
+
+typedef struct drm_savage_dma_page {
+	drm_savage_age_t age;
+	unsigned int used, flushed;
+} drm_savage_dma_page_t;
+#define SAVAGE_DMA_PAGE_SIZE 1024 /* in dwords */
+/* Fake DMA buffer size in bytes. 4 pages. Allows a maximum command
+ * size of 16kbytes or 4k entries. Minimum requirement would be
+ * 10kbytes for 255 40-byte vertices in one drawing command. */
+#define SAVAGE_FAKE_DMA_SIZE (SAVAGE_DMA_PAGE_SIZE*4*4)
+
+/* interesting bits of hardware state that are saved in dev_priv */
+typedef union {
+	struct drm_savage_common_state {
+		uint32_t vbaddr;
+	} common;
+	struct {
+		unsigned char pad[sizeof(struct drm_savage_common_state)];
+		uint32_t texctrl, texaddr;
+		uint32_t scstart, new_scstart;
+		uint32_t scend, new_scend;
+	} s3d;
+	struct {
+		unsigned char pad[sizeof(struct drm_savage_common_state)];
+		uint32_t texdescr, texaddr0, texaddr1;
+		uint32_t drawctrl0, new_drawctrl0;
+		uint32_t drawctrl1, new_drawctrl1;
+	} s4;
+} drm_savage_state_t;
+
+/* these chip tags should match the ones in the 2D driver in savage_regs.h. */
+enum savage_family {
+	S3_UNKNOWN = 0,
+	S3_SAVAGE3D,
+	S3_SAVAGE_MX,
+	S3_SAVAGE4,
+	S3_PROSAVAGE,
+	S3_TWISTER,
+	S3_PROSAVAGEDDR,
+	S3_SUPERSAVAGE,
+	S3_SAVAGE2000,
+	S3_LAST
+};
+
+extern struct drm_ioctl_desc savage_ioctls[];
+extern int savage_max_ioctl;
+
+#define S3_SAVAGE3D_SERIES(chip)  ((chip>=S3_SAVAGE3D) && (chip<=S3_SAVAGE_MX))
+
+#define S3_SAVAGE4_SERIES(chip)  ((chip==S3_SAVAGE4)            \
+                                  || (chip==S3_PROSAVAGE)       \
+                                  || (chip==S3_TWISTER)         \
+                                  || (chip==S3_PROSAVAGEDDR))
+
+#define	S3_SAVAGE_MOBILE_SERIES(chip)	((chip==S3_SAVAGE_MX) || (chip==S3_SUPERSAVAGE))
+
+#define S3_SAVAGE_SERIES(chip)    ((chip>=S3_SAVAGE3D) && (chip<=S3_SAVAGE2000))
+
+#define S3_MOBILE_TWISTER_SERIES(chip)   ((chip==S3_TWISTER)    \
+                                          ||(chip==S3_PROSAVAGEDDR))
+
+/* flags */
+#define SAVAGE_IS_AGP 1
+
+typedef struct drm_savage_private {
+	drm_savage_sarea_t *sarea_priv;
+
+	drm_savage_buf_priv_t head, tail;
+
+	/* who am I? */
+	enum savage_family chipset;
+
+	unsigned int cob_size;
+	unsigned int bci_threshold_lo, bci_threshold_hi;
+	unsigned int dma_type;
+
+	/* frame buffer layout */
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+
+	/* bitmap descriptors for swap and clear */
+	unsigned int front_bd, back_bd, depth_bd;
+
+	/* local textures */
+	unsigned int texture_offset;
+	unsigned int texture_size;
+
+	/* memory regions in physical memory */
+	drm_local_map_t *sarea;
+	drm_local_map_t *mmio;
+	drm_local_map_t *fb;
+	drm_local_map_t *aperture;
+	drm_local_map_t *status;
+	drm_local_map_t *agp_textures;
+	drm_local_map_t *cmd_dma;
+	drm_local_map_t fake_dma;
+
+	struct {
+		int handle;
+		unsigned long base, size;
+	} mtrr[3];
+
+	/* BCI and status-related stuff */
+	volatile uint32_t *status_ptr, *bci_ptr;
+	uint32_t status_used_mask;
+	uint16_t event_counter;
+	unsigned int event_wrap;
+
+	/* Savage4 command DMA */
+	drm_savage_dma_page_t *dma_pages;
+	unsigned int nr_dma_pages, first_dma_page, current_dma_page;
+	drm_savage_age_t last_dma_age;
+
+	/* saved hw state for global/local check on S3D */
+	uint32_t hw_draw_ctrl, hw_zbuf_ctrl;
+	/* and for scissors (global, so don't emit if not changed) */
+	uint32_t hw_scissors_start, hw_scissors_end;
+
+	drm_savage_state_t state;
+
+	/* after emitting a wait cmd Savage3D needs 63 nops before next DMA */
+	unsigned int waiting;
+
+	/* config/hardware-dependent function pointers */
+	int (*wait_fifo)(struct drm_savage_private *dev_priv, unsigned int n);
+	int (*wait_evnt)(struct drm_savage_private *dev_priv, uint16_t e);
+	/* Err, there is a macro wait_event in include/linux/wait.h.
+	 * Avoid unwanted macro expansion. */
+	void (*emit_clip_rect)(struct drm_savage_private *dev_priv,
+			       const struct drm_clip_rect *pbox);
+	void (*dma_flush)(struct drm_savage_private *dev_priv);
+} drm_savage_private_t;
+
+/* ioctls */
+extern int savage_bci_cmdbuf(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int savage_bci_buffers(struct drm_device *dev, void *data, struct drm_file *file_priv);
+
+/* BCI functions */
+extern uint16_t savage_bci_emit_event(drm_savage_private_t *dev_priv,
+				      unsigned int flags);
+extern void savage_freelist_put(struct drm_device *dev, struct drm_buf *buf);
+extern void savage_dma_reset(drm_savage_private_t *dev_priv);
+extern void savage_dma_wait(drm_savage_private_t *dev_priv, unsigned int page);
+extern uint32_t *savage_dma_alloc(drm_savage_private_t *dev_priv,
+				  unsigned int n);
+extern int savage_driver_load(struct drm_device *dev, unsigned long chipset);
+extern int savage_driver_firstopen(struct drm_device *dev);
+extern void savage_driver_lastclose(struct drm_device *dev);
+extern int savage_driver_unload(struct drm_device *dev);
+extern void savage_reclaim_buffers(struct drm_device *dev,
+				   struct drm_file *file_priv);
+
+/* state functions */
+extern void savage_emit_clip_rect_s3d(drm_savage_private_t *dev_priv,
+				      const struct drm_clip_rect *pbox);
+extern void savage_emit_clip_rect_s4(drm_savage_private_t *dev_priv,
+				     const struct drm_clip_rect *pbox);
+
+#define SAVAGE_FB_SIZE_S3	0x01000000	/*  16MB */
+#define SAVAGE_FB_SIZE_S4	0x02000000	/*  32MB */
+#define SAVAGE_MMIO_SIZE        0x00080000	/* 512kB */
+#define SAVAGE_APERTURE_OFFSET  0x02000000	/*  32MB */
+#define SAVAGE_APERTURE_SIZE    0x05000000	/* 5 tiled surfaces, 16MB each */
+
+#define SAVAGE_BCI_OFFSET       0x00010000      /* offset of the BCI region
+						 * inside the MMIO region */
+#define SAVAGE_BCI_FIFO_SIZE	32		/* number of entries in on-chip
+						 * BCI FIFO */
+
+/*
+ * MMIO registers
+ */
+#define SAVAGE_STATUS_WORD0		0x48C00
+#define SAVAGE_STATUS_WORD1		0x48C04
+#define SAVAGE_ALT_STATUS_WORD0 	0x48C60
+
+#define SAVAGE_FIFO_USED_MASK_S3D	0x0001ffff
+#define SAVAGE_FIFO_USED_MASK_S4	0x001fffff
+
+/* Copied from savage_bci.h in the 2D driver with some renaming. */
+
+/* Bitmap descriptors */
+#define SAVAGE_BD_STRIDE_SHIFT 0
+#define SAVAGE_BD_BPP_SHIFT   16
+#define SAVAGE_BD_TILE_SHIFT  24
+#define SAVAGE_BD_BW_DISABLE  (1<<28)
+/* common: */
+#define	SAVAGE_BD_TILE_LINEAR		0
+/* savage4, MX, IX, 3D */
+#define	SAVAGE_BD_TILE_16BPP		2
+#define	SAVAGE_BD_TILE_32BPP		3
+/* twister, prosavage, DDR, supersavage, 2000 */
+#define	SAVAGE_BD_TILE_DEST		1
+#define	SAVAGE_BD_TILE_TEXTURE		2
+/* GBD - BCI enable */
+/* savage4, MX, IX, 3D */
+#define SAVAGE_GBD_BCI_ENABLE                    8
+/* twister, prosavage, DDR, supersavage, 2000 */
+#define SAVAGE_GBD_BCI_ENABLE_TWISTER            0
+
+#define SAVAGE_GBD_BIG_ENDIAN                    4
+#define SAVAGE_GBD_LITTLE_ENDIAN                 0
+#define SAVAGE_GBD_64                            1
+
+/*  Global Bitmap Descriptor */
+#define SAVAGE_BCI_GLB_BD_LOW             0x8168
+#define SAVAGE_BCI_GLB_BD_HIGH            0x816C
+
+/*
+ * BCI registers
+ */
+/* Savage4/Twister/ProSavage 3D registers */
+#define SAVAGE_DRAWLOCALCTRL_S4		0x1e
+#define SAVAGE_TEXPALADDR_S4		0x1f
+#define SAVAGE_TEXCTRL0_S4		0x20
+#define SAVAGE_TEXCTRL1_S4		0x21
+#define SAVAGE_TEXADDR0_S4		0x22
+#define SAVAGE_TEXADDR1_S4		0x23
+#define SAVAGE_TEXBLEND0_S4		0x24
+#define SAVAGE_TEXBLEND1_S4		0x25
+#define SAVAGE_TEXXPRCLR_S4		0x26 /* never used */
+#define SAVAGE_TEXDESCR_S4		0x27
+#define SAVAGE_FOGTABLE_S4		0x28
+#define SAVAGE_FOGCTRL_S4		0x30
+#define SAVAGE_STENCILCTRL_S4		0x31
+#define SAVAGE_ZBUFCTRL_S4		0x32
+#define SAVAGE_ZBUFOFF_S4		0x33
+#define SAVAGE_DESTCTRL_S4		0x34
+#define SAVAGE_DRAWCTRL0_S4		0x35
+#define SAVAGE_DRAWCTRL1_S4		0x36
+#define SAVAGE_ZWATERMARK_S4		0x37
+#define SAVAGE_DESTTEXRWWATERMARK_S4	0x38
+#define SAVAGE_TEXBLENDCOLOR_S4		0x39
+/* Savage3D/MX/IX 3D registers */
+#define SAVAGE_TEXPALADDR_S3D		0x18
+#define SAVAGE_TEXXPRCLR_S3D		0x19 /* never used */
+#define SAVAGE_TEXADDR_S3D		0x1A
+#define SAVAGE_TEXDESCR_S3D		0x1B
+#define SAVAGE_TEXCTRL_S3D		0x1C
+#define SAVAGE_FOGTABLE_S3D		0x20
+#define SAVAGE_FOGCTRL_S3D		0x30
+#define SAVAGE_DRAWCTRL_S3D		0x31
+#define SAVAGE_ZBUFCTRL_S3D		0x32
+#define SAVAGE_ZBUFOFF_S3D		0x33
+#define SAVAGE_DESTCTRL_S3D		0x34
+#define SAVAGE_SCSTART_S3D		0x35
+#define SAVAGE_SCEND_S3D		0x36
+#define SAVAGE_ZWATERMARK_S3D		0x37 
+#define SAVAGE_DESTTEXRWWATERMARK_S3D	0x38
+/* common stuff */
+#define SAVAGE_VERTBUFADDR		0x3e
+#define SAVAGE_BITPLANEWTMASK		0xd7
+#define SAVAGE_DMABUFADDR		0x51
+
+/* texture enable bits (needed for tex addr checking) */
+#define SAVAGE_TEXCTRL_TEXEN_MASK	0x00010000 /* S3D */
+#define SAVAGE_TEXDESCR_TEX0EN_MASK	0x02000000 /* S4 */
+#define SAVAGE_TEXDESCR_TEX1EN_MASK	0x04000000 /* S4 */
+
+/* Global fields in Savage4/Twister/ProSavage 3D registers:
+ *
+ * All texture registers and DrawLocalCtrl are local. All other
+ * registers are global. */
+
+/* Global fields in Savage3D/MX/IX 3D registers:
+ *
+ * All texture registers are local. DrawCtrl and ZBufCtrl are
+ * partially local. All other registers are global.
+ *
+ * DrawCtrl global fields: cullMode, alphaTestCmpFunc, alphaTestEn, alphaRefVal
+ * ZBufCtrl global fields: zCmpFunc, zBufEn
+ */
+#define SAVAGE_DRAWCTRL_S3D_GLOBAL	0x03f3c00c
+#define SAVAGE_ZBUFCTRL_S3D_GLOBAL	0x00000027
+
+/* Masks for scissor bits (drawCtrl[01] on s4, scissorStart/End on s3d)
+ */
+#define SAVAGE_SCISSOR_MASK_S4		0x00fff7ff
+#define SAVAGE_SCISSOR_MASK_S3D		0x07ff07ff
+
+/*
+ * BCI commands
+ */
+#define BCI_CMD_NOP                  0x40000000
+#define BCI_CMD_RECT                 0x48000000
+#define BCI_CMD_RECT_XP              0x01000000
+#define BCI_CMD_RECT_YP              0x02000000
+#define BCI_CMD_SCANLINE             0x50000000
+#define BCI_CMD_LINE                 0x5C000000
+#define BCI_CMD_LINE_LAST_PIXEL      0x58000000
+#define BCI_CMD_BYTE_TEXT            0x63000000
+#define BCI_CMD_NT_BYTE_TEXT         0x67000000
+#define BCI_CMD_BIT_TEXT             0x6C000000
+#define BCI_CMD_GET_ROP(cmd)         (((cmd) >> 16) & 0xFF)
+#define BCI_CMD_SET_ROP(cmd, rop)    ((cmd) |= ((rop & 0xFF) << 16))
+#define BCI_CMD_SEND_COLOR           0x00008000
+
+#define BCI_CMD_CLIP_NONE            0x00000000
+#define BCI_CMD_CLIP_CURRENT         0x00002000
+#define BCI_CMD_CLIP_LR              0x00004000
+#define BCI_CMD_CLIP_NEW             0x00006000
+
+#define BCI_CMD_DEST_GBD             0x00000000
+#define BCI_CMD_DEST_PBD             0x00000800
+#define BCI_CMD_DEST_PBD_NEW         0x00000C00
+#define BCI_CMD_DEST_SBD             0x00001000
+#define BCI_CMD_DEST_SBD_NEW         0x00001400
+
+#define BCI_CMD_SRC_TRANSPARENT      0x00000200
+#define BCI_CMD_SRC_SOLID            0x00000000
+#define BCI_CMD_SRC_GBD              0x00000020
+#define BCI_CMD_SRC_COLOR            0x00000040
+#define BCI_CMD_SRC_MONO             0x00000060
+#define BCI_CMD_SRC_PBD_COLOR        0x00000080
+#define BCI_CMD_SRC_PBD_MONO         0x000000A0
+#define BCI_CMD_SRC_PBD_COLOR_NEW    0x000000C0
+#define BCI_CMD_SRC_PBD_MONO_NEW     0x000000E0
+#define BCI_CMD_SRC_SBD_COLOR        0x00000100
+#define BCI_CMD_SRC_SBD_MONO         0x00000120
+#define BCI_CMD_SRC_SBD_COLOR_NEW    0x00000140
+#define BCI_CMD_SRC_SBD_MONO_NEW     0x00000160
+
+#define BCI_CMD_PAT_TRANSPARENT      0x00000010
+#define BCI_CMD_PAT_NONE             0x00000000
+#define BCI_CMD_PAT_COLOR            0x00000002
+#define BCI_CMD_PAT_MONO             0x00000003
+#define BCI_CMD_PAT_PBD_COLOR        0x00000004
+#define BCI_CMD_PAT_PBD_MONO         0x00000005
+#define BCI_CMD_PAT_PBD_COLOR_NEW    0x00000006
+#define BCI_CMD_PAT_PBD_MONO_NEW     0x00000007
+#define BCI_CMD_PAT_SBD_COLOR        0x00000008
+#define BCI_CMD_PAT_SBD_MONO         0x00000009
+#define BCI_CMD_PAT_SBD_COLOR_NEW    0x0000000A
+#define BCI_CMD_PAT_SBD_MONO_NEW     0x0000000B
+
+#define BCI_BD_BW_DISABLE            0x10000000
+#define BCI_BD_TILE_MASK             0x03000000
+#define BCI_BD_TILE_NONE             0x00000000
+#define BCI_BD_TILE_16               0x02000000
+#define BCI_BD_TILE_32               0x03000000
+#define BCI_BD_GET_BPP(bd)           (((bd) >> 16) & 0xFF)
+#define BCI_BD_SET_BPP(bd, bpp)      ((bd) |= (((bpp) & 0xFF) << 16))
+#define BCI_BD_GET_STRIDE(bd)        ((bd) & 0xFFFF)
+#define BCI_BD_SET_STRIDE(bd, st)    ((bd) |= ((st) & 0xFFFF))
+
+#define BCI_CMD_SET_REGISTER            0x96000000
+
+#define BCI_CMD_WAIT                    0xC0000000
+#define BCI_CMD_WAIT_3D                 0x00010000
+#define BCI_CMD_WAIT_2D                 0x00020000
+
+#define BCI_CMD_UPDATE_EVENT_TAG        0x98000000
+
+#define BCI_CMD_DRAW_PRIM               0x80000000
+#define BCI_CMD_DRAW_INDEXED_PRIM       0x88000000
+#define BCI_CMD_DRAW_CONT               0x01000000
+#define BCI_CMD_DRAW_TRILIST            0x00000000
+#define BCI_CMD_DRAW_TRISTRIP           0x02000000
+#define BCI_CMD_DRAW_TRIFAN             0x04000000
+#define BCI_CMD_DRAW_SKIPFLAGS          0x000000ff
+#define BCI_CMD_DRAW_NO_Z		0x00000001
+#define BCI_CMD_DRAW_NO_W		0x00000002
+#define BCI_CMD_DRAW_NO_CD		0x00000004
+#define BCI_CMD_DRAW_NO_CS		0x00000008
+#define BCI_CMD_DRAW_NO_U0		0x00000010
+#define BCI_CMD_DRAW_NO_V0		0x00000020
+#define BCI_CMD_DRAW_NO_UV0		0x00000030
+#define BCI_CMD_DRAW_NO_U1		0x00000040
+#define BCI_CMD_DRAW_NO_V1		0x00000080
+#define BCI_CMD_DRAW_NO_UV1		0x000000c0
+
+#define BCI_CMD_DMA			0xa8000000
+
+#define BCI_W_H(w, h)                ((((h) << 16) | (w)) & 0x0FFF0FFF)
+#define BCI_X_Y(x, y)                ((((y) << 16) | (x)) & 0x0FFF0FFF)
+#define BCI_X_W(x, y)                ((((w) << 16) | (x)) & 0x0FFF0FFF)
+#define BCI_CLIP_LR(l, r)            ((((r) << 16) | (l)) & 0x0FFF0FFF)
+#define BCI_CLIP_TL(t, l)            ((((t) << 16) | (l)) & 0x0FFF0FFF)
+#define BCI_CLIP_BR(b, r)            ((((b) << 16) | (r)) & 0x0FFF0FFF)
+
+#define BCI_LINE_X_Y(x, y)           (((y) << 16) | ((x) & 0xFFFF))
+#define BCI_LINE_STEPS(diag, axi)    (((axi) << 16) | ((diag) & 0xFFFF))
+#define BCI_LINE_MISC(maj, ym, xp, yp, err) \
+	(((maj) & 0x1FFF) | \
+	((ym) ? 1<<13 : 0) | \
+	((xp) ? 1<<14 : 0) | \
+	((yp) ? 1<<15 : 0) | \
+	((err) << 16))
+
+/*
+ * common commands
+ */
+#define BCI_SET_REGISTERS( first, n )			\
+	BCI_WRITE(BCI_CMD_SET_REGISTER |		\
+		  ((uint32_t)(n) & 0xff) << 16 |	\
+		  ((uint32_t)(first) & 0xffff))
+#define DMA_SET_REGISTERS( first, n )			\
+	DMA_WRITE(BCI_CMD_SET_REGISTER |		\
+		  ((uint32_t)(n) & 0xff) << 16 |	\
+		  ((uint32_t)(first) & 0xffff))
+
+#define BCI_DRAW_PRIMITIVE(n, type, skip)         \
+        BCI_WRITE(BCI_CMD_DRAW_PRIM | (type) | (skip) | \
+		  ((n) << 16))
+#define DMA_DRAW_PRIMITIVE(n, type, skip)         \
+        DMA_WRITE(BCI_CMD_DRAW_PRIM | (type) | (skip) | \
+		  ((n) << 16))
+
+#define BCI_DRAW_INDICES_S3D(n, type, i0)         \
+        BCI_WRITE(BCI_CMD_DRAW_INDEXED_PRIM | (type) |  \
+		  ((n) << 16) | (i0))
+
+#define BCI_DRAW_INDICES_S4(n, type, skip)        \
+        BCI_WRITE(BCI_CMD_DRAW_INDEXED_PRIM | (type) |  \
+                  (skip) | ((n) << 16))
+
+#define BCI_DMA(n)	\
+	BCI_WRITE(BCI_CMD_DMA | (((n) >> 1) - 1))
+
+/*
+ * access to MMIO
+ */
+#define SAVAGE_READ(reg)	DRM_READ32(  dev_priv->mmio, (reg) )
+#define SAVAGE_WRITE(reg)	DRM_WRITE32( dev_priv->mmio, (reg) )
+
+/*
+ * access to the burst command interface (BCI)
+ */
+#define SAVAGE_BCI_DEBUG 1
+
+#define BCI_LOCALS    volatile uint32_t *bci_ptr;
+
+#define BEGIN_BCI( n ) do {			\
+	dev_priv->wait_fifo(dev_priv, (n));	\
+	bci_ptr = dev_priv->bci_ptr;		\
+} while(0)
+
+#define BCI_WRITE( val ) *bci_ptr++ = (uint32_t)(val)
+
+/*
+ * command DMA support
+ */
+#define SAVAGE_DMA_DEBUG 1
+
+#define DMA_LOCALS   uint32_t *dma_ptr;
+
+#define BEGIN_DMA( n ) do {						\
+	unsigned int cur = dev_priv->current_dma_page;			\
+	unsigned int rest = SAVAGE_DMA_PAGE_SIZE -			\
+		dev_priv->dma_pages[cur].used;				\
+	if ((n) > rest) {						\
+		dma_ptr = savage_dma_alloc(dev_priv, (n));		\
+	} else { /* fast path for small allocations */			\
+		dma_ptr = (uint32_t *)dev_priv->cmd_dma->handle +	\
+			cur * SAVAGE_DMA_PAGE_SIZE +			\
+			dev_priv->dma_pages[cur].used;			\
+		if (dev_priv->dma_pages[cur].used == 0)			\
+			savage_dma_wait(dev_priv, cur);			\
+		dev_priv->dma_pages[cur].used += (n);			\
+	}								\
+} while(0)
+
+#define DMA_WRITE( val ) *dma_ptr++ = (uint32_t)(val)
+
+#define DMA_COPY(src, n) do {					\
+	memcpy(dma_ptr, (src), (n)*4);				\
+	dma_ptr += n;						\
+} while(0)
+
+#if SAVAGE_DMA_DEBUG
+#define DMA_COMMIT() do {						\
+	unsigned int cur = dev_priv->current_dma_page;			\
+	uint32_t *expected = (uint32_t *)dev_priv->cmd_dma->handle +	\
+			cur * SAVAGE_DMA_PAGE_SIZE +			\
+			dev_priv->dma_pages[cur].used;			\
+	if (dma_ptr != expected) {					\
+		DRM_ERROR("DMA allocation and use don't match: "	\
+			  "%p != %p\n", expected, dma_ptr);		\
+		savage_dma_reset(dev_priv);				\
+	}								\
+} while(0)
+#else
+#define DMA_COMMIT() do {/* nothing */} while(0)
+#endif
+
+#define DMA_FLUSH() dev_priv->dma_flush(dev_priv)
+
+/* Buffer aging via event tag
+ */
+
+#define UPDATE_EVENT_COUNTER( ) do {			\
+	if (dev_priv->status_ptr) {			\
+		uint16_t count;				\
+		/* coordinate with Xserver */		\
+		count = dev_priv->status_ptr[1023];	\
+		if (count < dev_priv->event_counter)	\
+			dev_priv->event_wrap++;		\
+		dev_priv->event_counter = count;	\
+	}						\
+} while(0)
+
+#define SET_AGE( age, e, w ) do {	\
+	(age)->event = e;		\
+	(age)->wrap = w;		\
+} while(0)
+
+#define TEST_AGE( age, e, w )				\
+	( (age)->wrap < (w) || ( (age)->wrap == (w) && (age)->event <= (e) ) )
+
+#endif /* __SAVAGE_DRV_H__ */
Index: git/shared-core/savage_state.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/savage_state.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,1165 @@
+/* savage_state.c -- State and drawing support for Savage
+ *
+ * Copyright 2004  Felix Kuehling
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL FELIX KUEHLING BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "drmP.h"
+#include "savage_drm.h"
+#include "savage_drv.h"
+
+void savage_emit_clip_rect_s3d(drm_savage_private_t *dev_priv,
+			       const struct drm_clip_rect *pbox)
+{
+	uint32_t scstart = dev_priv->state.s3d.new_scstart;
+	uint32_t scend   = dev_priv->state.s3d.new_scend;
+	scstart = (scstart & ~SAVAGE_SCISSOR_MASK_S3D) |
+		((uint32_t)pbox->x1 & 0x000007ff) | 
+		(((uint32_t)pbox->y1 << 16) & 0x07ff0000);
+	scend   = (scend   & ~SAVAGE_SCISSOR_MASK_S3D) |
+		(((uint32_t)pbox->x2-1) & 0x000007ff) |
+		((((uint32_t)pbox->y2-1) << 16) & 0x07ff0000);
+	if (scstart != dev_priv->state.s3d.scstart ||
+	    scend   != dev_priv->state.s3d.scend) {
+		DMA_LOCALS;
+		BEGIN_DMA(4);
+		DMA_WRITE(BCI_CMD_WAIT|BCI_CMD_WAIT_3D);
+		DMA_SET_REGISTERS(SAVAGE_SCSTART_S3D, 2);
+		DMA_WRITE(scstart);
+		DMA_WRITE(scend);
+		dev_priv->state.s3d.scstart = scstart;
+		dev_priv->state.s3d.scend   = scend;
+		dev_priv->waiting = 1;
+		DMA_COMMIT();
+	}
+}
+
+void savage_emit_clip_rect_s4(drm_savage_private_t *dev_priv,
+			      const struct drm_clip_rect *pbox)
+{
+	uint32_t drawctrl0 = dev_priv->state.s4.new_drawctrl0;
+	uint32_t drawctrl1 = dev_priv->state.s4.new_drawctrl1;
+	drawctrl0 = (drawctrl0 & ~SAVAGE_SCISSOR_MASK_S4) |
+		((uint32_t)pbox->x1 & 0x000007ff) |
+		(((uint32_t)pbox->y1 << 12) & 0x00fff000);
+	drawctrl1 = (drawctrl1 & ~SAVAGE_SCISSOR_MASK_S4) |
+		(((uint32_t)pbox->x2-1) & 0x000007ff) |
+		((((uint32_t)pbox->y2-1) << 12) & 0x00fff000);
+	if (drawctrl0 != dev_priv->state.s4.drawctrl0 ||
+	    drawctrl1 != dev_priv->state.s4.drawctrl1) {
+		DMA_LOCALS;
+		BEGIN_DMA(4);
+		DMA_WRITE(BCI_CMD_WAIT|BCI_CMD_WAIT_3D);
+		DMA_SET_REGISTERS(SAVAGE_DRAWCTRL0_S4, 2);
+		DMA_WRITE(drawctrl0);
+		DMA_WRITE(drawctrl1);
+		dev_priv->state.s4.drawctrl0 = drawctrl0;
+		dev_priv->state.s4.drawctrl1 = drawctrl1;
+		dev_priv->waiting = 1;
+		DMA_COMMIT();
+	}
+}
+
+static int savage_verify_texaddr(drm_savage_private_t *dev_priv, int unit,
+				 uint32_t addr)
+{
+	if ((addr & 6) != 2) { /* reserved bits */
+		DRM_ERROR("bad texAddr%d %08x (reserved bits)\n", unit, addr);
+		return -EINVAL;
+	}
+	if (!(addr & 1)) { /* local */
+		addr &= ~7;
+		if (addr <  dev_priv->texture_offset ||
+		    addr >= dev_priv->texture_offset+dev_priv->texture_size) {
+			DRM_ERROR
+			    ("bad texAddr%d %08x (local addr out of range)\n",
+			     unit, addr);
+			return -EINVAL;
+		}
+	} else { /* AGP */
+		if (!dev_priv->agp_textures) {
+			DRM_ERROR("bad texAddr%d %08x (AGP not available)\n",
+				  unit, addr);
+			return -EINVAL;
+		}
+		addr &= ~7;
+		if (addr < dev_priv->agp_textures->offset ||
+		    addr >= (dev_priv->agp_textures->offset +
+			     dev_priv->agp_textures->size)) {
+			DRM_ERROR
+			    ("bad texAddr%d %08x (AGP addr out of range)\n",
+			     unit, addr);
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+#define SAVE_STATE(reg,where)			\
+	if(start <= reg && start+count > reg)	\
+		dev_priv->state.where = regs[reg - start]
+#define SAVE_STATE_MASK(reg,where,mask) do {			\
+	if(start <= reg && start+count > reg) {			\
+		uint32_t tmp;					\
+		tmp = regs[reg - start];			\
+		dev_priv->state.where = (tmp & (mask)) |	\
+			(dev_priv->state.where & ~(mask));	\
+	}							\
+} while (0)
+static int savage_verify_state_s3d(drm_savage_private_t *dev_priv,
+				   unsigned int start, unsigned int count,
+				   const uint32_t *regs)
+{
+	if (start < SAVAGE_TEXPALADDR_S3D ||
+	    start+count-1 > SAVAGE_DESTTEXRWWATERMARK_S3D) {
+		DRM_ERROR("invalid register range (0x%04x-0x%04x)\n",
+			  start, start+count-1);
+		return -EINVAL;
+	}
+
+	SAVE_STATE_MASK(SAVAGE_SCSTART_S3D, s3d.new_scstart,
+			~SAVAGE_SCISSOR_MASK_S3D);
+	SAVE_STATE_MASK(SAVAGE_SCEND_S3D, s3d.new_scend,
+			~SAVAGE_SCISSOR_MASK_S3D);
+
+	/* if any texture regs were changed ... */
+	if (start <= SAVAGE_TEXCTRL_S3D &&
+	    start+count > SAVAGE_TEXPALADDR_S3D) {
+		/* ... check texture state */
+		SAVE_STATE(SAVAGE_TEXCTRL_S3D, s3d.texctrl);
+		SAVE_STATE(SAVAGE_TEXADDR_S3D, s3d.texaddr);
+		if (dev_priv->state.s3d.texctrl & SAVAGE_TEXCTRL_TEXEN_MASK)
+			return savage_verify_texaddr(dev_priv, 0,
+						dev_priv->state.s3d.texaddr);
+	}
+
+	return 0;
+}
+
+static int savage_verify_state_s4(drm_savage_private_t *dev_priv,
+				  unsigned int start, unsigned int count,
+				  const uint32_t *regs)
+{
+	int ret = 0;
+
+	if (start < SAVAGE_DRAWLOCALCTRL_S4 ||
+	    start+count-1 > SAVAGE_TEXBLENDCOLOR_S4) {
+		DRM_ERROR("invalid register range (0x%04x-0x%04x)\n",
+			  start, start+count-1);
+		return -EINVAL;
+	}
+
+	SAVE_STATE_MASK(SAVAGE_DRAWCTRL0_S4, s4.new_drawctrl0,
+			~SAVAGE_SCISSOR_MASK_S4);
+	SAVE_STATE_MASK(SAVAGE_DRAWCTRL1_S4, s4.new_drawctrl1,
+			~SAVAGE_SCISSOR_MASK_S4);
+
+	/* if any texture regs were changed ... */
+	if (start <= SAVAGE_TEXDESCR_S4 &&
+	    start + count > SAVAGE_TEXPALADDR_S4) {
+		/* ... check texture state */
+		SAVE_STATE(SAVAGE_TEXDESCR_S4, s4.texdescr);
+		SAVE_STATE(SAVAGE_TEXADDR0_S4, s4.texaddr0);
+		SAVE_STATE(SAVAGE_TEXADDR1_S4, s4.texaddr1);
+		if (dev_priv->state.s4.texdescr & SAVAGE_TEXDESCR_TEX0EN_MASK)
+			ret |= savage_verify_texaddr(dev_priv, 0,
+						dev_priv->state.s4.texaddr0);
+		if (dev_priv->state.s4.texdescr & SAVAGE_TEXDESCR_TEX1EN_MASK)
+			ret |= savage_verify_texaddr(dev_priv, 1,
+						dev_priv->state.s4.texaddr1);
+	}
+
+	return ret;
+}
+#undef SAVE_STATE
+#undef SAVE_STATE_MASK
+
+static int savage_dispatch_state(drm_savage_private_t *dev_priv,
+				 const drm_savage_cmd_header_t *cmd_header,
+				 const uint32_t *regs)
+{
+	unsigned int count = cmd_header->state.count;
+	unsigned int start = cmd_header->state.start;
+	unsigned int count2 = 0;
+	unsigned int bci_size;
+	int ret;
+	DMA_LOCALS;
+
+	if (!count)
+		return 0;
+
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		ret = savage_verify_state_s3d(dev_priv, start, count, regs);
+		if (ret != 0)
+			return ret;
+		/* scissor regs are emitted in savage_dispatch_draw */
+		if (start < SAVAGE_SCSTART_S3D) {
+			if (start+count > SAVAGE_SCEND_S3D+1)
+				count2 = count - (SAVAGE_SCEND_S3D+1 - start);
+			if (start+count > SAVAGE_SCSTART_S3D)
+				count = SAVAGE_SCSTART_S3D - start;
+		} else if (start <= SAVAGE_SCEND_S3D) {
+			if (start+count > SAVAGE_SCEND_S3D+1) {
+				count -= SAVAGE_SCEND_S3D+1 - start;
+				start = SAVAGE_SCEND_S3D+1;
+			} else
+				return 0;
+		}
+	} else {
+		ret = savage_verify_state_s4(dev_priv, start, count, regs);
+		if (ret != 0)
+			return ret;
+		/* scissor regs are emitted in savage_dispatch_draw */
+		if (start < SAVAGE_DRAWCTRL0_S4) {
+			if (start+count > SAVAGE_DRAWCTRL1_S4+1)
+				count2 = count -
+					 (SAVAGE_DRAWCTRL1_S4 + 1 - start);
+			if (start+count > SAVAGE_DRAWCTRL0_S4)
+				count = SAVAGE_DRAWCTRL0_S4 - start;
+		} else if (start <= SAVAGE_DRAWCTRL1_S4) {
+			if (start+count > SAVAGE_DRAWCTRL1_S4+1) {
+				count -= SAVAGE_DRAWCTRL1_S4+1 - start;
+				start = SAVAGE_DRAWCTRL1_S4+1;
+			} else
+				return 0;
+		}
+	}
+
+	bci_size = count + (count+254)/255 + count2 + (count2+254)/255;
+
+	if (cmd_header->state.global) {
+		BEGIN_DMA(bci_size+1);
+		DMA_WRITE(BCI_CMD_WAIT | BCI_CMD_WAIT_3D);
+		dev_priv->waiting = 1;
+	} else {
+		BEGIN_DMA(bci_size);
+	}
+
+	do {
+		while (count > 0) {
+			unsigned int n = count < 255 ? count : 255;
+			DMA_SET_REGISTERS(start, n);
+			DMA_COPY(regs, n);
+			count -= n;
+			start += n;
+			regs += n;
+		}
+		start += 2;
+		regs += 2;
+		count = count2;
+		count2 = 0;
+	} while (count);
+
+	DMA_COMMIT();
+
+	return 0;
+}
+
+static int savage_dispatch_dma_prim(drm_savage_private_t *dev_priv,
+				    const drm_savage_cmd_header_t *cmd_header,
+				    const struct drm_buf *dmabuf)
+{
+	unsigned char reorder = 0;
+	unsigned int prim = cmd_header->prim.prim;
+	unsigned int skip = cmd_header->prim.skip;
+	unsigned int n = cmd_header->prim.count;
+	unsigned int start = cmd_header->prim.start;
+	unsigned int i;
+	BCI_LOCALS;
+
+	if (!dmabuf) {
+	    DRM_ERROR("called without dma buffers!\n");
+	    return -EINVAL;
+	}
+
+	if (!n)
+		return 0;
+
+	switch (prim) {
+	case SAVAGE_PRIM_TRILIST_201:
+		reorder = 1;
+		prim = SAVAGE_PRIM_TRILIST;
+	case SAVAGE_PRIM_TRILIST:
+		if (n % 3 != 0) {
+			DRM_ERROR("wrong number of vertices %u in TRILIST\n",
+				  n);
+			return -EINVAL;
+		}
+		break;
+	case SAVAGE_PRIM_TRISTRIP:
+	case SAVAGE_PRIM_TRIFAN:
+		if (n < 3) {
+			DRM_ERROR
+			   ("wrong number of vertices %u in TRIFAN/STRIP\n",
+			    n);
+			return -EINVAL;
+		}
+		break;
+	default:
+		DRM_ERROR("invalid primitive type %u\n", prim);
+		return -EINVAL;
+	}
+
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		if (skip != 0) {
+			DRM_ERROR("invalid skip flags 0x%04x for DMA\n", skip);
+			return -EINVAL;
+		}
+	} else {
+		unsigned int size = 10 - (skip & 1) - (skip >> 1 & 1) -
+			(skip >> 2 & 1) - (skip >> 3 & 1) - (skip >> 4 & 1) -
+			(skip >> 5 & 1) - (skip >> 6 & 1) - (skip >> 7 & 1);
+		if (skip > SAVAGE_SKIP_ALL_S4 || size != 8) {
+			DRM_ERROR("invalid skip flags 0x%04x for DMA\n", skip);
+			return -EINVAL;
+		}
+		if (reorder) {
+			DRM_ERROR("TRILIST_201 used on Savage4 hardware\n");
+			return -EINVAL;
+		}
+	}
+
+	if (start + n > dmabuf->total/32) {
+		DRM_ERROR("vertex indices (%u-%u) out of range (0-%u)\n",
+			  start, start + n - 1, dmabuf->total/32);
+		return -EINVAL;
+	}
+
+	/* Vertex DMA doesn't work with command DMA at the same time,
+	 * so we use BCI_... to submit commands here. Flush buffered
+	 * faked DMA first. */
+	DMA_FLUSH();
+
+	if (dmabuf->bus_address != dev_priv->state.common.vbaddr) {
+		BEGIN_BCI(2);
+		BCI_SET_REGISTERS(SAVAGE_VERTBUFADDR, 1);
+		BCI_WRITE(dmabuf->bus_address | dev_priv->dma_type);
+		dev_priv->state.common.vbaddr = dmabuf->bus_address;
+	}
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset) && dev_priv->waiting) {
+		/* Workaround for what looks like a hardware bug. If a
+		 * WAIT_3D_IDLE was emitted some time before the
+		 * indexed drawing command then the engine will lock
+		 * up. There are two known workarounds:
+		 * WAIT_IDLE_EMPTY or emit at least 63 NOPs. */
+		BEGIN_BCI(63);
+		for (i = 0; i < 63; ++i)
+			BCI_WRITE(BCI_CMD_WAIT);
+		dev_priv->waiting = 0;
+	}
+
+	prim <<= 25;
+	while (n != 0) {
+		/* Can emit up to 255 indices (85 triangles) at once. */
+		unsigned int count = n > 255 ? 255 : n;
+		if (reorder) {
+			/* Need to reorder indices for correct flat
+			 * shading while preserving the clock sense
+			 * for correct culling. Only on Savage3D. */
+			int reorder[3] = {-1, -1, -1};
+			reorder[start%3] = 2;
+
+			BEGIN_BCI((count+1+1)/2);
+			BCI_DRAW_INDICES_S3D(count, prim, start+2);
+
+			for (i = start+1; i+1 < start+count; i += 2)
+				BCI_WRITE((i + reorder[i % 3]) |
+					  ((i + 1 +
+					    reorder[(i + 1) % 3]) << 16));
+			if (i < start+count)
+				BCI_WRITE(i + reorder[i%3]);
+		} else if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+			BEGIN_BCI((count+1+1)/2);
+			BCI_DRAW_INDICES_S3D(count, prim, start);
+
+			for (i = start+1; i+1 < start+count; i += 2)
+				BCI_WRITE(i | ((i+1) << 16));
+			if (i < start+count)
+				BCI_WRITE(i);
+		} else {
+			BEGIN_BCI((count+2+1)/2);
+			BCI_DRAW_INDICES_S4(count, prim, skip);
+
+			for (i = start; i+1 < start+count; i += 2)
+				BCI_WRITE(i | ((i+1) << 16));
+			if (i < start+count)
+				BCI_WRITE(i);
+		}
+
+		start += count;
+		n -= count;
+
+		prim |= BCI_CMD_DRAW_CONT;
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_vb_prim(drm_savage_private_t *dev_priv,
+				   const drm_savage_cmd_header_t *cmd_header,
+				   const uint32_t *vtxbuf, unsigned int vb_size,
+				   unsigned int vb_stride)
+{
+	unsigned char reorder = 0;
+	unsigned int prim = cmd_header->prim.prim;
+	unsigned int skip = cmd_header->prim.skip;
+	unsigned int n = cmd_header->prim.count;
+	unsigned int start = cmd_header->prim.start;
+	unsigned int vtx_size;
+	unsigned int i;
+	DMA_LOCALS;
+
+	if (!n)
+		return 0;
+
+	switch (prim) {
+	case SAVAGE_PRIM_TRILIST_201:
+		reorder = 1;
+		prim = SAVAGE_PRIM_TRILIST;
+	case SAVAGE_PRIM_TRILIST:
+		if (n % 3 != 0) {
+			DRM_ERROR("wrong number of vertices %u in TRILIST\n",
+				  n);
+			return -EINVAL;
+		}
+		break;
+	case SAVAGE_PRIM_TRISTRIP:
+	case SAVAGE_PRIM_TRIFAN:
+		if (n < 3) {
+			DRM_ERROR
+			    ("wrong number of vertices %u in TRIFAN/STRIP\n",
+			     n);
+			return -EINVAL;
+		}
+		break;
+	default:
+		DRM_ERROR("invalid primitive type %u\n", prim);
+		return -EINVAL;
+	}
+
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		if (skip > SAVAGE_SKIP_ALL_S3D) {
+			DRM_ERROR("invalid skip flags 0x%04x\n", skip);
+			return -EINVAL;
+		}
+		vtx_size = 8; /* full vertex */
+	} else {
+		if (skip > SAVAGE_SKIP_ALL_S4) {
+			DRM_ERROR("invalid skip flags 0x%04x\n", skip);
+			return -EINVAL;
+		}
+		vtx_size = 10; /* full vertex */
+	}
+
+	vtx_size -= (skip & 1) + (skip >> 1 & 1) +
+		(skip >> 2 & 1) + (skip >> 3 & 1) + (skip >> 4 & 1) +
+		(skip >> 5 & 1) + (skip >> 6 & 1) + (skip >> 7 & 1);
+
+	if (vtx_size > vb_stride) {
+		DRM_ERROR("vertex size greater than vb stride (%u > %u)\n",
+			  vtx_size, vb_stride);
+		return -EINVAL;
+	}
+
+	if (start + n > vb_size / (vb_stride*4)) {
+		DRM_ERROR("vertex indices (%u-%u) out of range (0-%u)\n",
+			  start, start + n - 1, vb_size / (vb_stride*4));
+		return -EINVAL;
+	}
+
+	prim <<= 25;
+	while (n != 0) {
+		/* Can emit up to 255 vertices (85 triangles) at once. */
+		unsigned int count = n > 255 ? 255 : n;
+		if (reorder) {
+			/* Need to reorder vertices for correct flat
+			 * shading while preserving the clock sense
+			 * for correct culling. Only on Savage3D. */
+			int reorder[3] = {-1, -1, -1};
+			reorder[start%3] = 2;
+
+			BEGIN_DMA(count*vtx_size+1);
+			DMA_DRAW_PRIMITIVE(count, prim, skip);
+
+			for (i = start; i < start+count; ++i) {
+				unsigned int j = i + reorder[i % 3];
+				DMA_COPY(&vtxbuf[vb_stride*j], vtx_size);
+			}
+
+			DMA_COMMIT();
+		} else {
+			BEGIN_DMA(count*vtx_size+1);
+			DMA_DRAW_PRIMITIVE(count, prim, skip);
+
+			if (vb_stride == vtx_size) {
+				DMA_COPY(&vtxbuf[vb_stride*start],
+					 vtx_size*count);
+			} else {
+				for (i = start; i < start+count; ++i) {
+					DMA_COPY(&vtxbuf[vb_stride*i],
+						 vtx_size);
+				}
+			}
+
+			DMA_COMMIT();
+		}
+
+		start += count;
+		n -= count;
+
+		prim |= BCI_CMD_DRAW_CONT;
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_dma_idx(drm_savage_private_t *dev_priv,
+				   const drm_savage_cmd_header_t *cmd_header,
+				   const uint16_t *idx,
+				   const struct drm_buf *dmabuf)
+{
+	unsigned char reorder = 0;
+	unsigned int prim = cmd_header->idx.prim;
+	unsigned int skip = cmd_header->idx.skip;
+	unsigned int n = cmd_header->idx.count;
+	unsigned int i;
+	BCI_LOCALS;
+
+	if (!dmabuf) {
+	    DRM_ERROR("called without dma buffers!\n");
+	    return -EINVAL;
+	}
+
+	if (!n)
+		return 0;
+
+	switch (prim) {
+	case SAVAGE_PRIM_TRILIST_201:
+		reorder = 1;
+		prim = SAVAGE_PRIM_TRILIST;
+	case SAVAGE_PRIM_TRILIST:
+		if (n % 3 != 0) {
+			DRM_ERROR("wrong number of indices %u in TRILIST\n", n);
+			return -EINVAL;
+		}
+		break;
+	case SAVAGE_PRIM_TRISTRIP:
+	case SAVAGE_PRIM_TRIFAN:
+		if (n < 3) {
+			DRM_ERROR
+			    ("wrong number of indices %u in TRIFAN/STRIP\n", n);
+			return -EINVAL;
+		}
+		break;
+	default:
+		DRM_ERROR("invalid primitive type %u\n", prim);
+		return -EINVAL;
+	}
+
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		if (skip != 0) {
+			DRM_ERROR("invalid skip flags 0x%04x for DMA\n", skip);
+			return -EINVAL;
+		}
+	} else {
+		unsigned int size = 10 - (skip & 1) - (skip >> 1 & 1) -
+			(skip >> 2 & 1) - (skip >> 3 & 1) - (skip >> 4 & 1) -
+			(skip >> 5 & 1) - (skip >> 6 & 1) - (skip >> 7 & 1);
+		if (skip > SAVAGE_SKIP_ALL_S4 || size != 8) {
+			DRM_ERROR("invalid skip flags 0x%04x for DMA\n", skip);
+			return -EINVAL;
+		}
+		if (reorder) {
+			DRM_ERROR("TRILIST_201 used on Savage4 hardware\n");
+			return -EINVAL;
+		}
+	}
+
+	/* Vertex DMA doesn't work with command DMA at the same time,
+	 * so we use BCI_... to submit commands here. Flush buffered
+	 * faked DMA first. */
+	DMA_FLUSH();
+
+	if (dmabuf->bus_address != dev_priv->state.common.vbaddr) {
+		BEGIN_BCI(2);
+		BCI_SET_REGISTERS(SAVAGE_VERTBUFADDR, 1);
+		BCI_WRITE(dmabuf->bus_address | dev_priv->dma_type);
+		dev_priv->state.common.vbaddr = dmabuf->bus_address;
+	}
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset) && dev_priv->waiting) {
+		/* Workaround for what looks like a hardware bug. If a
+		 * WAIT_3D_IDLE was emitted some time before the
+		 * indexed drawing command then the engine will lock
+		 * up. There are two known workarounds:
+		 * WAIT_IDLE_EMPTY or emit at least 63 NOPs. */
+		BEGIN_BCI(63);
+		for (i = 0; i < 63; ++i)
+			BCI_WRITE(BCI_CMD_WAIT);
+		dev_priv->waiting = 0;
+	}
+
+	prim <<= 25;
+	while (n != 0) {
+		/* Can emit up to 255 indices (85 triangles) at once. */
+		unsigned int count = n > 255 ? 255 : n;
+
+		/* check indices */
+		for (i = 0; i < count; ++i) {
+			if (idx[i] > dmabuf->total/32) {
+				DRM_ERROR("idx[%u]=%u out of range (0-%u)\n",
+					  i, idx[i], dmabuf->total/32);
+				return -EINVAL;
+			}
+		}
+
+		if (reorder) {
+			/* Need to reorder indices for correct flat
+			 * shading while preserving the clock sense
+			 * for correct culling. Only on Savage3D. */
+			int reorder[3] = {2, -1, -1};
+
+			BEGIN_BCI((count+1+1)/2);
+			BCI_DRAW_INDICES_S3D(count, prim, idx[2]);
+
+			for (i = 1; i+1 < count; i += 2)
+				BCI_WRITE(idx[i + reorder[i % 3]] |
+					  (idx[i + 1 +
+					   reorder[(i + 1) % 3]] << 16));
+			if (i < count)
+				BCI_WRITE(idx[i + reorder[i%3]]);
+		} else if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+			BEGIN_BCI((count+1+1)/2);
+			BCI_DRAW_INDICES_S3D(count, prim, idx[0]);
+
+			for (i = 1; i+1 < count; i += 2)
+				BCI_WRITE(idx[i] | (idx[i+1] << 16));
+			if (i < count)
+				BCI_WRITE(idx[i]);
+		} else {
+			BEGIN_BCI((count+2+1)/2);
+			BCI_DRAW_INDICES_S4(count, prim, skip);
+
+			for (i = 0; i+1 < count; i += 2)
+				BCI_WRITE(idx[i] | (idx[i+1] << 16));
+			if (i < count)
+				BCI_WRITE(idx[i]);
+		}
+
+		idx += count;
+		n -= count;
+
+		prim |= BCI_CMD_DRAW_CONT;
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_vb_idx(drm_savage_private_t *dev_priv,
+				  const drm_savage_cmd_header_t *cmd_header,
+				  const uint16_t *idx,
+				  const uint32_t *vtxbuf,
+				  unsigned int vb_size, unsigned int vb_stride)
+{
+	unsigned char reorder = 0;
+	unsigned int prim = cmd_header->idx.prim;
+	unsigned int skip = cmd_header->idx.skip;
+	unsigned int n = cmd_header->idx.count;
+	unsigned int vtx_size;
+	unsigned int i;
+	DMA_LOCALS;
+
+	if (!n)
+		return 0;
+
+	switch (prim) {
+	case SAVAGE_PRIM_TRILIST_201:
+		reorder = 1;
+		prim = SAVAGE_PRIM_TRILIST;
+	case SAVAGE_PRIM_TRILIST:
+		if (n % 3 != 0) {
+			DRM_ERROR("wrong number of indices %u in TRILIST\n", n);
+			return -EINVAL;
+		}
+		break;
+	case SAVAGE_PRIM_TRISTRIP:
+	case SAVAGE_PRIM_TRIFAN:
+		if (n < 3) {
+			DRM_ERROR
+			    ("wrong number of indices %u in TRIFAN/STRIP\n", n);
+			return -EINVAL;
+		}
+		break;
+	default:
+		DRM_ERROR("invalid primitive type %u\n", prim);
+		return -EINVAL;
+	}
+
+	if (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {
+		if (skip > SAVAGE_SKIP_ALL_S3D) {
+			DRM_ERROR("invalid skip flags 0x%04x\n", skip);
+			return -EINVAL;
+		}
+		vtx_size = 8; /* full vertex */
+	} else {
+		if (skip > SAVAGE_SKIP_ALL_S4) {
+			DRM_ERROR("invalid skip flags 0x%04x\n", skip);
+			return -EINVAL;
+		}
+		vtx_size = 10; /* full vertex */
+	}
+
+	vtx_size -= (skip & 1) + (skip >> 1 & 1) +
+		(skip >> 2 & 1) + (skip >> 3 & 1) + (skip >> 4 & 1) +
+		(skip >> 5 & 1) + (skip >> 6 & 1) + (skip >> 7 & 1);
+
+	if (vtx_size > vb_stride) {
+		DRM_ERROR("vertex size greater than vb stride (%u > %u)\n",
+			  vtx_size, vb_stride);
+		return -EINVAL;
+	}
+
+	prim <<= 25;
+	while (n != 0) {
+		/* Can emit up to 255 vertices (85 triangles) at once. */
+		unsigned int count = n > 255 ? 255 : n;
+
+		/* Check indices */
+		for (i = 0; i < count; ++i) {
+			if (idx[i] > vb_size / (vb_stride*4)) {
+				DRM_ERROR("idx[%u]=%u out of range (0-%u)\n",
+					  i, idx[i],  vb_size / (vb_stride*4));
+				return -EINVAL;
+			}
+		}
+
+		if (reorder) {
+			/* Need to reorder vertices for correct flat
+			 * shading while preserving the clock sense
+			 * for correct culling. Only on Savage3D. */
+			int reorder[3] = {2, -1, -1};
+
+			BEGIN_DMA(count*vtx_size+1);
+			DMA_DRAW_PRIMITIVE(count, prim, skip);
+
+			for (i = 0; i < count; ++i) {
+				unsigned int j = idx[i + reorder[i % 3]];
+				DMA_COPY(&vtxbuf[vb_stride*j], vtx_size);
+			}
+
+			DMA_COMMIT();
+		} else {
+			BEGIN_DMA(count*vtx_size+1);
+			DMA_DRAW_PRIMITIVE(count, prim, skip);
+
+			for (i = 0; i < count; ++i) {
+				unsigned int j = idx[i];
+				DMA_COPY(&vtxbuf[vb_stride*j], vtx_size);
+			}
+
+			DMA_COMMIT();
+		}
+
+		idx += count;
+		n -= count;
+
+		prim |= BCI_CMD_DRAW_CONT;
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_clear(drm_savage_private_t *dev_priv,
+				 const drm_savage_cmd_header_t *cmd_header,
+				 const drm_savage_cmd_header_t *data,
+				 unsigned int nbox,
+				 const struct drm_clip_rect *boxes)
+{
+	unsigned int flags = cmd_header->clear0.flags;
+	unsigned int clear_cmd;
+	unsigned int i, nbufs;
+	DMA_LOCALS;
+
+	if (nbox == 0)
+		return 0;
+
+	clear_cmd = BCI_CMD_RECT | BCI_CMD_RECT_XP | BCI_CMD_RECT_YP |
+		BCI_CMD_SEND_COLOR | BCI_CMD_DEST_PBD_NEW;
+	BCI_CMD_SET_ROP(clear_cmd,0xCC);
+
+	nbufs = ((flags & SAVAGE_FRONT) ? 1 : 0) +
+	    ((flags & SAVAGE_BACK) ? 1 : 0) + ((flags & SAVAGE_DEPTH) ? 1 : 0);
+	if (nbufs == 0)
+		return 0;
+
+	if (data->clear1.mask != 0xffffffff) {
+		/* set mask */
+		BEGIN_DMA(2);
+		DMA_SET_REGISTERS(SAVAGE_BITPLANEWTMASK, 1);
+		DMA_WRITE(data->clear1.mask);
+		DMA_COMMIT();
+	}
+	for (i = 0; i < nbox; ++i) {
+		unsigned int x, y, w, h;
+		unsigned int buf;
+
+		x = boxes[i].x1, y = boxes[i].y1;
+		w = boxes[i].x2 - boxes[i].x1;
+		h = boxes[i].y2 - boxes[i].y1;
+		BEGIN_DMA(nbufs*6);
+		for (buf = SAVAGE_FRONT; buf <= SAVAGE_DEPTH; buf <<= 1) {
+			if (!(flags & buf))
+				continue;
+			DMA_WRITE(clear_cmd);
+			switch(buf) {
+			case SAVAGE_FRONT:
+				DMA_WRITE(dev_priv->front_offset);
+				DMA_WRITE(dev_priv->front_bd);
+				break;
+			case SAVAGE_BACK:
+				DMA_WRITE(dev_priv->back_offset);
+				DMA_WRITE(dev_priv->back_bd);
+				break;
+			case SAVAGE_DEPTH:
+				DMA_WRITE(dev_priv->depth_offset);
+				DMA_WRITE(dev_priv->depth_bd);
+				break;
+			}
+			DMA_WRITE(data->clear1.value);
+			DMA_WRITE(BCI_X_Y(x, y));
+			DMA_WRITE(BCI_W_H(w, h));
+		}
+		DMA_COMMIT();
+	}
+	if (data->clear1.mask != 0xffffffff) {
+		/* reset mask */
+		BEGIN_DMA(2);
+		DMA_SET_REGISTERS(SAVAGE_BITPLANEWTMASK, 1);
+		DMA_WRITE(0xffffffff);
+		DMA_COMMIT();
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_swap(drm_savage_private_t *dev_priv,
+				unsigned int nbox, const struct drm_clip_rect *boxes)
+{
+	unsigned int swap_cmd;
+	unsigned int i;
+	DMA_LOCALS;
+
+	if (nbox == 0)
+		return 0;
+
+	swap_cmd = BCI_CMD_RECT | BCI_CMD_RECT_XP | BCI_CMD_RECT_YP |
+		BCI_CMD_SRC_PBD_COLOR_NEW | BCI_CMD_DEST_GBD;
+	BCI_CMD_SET_ROP(swap_cmd,0xCC);
+
+	for (i = 0; i < nbox; ++i) {
+		BEGIN_DMA(6);
+		DMA_WRITE(swap_cmd);
+		DMA_WRITE(dev_priv->back_offset);
+		DMA_WRITE(dev_priv->back_bd);
+		DMA_WRITE(BCI_X_Y(boxes[i].x1, boxes[i].y1));
+		DMA_WRITE(BCI_X_Y(boxes[i].x1, boxes[i].y1));
+		DMA_WRITE(BCI_W_H(boxes[i].x2-boxes[i].x1,
+				  boxes[i].y2-boxes[i].y1));
+		DMA_COMMIT();
+	}
+
+	return 0;
+}
+
+static int savage_dispatch_draw(drm_savage_private_t *dev_priv,
+				const drm_savage_cmd_header_t *start,
+				const drm_savage_cmd_header_t *end,
+				const struct drm_buf *dmabuf,
+				const unsigned int *vtxbuf,
+				unsigned int vb_size, unsigned int vb_stride,
+				unsigned int nbox,
+				const struct drm_clip_rect *boxes)
+{
+	unsigned int i, j;
+	int ret;
+
+	for (i = 0; i < nbox; ++i) {
+		const drm_savage_cmd_header_t *cmdbuf;
+		dev_priv->emit_clip_rect(dev_priv, &boxes[i]);
+
+		cmdbuf = start;
+		while (cmdbuf < end) {
+			drm_savage_cmd_header_t cmd_header;
+			cmd_header = *cmdbuf;
+			cmdbuf++;
+			switch (cmd_header.cmd.cmd) {
+			case SAVAGE_CMD_DMA_PRIM:
+				ret = savage_dispatch_dma_prim(
+					dev_priv, &cmd_header, dmabuf);
+				break;
+			case SAVAGE_CMD_VB_PRIM:
+				ret = savage_dispatch_vb_prim(
+					dev_priv, &cmd_header,
+					vtxbuf, vb_size, vb_stride);
+				break;
+			case SAVAGE_CMD_DMA_IDX:
+				j = (cmd_header.idx.count + 3) / 4;
+				/* j was check in savage_bci_cmdbuf */
+				ret = savage_dispatch_dma_idx(dev_priv,
+					&cmd_header, (const uint16_t *)cmdbuf,
+					dmabuf);
+				cmdbuf += j;
+				break;
+			case SAVAGE_CMD_VB_IDX:
+				j = (cmd_header.idx.count + 3) / 4;
+				/* j was check in savage_bci_cmdbuf */
+				ret = savage_dispatch_vb_idx(dev_priv,
+					&cmd_header, (const uint16_t *)cmdbuf,
+					(const uint32_t *)vtxbuf, vb_size,
+					vb_stride);
+				cmdbuf += j;
+				break;
+			default:
+				/* What's the best return code? EFAULT? */
+				DRM_ERROR("IMPLEMENTATION ERROR: "
+					  "non-drawing-command %d\n",
+					  cmd_header.cmd.cmd);
+				return -EINVAL;
+			}
+
+			if (ret != 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+int savage_bci_cmdbuf(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_savage_private_t *dev_priv = dev->dev_private;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *dmabuf;
+	drm_savage_cmdbuf_t *cmdbuf = data;
+	drm_savage_cmd_header_t *kcmd_addr = NULL;
+	drm_savage_cmd_header_t *first_draw_cmd;
+	unsigned int *kvb_addr = NULL;
+	struct drm_clip_rect *kbox_addr = NULL;
+	unsigned int i, j;
+	int ret = 0;
+
+	DRM_DEBUG("\n");
+	
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	if (dma && dma->buflist) {
+		if (cmdbuf->dma_idx > dma->buf_count) {
+			DRM_ERROR
+			    ("vertex buffer index %u out of range (0-%u)\n",
+			     cmdbuf->dma_idx, dma->buf_count-1);
+			return -EINVAL;
+		}
+		dmabuf = dma->buflist[cmdbuf->dma_idx];
+	} else {
+		dmabuf = NULL;
+	}
+
+	/* Copy the user buffers into kernel temporary areas.  This hasn't been
+	 * a performance loss compared to VERIFYAREA_READ/
+	 * COPY_FROM_USER_UNCHECKED when done in other drivers, and is correct
+	 * for locking on FreeBSD.
+	 */
+	if (cmdbuf->size) {
+		kcmd_addr = drm_alloc(cmdbuf->size * 8, DRM_MEM_DRIVER);
+		if (kcmd_addr == NULL)
+			return -ENOMEM;
+
+		if (DRM_COPY_FROM_USER(kcmd_addr, cmdbuf->cmd_addr,
+				       cmdbuf->size * 8))
+		{
+			drm_free(kcmd_addr, cmdbuf->size * 8, DRM_MEM_DRIVER);
+			return -EFAULT;
+		}
+		cmdbuf->cmd_addr = kcmd_addr;
+	}
+	if (cmdbuf->vb_size) {
+		kvb_addr = drm_alloc(cmdbuf->vb_size, DRM_MEM_DRIVER);
+		if (kvb_addr == NULL) {
+			ret = -ENOMEM;
+			goto done;
+		}
+
+		if (DRM_COPY_FROM_USER(kvb_addr, cmdbuf->vb_addr,
+				       cmdbuf->vb_size)) {
+			ret = -EFAULT;
+			goto done;
+		}
+		cmdbuf->vb_addr = kvb_addr;
+	}
+	if (cmdbuf->nbox) {
+		kbox_addr = drm_alloc(cmdbuf->nbox *
+				      sizeof(struct drm_clip_rect),
+				      DRM_MEM_DRIVER);
+		if (kbox_addr == NULL) {
+			ret = -ENOMEM;
+			goto done;
+		}
+
+		if (DRM_COPY_FROM_USER(kbox_addr, cmdbuf->box_addr,
+				       cmdbuf->nbox *
+				       sizeof(struct drm_clip_rect))) {
+			ret = -EFAULT;
+			goto done;
+		}
+		cmdbuf->box_addr = kbox_addr;
+	}
+
+	/* Make sure writes to DMA buffers are finished before sending
+	 * DMA commands to the graphics hardware. */
+	DRM_MEMORYBARRIER();
+
+	/* Coming from user space. Don't know if the Xserver has
+	 * emitted wait commands. Assuming the worst. */
+	dev_priv->waiting = 1;
+
+	i = 0;
+	first_draw_cmd = NULL;
+	while (i < cmdbuf->size) {
+		drm_savage_cmd_header_t cmd_header;
+		cmd_header = *(drm_savage_cmd_header_t *)cmdbuf->cmd_addr;
+		cmdbuf->cmd_addr++;
+		i++;
+
+		/* Group drawing commands with same state to minimize
+		 * iterations over clip rects. */
+		j = 0;
+		switch (cmd_header.cmd.cmd) {
+		case SAVAGE_CMD_DMA_IDX:
+		case SAVAGE_CMD_VB_IDX:
+			j = (cmd_header.idx.count + 3) / 4;
+			if (i + j > cmdbuf->size) {
+				DRM_ERROR("indexed drawing command extends "
+					  "beyond end of command buffer\n");
+				DMA_FLUSH();
+				return -EINVAL;
+			}
+			/* fall through */
+		case SAVAGE_CMD_DMA_PRIM:
+		case SAVAGE_CMD_VB_PRIM:
+			if (!first_draw_cmd)
+				first_draw_cmd = cmdbuf->cmd_addr-1;
+			cmdbuf->cmd_addr += j;
+			i += j;
+			break;
+		default:
+			if (first_draw_cmd) {
+				ret = savage_dispatch_draw (
+					dev_priv, first_draw_cmd,
+					cmdbuf->cmd_addr-1,
+					dmabuf, cmdbuf->vb_addr,
+					cmdbuf->vb_size,
+					cmdbuf->vb_stride,
+					cmdbuf->nbox, cmdbuf->box_addr);
+				if (ret != 0)
+					return ret;
+				first_draw_cmd = NULL;
+			}
+		}
+		if (first_draw_cmd)
+			continue;
+
+		switch (cmd_header.cmd.cmd) {
+		case SAVAGE_CMD_STATE:
+			j = (cmd_header.state.count + 1) / 2;
+			if (i + j > cmdbuf->size) {
+				DRM_ERROR("command SAVAGE_CMD_STATE extends "
+					  "beyond end of command buffer\n");
+				DMA_FLUSH();
+				ret = -EINVAL;
+				goto done;
+			}
+			ret = savage_dispatch_state(dev_priv, &cmd_header,
+				(const uint32_t *)cmdbuf->cmd_addr);
+			cmdbuf->cmd_addr += j;
+			i += j;
+			break;
+		case SAVAGE_CMD_CLEAR:
+			if (i + 1 > cmdbuf->size) {
+				DRM_ERROR("command SAVAGE_CMD_CLEAR extends "
+					  "beyond end of command buffer\n");
+				DMA_FLUSH();
+				ret = -EINVAL;
+				goto done;
+			}
+			ret = savage_dispatch_clear(dev_priv, &cmd_header,
+						    cmdbuf->cmd_addr,
+						    cmdbuf->nbox,
+						    cmdbuf->box_addr);
+			cmdbuf->cmd_addr++;
+			i++;
+			break;
+		case SAVAGE_CMD_SWAP:
+			ret = savage_dispatch_swap(dev_priv, cmdbuf->nbox,
+						   cmdbuf->box_addr);
+			break;
+		default:
+			DRM_ERROR("invalid command 0x%x\n",
+				  cmd_header.cmd.cmd);
+			DMA_FLUSH();
+			ret = -EINVAL;
+			goto done;
+		}
+
+		if (ret != 0) {
+			DMA_FLUSH();
+			goto done;
+		}
+	}
+
+	if (first_draw_cmd) {
+		ret = savage_dispatch_draw (
+			dev_priv, first_draw_cmd, cmdbuf->cmd_addr, dmabuf,
+			cmdbuf->vb_addr, cmdbuf->vb_size, cmdbuf->vb_stride,
+			cmdbuf->nbox, cmdbuf->box_addr);
+		if (ret != 0) {
+			DMA_FLUSH();
+			goto done;
+		}
+	}
+
+	DMA_FLUSH();
+
+	if (dmabuf && cmdbuf->discard) {
+		drm_savage_buf_priv_t *buf_priv = dmabuf->dev_private;
+		uint16_t event;
+		event = savage_bci_emit_event(dev_priv, SAVAGE_WAIT_3D);
+		SET_AGE(&buf_priv->age, event, dev_priv->event_wrap);
+		savage_freelist_put(dev, dmabuf);
+	}
+
+done:
+	/* If we didn't need to allocate them, these'll be NULL */
+	drm_free(kcmd_addr, cmdbuf->size * 8, DRM_MEM_DRIVER);
+	drm_free(kvb_addr, cmdbuf->vb_size, DRM_MEM_DRIVER);
+	drm_free(kbox_addr, cmdbuf->nbox * sizeof(struct drm_clip_rect),
+		 DRM_MEM_DRIVER);
+
+	return ret;
+}
Index: git/shared-core/sis_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/sis_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,92 @@
+/* sis_drv.h -- Private header for sis driver -*- linux-c -*- */
+/*
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _SIS_DRV_H_
+#define _SIS_DRV_H_
+
+/* General customization:
+ */
+
+#define DRIVER_AUTHOR		"SIS, Tungsten Graphics"
+#define DRIVER_NAME		"sis"
+#define DRIVER_DESC		"SIS 300/630/540 and XGI V3XE/V5/V8"
+#define DRIVER_DATE		"20070626"
+#define DRIVER_MAJOR		1
+#define DRIVER_MINOR		3
+#define DRIVER_PATCHLEVEL	0
+
+enum sis_family {
+	SIS_OTHER = 0,
+	SIS_CHIP_315 = 1,
+};
+
+#if defined(__linux__)
+#define SIS_HAVE_CORE_MM
+#endif
+
+#ifdef SIS_HAVE_CORE_MM
+#include "drm_sman.h"
+
+#define SIS_BASE (dev_priv->mmio)
+#define SIS_READ(reg)	 DRM_READ32(SIS_BASE, reg);
+#define SIS_WRITE(reg, val)   DRM_WRITE32(SIS_BASE, reg, val);
+
+typedef struct drm_sis_private {
+	drm_local_map_t *mmio;
+	unsigned int idle_fault;
+	struct drm_sman sman;
+	unsigned int chipset;
+	int vram_initialized;
+	int agp_initialized;
+	unsigned long vram_offset;
+	unsigned long agp_offset;
+} drm_sis_private_t;
+
+extern int sis_idle(struct drm_device *dev);
+extern void sis_reclaim_buffers_locked(struct drm_device *dev,
+				       struct drm_file *file_priv);
+extern void sis_lastclose(struct drm_device *dev);
+
+#else
+#include "sis_ds.h"
+
+typedef struct drm_sis_private {
+	memHeap_t *AGPHeap;
+	memHeap_t *FBHeap;
+} drm_sis_private_t;
+
+extern int sis_init_context(struct drm_device * dev, int context);
+extern int sis_final_context(struct drm_device * dev, int context);
+
+#endif
+
+
+
+extern struct drm_ioctl_desc sis_ioctls[];
+extern int sis_max_ioctl;
+
+#endif
Index: git/shared-core/sis_ds.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/sis_ds.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,299 @@
+/* sis_ds.c -- Private header for Direct Rendering Manager -*- linux-c -*-
+ * Created: Mon Jan  4 10:05:05 1999 by sclin@sis.com.tw
+ *
+ * Copyright 2000 Silicon Integrated Systems Corp, Inc., HsinChu, Taiwan.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Sung-Ching Lin <sclin@sis.com.tw>
+ *
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "sis_ds.h"
+
+/* Set Data Structure, not check repeated value
+ * temporarily used
+ */
+
+set_t *setInit(void)
+{
+	int i;
+	set_t *set;
+
+	set = (set_t *) drm_alloc(sizeof(set_t), DRM_MEM_DRIVER);
+	if (set != NULL) {
+		for (i = 0; i < SET_SIZE; i++) {
+			set->list[i].free_next = i + 1;
+			set->list[i].alloc_next = -1;
+		}
+		set->list[SET_SIZE - 1].free_next = -1;
+		set->free = 0;
+		set->alloc = -1;
+		set->trace = -1;
+	}
+	return set;
+}
+
+int setAdd(set_t * set, ITEM_TYPE item)
+{
+	int free = set->free;
+
+	if (free != -1) {
+		set->list[free].val = item;
+		set->free = set->list[free].free_next;
+	} else {
+		return 0;
+	}
+
+	set->list[free].alloc_next = set->alloc;
+	set->alloc = free;
+	set->list[free].free_next = -1;
+
+	return 1;
+}
+
+int setDel(set_t * set, ITEM_TYPE item)
+{
+	int alloc = set->alloc;
+	int prev = -1;
+
+	while (alloc != -1) {
+		if (set->list[alloc].val == item) {
+			if (prev != -1)
+				set->list[prev].alloc_next =
+				    set->list[alloc].alloc_next;
+			else
+				set->alloc = set->list[alloc].alloc_next;
+			break;
+		}
+		prev = alloc;
+		alloc = set->list[alloc].alloc_next;
+	}
+
+	if (alloc == -1)
+		return 0;
+
+	set->list[alloc].free_next = set->free;
+	set->free = alloc;
+	set->list[alloc].alloc_next = -1;
+
+	return 1;
+}
+
+/* setFirst -> setAdd -> setNext is wrong */
+
+int setFirst(set_t * set, ITEM_TYPE * item)
+{
+	if (set->alloc == -1)
+		return 0;
+
+	*item = set->list[set->alloc].val;
+	set->trace = set->list[set->alloc].alloc_next;
+
+	return 1;
+}
+
+int setNext(set_t * set, ITEM_TYPE * item)
+{
+	if (set->trace == -1)
+		return 0;
+
+	*item = set->list[set->trace].val;
+	set->trace = set->list[set->trace].alloc_next;
+
+	return 1;
+}
+
+int setDestroy(set_t * set)
+{
+	drm_free(set, sizeof(set_t), DRM_MEM_DRIVER);
+
+	return 1;
+}
+
+/*
+ * GLX Hardware Device Driver common code
+ * Copyright (C) 1999 Wittawat Yamwong
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * WITTAWAT YAMWONG, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#define ISFREE(bptr) ((bptr)->free)
+
+memHeap_t *mmInit(int ofs, int size)
+{
+	PMemBlock blocks;
+
+	if (size <= 0)
+		return NULL;
+
+	blocks = (TMemBlock *) drm_calloc(1, sizeof(TMemBlock), DRM_MEM_DRIVER);
+	if (blocks != NULL) {
+		blocks->ofs = ofs;
+		blocks->size = size;
+		blocks->free = 1;
+		return (memHeap_t *) blocks;
+	} else
+		return NULL;
+}
+
+/* Checks if a pointer 'b' is part of the heap 'heap' */
+int mmBlockInHeap(memHeap_t * heap, PMemBlock b)
+{
+	TMemBlock *p;
+
+	if (heap == NULL || b == NULL)
+		return 0;
+
+	p = heap;
+	while (p != NULL && p != b) {
+		p = p->next;
+	}
+	if (p == b)
+		return 1;
+	else
+		return 0;
+}
+
+static TMemBlock *SliceBlock(TMemBlock * p,
+			     int startofs, int size,
+			     int reserved, int alignment)
+{
+	TMemBlock *newblock;
+
+	/* break left */
+	if (startofs > p->ofs) {
+		newblock = (TMemBlock *) drm_calloc(1, sizeof(TMemBlock),
+						    DRM_MEM_DRIVER);
+		newblock->ofs = startofs;
+		newblock->size = p->size - (startofs - p->ofs);
+		newblock->free = 1;
+		newblock->next = p->next;
+		p->size -= newblock->size;
+		p->next = newblock;
+		p = newblock;
+	}
+
+	/* break right */
+	if (size < p->size) {
+		newblock = (TMemBlock *) drm_calloc(1, sizeof(TMemBlock),
+						    DRM_MEM_DRIVER);
+		newblock->ofs = startofs + size;
+		newblock->size = p->size - size;
+		newblock->free = 1;
+		newblock->next = p->next;
+		p->size = size;
+		p->next = newblock;
+	}
+
+	/* p = middle block */
+	p->align = alignment;
+	p->free = 0;
+	p->reserved = reserved;
+	return p;
+}
+
+PMemBlock mmAllocMem(memHeap_t * heap, int size, int align2, int startSearch)
+{
+	int mask, startofs, endofs;
+	TMemBlock *p;
+
+	if (heap == NULL || align2 < 0 || size <= 0)
+		return NULL;
+
+	mask = (1 << align2) - 1;
+	startofs = 0;
+	p = (TMemBlock *) heap;
+	while (p != NULL) {
+		if (ISFREE(p)) {
+			startofs = (p->ofs + mask) & ~mask;
+			if (startofs < startSearch) {
+				startofs = startSearch;
+			}
+			endofs = startofs + size;
+			if (endofs <= (p->ofs + p->size))
+				break;
+		}
+		p = p->next;
+	}
+	if (p == NULL)
+		return NULL;
+	p = SliceBlock(p, startofs, size, 0, mask + 1);
+	p->heap = heap;
+	return p;
+}
+
+static __inline__ int Join2Blocks(TMemBlock * p)
+{
+	if (p->free && p->next && p->next->free) {
+		TMemBlock *q = p->next;
+		p->size += q->size;
+		p->next = q->next;
+		drm_free(q, sizeof(TMemBlock), DRM_MEM_DRIVER);
+		return 1;
+	}
+	return 0;
+}
+
+int mmFreeMem(PMemBlock b)
+{
+	TMemBlock *p, *prev;
+
+	if (b == NULL)
+		return 0;
+	if (b->heap == NULL)
+		return -1;
+
+	p = b->heap;
+	prev = NULL;
+	while (p != NULL && p != b) {
+		prev = p;
+		p = p->next;
+	}
+	if (p == NULL || p->free || p->reserved)
+		return -1;
+
+	p->free = 1;
+	Join2Blocks(p);
+	if (prev)
+		Join2Blocks(prev);
+	return 0;
+}
Index: git/shared-core/sis_ds.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/sis_ds.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,146 @@
+/* sis_ds.h -- Private header for Direct Rendering Manager -*- linux-c -*-
+ * Created: Mon Jan  4 10:05:05 1999 by sclin@sis.com.tw
+ */
+/*
+ * Copyright 2000 Silicon Integrated Systems Corp, Inc., HsinChu, Taiwan.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Sung-Ching Lin <sclin@sis.com.tw>
+ *
+ */
+
+#ifndef __SIS_DS_H__
+#define __SIS_DS_H__
+
+/* Set Data Structure */
+
+#define SET_SIZE 5000
+
+typedef unsigned long ITEM_TYPE;
+
+typedef struct {
+	ITEM_TYPE val;
+	int alloc_next, free_next;
+} list_item_t;
+
+typedef struct {
+	int alloc;
+	int free;
+	int trace;
+	list_item_t list[SET_SIZE];
+} set_t;
+
+set_t *setInit(void);
+int setAdd(set_t * set, ITEM_TYPE item);
+int setDel(set_t * set, ITEM_TYPE item);
+int setFirst(set_t * set, ITEM_TYPE * item);
+int setNext(set_t * set, ITEM_TYPE * item);
+int setDestroy(set_t * set);
+
+/*
+ * GLX Hardware Device Driver common code
+ * Copyright (C) 1999 Wittawat Yamwong
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * WITTAWAT YAMWONG, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+struct mem_block_t {
+	struct mem_block_t *next;
+	struct mem_block_t *heap;
+	int ofs, size;
+	int align;
+	unsigned int free:1;
+	unsigned int reserved:1;
+};
+typedef struct mem_block_t TMemBlock;
+typedef struct mem_block_t *PMemBlock;
+
+/* a heap is just the first block in a chain */
+typedef struct mem_block_t memHeap_t;
+
+static __inline__ int mmBlockSize(PMemBlock b)
+{
+	return b->size;
+}
+
+static __inline__ int mmOffset(PMemBlock b)
+{
+	return b->ofs;
+}
+
+static __inline__ void mmMarkReserved(PMemBlock b)
+{
+	b->reserved = 1;
+}
+
+/*
+ * input: total size in bytes
+ * return: a heap pointer if OK, NULL if error
+ */
+memHeap_t *mmInit(int ofs, int size);
+
+/*
+ * Allocate 'size' bytes with 2^align2 bytes alignment,
+ * restrict the search to free memory after 'startSearch'
+ * depth and back buffers should be in different 4mb banks
+ * to get better page hits if possible
+ * input:	size = size of block
+ *       	align2 = 2^align2 bytes alignment
+ *		startSearch = linear offset from start of heap to begin search
+ * return: pointer to the allocated block, 0 if error
+ */
+PMemBlock mmAllocMem(memHeap_t * heap, int size, int align2, int startSearch);
+
+/*
+ * Returns 1 if the block 'b' is part of the heap 'heap'
+ */
+int mmBlockInHeap(PMemBlock heap, PMemBlock b);
+
+/*
+ * Free block starts at offset
+ * input: pointer to a block
+ * return: 0 if OK, -1 if error
+ */
+int mmFreeMem(PMemBlock b);
+
+/* For debuging purpose. */
+void mmDumpMemInfo(memHeap_t * mmInit);
+
+#endif				/* __SIS_DS_H__ */
Index: git/shared-core/sis_mm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/sis_mm.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,386 @@
+/* sis_mm.c -- Private header for Direct Rendering Manager -*- linux-c -*-
+ * Created: Mon Jan  4 10:05:05 1999 by sclin@sis.com.tw
+ *
+ * Copyright 2000 Silicon Integrated Systems Corp, Inc., HsinChu, Taiwan.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Sung-Ching Lin <sclin@sis.com.tw>
+ *
+ */
+
+#if defined(__linux__) && defined(CONFIG_FB_SIS)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <video/sisfb.h>
+#else
+#include <linux/sisfb.h>
+#endif
+#endif
+#include "drmP.h"
+#include "sis_drm.h"
+#include "sis_drv.h"
+#include "sis_ds.h"
+
+#define MAX_CONTEXT 100
+#define VIDEO_TYPE 0
+#define AGP_TYPE 1
+
+typedef struct {
+	int used;
+	int context;
+	set_t *sets[2];		/* 0 for video, 1 for AGP */
+} sis_context_t;
+
+static sis_context_t global_ppriv[MAX_CONTEXT];
+
+static int add_alloc_set(int context, int type, unsigned int val)
+{
+	int i, retval = 0;
+
+	for (i = 0; i < MAX_CONTEXT; i++) {
+		if (global_ppriv[i].used && global_ppriv[i].context == context) {
+			retval = setAdd(global_ppriv[i].sets[type], val);
+			break;
+		}
+	}
+	return retval;
+}
+
+static int del_alloc_set(int context, int type, unsigned int val)
+{
+	int i, retval = 0;
+
+	for (i = 0; i < MAX_CONTEXT; i++) {
+		if (global_ppriv[i].used && global_ppriv[i].context == context) {
+			retval = setDel(global_ppriv[i].sets[type], val);
+			break;
+		}
+	}
+	return retval;
+}
+
+/* fb management via fb device */
+#if defined(__linux__) && defined(CONFIG_FB_SIS)
+
+static int sis_fb_init(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	return 0;
+}
+
+static int sis_fb_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_sis_mem_t *fb = data;
+	struct sis_memreq req;
+	int retval = 0;
+
+	req.size = fb->size;
+	sis_malloc(&req);
+	if (req.offset) {
+		/* TODO */
+		fb->offset = req.offset;
+		fb->free = req.offset;
+		if (!add_alloc_set(fb->context, VIDEO_TYPE, fb->free)) {
+			DRM_DEBUG("adding to allocation set fails\n");
+			sis_free(req.offset);
+			retval = -EINVAL;
+		}
+	} else {
+		fb->offset = 0;
+		fb->size = 0;
+		fb->free = 0;
+	}
+
+	DRM_DEBUG("alloc fb, size = %d, offset = %ld\n", fb->size, req.offset);
+
+	return retval;
+}
+
+static int sis_fb_free(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_sis_mem_t fb;
+	int retval = 0;
+
+	if (!fb->free)
+		return -EINVAL;
+
+	if (!del_alloc_set(fb->context, VIDEO_TYPE, fb->free))
+		retval = -EINVAL;
+	sis_free(fb->free);
+
+	DRM_DEBUG("free fb, offset = 0x%lx\n", fb->free);
+
+	return retval;
+}
+
+#else
+
+/* Called by the X Server to initialize the FB heap.  Allocations will fail
+ * unless this is called.  Offset is the beginning of the heap from the
+ * framebuffer offset (MaxXFBMem in XFree86).
+ *
+ * Memory layout according to Thomas Winischofer:
+ * |------------------|DDDDDDDDDDDDDDDDDDDDDDDDDDDDD|HHHH|CCCCCCCCCCC|
+ *
+ *    X driver/sisfb                                  HW-   Command-
+ *  framebuffer memory           DRI heap           Cursor   queue
+ */
+static int sis_fb_init(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_sis_private_t *dev_priv = dev->dev_private;
+	drm_sis_fb_t *fb = data;
+
+	if (dev_priv == NULL) {
+		dev->dev_private = drm_calloc(1, sizeof(drm_sis_private_t),
+					      DRM_MEM_DRIVER);
+		dev_priv = dev->dev_private;
+		if (dev_priv == NULL)
+			return ENOMEM;
+	}
+
+	if (dev_priv->FBHeap != NULL)
+		return -EINVAL;
+
+	dev_priv->FBHeap = mmInit(fb->offset, fb->size);
+
+	DRM_DEBUG("offset = %u, size = %u", fb->offset, fb->size);
+
+	return 0;
+}
+
+static int sis_fb_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_sis_private_t *dev_priv = dev->dev_private;
+	drm_sis_mem_t *fb = data;
+	PMemBlock block;
+	int retval = 0;
+
+	if (dev_priv == NULL || dev_priv->FBHeap == NULL)
+		return -EINVAL;
+
+	block = mmAllocMem(dev_priv->FBHeap, fb->size, 0, 0);
+	if (block) {
+		/* TODO */
+		fb->offset = block->ofs;
+		fb->free = (unsigned long)block;
+		if (!add_alloc_set(fb->context, VIDEO_TYPE, fb->free)) {
+			DRM_DEBUG("adding to allocation set fails\n");
+			mmFreeMem((PMemBlock) fb->free);
+			retval = -EINVAL;
+		}
+	} else {
+		fb->offset = 0;
+		fb->size = 0;
+		fb->free = 0;
+	}
+
+	DRM_DEBUG("alloc fb, size = %d, offset = %d\n", fb->size, fb->offset);
+
+	return retval;
+}
+
+static int sis_fb_free(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_sis_private_t *dev_priv = dev->dev_private;
+	drm_sis_mem_t *fb = data;
+
+	if (dev_priv == NULL || dev_priv->FBHeap == NULL)
+		return -EINVAL;
+
+	if (!mmBlockInHeap(dev_priv->FBHeap, (PMemBlock) fb->free))
+		return -EINVAL;
+
+	if (!del_alloc_set(fb->context, VIDEO_TYPE, fb->free))
+		return -EINVAL;
+	mmFreeMem((PMemBlock) fb->free);
+
+	DRM_DEBUG("free fb, free = 0x%lx\n", fb->free);
+
+	return 0;
+}
+
+#endif
+
+/* agp memory management */
+
+static int sis_ioctl_agp_init(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_sis_private_t *dev_priv = dev->dev_private;
+	drm_sis_agp_t *agp = data;
+
+	if (dev_priv == NULL) {
+		dev->dev_private = drm_calloc(1, sizeof(drm_sis_private_t),
+					      DRM_MEM_DRIVER);
+		dev_priv = dev->dev_private;
+		if (dev_priv == NULL)
+			return ENOMEM;
+	}
+
+	if (dev_priv->AGPHeap != NULL)
+		return -EINVAL;
+
+	dev_priv->AGPHeap = mmInit(agp->offset, agp->size);
+
+	DRM_DEBUG("offset = %u, size = %u", agp->offset, agp->size);
+
+	return 0;
+}
+
+static int sis_ioctl_agp_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_sis_private_t *dev_priv = dev->dev_private;
+	drm_sis_mem_t *agp = data;
+	PMemBlock block;
+	int retval = 0;
+
+	if (dev_priv == NULL || dev_priv->AGPHeap == NULL)
+		return -EINVAL;
+
+	block = mmAllocMem(dev_priv->AGPHeap, agp->size, 0, 0);
+	if (block) {
+		/* TODO */
+		agp->offset = block->ofs;
+		agp->free = (unsigned long)block;
+		if (!add_alloc_set(agp->context, AGP_TYPE, agp->free)) {
+			DRM_DEBUG("adding to allocation set fails\n");
+			mmFreeMem((PMemBlock) agp->free);
+			retval = -1;
+		}
+	} else {
+		agp->offset = 0;
+		agp->size = 0;
+		agp->free = 0;
+	}
+
+	DRM_DEBUG("alloc agp, size = %d, offset = %d\n", agp->size,
+	    agp->offset);
+
+	return retval;
+}
+
+static int sis_ioctl_agp_free(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_sis_private_t *dev_priv = dev->dev_private;
+	drm_sis_mem_t *agp = data;
+
+	if (dev_priv == NULL || dev_priv->AGPHeap == NULL)
+		return -EINVAL;
+
+	if (!mmBlockInHeap(dev_priv->AGPHeap, (PMemBlock) agp->free))
+		return -EINVAL;
+
+	mmFreeMem((PMemBlock) agp->free);
+	if (!del_alloc_set(agp->context, AGP_TYPE, agp->free))
+		return -EINVAL;
+
+	DRM_DEBUG("free agp, free = 0x%lx\n", agp->free);
+
+	return 0;
+}
+
+int sis_init_context(struct drm_device *dev, int context)
+{
+	int i;
+
+	for (i = 0; i < MAX_CONTEXT; i++) {
+		if (global_ppriv[i].used &&
+		    (global_ppriv[i].context == context))
+			break;
+	}
+
+	if (i >= MAX_CONTEXT) {
+		for (i = 0; i < MAX_CONTEXT; i++) {
+			if (!global_ppriv[i].used) {
+				global_ppriv[i].context = context;
+				global_ppriv[i].used = 1;
+				global_ppriv[i].sets[0] = setInit();
+				global_ppriv[i].sets[1] = setInit();
+				DRM_DEBUG("init allocation set, socket=%d, "
+					  "context = %d\n", i, context);
+				break;
+			}
+		}
+		if ((i >= MAX_CONTEXT) || (global_ppriv[i].sets[0] == NULL) ||
+		    (global_ppriv[i].sets[1] == NULL)) {
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+int sis_final_context(struct drm_device *dev, int context)
+{
+	int i;
+
+	for (i = 0; i < MAX_CONTEXT; i++) {
+		if (global_ppriv[i].used &&
+		    (global_ppriv[i].context == context))
+			break;
+	}
+
+	if (i < MAX_CONTEXT) {
+		set_t *set;
+		ITEM_TYPE item;
+		int retval;
+
+		DRM_DEBUG("find socket %d, context = %d\n", i, context);
+
+		/* Video Memory */
+		set = global_ppriv[i].sets[0];
+		retval = setFirst(set, &item);
+		while (retval) {
+			DRM_DEBUG("free video memory 0x%lx\n", item);
+#if defined(__linux__) && defined(CONFIG_FB_SIS)
+			sis_free(item);
+#else
+			mmFreeMem((PMemBlock) item);
+#endif
+			retval = setNext(set, &item);
+		}
+		setDestroy(set);
+
+		/* AGP Memory */
+		set = global_ppriv[i].sets[1];
+		retval = setFirst(set, &item);
+		while (retval) {
+			DRM_DEBUG("free agp memory 0x%lx\n", item);
+			mmFreeMem((PMemBlock) item);
+			retval = setNext(set, &item);
+		}
+		setDestroy(set);
+
+		global_ppriv[i].used = 0;
+	}
+
+	return 1;
+}
+
+drm_ioctl_desc_t sis_ioctls[] = {
+	DRM_IOCTL_DEF(DRM_SIS_FB_ALLOC, sis_fb_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_SIS_FB_FREE, sis_fb_free, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_SIS_AGP_INIT, sis_ioctl_agp_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_SIS_AGP_ALLOC, sis_ioctl_agp_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_SIS_AGP_FREE, sis_ioctl_agp_free, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_SIS_FB_INIT, sis_fb_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY)
+};
+
+int sis_max_ioctl = DRM_ARRAY_SIZE(sis_ioctls);
Index: git/shared-core/tdfx_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/tdfx_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,47 @@
+/* tdfx.h -- 3dfx DRM template customization -*- linux-c -*-
+ * Created: Wed Feb 14 12:32:32 2001 by gareth@valinux.com
+ */
+/*
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ */
+
+#ifndef __TDFX_H__
+#define __TDFX_H__
+
+/* General customization:
+ */
+
+#define DRIVER_AUTHOR		"VA Linux Systems Inc."
+
+#define DRIVER_NAME		"tdfx"
+#define DRIVER_DESC		"3dfx Banshee/Voodoo3+"
+#define DRIVER_DATE		"20010216"
+
+#define DRIVER_MAJOR		1
+#define DRIVER_MINOR		0
+#define DRIVER_PATCHLEVEL	0
+
+#endif
Index: git/shared-core/via_dma.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_dma.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,719 @@
+/* via_dma.c -- DMA support for the VIA Unichrome/Pro
+ * 
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ * Copyright 2004 Digeo, Inc., Palo Alto, CA, U.S.A.
+ * All Rights Reserved.
+ * 
+ * Copyright 2004 The Unichrome project.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, 
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: 
+ *    Tungsten Graphics, 
+ *    Erdi Chen, 
+ *    Thomas Hellstrom.
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "via_drm.h"
+#include "via_drv.h"
+#include "via_3d_reg.h"
+
+#define SetReg2DAGP(nReg, nData) {				\
+	*((uint32_t *)(vb)) = ((nReg) >> 2) | HALCYON_HEADER1;	\
+	*((uint32_t *)(vb) + 1) = (nData);			\
+	vb = ((uint32_t *)vb) + 2;				\
+	dev_priv->dma_low +=8;					\
+}
+
+#define via_flush_write_combine() DRM_MEMORYBARRIER() 
+
+#define VIA_OUT_RING_QW(w1,w2)			\
+	*vb++ = (w1);				\
+	*vb++ = (w2);				\
+	dev_priv->dma_low += 8; 
+
+static void via_cmdbuf_start(drm_via_private_t * dev_priv);
+static void via_cmdbuf_pause(drm_via_private_t * dev_priv);
+static void via_cmdbuf_reset(drm_via_private_t * dev_priv);
+static void via_cmdbuf_rewind(drm_via_private_t * dev_priv);
+static int via_wait_idle(drm_via_private_t * dev_priv);
+static void via_pad_cache(drm_via_private_t *dev_priv, int qwords);
+
+
+/*
+ * Free space in command buffer.
+ */
+
+static uint32_t via_cmdbuf_space(drm_via_private_t *dev_priv)
+{
+	uint32_t agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;
+	uint32_t hw_addr = *(dev_priv->hw_addr_ptr) - agp_base;
+	
+	return ((hw_addr <= dev_priv->dma_low) ? 
+		(dev_priv->dma_high + hw_addr - dev_priv->dma_low) : 
+		(hw_addr - dev_priv->dma_low));
+}
+
+/*
+ * How much does the command regulator lag behind?
+ */
+
+static uint32_t via_cmdbuf_lag(drm_via_private_t *dev_priv)
+{
+	uint32_t agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;
+	uint32_t hw_addr = *(dev_priv->hw_addr_ptr) - agp_base;
+
+	return ((hw_addr <= dev_priv->dma_low) ?
+		(dev_priv->dma_low - hw_addr) :
+		(dev_priv->dma_wrap + dev_priv->dma_low - hw_addr));
+}
+
+/*
+ * Check that the given size fits in the buffer, otherwise wait.
+ */
+
+static inline int
+via_cmdbuf_wait(drm_via_private_t * dev_priv, unsigned int size)
+{
+	uint32_t agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;
+	uint32_t cur_addr, hw_addr, next_addr;
+	volatile uint32_t *hw_addr_ptr;
+	uint32_t count;
+	hw_addr_ptr = dev_priv->hw_addr_ptr;
+	cur_addr = dev_priv->dma_low;
+	next_addr = cur_addr + size + 512 * 1024;
+	count = 1000000;
+	do {
+		hw_addr = *hw_addr_ptr - agp_base;
+		if (count-- == 0) {
+			DRM_ERROR
+			    ("via_cmdbuf_wait timed out hw %x cur_addr %x next_addr %x\n",
+			    hw_addr, cur_addr, next_addr);
+			return -1;
+		}
+	} while ((cur_addr < hw_addr) && (next_addr >= hw_addr));
+	return 0;
+}
+
+
+/*
+ * Checks whether buffer head has reach the end. Rewind the ring buffer
+ * when necessary.
+ *
+ * Returns virtual pointer to ring buffer.
+ */
+
+static inline uint32_t *via_check_dma(drm_via_private_t * dev_priv,
+				      unsigned int size)
+{
+	if ((dev_priv->dma_low + size + 4 * CMDBUF_ALIGNMENT_SIZE) >
+	    dev_priv->dma_high) {
+		via_cmdbuf_rewind(dev_priv);
+	}
+	if (via_cmdbuf_wait(dev_priv, size) != 0) {
+		return NULL;
+	}
+
+	return (uint32_t *) (dev_priv->dma_ptr + dev_priv->dma_low);
+}
+
+int via_dma_cleanup(struct drm_device * dev)
+{
+	if (dev->dev_private) {
+		drm_via_private_t *dev_priv =
+			(drm_via_private_t *) dev->dev_private;
+
+		if (dev_priv->ring.virtual_start) {
+			via_cmdbuf_reset(dev_priv);
+
+			drm_core_ioremapfree(&dev_priv->ring.map, dev);
+			dev_priv->ring.virtual_start = NULL;
+		}
+
+	}
+
+	return 0;
+}
+
+static int via_initialize(struct drm_device * dev,
+			  drm_via_private_t * dev_priv,
+			  drm_via_dma_init_t * init)
+{
+	if (!dev_priv || !dev_priv->mmio) {
+		DRM_ERROR("via_dma_init called before via_map_init\n");
+		return -EFAULT;
+	}
+
+	if (dev_priv->ring.virtual_start != NULL) {
+		DRM_ERROR("%s called again without calling cleanup\n",
+			  __FUNCTION__);
+		return -EFAULT;
+	}
+
+	if (!dev->agp || !dev->agp->base) {
+		DRM_ERROR("%s called with no agp memory available\n", 
+			  __FUNCTION__);
+		return -EFAULT;
+	}
+
+	if (dev_priv->chipset == VIA_DX9_0) {
+		DRM_ERROR("AGP DMA is not supported on this chip\n");
+		return -EINVAL;
+	}
+
+	dev_priv->ring.map.offset = dev->agp->base + init->offset;
+	dev_priv->ring.map.size = init->size;
+	dev_priv->ring.map.type = 0;
+	dev_priv->ring.map.flags = 0;
+	dev_priv->ring.map.mtrr = 0;
+
+	drm_core_ioremap(&dev_priv->ring.map, dev);
+
+	if (dev_priv->ring.map.handle == NULL) {
+		via_dma_cleanup(dev);
+		DRM_ERROR("can not ioremap virtual address for"
+			  " ring buffer\n");
+		return -ENOMEM;
+	}
+
+	dev_priv->ring.virtual_start = dev_priv->ring.map.handle;
+
+	dev_priv->dma_ptr = dev_priv->ring.virtual_start;
+	dev_priv->dma_low = 0;
+	dev_priv->dma_high = init->size;
+	dev_priv->dma_wrap = init->size;
+	dev_priv->dma_offset = init->offset;
+	dev_priv->last_pause_ptr = NULL;
+	dev_priv->hw_addr_ptr =
+		(volatile uint32_t *)((char *)dev_priv->mmio->handle +
+		init->reg_pause_addr);
+
+	via_cmdbuf_start(dev_priv);
+
+	return 0;
+}
+
+static int via_dma_init(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	drm_via_dma_init_t *init = data;
+	int retcode = 0;
+
+	switch (init->func) {
+	case VIA_INIT_DMA:
+		if (!DRM_SUSER(DRM_CURPROC))
+			retcode = -EPERM;
+		else
+			retcode = via_initialize(dev, dev_priv, init);
+		break;
+	case VIA_CLEANUP_DMA:
+		if (!DRM_SUSER(DRM_CURPROC))
+			retcode = -EPERM;
+		else
+			retcode = via_dma_cleanup(dev);
+		break;
+	case VIA_DMA_INITIALIZED:
+		retcode = (dev_priv->ring.virtual_start != NULL) ?
+			0 : -EFAULT;
+		break;
+	default:
+		retcode = -EINVAL;
+		break;
+	}
+
+	return retcode;
+}
+
+
+
+static int via_dispatch_cmdbuffer(struct drm_device * dev, drm_via_cmdbuffer_t * cmd)
+{
+	drm_via_private_t *dev_priv;
+	uint32_t *vb;
+	int ret;
+
+	dev_priv = (drm_via_private_t *) dev->dev_private;
+
+	if (dev_priv->ring.virtual_start == NULL) {
+		DRM_ERROR("%s called without initializing AGP ring buffer.\n",
+			  __FUNCTION__);
+		return -EFAULT;
+	}
+
+	if (cmd->size > VIA_PCI_BUF_SIZE) {
+		return -ENOMEM;
+	}
+
+	if (DRM_COPY_FROM_USER(dev_priv->pci_buf, cmd->buf, cmd->size))
+		return -EFAULT;
+
+	/*
+	 * Running this function on AGP memory is dead slow. Therefore
+	 * we run it on a temporary cacheable system memory buffer and
+	 * copy it to AGP memory when ready.
+	 */
+
+	if ((ret =
+	     via_verify_command_stream((uint32_t *)dev_priv->pci_buf,
+				       cmd->size, dev, 1))) {
+		return ret;
+	}
+
+	vb = via_check_dma(dev_priv, (cmd->size < 0x100) ? 0x102 : cmd->size);
+	if (vb == NULL) {
+		return -EAGAIN;
+	}
+
+	memcpy(vb, dev_priv->pci_buf, cmd->size);
+
+	dev_priv->dma_low += cmd->size;
+
+	/*
+	 * Small submissions somehow stalls the CPU. (AGP cache effects?)
+	 * pad to greater size.
+	 */
+
+	if (cmd->size < 0x100)
+		via_pad_cache(dev_priv, (0x100 - cmd->size) >> 3);
+	via_cmdbuf_pause(dev_priv);
+
+	return 0;
+}
+
+int via_driver_dma_quiescent(struct drm_device * dev)
+{
+	drm_via_private_t *dev_priv = dev->dev_private;
+
+	if (!via_wait_idle(dev_priv)) {
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int via_flush_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	return via_driver_dma_quiescent(dev);
+}
+
+static int via_cmdbuffer(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_via_cmdbuffer_t *cmdbuf = data;
+	int ret;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	DRM_DEBUG("via cmdbuffer, buf %p size %lu\n", cmdbuf->buf,
+		  cmdbuf->size);
+
+	ret = via_dispatch_cmdbuffer(dev, cmdbuf);
+	if (ret) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static int via_dispatch_pci_cmdbuffer(struct drm_device * dev,
+				      drm_via_cmdbuffer_t * cmd)
+{
+	drm_via_private_t *dev_priv = dev->dev_private;
+	int ret;
+
+	if (cmd->size > VIA_PCI_BUF_SIZE) {
+		return -ENOMEM;
+	}
+	if (DRM_COPY_FROM_USER(dev_priv->pci_buf, cmd->buf, cmd->size))
+		return -EFAULT;
+
+	if ((ret =
+	     via_verify_command_stream((uint32_t *) dev_priv->pci_buf,
+				       cmd->size, dev, 0))) {
+		return ret;
+	}
+
+	ret =
+	    via_parse_command_stream(dev, (const uint32_t *)dev_priv->pci_buf,
+				     cmd->size);
+	return ret;
+}
+
+static int via_pci_cmdbuffer(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_via_cmdbuffer_t *cmdbuf = data;
+	int ret;
+
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	DRM_DEBUG("via_pci_cmdbuffer, buf %p size %lu\n", cmdbuf->buf,
+		  cmdbuf->size);
+
+	ret = via_dispatch_pci_cmdbuffer(dev, cmdbuf);
+	if (ret) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline uint32_t *via_align_buffer(drm_via_private_t * dev_priv,
+					 uint32_t * vb, int qw_count)
+{
+	for (; qw_count > 0; --qw_count) {
+		VIA_OUT_RING_QW(HC_DUMMY, HC_DUMMY);
+	}
+	return vb;
+}
+
+/*
+ * This function is used internally by ring buffer mangement code.
+ *
+ * Returns virtual pointer to ring buffer.
+ */
+static inline uint32_t *via_get_dma(drm_via_private_t * dev_priv)
+{
+	return (uint32_t *) (dev_priv->dma_ptr + dev_priv->dma_low);
+}
+
+/*
+ * Hooks a segment of data into the tail of the ring-buffer by
+ * modifying the pause address stored in the buffer itself. If
+ * the regulator has already paused, restart it.
+ */
+static int via_hook_segment(drm_via_private_t * dev_priv,
+			    uint32_t pause_addr_hi, uint32_t pause_addr_lo,
+			    int no_pci_fire)
+{
+	int paused, count;
+	volatile uint32_t *paused_at = dev_priv->last_pause_ptr;
+	uint32_t reader,ptr;
+
+	paused = 0;
+	via_flush_write_combine();
+	(void) *(volatile uint32_t *)(via_get_dma(dev_priv) -1);
+	*paused_at = pause_addr_lo;
+	via_flush_write_combine();
+	(void) *paused_at;
+	reader = *(dev_priv->hw_addr_ptr);
+	ptr = ((volatile char *)paused_at - dev_priv->dma_ptr) +
+		dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr + 4;
+	dev_priv->last_pause_ptr = via_get_dma(dev_priv) - 1;
+
+	if ((ptr - reader) <= dev_priv->dma_diff ) {
+		count = 10000000;
+		while (!(paused = (VIA_READ(0x41c) & 0x80000000)) && count--);
+	}
+
+	if (paused && !no_pci_fire) {
+		reader = *(dev_priv->hw_addr_ptr);
+		if ((ptr - reader) == dev_priv->dma_diff) {
+
+			/*
+			 * There is a concern that these writes may stall the PCI bus
+			 * if the GPU is not idle. However, idling the GPU first
+			 * doesn't make a difference.
+			 */
+
+			VIA_WRITE(VIA_REG_TRANSET, (HC_ParaType_PreCR << 16));
+			VIA_WRITE(VIA_REG_TRANSPACE, pause_addr_hi);
+			VIA_WRITE(VIA_REG_TRANSPACE, pause_addr_lo);
+			VIA_READ(VIA_REG_TRANSPACE);
+		}
+	}
+
+	return paused;
+}
+
+
+
+static int via_wait_idle(drm_via_private_t * dev_priv)
+{
+	int count = 10000000;
+
+	while (!(VIA_READ(VIA_REG_STATUS) & VIA_VR_QUEUE_BUSY) && count--);
+
+	while (count-- && (VIA_READ(VIA_REG_STATUS) &
+			   (VIA_CMD_RGTR_BUSY | VIA_2D_ENG_BUSY |
+			    VIA_3D_ENG_BUSY))) ;
+	return count;
+}
+
+static uint32_t *via_align_cmd(drm_via_private_t * dev_priv, uint32_t cmd_type,
+			       uint32_t addr, uint32_t *cmd_addr_hi,
+			       uint32_t *cmd_addr_lo, int skip_wait)
+{
+	uint32_t agp_base;
+	uint32_t cmd_addr, addr_lo, addr_hi;
+	uint32_t *vb;
+	uint32_t qw_pad_count;
+
+	if (!skip_wait)
+		via_cmdbuf_wait(dev_priv, 2*CMDBUF_ALIGNMENT_SIZE);
+
+	vb = via_get_dma(dev_priv);
+	VIA_OUT_RING_QW( HC_HEADER2 | ((VIA_REG_TRANSET >> 2) << 12) |
+			 (VIA_REG_TRANSPACE >> 2), HC_ParaType_PreCR << 16); 
+	agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;
+	qw_pad_count = (CMDBUF_ALIGNMENT_SIZE >> 3) -
+		((dev_priv->dma_low & CMDBUF_ALIGNMENT_MASK) >> 3);
+
+	cmd_addr = (addr) ? addr : 
+		agp_base + dev_priv->dma_low - 8 + (qw_pad_count << 3);
+	addr_lo = ((HC_SubA_HAGPBpL << 24) | (cmd_type & HC_HAGPBpID_MASK) |
+		   (cmd_addr & HC_HAGPBpL_MASK));
+	addr_hi = ((HC_SubA_HAGPBpH << 24) | (cmd_addr >> 24));
+
+	vb = via_align_buffer(dev_priv, vb, qw_pad_count - 1);
+	VIA_OUT_RING_QW(*cmd_addr_hi = addr_hi, *cmd_addr_lo = addr_lo);
+	return vb;
+}
+
+static void via_cmdbuf_start(drm_via_private_t * dev_priv)
+{
+	uint32_t pause_addr_lo, pause_addr_hi;
+	uint32_t start_addr, start_addr_lo;
+	uint32_t end_addr, end_addr_lo;
+	uint32_t command;
+	uint32_t agp_base;
+	uint32_t ptr;
+	uint32_t reader;
+	int count;
+
+	dev_priv->dma_low = 0;
+
+	agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;
+	start_addr = agp_base;
+	end_addr = agp_base + dev_priv->dma_high;
+
+	start_addr_lo = ((HC_SubA_HAGPBstL << 24) | (start_addr & 0xFFFFFF));
+	end_addr_lo = ((HC_SubA_HAGPBendL << 24) | (end_addr & 0xFFFFFF));
+	command = ((HC_SubA_HAGPCMNT << 24) | (start_addr >> 24) |
+		   ((end_addr & 0xff000000) >> 16));
+
+	dev_priv->last_pause_ptr = 
+		via_align_cmd(dev_priv, HC_HAGPBpID_PAUSE, 0, 
+			      &pause_addr_hi, & pause_addr_lo, 1) - 1;
+
+	via_flush_write_combine();
+	(void) *(volatile uint32_t *)dev_priv->last_pause_ptr;
+
+	VIA_WRITE(VIA_REG_TRANSET, (HC_ParaType_PreCR << 16));
+	VIA_WRITE(VIA_REG_TRANSPACE, command);
+	VIA_WRITE(VIA_REG_TRANSPACE, start_addr_lo);
+	VIA_WRITE(VIA_REG_TRANSPACE, end_addr_lo);
+
+	VIA_WRITE(VIA_REG_TRANSPACE, pause_addr_hi);
+	VIA_WRITE(VIA_REG_TRANSPACE, pause_addr_lo);
+	DRM_WRITEMEMORYBARRIER();
+	VIA_WRITE(VIA_REG_TRANSPACE, command | HC_HAGPCMNT_MASK);
+	VIA_READ(VIA_REG_TRANSPACE);
+
+	dev_priv->dma_diff = 0;
+
+	count = 10000000;
+	while (!(VIA_READ(0x41c) & 0x80000000) && count--);
+
+	reader = *(dev_priv->hw_addr_ptr);
+	ptr = ((volatile char *)dev_priv->last_pause_ptr - dev_priv->dma_ptr) +
+	    dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr + 4;
+
+	/*
+	 * This is the difference between where we tell the
+	 * command reader to pause and where it actually pauses.
+	 * This differs between hw implementation so we need to
+	 * detect it.
+	 */
+
+	dev_priv->dma_diff = ptr - reader;
+}
+
+static void via_pad_cache(drm_via_private_t *dev_priv, int qwords)
+{
+	uint32_t *vb;
+
+	via_cmdbuf_wait(dev_priv, qwords + 2);
+	vb = via_get_dma(dev_priv);
+	VIA_OUT_RING_QW( HC_HEADER2, HC_ParaType_NotTex << 16);
+	via_align_buffer(dev_priv,vb,qwords);
+}
+
+static inline void via_dummy_bitblt(drm_via_private_t * dev_priv)
+{
+	uint32_t *vb = via_get_dma(dev_priv);
+	SetReg2DAGP(0x0C, (0 | (0 << 16)));
+	SetReg2DAGP(0x10, 0 | (0 << 16));
+	SetReg2DAGP(0x0, 0x1 | 0x2000 | 0xAA000000);
+}
+
+static void via_cmdbuf_jump(drm_via_private_t * dev_priv)
+{
+	uint32_t agp_base;
+	uint32_t pause_addr_lo, pause_addr_hi;
+	uint32_t jump_addr_lo, jump_addr_hi;
+	volatile uint32_t *last_pause_ptr;
+
+	agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;
+	via_align_cmd(dev_priv,  HC_HAGPBpID_JUMP, 0, &jump_addr_hi,
+		      &jump_addr_lo, 0);
+	
+	dev_priv->dma_wrap = dev_priv->dma_low;
+
+
+	/*
+	 * Wrap command buffer to the beginning.
+	 */
+
+	dev_priv->dma_low = 0;
+	if (via_cmdbuf_wait(dev_priv, CMDBUF_ALIGNMENT_SIZE) != 0) {
+		DRM_ERROR("via_cmdbuf_jump failed\n");
+	}
+
+	via_dummy_bitblt(dev_priv);
+	via_dummy_bitblt(dev_priv);
+	last_pause_ptr = via_align_cmd(dev_priv,  HC_HAGPBpID_PAUSE, 0, &pause_addr_hi,
+				       &pause_addr_lo, 0) -1;
+	via_align_cmd(dev_priv,  HC_HAGPBpID_PAUSE, 0, &pause_addr_hi,
+		      &pause_addr_lo, 0);
+	*last_pause_ptr = pause_addr_lo;
+
+	via_hook_segment( dev_priv, jump_addr_hi, jump_addr_lo, 0);
+}
+
+
+static void via_cmdbuf_rewind(drm_via_private_t * dev_priv)
+{
+	via_cmdbuf_jump(dev_priv); 
+}
+
+static void via_cmdbuf_flush(drm_via_private_t * dev_priv, uint32_t cmd_type)
+{
+	uint32_t pause_addr_lo, pause_addr_hi;
+
+	via_align_cmd(dev_priv, cmd_type, 0, &pause_addr_hi, &pause_addr_lo, 0);
+	via_hook_segment( dev_priv, pause_addr_hi, pause_addr_lo, 0);
+}
+
+
+static void via_cmdbuf_pause(drm_via_private_t * dev_priv)
+{
+	via_cmdbuf_flush(dev_priv, HC_HAGPBpID_PAUSE);
+}
+
+static void via_cmdbuf_reset(drm_via_private_t * dev_priv)
+{
+	via_cmdbuf_flush(dev_priv, HC_HAGPBpID_STOP);
+	via_wait_idle(dev_priv);
+}
+
+/*
+ * User interface to the space and lag functions.
+ */
+
+static int via_cmdbuf_size(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_via_cmdbuf_size_t *d_siz = data;
+	int ret = 0;
+	uint32_t tmp_size, count;
+	drm_via_private_t *dev_priv;
+
+	DRM_DEBUG("via cmdbuf_size\n");
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
+
+	dev_priv = (drm_via_private_t *) dev->dev_private;
+
+	if (dev_priv->ring.virtual_start == NULL) {
+		DRM_ERROR("%s called without initializing AGP ring buffer.\n",
+			  __FUNCTION__);
+		return -EFAULT;
+	}
+
+	count = 1000000;
+	tmp_size = d_siz->size;
+	switch(d_siz->func) {
+	case VIA_CMDBUF_SPACE:
+		while (((tmp_size = via_cmdbuf_space(dev_priv)) < d_siz->size)
+		       && count--) {
+			if (!d_siz->wait) {
+				break;
+			}
+		}
+		if (!count) {
+			DRM_ERROR("VIA_CMDBUF_SPACE timed out.\n");
+			ret = -EAGAIN;
+		}
+		break;
+	case VIA_CMDBUF_LAG:
+		while (((tmp_size = via_cmdbuf_lag(dev_priv)) > d_siz->size)
+		       && count--) {
+			if (!d_siz->wait) {
+				break;
+			}
+		}
+		if (!count) {
+			DRM_ERROR("VIA_CMDBUF_LAG timed out.\n");
+			ret = -EAGAIN;
+		}
+		break;
+	default:
+		ret = -EFAULT;
+	}
+	d_siz->size = tmp_size;
+
+	return ret;
+}
+
+#ifndef VIA_HAVE_DMABLIT
+int 
+via_dma_blit_sync( struct drm_device *dev, void *data, struct drm_file *file_priv ) {
+	DRM_ERROR("PCI DMA BitBlt is not implemented for this system.\n");
+	return -EINVAL;
+}
+int 
+via_dma_blit( struct drm_device *dev, void *data, struct drm_file *file_priv ) {
+	DRM_ERROR("PCI DMA BitBlt is not implemented for this system.\n");
+	return -EINVAL;
+}
+#endif
+
+struct drm_ioctl_desc via_ioctls[] = {
+	DRM_IOCTL_DEF(DRM_VIA_ALLOCMEM, via_mem_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_VIA_FREEMEM, via_mem_free, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_VIA_AGP_INIT, via_agp_init, DRM_AUTH|DRM_MASTER),
+	DRM_IOCTL_DEF(DRM_VIA_FB_INIT, via_fb_init, DRM_AUTH|DRM_MASTER),
+	DRM_IOCTL_DEF(DRM_VIA_MAP_INIT, via_map_init, DRM_AUTH|DRM_MASTER),
+	DRM_IOCTL_DEF(DRM_VIA_DEC_FUTEX, via_decoder_futex, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_VIA_DMA_INIT, via_dma_init, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_VIA_CMDBUFFER, via_cmdbuffer, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_VIA_FLUSH, via_flush_ioctl, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_VIA_PCICMD, via_pci_cmdbuffer, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_VIA_CMDBUF_SIZE, via_cmdbuf_size, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_VIA_WAIT_IRQ, via_wait_irq, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_VIA_DMA_BLIT, via_dma_blit, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_VIA_BLIT_SYNC, via_dma_blit_sync, DRM_AUTH)
+};
+
+int via_max_ioctl = DRM_ARRAY_SIZE(via_ioctls);
Index: git/shared-core/via_drm.h
===================================================================
--- git.orig/shared-core/via_drm.h	2008-12-12 17:20:14.000000000 +0000
+++ git/shared-core/via_drm.h	2008-12-12 17:35:22.000000000 +0000
@@ -42,37 +42,27 @@
  * backwards incompatibilities, (which should be avoided whenever possible).
  */
 
-#define VIA_DRM_DRIVER_DATE		"20060616"
+#define VIA_DRM_DRIVER_DATE		"20070202"
 
 #define VIA_DRM_DRIVER_MAJOR		2
-#define VIA_DRM_DRIVER_MINOR		10
-#define VIA_DRM_DRIVER_PATCHLEVEL	2
+#define VIA_DRM_DRIVER_MINOR		11
+#define VIA_DRM_DRIVER_PATCHLEVEL	1
 #define VIA_DRM_DRIVER_VERSION	  (((VIA_DRM_DRIVER_MAJOR) << 16) | (VIA_DRM_DRIVER_MINOR))
 
-#define VIA_NR_SAREA_CLIPRECTS 		8
+#define VIA_NR_SAREA_CLIPRECTS		8
 #define VIA_NR_XVMC_PORTS	       10
 #define VIA_NR_XVMC_LOCKS	       5
 #define VIA_MAX_CACHELINE_SIZE	  64
 #define XVMCLOCKPTR(saPriv,lockNo)					\
-	((volatile drm_hw_lock_t *)(((((unsigned long) (saPriv)->XvMCLockArea) + \
+	((volatile struct drm_hw_lock *)(((((unsigned long) (saPriv)->XvMCLockArea) + \
 				      (VIA_MAX_CACHELINE_SIZE - 1)) &	\
 				     ~(VIA_MAX_CACHELINE_SIZE - 1)) +	\
 				    VIA_MAX_CACHELINE_SIZE*(lockNo)))
-
-/* Each region is a minimum of 64k, and there are at most 64 of them.
- */
 #define VIA_NR_TEX_REGIONS 64
-#define VIA_LOG_MIN_TEX_REGION_SIZE 16
+
 #endif
 
-#define VIA_UPLOAD_TEX0IMAGE  0x1	/* handled clientside */
-#define VIA_UPLOAD_TEX1IMAGE  0x2	/* handled clientside */
-#define VIA_UPLOAD_CTX	0x4
-#define VIA_UPLOAD_BUFFERS    0x8
-#define VIA_UPLOAD_TEX0       0x10
-#define VIA_UPLOAD_TEX1       0x20
-#define VIA_UPLOAD_CLIPRECTS  0x40
-#define VIA_UPLOAD_ALL	0xff
+#define DRM_VIA_FENCE_TYPE_ACCEL 0x00000002
 
 /* VIA specific ioctls */
 #define DRM_VIA_ALLOCMEM	0x00
@@ -124,7 +114,7 @@
 
 #define VIA_MEM_VIDEO   0	/* matches drm constant */
 #define VIA_MEM_AGP     1	/* matches drm constant */
-#define VIA_MEM_SYSTEM  2		
+#define VIA_MEM_SYSTEM  2
 #define VIA_MEM_MIXED   3
 #define VIA_MEM_UNKNOWN 4
 
@@ -197,7 +187,7 @@
 typedef struct _drm_via_sarea {
 	unsigned int dirty;
 	unsigned int nbox;
-	drm_clip_rect_t boxes[VIA_NR_SAREA_CLIPRECTS];
+	struct drm_clip_rect boxes[VIA_NR_SAREA_CLIPRECTS];
 	drm_via_tex_region_t texList[VIA_NR_TEX_REGIONS + 1];
 	int texAge;		/* last time texture was uploaded */
 	int ctxOwner;		/* last context to upload state */
@@ -213,7 +203,7 @@
 
 	unsigned int XvMCDisplaying[VIA_NR_XVMC_PORTS];
 	unsigned int XvMCSubPicOn[VIA_NR_XVMC_PORTS];
-	unsigned int XvMCCtxNoGrabbed;	/* Last context to hold decoder */	
+	unsigned int XvMCCtxNoGrabbed;	/* Last context to hold decoder */
 
 	/* Used by the 3d driver only at this point, for pageflipping:
 	 */
@@ -260,14 +250,14 @@
 	struct drm_wait_vblank_reply reply;
 } drm_via_irqwait_t;
 
-typedef struct drm_via_blitsync { 
+typedef struct drm_via_blitsync {
 	uint32_t sync_handle;
 	unsigned engine;
 } drm_via_blitsync_t;
 
-/* 
+/*
  * Below,"flags" is currently unused but will be used for possible future
- * extensions like kernel space bounce buffers for bad alignments and 
+ * extensions like kernel space bounce buffers for bad alignments and
  * blit engine busy-wait polling for better latency in the absence of
  * interrupts.
  */
@@ -281,11 +271,11 @@
 
 	unsigned char *mem_addr;
 	uint32_t  mem_stride;
-       
+
 	uint32_t  flags;
 	int to_fb;
 
-	drm_via_blitsync_t sync;   
+	drm_via_blitsync_t sync;
 } drm_via_dmablit_t;
 
 
Index: git/shared-core/via_drv.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_drv.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,161 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "drmP.h"
+#include "via_drm.h"
+#include "via_drv.h"
+
+#include "drm_pciids.h"
+
+
+static int dri_library_name(struct drm_device * dev, char * buf)
+{
+	return snprintf(buf, PAGE_SIZE, "unichrome\n");
+}
+
+static struct pci_device_id pciidlist[] = {
+	viadrv_PCI_IDS
+};
+
+
+#ifdef VIA_HAVE_FENCE
+static struct drm_fence_driver via_fence_driver = {
+	.num_classes = 1,
+	.wrap_diff = (1 << 30),
+	.flush_diff = (1 << 20),
+	.sequence_mask = 0xffffffffU,
+	.lazy_capable = 1,
+	.emit = via_fence_emit_sequence,
+	.poke_flush = via_poke_flush,
+	.has_irq = via_fence_has_irq,
+};
+#endif
+#ifdef VIA_HAVE_BUFFER
+
+/**
+ * If there's no thrashing. This is the preferred memory type order.
+ */
+static uint32_t via_mem_prios[] = {DRM_BO_MEM_PRIV0, DRM_BO_MEM_VRAM, DRM_BO_MEM_TT, DRM_BO_MEM_LOCAL};
+
+/**
+ * If we have thrashing, most memory will be evicted to TT anyway, so we might as well
+ * just move the new buffer into TT from the start.
+ */
+static uint32_t via_busy_prios[] = {DRM_BO_MEM_TT, DRM_BO_MEM_PRIV0, DRM_BO_MEM_VRAM, DRM_BO_MEM_LOCAL};
+
+
+static struct drm_bo_driver via_bo_driver = {
+	.mem_type_prio = via_mem_prios,
+	.mem_busy_prio = via_busy_prios,
+	.num_mem_type_prio = ARRAY_SIZE(via_mem_prios),
+	.num_mem_busy_prio = ARRAY_SIZE(via_busy_prios),
+	.create_ttm_backend_entry = via_create_ttm_backend_entry,
+	.fence_type = via_fence_types,
+	.invalidate_caches = via_invalidate_caches,
+	.init_mem_type = via_init_mem_type,
+	.evict_mask = via_evict_mask,
+	.move = NULL,
+};
+#endif
+
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent);
+static struct drm_driver driver = {
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_USE_MTRR | DRIVER_HAVE_IRQ |
+	    DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL,
+	.load = via_driver_load,
+	.unload = via_driver_unload,
+#ifndef VIA_HAVE_CORE_MM
+	.context_ctor = via_init_context,
+#endif
+	.context_dtor = via_final_context,
+	.vblank_wait = via_driver_vblank_wait,
+	.irq_preinstall = via_driver_irq_preinstall,
+	.irq_postinstall = via_driver_irq_postinstall,
+	.irq_uninstall = via_driver_irq_uninstall,
+	.irq_handler = via_driver_irq_handler,
+	.dma_quiescent = via_driver_dma_quiescent,
+	.dri_library_name = dri_library_name,
+	.reclaim_buffers = drm_core_reclaim_buffers,
+	.reclaim_buffers_locked = NULL,
+#ifdef VIA_HAVE_CORE_MM
+	.reclaim_buffers_idlelocked = via_reclaim_buffers_locked,
+	.lastclose = via_lastclose,
+#endif
+	.get_map_ofs = drm_core_get_map_ofs,
+	.get_reg_ofs = drm_core_get_reg_ofs,
+	.ioctls = via_ioctls,
+	.fops = {
+		.owner = THIS_MODULE,
+		.open = drm_open,
+		.release = drm_release,
+		.ioctl = drm_ioctl,
+		.mmap = drm_mmap,
+		.poll = drm_poll,
+		.fasync = drm_fasync,
+		},
+	.pci_driver = {
+		.name = DRIVER_NAME,
+		.id_table = pciidlist,
+		.probe = probe,
+		.remove = __devexit_p(drm_cleanup_pci),
+	},
+#ifdef VIA_HAVE_FENCE
+	.fence_driver = &via_fence_driver,
+#endif
+#ifdef VIA_HAVE_BUFFER
+	.bo_driver = &via_bo_driver,
+#endif
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+	.date = VIA_DRM_DRIVER_DATE,
+	.major = VIA_DRM_DRIVER_MAJOR,
+	.minor = VIA_DRM_DRIVER_MINOR,
+	.patchlevel = VIA_DRM_DRIVER_PATCHLEVEL
+};
+
+static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
+static int __init via_init(void)
+{
+	driver.num_ioctls = via_max_ioctl;
+
+	via_init_command_verifier();
+	return drm_init(&driver, pciidlist);
+}
+
+static void __exit via_exit(void)
+{
+	drm_exit(&driver);
+}
+
+module_init(via_init);
+module_exit(via_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL and additional rights");
Index: git/shared-core/via_drv.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_drv.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,219 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _VIA_DRV_H_
+#define _VIA_DRV_H_
+
+#include "drm_sman.h"
+#define DRIVER_AUTHOR	"Various"
+
+#define DRIVER_NAME		"via"
+#define DRIVER_DESC		"VIA Unichrome / Pro"
+
+#include "via_verifier.h"
+
+/*
+ * Registers go here.
+ */
+
+
+#define CMDBUF_ALIGNMENT_SIZE   (0x100)
+#define CMDBUF_ALIGNMENT_MASK   (0x0ff)
+
+/* defines for VIA 3D registers */
+#define VIA_REG_STATUS	        0x400
+#define VIA_REG_TRANSET	        0x43C
+#define VIA_REG_TRANSPACE       0x440
+
+/* VIA_REG_STATUS(0x400): Engine Status */
+#define VIA_CMD_RGTR_BUSY       0x00000080	/* Command Regulator is busy */
+#define VIA_2D_ENG_BUSY	        0x00000001	/* 2D Engine is busy */
+#define VIA_3D_ENG_BUSY	        0x00000002	/* 3D Engine is busy */
+#define VIA_VR_QUEUE_BUSY       0x00020000	/* Virtual Queue is busy */
+
+
+
+#if defined(__linux__)
+#include "via_dmablit.h"
+
+/*
+ * This define and all its references can be removed when
+ * the DMA blit code has been implemented for FreeBSD.
+ */
+#define VIA_HAVE_DMABLIT 1
+#define VIA_HAVE_CORE_MM 1
+#define VIA_HAVE_FENCE   1
+#define VIA_HAVE_BUFFER  1
+#endif
+
+#define VIA_PCI_BUF_SIZE 60000
+#define VIA_FIRE_BUF_SIZE  1024
+#define VIA_NUM_IRQS 4
+
+typedef struct drm_via_ring_buffer {
+	drm_local_map_t map;
+	char *virtual_start;
+} drm_via_ring_buffer_t;
+
+typedef uint32_t maskarray_t[5];
+
+typedef struct drm_via_irq {
+	atomic_t irq_received;
+	uint32_t pending_mask;
+	uint32_t enable_mask;
+	wait_queue_head_t irq_queue;
+} drm_via_irq_t;
+	
+typedef struct drm_via_private {
+	drm_via_sarea_t *sarea_priv;
+	drm_local_map_t *sarea;
+	drm_local_map_t *fb;
+	drm_local_map_t *mmio;
+	unsigned long agpAddr;
+	wait_queue_head_t decoder_queue[VIA_NR_XVMC_LOCKS];
+	char *dma_ptr;
+	unsigned int dma_low;
+	unsigned int dma_high;
+	unsigned int dma_offset;
+	uint32_t dma_wrap;
+	volatile uint32_t *last_pause_ptr;
+	volatile uint32_t *hw_addr_ptr;
+	drm_via_ring_buffer_t ring;
+	struct timeval last_vblank;
+	int last_vblank_valid;
+	unsigned usec_per_vblank;
+	drm_via_state_t hc_state;
+	char pci_buf[VIA_PCI_BUF_SIZE];
+	const uint32_t *fire_offsets[VIA_FIRE_BUF_SIZE];
+	uint32_t num_fire_offsets;
+	int chipset;
+	drm_via_irq_t via_irqs[VIA_NUM_IRQS];
+	unsigned num_irqs;
+	maskarray_t *irq_masks;
+	uint32_t irq_enable_mask; 
+	uint32_t irq_pending_mask;	
+	int *irq_map;
+	/* Memory manager stuff */
+#ifdef VIA_HAVE_CORE_MM
+	unsigned int idle_fault;
+	struct drm_sman sman;
+	int vram_initialized;
+	int agp_initialized;
+	unsigned long vram_offset;
+	unsigned long agp_offset;
+#endif
+#ifdef VIA_HAVE_DMABLIT
+	drm_via_blitq_t blit_queues[VIA_NUM_BLIT_ENGINES];
+#endif
+        uint32_t dma_diff;
+#ifdef VIA_HAVE_FENCE
+	spinlock_t fence_lock;
+	uint32_t emit_0_sequence;
+	int have_idlelock;
+	struct timer_list fence_timer;
+#endif
+} drm_via_private_t;
+
+enum via_family {
+  VIA_OTHER = 0,     /* Baseline */
+  VIA_PRO_GROUP_A,   /* Another video engine and DMA commands */
+  VIA_DX9_0          /* Same video as pro_group_a, but 3D is unsupported */
+};
+
+/* VIA MMIO register access */
+#define VIA_BASE ((dev_priv->mmio))
+
+#define VIA_READ(reg)		DRM_READ32(VIA_BASE, reg)
+#define VIA_WRITE(reg,val)	DRM_WRITE32(VIA_BASE, reg, val)
+#define VIA_READ8(reg)		DRM_READ8(VIA_BASE, reg)
+#define VIA_WRITE8(reg,val)	DRM_WRITE8(VIA_BASE, reg, val)
+
+extern struct drm_ioctl_desc via_ioctls[];
+extern int via_max_ioctl;
+
+extern int via_fb_init(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int via_mem_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int via_mem_free(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int via_agp_init(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int via_map_init(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int via_decoder_futex(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int via_wait_irq(struct drm_device *dev, void *data, struct drm_file *file_priv);
+extern int via_dma_blit_sync( struct drm_device *dev, void *data, struct drm_file *file_priv );
+extern int via_dma_blit( struct drm_device *dev, void *data, struct drm_file *file_priv );
+
+extern int via_driver_load(struct drm_device *dev, unsigned long chipset);
+extern int via_driver_unload(struct drm_device *dev);
+extern int via_final_context(struct drm_device * dev, int context);
+
+extern int via_do_cleanup_map(struct drm_device * dev);
+extern int via_driver_vblank_wait(struct drm_device * dev, unsigned int *sequence);
+
+extern irqreturn_t via_driver_irq_handler(DRM_IRQ_ARGS);
+extern void via_driver_irq_preinstall(struct drm_device * dev);
+extern void via_driver_irq_postinstall(struct drm_device * dev);
+extern void via_driver_irq_uninstall(struct drm_device * dev);
+
+extern int via_dma_cleanup(struct drm_device * dev);
+extern void via_init_command_verifier(void);
+extern int via_driver_dma_quiescent(struct drm_device * dev);
+extern void via_init_futex(drm_via_private_t *dev_priv);
+extern void via_cleanup_futex(drm_via_private_t *dev_priv);
+extern void via_release_futex(drm_via_private_t *dev_priv, int context);
+
+#ifdef VIA_HAVE_CORE_MM
+extern void via_reclaim_buffers_locked(struct drm_device *dev,
+				       struct drm_file *file_priv);
+extern void via_lastclose(struct drm_device *dev);
+#else
+extern int via_init_context(struct drm_device * dev, int context);
+#endif
+
+#ifdef VIA_HAVE_DMABLIT
+extern void via_dmablit_handler(struct drm_device *dev, int engine, int from_irq);
+extern void via_init_dmablit(struct drm_device *dev);
+#endif
+
+#ifdef VIA_HAVE_FENCE
+extern void via_fence_timer(unsigned long data);
+extern void via_poke_flush(struct drm_device * dev, uint32_t class);
+extern int via_fence_emit_sequence(struct drm_device * dev, uint32_t class,
+				   uint32_t flags,
+				   uint32_t * sequence,
+				   uint32_t * native_type);
+extern int via_fence_has_irq(struct drm_device * dev, uint32_t class,
+			     uint32_t flags);
+#endif
+
+#ifdef VIA_HAVE_BUFFER
+extern struct drm_ttm_backend *via_create_ttm_backend_entry(struct drm_device *dev);
+extern int via_fence_types(struct drm_buffer_object *bo, uint32_t *fclass, 
+			   uint32_t *type);
+extern int via_invalidate_caches(struct drm_device *dev, uint64_t buffer_flags);
+extern int via_init_mem_type(struct drm_device *dev, uint32_t type,
+			       struct drm_mem_type_manager *man);
+extern uint32_t via_evict_mask(struct drm_buffer_object *bo);
+extern int via_move(struct drm_buffer_object *bo, int evict,
+	      	int no_wait, struct drm_bo_mem_reg *new_mem);
+#endif
+
+#endif
Index: git/shared-core/via_ds.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_ds.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,274 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ * Copyright 2000 Silicon Integrated Systems Corp, Inc., HsinChu, Taiwan.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "drmP.h"
+
+#include "via_ds.h"
+extern unsigned int VIA_DEBUG;
+
+set_t *via_setInit(void)
+{
+	int i;
+	set_t *set;
+	set = (set_t *) drm_alloc(sizeof(set_t), DRM_MEM_DRIVER);
+	for (i = 0; i < SET_SIZE; i++) {
+		set->list[i].free_next = i + 1;
+		set->list[i].alloc_next = -1;
+	}
+	set->list[SET_SIZE - 1].free_next = -1;
+	set->free = 0;
+	set->alloc = -1;
+	set->trace = -1;
+	return set;
+}
+
+int via_setAdd(set_t * set, ITEM_TYPE item)
+{
+	int free = set->free;
+	if (free != -1) {
+		set->list[free].val = item;
+		set->free = set->list[free].free_next;
+	} else {
+		return 0;
+	}
+	set->list[free].alloc_next = set->alloc;
+	set->alloc = free;
+	set->list[free].free_next = -1;
+	return 1;
+}
+
+int via_setDel(set_t * set, ITEM_TYPE item)
+{
+	int alloc = set->alloc;
+	int prev = -1;
+
+	while (alloc != -1) {
+		if (set->list[alloc].val == item) {
+			if (prev != -1)
+				set->list[prev].alloc_next =
+				    set->list[alloc].alloc_next;
+			else
+				set->alloc = set->list[alloc].alloc_next;
+			break;
+		}
+		prev = alloc;
+		alloc = set->list[alloc].alloc_next;
+	}
+
+	if (alloc == -1)
+		return 0;
+
+	set->list[alloc].free_next = set->free;
+	set->free = alloc;
+	set->list[alloc].alloc_next = -1;
+
+	return 1;
+}
+
+/* setFirst -> setAdd -> setNext is wrong */
+
+int via_setFirst(set_t * set, ITEM_TYPE * item)
+{
+	if (set->alloc == -1)
+		return 0;
+
+	*item = set->list[set->alloc].val;
+	set->trace = set->list[set->alloc].alloc_next;
+
+	return 1;
+}
+
+int via_setNext(set_t * set, ITEM_TYPE * item)
+{
+	if (set->trace == -1)
+		return 0;
+
+	*item = set->list[set->trace].val;
+	set->trace = set->list[set->trace].alloc_next;
+
+	return 1;
+}
+
+int via_setDestroy(set_t * set)
+{
+	drm_free(set, sizeof(set_t), DRM_MEM_DRIVER);
+
+	return 1;
+}
+
+#define ISFREE(bptr) ((bptr)->free)
+
+#define fprintf(fmt, arg...) do{}while(0)
+
+memHeap_t *via_mmInit(int ofs, int size)
+{
+	PMemBlock blocks;
+
+	if (size <= 0)
+		return NULL;
+
+	blocks = (TMemBlock *) drm_calloc(1, sizeof(TMemBlock), DRM_MEM_DRIVER);
+
+	if (blocks) {
+		blocks->ofs = ofs;
+		blocks->size = size;
+		blocks->free = 1;
+		return (memHeap_t *) blocks;
+	} else
+		return NULL;
+}
+
+static TMemBlock *SliceBlock(TMemBlock * p,
+			     int startofs, int size,
+			     int reserved, int alignment)
+{
+	TMemBlock *newblock;
+
+	/* break left */
+	if (startofs > p->ofs) {
+		newblock =
+		    (TMemBlock *) drm_calloc(1, sizeof(TMemBlock),
+					     DRM_MEM_DRIVER);
+		newblock->ofs = startofs;
+		newblock->size = p->size - (startofs - p->ofs);
+		newblock->free = 1;
+		newblock->next = p->next;
+		p->size -= newblock->size;
+		p->next = newblock;
+		p = newblock;
+	}
+
+	/* break right */
+	if (size < p->size) {
+		newblock =
+		    (TMemBlock *) drm_calloc(1, sizeof(TMemBlock),
+					     DRM_MEM_DRIVER);
+		newblock->ofs = startofs + size;
+		newblock->size = p->size - size;
+		newblock->free = 1;
+		newblock->next = p->next;
+		p->size = size;
+		p->next = newblock;
+	}
+
+	/* p = middle block */
+	p->align = alignment;
+	p->free = 0;
+	p->reserved = reserved;
+	return p;
+}
+
+PMemBlock via_mmAllocMem(memHeap_t * heap, int size, int align2,
+			 int startSearch)
+{
+	int mask, startofs, endofs;
+	TMemBlock *p;
+
+	if (!heap || align2 < 0 || size <= 0)
+		return NULL;
+
+	mask = (1 << align2) - 1;
+	startofs = 0;
+	p = (TMemBlock *) heap;
+
+	while (p) {
+		if (ISFREE(p)) {
+			startofs = (p->ofs + mask) & ~mask;
+
+			if (startofs < startSearch)
+				startofs = startSearch;
+
+			endofs = startofs + size;
+
+			if (endofs <= (p->ofs + p->size))
+				break;
+		}
+
+		p = p->next;
+	}
+
+	if (!p)
+		return NULL;
+
+	p = SliceBlock(p, startofs, size, 0, mask + 1);
+	p->heap = heap;
+
+	return p;
+}
+
+static __inline__ int Join2Blocks(TMemBlock * p)
+{
+	if (p->free && p->next && p->next->free) {
+		TMemBlock *q = p->next;
+		p->size += q->size;
+		p->next = q->next;
+		drm_free(q, sizeof(TMemBlock), DRM_MEM_DRIVER);
+
+		return 1;
+	}
+
+	return 0;
+}
+
+int via_mmFreeMem(PMemBlock b)
+{
+	TMemBlock *p, *prev;
+
+	if (!b)
+		return 0;
+
+	if (!b->heap) {
+		fprintf(stderr, "no heap\n");
+
+		return -1;
+	}
+
+	p = b->heap;
+	prev = NULL;
+
+	while (p && p != b) {
+		prev = p;
+		p = p->next;
+	}
+
+	if (!p || p->free || p->reserved) {
+		if (!p)
+			fprintf(stderr, "block not found in heap\n");
+		else if (p->free)
+			fprintf(stderr, "block already free\n");
+		else
+			fprintf(stderr, "block is reserved\n");
+
+		return -1;
+	}
+
+	p->free = 1;
+	Join2Blocks(p);
+
+	if (prev)
+		Join2Blocks(prev);
+
+	return 0;
+}
Index: git/shared-core/via_ds.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_ds.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,104 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ * Copyright 2000 Silicon Integrated Systems Corp, Inc., HsinChu, Taiwan.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _via_ds_h_
+#define _via_ds_h_
+
+#include "drmP.h"
+
+/* Set Data Structure */
+#define SET_SIZE 5000
+typedef unsigned long ITEM_TYPE;
+
+typedef struct {
+	ITEM_TYPE val;
+	int alloc_next, free_next;
+} list_item_t;
+
+typedef struct {
+	int alloc;
+	int free;
+	int trace;
+	list_item_t list[SET_SIZE];
+} set_t;
+
+set_t *via_setInit(void);
+int via_setAdd(set_t * set, ITEM_TYPE item);
+int via_setDel(set_t * set, ITEM_TYPE item);
+int via_setFirst(set_t * set, ITEM_TYPE * item);
+int via_setNext(set_t * set, ITEM_TYPE * item);
+int via_setDestroy(set_t * set);
+
+#endif
+
+#ifndef MM_INC
+#define MM_INC
+
+struct mem_block_t {
+	struct mem_block_t *next;
+	struct mem_block_t *heap;
+	int ofs, size;
+	int align;
+	unsigned int free:1;
+	unsigned int reserved:1;
+};
+typedef struct mem_block_t TMemBlock;
+typedef struct mem_block_t *PMemBlock;
+
+/* a heap is just the first block in a chain */
+typedef struct mem_block_t memHeap_t;
+
+static __inline__ int mmBlockSize(PMemBlock b)
+{
+	return b->size;
+}
+
+static __inline__ int mmOffset(PMemBlock b)
+{
+	return b->ofs;
+}
+
+static __inline__ void mmMarkReserved(PMemBlock b)
+{
+	b->reserved = 1;
+}
+
+/*
+ * input: total size in bytes
+ * return: a heap pointer if OK, NULL if error
+ */
+memHeap_t *via_mmInit(int ofs, int size);
+
+PMemBlock via_mmAllocMem(memHeap_t * heap, int size, int align2,
+			 int startSearch);
+
+/*
+ * Free block starts at offset
+ * input: pointer to a block
+ * return: 0 if OK, -1 if error
+ */
+int via_mmFreeMem(PMemBlock b);
+
+#endif
Index: git/shared-core/via_irq.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_irq.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,393 @@
+/* via_irq.c
+ *
+ * Copyright 2004 BEAM Ltd.
+ * Copyright 2002 Tungsten Graphics, Inc.
+ * Copyright 2005 Thomas Hellstrom.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BEAM LTD, TUNGSTEN GRAPHICS  AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Terry Barnaby <terry1@beam.ltd.uk>
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ *    Thomas Hellstrom <unichrome@shipmail.org>
+ *
+ * This code provides standard DRM access to the Via Unichrome / Pro Vertical blank
+ * interrupt, as well as an infrastructure to handle other interrupts of the chip.
+ * The refresh rate is also calculated for video playback sync purposes.
+ */
+
+#include "drmP.h"
+#include "drm.h"
+#include "via_drm.h"
+#include "via_drv.h"
+
+#define VIA_REG_INTERRUPT       0x200
+
+/* VIA_REG_INTERRUPT */
+#define VIA_IRQ_GLOBAL	  (1 << 31)
+#define VIA_IRQ_VBLANK_ENABLE   (1 << 19)
+#define VIA_IRQ_VBLANK_PENDING  (1 << 3)
+#define VIA_IRQ_HQV0_ENABLE     (1 << 11)
+#define VIA_IRQ_HQV1_ENABLE     (1 << 25)
+#define VIA_IRQ_HQV0_PENDING    (1 << 9)
+#define VIA_IRQ_HQV1_PENDING    (1 << 10)
+#define VIA_IRQ_DMA0_DD_ENABLE  (1 << 20)
+#define VIA_IRQ_DMA0_TD_ENABLE  (1 << 21)
+#define VIA_IRQ_DMA1_DD_ENABLE  (1 << 22)
+#define VIA_IRQ_DMA1_TD_ENABLE  (1 << 23)
+#define VIA_IRQ_DMA0_DD_PENDING (1 << 4)
+#define VIA_IRQ_DMA0_TD_PENDING (1 << 5)
+#define VIA_IRQ_DMA1_DD_PENDING (1 << 6)
+#define VIA_IRQ_DMA1_TD_PENDING (1 << 7)
+
+
+/*
+ * Device-specific IRQs go here. This type might need to be extended with
+ * the register if there are multiple IRQ control registers.
+ * Currently we activate the HQV interrupts of  Unichrome Pro group A. 
+ */
+
+static maskarray_t via_pro_group_a_irqs[] = {
+	{VIA_IRQ_HQV0_ENABLE, VIA_IRQ_HQV0_PENDING, 0x000003D0, 0x00008010,
+	 0x00000000 },
+	{VIA_IRQ_HQV1_ENABLE, VIA_IRQ_HQV1_PENDING, 0x000013D0, 0x00008010,
+	 0x00000000 },
+	{VIA_IRQ_DMA0_TD_ENABLE, VIA_IRQ_DMA0_TD_PENDING, VIA_PCI_DMA_CSR0, 
+	 VIA_DMA_CSR_TA | VIA_DMA_CSR_TD, 0x00000008},
+	{VIA_IRQ_DMA1_TD_ENABLE, VIA_IRQ_DMA1_TD_PENDING, VIA_PCI_DMA_CSR1,
+	 VIA_DMA_CSR_TA | VIA_DMA_CSR_TD, 0x00000008},
+};
+static int via_num_pro_group_a =
+    sizeof(via_pro_group_a_irqs)/sizeof(maskarray_t);
+static int via_irqmap_pro_group_a[] = {0, 1, -1, 2, -1, 3};
+
+static maskarray_t via_unichrome_irqs[] = {
+	{VIA_IRQ_DMA0_TD_ENABLE, VIA_IRQ_DMA0_TD_PENDING, VIA_PCI_DMA_CSR0, 
+	 VIA_DMA_CSR_TA | VIA_DMA_CSR_TD, 0x00000008},
+	{VIA_IRQ_DMA1_TD_ENABLE, VIA_IRQ_DMA1_TD_PENDING, VIA_PCI_DMA_CSR1,
+	 VIA_DMA_CSR_TA | VIA_DMA_CSR_TD, 0x00000008}
+};
+static int via_num_unichrome = sizeof(via_unichrome_irqs)/sizeof(maskarray_t);
+static int via_irqmap_unichrome[] = {-1, -1, -1, 0, -1, 1};
+
+
+static unsigned time_diff(struct timeval *now,struct timeval *then) 
+{
+    return (now->tv_usec >= then->tv_usec) ?
+	now->tv_usec - then->tv_usec :
+	1000000 - (then->tv_usec - now->tv_usec);
+}
+
+irqreturn_t via_driver_irq_handler(DRM_IRQ_ARGS)
+{
+	struct drm_device *dev = (struct drm_device *) arg;
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	u32 status;
+	int handled = 0;
+	struct timeval cur_vblank;
+	drm_via_irq_t *cur_irq = dev_priv->via_irqs;
+	int i;
+
+	status = VIA_READ(VIA_REG_INTERRUPT);
+	if (status & VIA_IRQ_VBLANK_PENDING) {
+		atomic_inc(&dev->vbl_received);
+		if (!(atomic_read(&dev->vbl_received) & 0x0F)) {
+#ifdef __linux__
+			do_gettimeofday(&cur_vblank);
+#else
+			microtime(&cur_vblank);
+#endif
+			if (dev_priv->last_vblank_valid) {
+				dev_priv->usec_per_vblank = 
+					time_diff(&cur_vblank,
+						  &dev_priv->last_vblank) >> 4;
+			}
+			dev_priv->last_vblank = cur_vblank;
+			dev_priv->last_vblank_valid = 1;
+		}
+		if (!(atomic_read(&dev->vbl_received) & 0xFF)) {
+			DRM_DEBUG("US per vblank is: %u\n",
+				dev_priv->usec_per_vblank);
+		}
+		DRM_WAKEUP(&dev->vbl_queue);
+		drm_vbl_send_signals(dev);
+		handled = 1;
+	}
+	
+	for (i=0; i<dev_priv->num_irqs; ++i) {
+		if (status & cur_irq->pending_mask) {
+			atomic_inc( &cur_irq->irq_received );
+			DRM_WAKEUP( &cur_irq->irq_queue );
+			handled = 1;
+#ifdef VIA_HAVE_DMABLIT
+			if (dev_priv->irq_map[drm_via_irq_dma0_td] == i) {
+				via_dmablit_handler(dev, 0, 1);
+			} else if (dev_priv->irq_map[drm_via_irq_dma1_td] == i) {
+				via_dmablit_handler(dev, 1, 1);
+			}
+#endif
+		}
+		cur_irq++;
+	}
+	
+	/* Acknowlege interrupts */
+	VIA_WRITE(VIA_REG_INTERRUPT, status);
+
+
+	if (handled)
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+}
+
+static __inline__ void viadrv_acknowledge_irqs(drm_via_private_t * dev_priv)
+{
+	u32 status;
+
+	if (dev_priv) {
+		/* Acknowlege interrupts */
+		status = VIA_READ(VIA_REG_INTERRUPT);
+		VIA_WRITE(VIA_REG_INTERRUPT, status | 
+			  dev_priv->irq_pending_mask);
+	}
+}
+
+int via_driver_vblank_wait(struct drm_device * dev, unsigned int *sequence)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	unsigned int cur_vblank;
+	int ret = 0;
+
+	DRM_DEBUG("viadrv_vblank_wait\n");
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	viadrv_acknowledge_irqs(dev_priv);
+
+	/* Assume that the user has missed the current sequence number
+	 * by about a day rather than she wants to wait for years
+	 * using vertical blanks...
+	 */
+
+	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
+		    (((cur_vblank = atomic_read(&dev->vbl_received)) -
+		      *sequence) <= (1 << 23)));
+	
+	*sequence = cur_vblank;
+	return ret;
+}
+
+static int
+via_driver_irq_wait(struct drm_device * dev, unsigned int irq, int force_sequence,
+		    unsigned int *sequence)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	unsigned int cur_irq_sequence;
+	drm_via_irq_t *cur_irq;
+	int ret = 0;
+	maskarray_t *masks;
+	int real_irq;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (irq >= drm_via_irq_num ) {
+		DRM_ERROR("%s Trying to wait on unknown irq %d\n", __FUNCTION__,
+			  irq);
+		return -EINVAL;
+	}
+		
+	real_irq = dev_priv->irq_map[irq];
+
+	if (real_irq < 0) {
+		DRM_ERROR("%s Video IRQ %d not available on this hardware.\n",
+			  __FUNCTION__, irq);
+		return -EINVAL;
+	}
+
+	masks = dev_priv->irq_masks;
+	cur_irq = dev_priv->via_irqs + real_irq;
+
+	if (masks[real_irq][2] && !force_sequence) {
+		DRM_WAIT_ON(ret, cur_irq->irq_queue, 3 * DRM_HZ,
+			    ((VIA_READ(masks[irq][2]) & masks[irq][3]) == 
+			     masks[irq][4]));
+		cur_irq_sequence = atomic_read(&cur_irq->irq_received);
+	} else {
+		DRM_WAIT_ON(ret, cur_irq->irq_queue, 3 * DRM_HZ,
+			    (((cur_irq_sequence =
+			       atomic_read(&cur_irq->irq_received)) -
+			      *sequence) <= (1 << 23)));		
+	}
+	*sequence = cur_irq_sequence;
+	return ret;
+}
+
+
+/*
+ * drm_dma.h hooks
+ */
+
+void via_driver_irq_preinstall(struct drm_device * dev)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	u32 status;
+	drm_via_irq_t *cur_irq;
+	int i;
+
+	DRM_DEBUG("driver_irq_preinstall: dev_priv: %p\n", dev_priv);
+	if (dev_priv) {
+		cur_irq = dev_priv->via_irqs;
+
+		dev_priv->irq_enable_mask = VIA_IRQ_VBLANK_ENABLE;
+		dev_priv->irq_pending_mask = VIA_IRQ_VBLANK_PENDING;
+
+		if (dev_priv->chipset == VIA_PRO_GROUP_A ||
+		    dev_priv->chipset == VIA_DX9_0) {
+			dev_priv->irq_masks = via_pro_group_a_irqs;
+			dev_priv->num_irqs = via_num_pro_group_a;
+			dev_priv->irq_map = via_irqmap_pro_group_a;
+		} else {
+			dev_priv->irq_masks = via_unichrome_irqs;
+			dev_priv->num_irqs = via_num_unichrome;
+			dev_priv->irq_map = via_irqmap_unichrome;
+		}
+
+		for(i=0; i < dev_priv->num_irqs; ++i) {
+			atomic_set(&cur_irq->irq_received, 0);
+			cur_irq->enable_mask = dev_priv->irq_masks[i][0]; 
+			cur_irq->pending_mask = dev_priv->irq_masks[i][1];
+			DRM_INIT_WAITQUEUE( &cur_irq->irq_queue );
+			dev_priv->irq_enable_mask |= cur_irq->enable_mask;
+			dev_priv->irq_pending_mask |= cur_irq->pending_mask;
+			cur_irq++;
+			
+			DRM_DEBUG("Initializing IRQ %d\n", i);
+		}
+			
+		dev_priv->last_vblank_valid = 0;
+
+		/* Clear VSync interrupt regs */
+		status = VIA_READ(VIA_REG_INTERRUPT);
+		VIA_WRITE(VIA_REG_INTERRUPT, status & 
+			  ~(dev_priv->irq_enable_mask));
+		
+		/* Clear bits if they're already high */
+		viadrv_acknowledge_irqs(dev_priv);
+	}
+}
+
+void via_driver_irq_postinstall(struct drm_device * dev)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	u32 status;
+
+	DRM_DEBUG("via_driver_irq_postinstall\n");
+	if (dev_priv) {
+		status = VIA_READ(VIA_REG_INTERRUPT);
+		VIA_WRITE(VIA_REG_INTERRUPT, status | VIA_IRQ_GLOBAL
+			  | dev_priv->irq_enable_mask);
+
+		/* Some magic, oh for some data sheets ! */
+
+		VIA_WRITE8(0x83d4, 0x11);
+		VIA_WRITE8(0x83d5, VIA_READ8(0x83d5) | 0x30);
+		
+	}
+}
+
+void via_driver_irq_uninstall(struct drm_device * dev)
+{
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	u32 status;
+
+	DRM_DEBUG("driver_irq_uninstall)\n");
+	if (dev_priv) {
+
+		/* Some more magic, oh for some data sheets ! */
+
+		VIA_WRITE8(0x83d4, 0x11);
+		VIA_WRITE8(0x83d5, VIA_READ8(0x83d5) & ~0x30);
+
+		status = VIA_READ(VIA_REG_INTERRUPT);
+		VIA_WRITE(VIA_REG_INTERRUPT, status & 
+			  ~(VIA_IRQ_VBLANK_ENABLE | dev_priv->irq_enable_mask));
+	}
+}
+
+int via_wait_irq(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_via_irqwait_t *irqwait = data;
+	struct timeval now;
+	int ret = 0;
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	drm_via_irq_t *cur_irq = dev_priv->via_irqs;
+	int force_sequence;
+
+	if (!dev->irq)
+		return -EINVAL;
+
+	if (irqwait->request.irq >= dev_priv->num_irqs) {
+		DRM_ERROR("%s Trying to wait on unknown irq %d\n", __FUNCTION__, 
+			  irqwait->request.irq);
+		return -EINVAL;
+	}
+
+	cur_irq += irqwait->request.irq;
+
+	switch (irqwait->request.type & ~VIA_IRQ_FLAGS_MASK) {
+	case VIA_IRQ_RELATIVE:
+		irqwait->request.sequence +=
+			atomic_read(&cur_irq->irq_received);
+		irqwait->request.type &= ~_DRM_VBLANK_RELATIVE;
+	case VIA_IRQ_ABSOLUTE:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (irqwait->request.type & VIA_IRQ_SIGNAL) {
+		DRM_ERROR("%s Signals on Via IRQs not implemented yet.\n", 
+			  __FUNCTION__);
+		return -EINVAL;
+	}
+
+	force_sequence = (irqwait->request.type & VIA_IRQ_FORCE_SEQUENCE);
+
+	ret = via_driver_irq_wait(dev, irqwait->request.irq, force_sequence,
+				  &irqwait->request.sequence);
+#ifdef __linux__
+	do_gettimeofday(&now);
+#else
+	microtime(&now);
+#endif
+	irqwait->reply.tval_sec = now.tv_sec;
+	irqwait->reply.tval_usec = now.tv_usec;
+
+	return ret;
+}
Index: git/shared-core/via_map.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_map.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,143 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include "drmP.h"
+#include "via_drm.h"
+#include "via_drv.h"
+
+static int via_do_init_map(struct drm_device * dev, drm_via_init_t * init)
+{
+	drm_via_private_t *dev_priv = dev->dev_private;
+	int ret = 0;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	dev_priv->sarea = drm_getsarea(dev);
+	if (!dev_priv->sarea) {
+		DRM_ERROR("could not find sarea!\n");
+		dev->dev_private = (void *)dev_priv;
+		via_do_cleanup_map(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->fb = drm_core_findmap(dev, init->fb_offset);
+	if (!dev_priv->fb) {
+		DRM_ERROR("could not find framebuffer!\n");
+		dev->dev_private = (void *)dev_priv;
+		via_do_cleanup_map(dev);
+		return -EINVAL;
+	}
+	dev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);
+	if (!dev_priv->mmio) {
+		DRM_ERROR("could not find mmio region!\n");
+		dev->dev_private = (void *)dev_priv;
+		via_do_cleanup_map(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->sarea_priv =
+	    (drm_via_sarea_t *) ((u8 *) dev_priv->sarea->handle +
+				 init->sarea_priv_offset);
+
+	dev_priv->agpAddr = init->agpAddr;
+
+	via_init_futex( dev_priv );
+#ifdef VIA_HAVE_DMABLIT
+	via_init_dmablit( dev );
+#endif
+#ifdef VIA_HAVE_FENCE
+	dev_priv->emit_0_sequence = 0;
+	dev_priv->have_idlelock = 0;
+	spin_lock_init(&dev_priv->fence_lock);
+	init_timer(&dev_priv->fence_timer);
+	dev_priv->fence_timer.function = &via_fence_timer;
+	dev_priv->fence_timer.data = (unsigned long) dev;
+#endif /* VIA_HAVE_FENCE */
+	dev->dev_private = (void *)dev_priv;
+#ifdef VIA_HAVE_BUFFER
+	ret = drm_bo_driver_init(dev);
+	if (ret)
+		DRM_ERROR("Could not initialize buffer object driver.\n");
+#endif
+	return ret;
+
+}
+
+int via_do_cleanup_map(struct drm_device * dev)
+{
+	via_dma_cleanup(dev);
+
+	return 0;
+}
+
+
+int via_map_init(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_via_init_t *init = data;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	switch (init->func) {
+	case VIA_INIT_MAP:
+		return via_do_init_map(dev, init);
+	case VIA_CLEANUP_MAP:
+		return via_do_cleanup_map(dev);
+	}
+
+	return -EINVAL;
+}
+
+int via_driver_load(struct drm_device *dev, unsigned long chipset)
+{
+	drm_via_private_t *dev_priv;
+	int ret = 0;
+
+	dev_priv = drm_calloc(1, sizeof(drm_via_private_t), DRM_MEM_DRIVER);
+	if (dev_priv == NULL)
+		return -ENOMEM;
+
+	dev->dev_private = (void *)dev_priv;
+
+	dev_priv->chipset = chipset;
+
+#ifdef VIA_HAVE_CORE_MM
+	ret = drm_sman_init(&dev_priv->sman, 2, 12, 8);
+	if (ret) {
+		drm_free(dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER);
+	}
+#endif
+	return ret;
+}
+
+int via_driver_unload(struct drm_device *dev)
+{
+	drm_via_private_t *dev_priv = dev->dev_private;
+
+#ifdef VIA_HAVE_CORE_MM
+	drm_sman_takedown(&dev_priv->sman);
+#endif
+	drm_free(dev_priv, sizeof(drm_via_private_t), DRM_MEM_DRIVER);
+
+	return 0;
+}
+
Index: git/shared-core/via_mm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_mm.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,347 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include "drmP.h"
+#include "via_drm.h"
+#include "via_drv.h"
+#include "via_ds.h"
+#include "via_mm.h"
+
+#define MAX_CONTEXT 100
+
+typedef struct {
+	int used;
+	int context;
+	set_t *sets[2];		/* 0 for frame buffer, 1 for AGP , 2 for System */
+} via_context_t;
+
+static via_context_t global_ppriv[MAX_CONTEXT];
+
+static int via_agp_alloc(drm_via_mem_t * mem);
+static int via_agp_free(drm_via_mem_t * mem);
+static int via_fb_alloc(drm_via_mem_t * mem);
+static int via_fb_free(drm_via_mem_t * mem);
+
+static int add_alloc_set(int context, int type, unsigned long val)
+{
+	int i, retval = 0;
+
+	for (i = 0; i < MAX_CONTEXT; i++) {
+		if (global_ppriv[i].used && global_ppriv[i].context == context) {
+			retval = via_setAdd(global_ppriv[i].sets[type], val);
+			break;
+		}
+	}
+
+	return retval;
+}
+
+static int del_alloc_set(int context, int type, unsigned long val)
+{
+	int i, retval = 0;
+
+	for (i = 0; i < MAX_CONTEXT; i++)
+		if (global_ppriv[i].used && global_ppriv[i].context == context) {
+			retval = via_setDel(global_ppriv[i].sets[type], val);
+			break;
+		}
+
+	return retval;
+}
+
+/* agp memory management */
+static memHeap_t *AgpHeap = NULL;
+
+int via_agp_init(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_via_agp_t *agp = data;
+
+	AgpHeap = via_mmInit(agp->offset, agp->size);
+
+	DRM_DEBUG("offset = %lu, size = %lu", (unsigned long)agp->offset,
+		  (unsigned long)agp->size);
+
+	return 0;
+}
+
+/* fb memory management */
+static memHeap_t *FBHeap = NULL;
+
+int via_fb_init(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_via_fb_t *fb = data;
+
+	FBHeap = via_mmInit(fb.offset, fb.size);
+
+	DRM_DEBUG("offset = %lu, size = %lu", (unsigned long)fb.offset,
+		  (unsigned long)fb.size);
+
+	return 0;
+}
+
+int via_init_context(struct drm_device *dev, int context)
+{
+	int i;
+
+	for (i = 0; i < MAX_CONTEXT; i++)
+		if (global_ppriv[i].used &&
+		    (global_ppriv[i].context == context))
+			break;
+
+	if (i >= MAX_CONTEXT) {
+		for (i = 0; i < MAX_CONTEXT; i++) {
+			if (!global_ppriv[i].used) {
+				global_ppriv[i].context = context;
+				global_ppriv[i].used = 1;
+				global_ppriv[i].sets[0] = via_setInit();
+				global_ppriv[i].sets[1] = via_setInit();
+				DRM_DEBUG("init allocation set, socket=%d,"
+					  " context = %d\n", i, context);
+				break;
+			}
+		}
+
+		if ((i >= MAX_CONTEXT) || (global_ppriv[i].sets[0] == NULL) ||
+		    (global_ppriv[i].sets[1] == NULL)) {
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+int via_final_context(struct drm_device *dev, int context)
+{	
+        int i;
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+
+	for (i = 0; i < MAX_CONTEXT; i++)
+		if (global_ppriv[i].used &&
+		    (global_ppriv[i].context == context))
+			break;
+
+	if (i < MAX_CONTEXT) {
+		set_t *set;
+		ITEM_TYPE item;
+		int retval;
+
+		DRM_DEBUG("find socket %d, context = %d\n", i, context);
+
+		/* Video Memory */
+		set = global_ppriv[i].sets[0];
+		retval = via_setFirst(set, &item);
+		while (retval) {
+			DRM_DEBUG("free video memory 0x%lx\n", item);
+			via_mmFreeMem((PMemBlock) item);
+			retval = via_setNext(set, &item);
+		}
+		via_setDestroy(set);
+
+		/* AGP Memory */
+		set = global_ppriv[i].sets[1];
+		retval = via_setFirst(set, &item);
+		while (retval) {
+			DRM_DEBUG("free agp memory 0x%lx\n", item);
+			via_mmFreeMem((PMemBlock) item);
+			retval = via_setNext(set, &item);
+		}
+		via_setDestroy(set);
+		global_ppriv[i].used = 0;
+	}
+	via_release_futex(dev_priv, context); 
+	
+#if defined(__linux__)
+	/* Linux specific until context tracking code gets ported to BSD */
+	/* Last context, perform cleanup */
+	if (dev->ctx_count == 1 && dev->dev_private) {
+	        DRM_DEBUG("Last Context\n");
+		if (dev->irq)
+			drm_irq_uninstall(dev);
+
+		via_cleanup_futex(dev_priv);
+		via_do_cleanup_map(dev);
+	}
+#endif
+
+	return 1;
+}
+
+int via_mem_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_via_mem_t *mem = data;
+
+	switch (mem.type) {
+	case VIA_MEM_VIDEO:
+		if (via_fb_alloc(mem) < 0)
+			return -EFAULT;
+		return 0;
+	case VIA_MEM_AGP:
+		if (via_agp_alloc(mem) < 0)
+			return -EFAULT;
+		return 0;
+	}
+
+	return -EFAULT;
+}
+
+static int via_fb_alloc(drm_via_mem_t * mem)
+{
+	drm_via_mm_t fb;
+	PMemBlock block;
+	int retval = 0;
+
+	if (!FBHeap)
+		return -1;
+
+	fb.size = mem->size;
+	fb.context = mem->context;
+
+	block = via_mmAllocMem(FBHeap, fb.size, 5, 0);
+	if (block) {
+		fb.offset = block->ofs;
+		fb.free = (unsigned long)block;
+		if (!add_alloc_set(fb.context, VIA_MEM_VIDEO, fb.free)) {
+			DRM_DEBUG("adding to allocation set fails\n");
+			via_mmFreeMem((PMemBlock) fb.free);
+			retval = -1;
+		}
+	} else {
+		fb.offset = 0;
+		fb.size = 0;
+		fb.free = 0;
+		retval = -1;
+	}
+
+	mem->offset = fb.offset;
+	mem->index = fb.free;
+
+	DRM_DEBUG("alloc fb, size = %d, offset = %d\n", fb.size,
+		  (int)fb.offset);
+
+	return retval;
+}
+
+static int via_agp_alloc(drm_via_mem_t * mem)
+{
+	drm_via_mm_t agp;
+	PMemBlock block;
+	int retval = 0;
+
+	if (!AgpHeap)
+		return -1;
+
+	agp.size = mem->size;
+	agp.context = mem->context;
+
+	block = via_mmAllocMem(AgpHeap, agp.size, 5, 0);
+	if (block) {
+		agp.offset = block->ofs;
+		agp.free = (unsigned long)block;
+		if (!add_alloc_set(agp.context, VIA_MEM_AGP, agp.free)) {
+			DRM_DEBUG("adding to allocation set fails\n");
+			via_mmFreeMem((PMemBlock) agp.free);
+			retval = -1;
+		}
+	} else {
+		agp.offset = 0;
+		agp.size = 0;
+		agp.free = 0;
+	}
+
+	mem->offset = agp.offset;
+	mem->index = agp.free;
+
+	DRM_DEBUG("alloc agp, size = %d, offset = %d\n", agp.size,
+		  (unsigned int)agp.offset);
+	return retval;
+}
+
+int via_mem_free(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_via_mem_t *mem = data;
+
+	switch (mem->type) {
+
+	case VIA_MEM_VIDEO:
+		if (via_fb_free(mem) == 0)
+			return 0;
+		break;
+	case VIA_MEM_AGP:
+		if (via_agp_free(mem) == 0)
+			return 0;
+		break;
+	}
+
+	return -EFAULT;
+}
+
+static int via_fb_free(drm_via_mem_t * mem)
+{
+	drm_via_mm_t fb;
+	int retval = 0;
+
+	if (!FBHeap) {
+		return -1;
+	}
+
+	fb.free = mem->index;
+	fb.context = mem->context;
+
+	if (!fb.free) {
+		return -1;
+
+	}
+
+	via_mmFreeMem((PMemBlock) fb.free);
+
+	if (!del_alloc_set(fb.context, VIA_MEM_VIDEO, fb.free)) {
+		retval = -1;
+	}
+
+	DRM_DEBUG("free fb, free = %ld\n", fb.free);
+
+	return retval;
+}
+
+static int via_agp_free(drm_via_mem_t * mem)
+{
+	drm_via_mm_t agp;
+
+	int retval = 0;
+
+	agp.free = mem->index;
+	agp.context = mem->context;
+
+	if (!agp.free)
+		return -1;
+
+	via_mmFreeMem((PMemBlock) agp.free);
+
+	if (!del_alloc_set(agp.context, VIA_MEM_AGP, agp.free)) {
+		retval = -1;
+	}
+
+	DRM_DEBUG("free agp, free = %ld\n", agp.nfree);
+
+	return retval;
+}
Index: git/shared-core/via_mm.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_mm.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,40 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _via_drm_mm_h_
+#define _via_drm_mm_h_
+
+typedef struct {
+	unsigned int context;
+	unsigned int size;
+	unsigned long offset;
+	unsigned long free;
+} drm_via_mm_t;
+
+typedef struct {
+	unsigned int size;
+	unsigned long handle;
+	void *virtual;
+} drm_via_dma_t;
+
+#endif
Index: git/shared-core/via_verifier.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_verifier.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,1121 @@
+/*
+ * Copyright 2004 The Unichrome Project. All Rights Reserved.
+ * Copyright 2005 Thomas Hellstrom. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHOR(S), AND/OR THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Thomas Hellstrom 2004, 2005.
+ * This code was written using docs obtained under NDA from VIA Inc.
+ *
+ * Don't run this code directly on an AGP buffer. Due to cache problems it will
+ * be very slow.
+ */
+
+#include "via_3d_reg.h"
+#include "drmP.h"
+#include "drm.h"
+#include "via_drm.h"
+#include "via_verifier.h"
+#include "via_drv.h"
+
+typedef enum {
+	state_command,
+	state_header2,
+	state_header1,
+	state_vheader5,
+	state_vheader6,
+	state_error
+} verifier_state_t;
+
+typedef enum {
+	no_check = 0,
+	check_for_header2,
+	check_for_header1,
+	check_for_header2_err,
+	check_for_header1_err,
+	check_for_fire,
+	check_z_buffer_addr0,
+	check_z_buffer_addr1,
+	check_z_buffer_addr_mode,
+	check_destination_addr0,
+	check_destination_addr1,
+	check_destination_addr_mode,
+	check_for_dummy,
+	check_for_dd,
+	check_texture_addr0,
+	check_texture_addr1,
+	check_texture_addr2,
+	check_texture_addr3,
+	check_texture_addr4,
+	check_texture_addr5,
+	check_texture_addr6,
+	check_texture_addr7,
+	check_texture_addr8,
+	check_texture_addr_mode,
+	check_for_vertex_count,
+	check_number_texunits,
+	forbidden_command
+} hazard_t;
+
+/*
+ * Associates each hazard above with a possible multi-command
+ * sequence. For example an address that is split over multiple
+ * commands and that needs to be checked at the first command 
+ * that does not include any part of the address.
+ */
+
+static drm_via_sequence_t seqs[] = {
+	no_sequence,
+	no_sequence,
+	no_sequence,
+	no_sequence,
+	no_sequence,
+	no_sequence,
+	z_address,
+	z_address,
+	z_address,
+	dest_address,
+	dest_address,
+	dest_address,
+	no_sequence,
+	no_sequence,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	tex_address,
+	no_sequence
+};
+
+typedef struct {
+	unsigned int code;
+	hazard_t hz;
+} hz_init_t;
+
+static hz_init_t init_table1[] = {
+	{0xf2, check_for_header2_err},
+	{0xf0, check_for_header1_err},
+	{0xee, check_for_fire},
+	{0xcc, check_for_dummy},
+	{0xdd, check_for_dd},
+	{0x00, no_check},
+	{0x10, check_z_buffer_addr0},
+	{0x11, check_z_buffer_addr1},
+	{0x12, check_z_buffer_addr_mode},
+	{0x13, no_check},
+	{0x14, no_check},
+	{0x15, no_check},
+	{0x23, no_check},
+	{0x24, no_check},
+	{0x33, no_check},
+	{0x34, no_check},
+	{0x35, no_check},
+	{0x36, no_check},
+	{0x37, no_check},
+	{0x38, no_check},
+	{0x39, no_check},
+	{0x3A, no_check},
+	{0x3B, no_check},
+	{0x3C, no_check},
+	{0x3D, no_check},
+	{0x3E, no_check},
+	{0x40, check_destination_addr0},
+	{0x41, check_destination_addr1},
+	{0x42, check_destination_addr_mode},
+	{0x43, no_check},
+	{0x44, no_check},
+	{0x50, no_check},
+	{0x51, no_check},
+	{0x52, no_check},
+	{0x53, no_check},
+	{0x54, no_check},
+	{0x55, no_check},
+	{0x56, no_check},
+	{0x57, no_check},
+	{0x58, no_check},
+	{0x70, no_check},
+	{0x71, no_check},
+	{0x78, no_check},
+	{0x79, no_check},
+	{0x7A, no_check},
+	{0x7B, no_check},
+	{0x7C, no_check},
+	{0x7D, check_for_vertex_count}
+};
+
+static hz_init_t init_table2[] = {
+	{0xf2, check_for_header2_err},
+	{0xf0, check_for_header1_err},
+	{0xee, check_for_fire},
+	{0xcc, check_for_dummy},
+	{0x00, check_texture_addr0},
+	{0x01, check_texture_addr0},
+	{0x02, check_texture_addr0},
+	{0x03, check_texture_addr0},
+	{0x04, check_texture_addr0},
+	{0x05, check_texture_addr0},
+	{0x06, check_texture_addr0},
+	{0x07, check_texture_addr0},
+	{0x08, check_texture_addr0},
+	{0x09, check_texture_addr0},
+	{0x20, check_texture_addr1},
+	{0x21, check_texture_addr1},
+	{0x22, check_texture_addr1},
+	{0x23, check_texture_addr4},
+	{0x2B, check_texture_addr3},
+	{0x2C, check_texture_addr3},
+	{0x2D, check_texture_addr3},
+	{0x2E, check_texture_addr3},
+	{0x2F, check_texture_addr3},
+	{0x30, check_texture_addr3},
+	{0x31, check_texture_addr3},
+	{0x32, check_texture_addr3},
+	{0x33, check_texture_addr3},
+	{0x34, check_texture_addr3},
+	{0x4B, check_texture_addr5},
+	{0x4C, check_texture_addr6},
+	{0x51, check_texture_addr7},
+	{0x52, check_texture_addr8},
+	{0x77, check_texture_addr2},
+	{0x78, no_check},
+	{0x79, no_check},
+	{0x7A, no_check},
+	{0x7B, check_texture_addr_mode},
+	{0x7C, no_check},
+	{0x7D, no_check},
+	{0x7E, no_check},
+	{0x7F, no_check},
+	{0x80, no_check},
+	{0x81, no_check},
+	{0x82, no_check},
+	{0x83, no_check},
+	{0x85, no_check},
+	{0x86, no_check},
+	{0x87, no_check},
+	{0x88, no_check},
+	{0x89, no_check},
+	{0x8A, no_check},
+	{0x90, no_check},
+	{0x91, no_check},
+	{0x92, no_check},
+	{0x93, no_check}
+};
+
+static hz_init_t init_table3[] = {
+	{0xf2, check_for_header2_err},
+	{0xf0, check_for_header1_err},
+	{0xcc, check_for_dummy},
+	{0x00, check_number_texunits}
+};
+
+static hazard_t table1[256];
+static hazard_t table2[256];
+static hazard_t table3[256];
+
+static __inline__ int
+eat_words(const uint32_t ** buf, const uint32_t * buf_end, unsigned num_words)
+{
+	if ((buf_end - *buf) >= num_words) {
+		*buf += num_words;
+		return 0;
+	}
+	DRM_ERROR("Illegal termination of DMA command buffer\n");
+	return 1;
+}
+
+/*
+ * Partially stolen from drm_memory.h
+ */
+
+static __inline__ drm_local_map_t *via_drm_lookup_agp_map(drm_via_state_t * seq,
+							  unsigned long offset,
+							  unsigned long size,
+							  struct drm_device * dev)
+{
+#ifdef __linux__
+	struct drm_map_list *r_list;
+#endif
+	drm_local_map_t *map = seq->map_cache;
+
+	if (map && map->offset <= offset
+	    && (offset + size) <= (map->offset + map->size)) {
+		return map;
+	}
+#ifdef __linux__
+	list_for_each_entry(r_list, &dev->maplist, head) {
+		map = r_list->map;
+		if (!map)
+			continue;
+#else
+	TAILQ_FOREACH(map, &dev->maplist, link) {
+#endif
+		if (map->offset <= offset
+		    && (offset + size) <= (map->offset + map->size)
+		    && !(map->flags & _DRM_RESTRICTED)
+		    && (map->type == _DRM_AGP)) {
+			seq->map_cache = map;
+			return map;
+		}
+	}
+	return NULL;
+}
+
+/*
+ * Require that all AGP texture levels reside in the same AGP map which should 
+ * be mappable by the client. This is not a big restriction.
+ * FIXME: To actually enforce this security policy strictly, drm_rmmap 
+ * would have to wait for dma quiescent before removing an AGP map. 
+ * The via_drm_lookup_agp_map call in reality seems to take
+ * very little CPU time.
+ */
+
+static __inline__ int finish_current_sequence(drm_via_state_t * cur_seq)
+{
+	switch (cur_seq->unfinished) {
+	case z_address:
+		DRM_DEBUG("Z Buffer start address is 0x%x\n", cur_seq->z_addr);
+		break;
+	case dest_address:
+		DRM_DEBUG("Destination start address is 0x%x\n",
+			  cur_seq->d_addr);
+		break;
+	case tex_address:
+		if (cur_seq->agp_texture) {
+			unsigned start =
+			    cur_seq->tex_level_lo[cur_seq->texture];
+			unsigned end = cur_seq->tex_level_hi[cur_seq->texture];
+			unsigned long lo = ~0, hi = 0, tmp;
+			uint32_t *addr, *pitch, *height, tex;
+			unsigned i;
+			int npot;
+
+			if (end > 9)
+				end = 9;
+			if (start > 9)
+				start = 9;
+
+			addr =
+			    &(cur_seq->t_addr[tex = cur_seq->texture][start]);
+			pitch = &(cur_seq->pitch[tex][start]);
+			height = &(cur_seq->height[tex][start]);
+			npot = cur_seq->tex_npot[tex];
+			for (i = start; i <= end; ++i) {
+				tmp = *addr++;
+				if (tmp < lo)
+					lo = tmp;
+				if (i == 0 && npot)
+					tmp += (*height++ * *pitch++);
+				else
+					tmp += (*height++ << *pitch++);
+				if (tmp > hi)
+					hi = tmp;
+			}
+
+			if (!via_drm_lookup_agp_map
+			    (cur_seq, lo, hi - lo, cur_seq->dev)) {
+				DRM_ERROR
+				    ("AGP texture is not in allowed map\n");
+				return 2;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	cur_seq->unfinished = no_sequence;
+	return 0;
+}
+
+static __inline__ int
+investigate_hazard(uint32_t cmd, hazard_t hz, drm_via_state_t * cur_seq)
+{
+	register uint32_t tmp, *tmp_addr;
+
+	if (cur_seq->unfinished && (cur_seq->unfinished != seqs[hz])) {
+		int ret;
+		if ((ret = finish_current_sequence(cur_seq)))
+			return ret;
+	}
+
+	switch (hz) {
+	case check_for_header2:
+		if (cmd == HALCYON_HEADER2)
+			return 1;
+		return 0;
+	case check_for_header1:
+		if ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1)
+			return 1;
+		return 0;
+	case check_for_header2_err:
+		if (cmd == HALCYON_HEADER2)
+			return 1;
+		DRM_ERROR("Illegal DMA HALCYON_HEADER2 command\n");
+		break;
+	case check_for_header1_err:
+		if ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1)
+			return 1;
+		DRM_ERROR("Illegal DMA HALCYON_HEADER1 command\n");
+		break;
+	case check_for_fire:
+		if ((cmd & HALCYON_FIREMASK) == HALCYON_FIRECMD)
+			return 1;
+		DRM_ERROR("Illegal DMA HALCYON_FIRECMD command\n");
+		break;
+	case check_for_dummy:
+		if (HC_DUMMY == cmd)
+			return 0;
+		DRM_ERROR("Illegal DMA HC_DUMMY command\n");
+		break;
+	case check_for_dd:
+		if (0xdddddddd == cmd)
+			return 0;
+		DRM_ERROR("Illegal DMA 0xdddddddd command\n");
+		break;
+	case check_z_buffer_addr0:
+		cur_seq->unfinished = z_address;
+		cur_seq->z_addr = (cur_seq->z_addr & 0xFF000000) |
+		    (cmd & 0x00FFFFFF);
+		return 0;
+	case check_z_buffer_addr1:
+		cur_seq->unfinished = z_address;
+		cur_seq->z_addr = (cur_seq->z_addr & 0x00FFFFFF) |
+		    ((cmd & 0xFF) << 24);
+		return 0;
+	case check_z_buffer_addr_mode:
+		cur_seq->unfinished = z_address;
+		if ((cmd & 0x0000C000) == 0)
+			return 0;
+		DRM_ERROR("Attempt to place Z buffer in system memory\n");
+		return 2;
+	case check_destination_addr0:
+		cur_seq->unfinished = dest_address;
+		cur_seq->d_addr = (cur_seq->d_addr & 0xFF000000) |
+		    (cmd & 0x00FFFFFF);
+		return 0;
+	case check_destination_addr1:
+		cur_seq->unfinished = dest_address;
+		cur_seq->d_addr = (cur_seq->d_addr & 0x00FFFFFF) |
+		    ((cmd & 0xFF) << 24);
+		return 0;
+	case check_destination_addr_mode:
+		cur_seq->unfinished = dest_address;
+		if ((cmd & 0x0000C000) == 0)
+			return 0;
+		DRM_ERROR
+		    ("Attempt to place 3D drawing buffer in system memory\n");
+		return 2;
+	case check_texture_addr0:
+		cur_seq->unfinished = tex_address;
+		tmp = (cmd >> 24);
+		tmp_addr = &cur_seq->t_addr[cur_seq->texture][tmp];
+		*tmp_addr = (*tmp_addr & 0xFF000000) | (cmd & 0x00FFFFFF);
+		return 0;
+	case check_texture_addr1:
+		cur_seq->unfinished = tex_address;
+		tmp = ((cmd >> 24) - 0x20);
+		tmp += tmp << 1;
+		tmp_addr = &cur_seq->t_addr[cur_seq->texture][tmp];
+		*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF) << 24);
+		tmp_addr++;
+		*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF00) << 16);
+		tmp_addr++;
+		*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF0000) << 8);
+		return 0;
+	case check_texture_addr2:
+		cur_seq->unfinished = tex_address;
+		cur_seq->tex_level_lo[tmp = cur_seq->texture] = cmd & 0x3F;
+		cur_seq->tex_level_hi[tmp] = (cmd & 0xFC0) >> 6;
+		return 0;
+	case check_texture_addr3:
+		cur_seq->unfinished = tex_address;
+		tmp = ((cmd >> 24) - HC_SubA_HTXnL0Pit);
+		if (tmp == 0 && 
+		    (cmd & HC_HTXnEnPit_MASK)) {
+			cur_seq->pitch[cur_seq->texture][tmp] = 
+				(cmd & HC_HTXnLnPit_MASK);
+			cur_seq->tex_npot[cur_seq->texture] = 1;
+		} else {
+			cur_seq->pitch[cur_seq->texture][tmp] =
+				(cmd & HC_HTXnLnPitE_MASK) >> HC_HTXnLnPitE_SHIFT;
+			cur_seq->tex_npot[cur_seq->texture] = 0;			
+			if (cmd & 0x000FFFFF) {
+				DRM_ERROR
+					("Unimplemented texture level 0 pitch mode.\n");
+				return 2;
+			}
+		}
+		return 0;
+	case check_texture_addr4:
+		cur_seq->unfinished = tex_address;
+		tmp_addr = &cur_seq->t_addr[cur_seq->texture][9];
+		*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF) << 24);
+		return 0;
+	case check_texture_addr5:
+	case check_texture_addr6:
+		cur_seq->unfinished = tex_address;
+		/*
+		 * Texture width. We don't care since we have the pitch.
+		 */
+		return 0;
+	case check_texture_addr7:
+		cur_seq->unfinished = tex_address;
+		tmp_addr = &(cur_seq->height[cur_seq->texture][0]);
+		tmp_addr[5] = 1 << ((cmd & 0x00F00000) >> 20);
+		tmp_addr[4] = 1 << ((cmd & 0x000F0000) >> 16);
+		tmp_addr[3] = 1 << ((cmd & 0x0000F000) >> 12);
+		tmp_addr[2] = 1 << ((cmd & 0x00000F00) >> 8);
+		tmp_addr[1] = 1 << ((cmd & 0x000000F0) >> 4);
+		tmp_addr[0] = 1 << (cmd & 0x0000000F);
+		return 0;
+	case check_texture_addr8:
+		cur_seq->unfinished = tex_address;
+		tmp_addr = &(cur_seq->height[cur_seq->texture][0]);
+		tmp_addr[9] = 1 << ((cmd & 0x0000F000) >> 12);
+		tmp_addr[8] = 1 << ((cmd & 0x00000F00) >> 8);
+		tmp_addr[7] = 1 << ((cmd & 0x000000F0) >> 4);
+		tmp_addr[6] = 1 << (cmd & 0x0000000F);
+		return 0;
+	case check_texture_addr_mode:
+		cur_seq->unfinished = tex_address;
+		if (2 == (tmp = cmd & 0x00000003)) {
+			DRM_ERROR
+			    ("Attempt to fetch texture from system memory.\n");
+			return 2;
+		}
+		cur_seq->agp_texture = (tmp == 3);
+		cur_seq->tex_palette_size[cur_seq->texture] =
+		    (cmd >> 16) & 0x000000007;
+		return 0;
+	case check_for_vertex_count:
+		cur_seq->vertex_count = cmd & 0x0000FFFF;
+		return 0;
+	case check_number_texunits:
+		cur_seq->multitex = (cmd >> 3) & 1;
+		return 0;
+	default:
+		DRM_ERROR("Illegal DMA data: 0x%x\n", cmd);
+		return 2;
+	}
+	return 2;
+}
+
+static __inline__ int
+via_check_prim_list(uint32_t const **buffer, const uint32_t * buf_end,
+		    drm_via_state_t * cur_seq)
+{
+	drm_via_private_t *dev_priv =
+	    (drm_via_private_t *) cur_seq->dev->dev_private;
+	uint32_t a_fire, bcmd, dw_count;
+	int ret = 0;
+	int have_fire;
+	const uint32_t *buf = *buffer;
+
+	while (buf < buf_end) {
+		have_fire = 0;
+		if ((buf_end - buf) < 2) {
+			DRM_ERROR
+			    ("Unexpected termination of primitive list.\n");
+			ret = 1;
+			break;
+		}
+		if ((*buf & HC_ACMD_MASK) != HC_ACMD_HCmdB)
+			break;
+		bcmd = *buf++;
+		if ((*buf & HC_ACMD_MASK) != HC_ACMD_HCmdA) {
+			DRM_ERROR("Expected Vertex List A command, got 0x%x\n",
+				  *buf);
+			ret = 1;
+			break;
+		}
+		a_fire =
+		    *buf++ | HC_HPLEND_MASK | HC_HPMValidN_MASK |
+		    HC_HE3Fire_MASK;
+
+		/*
+		 * How many dwords per vertex ?
+		 */
+
+		if (cur_seq->agp && ((bcmd & (0xF << 11)) == 0)) {
+			DRM_ERROR("Illegal B command vertex data for AGP.\n");
+			ret = 1;
+			break;
+		}
+
+		dw_count = 0;
+		if (bcmd & (1 << 7))
+			dw_count += (cur_seq->multitex) ? 2 : 1;
+		if (bcmd & (1 << 8))
+			dw_count += (cur_seq->multitex) ? 2 : 1;
+		if (bcmd & (1 << 9))
+			dw_count++;
+		if (bcmd & (1 << 10))
+			dw_count++;
+		if (bcmd & (1 << 11))
+			dw_count++;
+		if (bcmd & (1 << 12))
+			dw_count++;
+		if (bcmd & (1 << 13))
+			dw_count++;
+		if (bcmd & (1 << 14))
+			dw_count++;
+
+		while (buf < buf_end) {
+			if (*buf == a_fire) {
+				if (dev_priv->num_fire_offsets >=
+				    VIA_FIRE_BUF_SIZE) {
+					DRM_ERROR("Fire offset buffer full.\n");
+					ret = 1;
+					break;
+				}
+				dev_priv->fire_offsets[dev_priv->
+						       num_fire_offsets++] =
+				    buf;
+				have_fire = 1;
+				buf++;
+				if (buf < buf_end && *buf == a_fire)
+					buf++;
+				break;
+			}
+			if ((*buf == HALCYON_HEADER2) ||
+			    ((*buf & HALCYON_FIREMASK) == HALCYON_FIRECMD)) {
+				DRM_ERROR("Missing Vertex Fire command, "
+					  "Stray Vertex Fire command  or verifier "
+					  "lost sync.\n");
+				ret = 1;
+				break;
+			}
+			if ((ret = eat_words(&buf, buf_end, dw_count)))
+				break;
+		}
+		if (buf >= buf_end && !have_fire) {
+			DRM_ERROR("Missing Vertex Fire command or verifier "
+				  "lost sync.\n");
+			ret = 1;
+			break;
+		}
+		if (cur_seq->agp && ((buf - cur_seq->buf_start) & 0x01)) {
+			DRM_ERROR("AGP Primitive list end misaligned.\n");
+			ret = 1;
+			break;
+		}
+	}
+	*buffer = buf;
+	return ret;
+}
+
+static __inline__ verifier_state_t
+via_check_header2(uint32_t const **buffer, const uint32_t * buf_end,
+		  drm_via_state_t * hc_state)
+{
+	uint32_t cmd;
+	int hz_mode;
+	hazard_t hz;
+	const uint32_t *buf = *buffer;
+	const hazard_t *hz_table;
+
+	if ((buf_end - buf) < 2) {
+		DRM_ERROR
+		    ("Illegal termination of DMA HALCYON_HEADER2 sequence.\n");
+		return state_error;
+	}
+	buf++;
+	cmd = (*buf++ & 0xFFFF0000) >> 16;
+
+	switch (cmd) {
+	case HC_ParaType_CmdVdata:
+		if (via_check_prim_list(&buf, buf_end, hc_state))
+			return state_error;
+		*buffer = buf;
+		return state_command;
+	case HC_ParaType_NotTex:
+		hz_table = table1;
+		break;
+	case HC_ParaType_Tex:
+		hc_state->texture = 0;
+		hz_table = table2;
+		break;
+	case (HC_ParaType_Tex | (HC_SubType_Tex1 << 8)):
+		hc_state->texture = 1;
+		hz_table = table2;
+		break;
+	case (HC_ParaType_Tex | (HC_SubType_TexGeneral << 8)):
+		hz_table = table3;
+		break;
+	case HC_ParaType_Auto:
+		if (eat_words(&buf, buf_end, 2))
+			return state_error;
+		*buffer = buf;
+		return state_command;
+	case (HC_ParaType_Palette | (HC_SubType_Stipple << 8)):
+		if (eat_words(&buf, buf_end, 32))
+			return state_error;
+		*buffer = buf;
+		return state_command;
+	case (HC_ParaType_Palette | (HC_SubType_TexPalette0 << 8)):
+	case (HC_ParaType_Palette | (HC_SubType_TexPalette1 << 8)):
+		DRM_ERROR("Texture palettes are rejected because of "
+			  "lack of info how to determine their size.\n");
+		return state_error;
+	case (HC_ParaType_Palette | (HC_SubType_FogTable << 8)):
+		DRM_ERROR("Fog factor palettes are rejected because of "
+			  "lack of info how to determine their size.\n");
+		return state_error;
+	default:
+
+		/*
+		 * There are some unimplemented HC_ParaTypes here, that
+		 * need to be implemented if the Mesa driver is extended.
+		 */
+
+		DRM_ERROR("Invalid or unimplemented HALCYON_HEADER2 "
+			  "DMA subcommand: 0x%x. Previous dword: 0x%x\n",
+			  cmd, *(buf - 2));
+		*buffer = buf;
+		return state_error;
+	}
+
+	while (buf < buf_end) {
+		cmd = *buf++;
+		if ((hz = hz_table[cmd >> 24])) {
+			if ((hz_mode = investigate_hazard(cmd, hz, hc_state))) {
+				if (hz_mode == 1) {
+					buf--;
+					break;
+				}
+				return state_error;
+			}
+		} else if (hc_state->unfinished &&
+			   finish_current_sequence(hc_state)) {
+			return state_error;
+		}
+	}
+	if (hc_state->unfinished && finish_current_sequence(hc_state)) {
+		return state_error;
+	}
+	*buffer = buf;
+	return state_command;
+}
+
+static __inline__ verifier_state_t
+via_parse_header2(drm_via_private_t * dev_priv, uint32_t const **buffer,
+		  const uint32_t * buf_end, int *fire_count)
+{
+	uint32_t cmd;
+	const uint32_t *buf = *buffer;
+	const uint32_t *next_fire;
+	int burst = 0;
+
+	next_fire = dev_priv->fire_offsets[*fire_count];
+	buf++;
+	cmd = (*buf & 0xFFFF0000) >> 16;
+	VIA_WRITE(HC_REG_TRANS_SET + HC_REG_BASE, *buf++);
+	switch (cmd) {
+	case HC_ParaType_CmdVdata:
+		while ((buf < buf_end) &&
+		       (*fire_count < dev_priv->num_fire_offsets) &&
+		       (*buf & HC_ACMD_MASK) == HC_ACMD_HCmdB) {
+			while (buf <= next_fire) {
+				VIA_WRITE(HC_REG_TRANS_SPACE + HC_REG_BASE +
+					  (burst & 63), *buf++);
+				burst += 4;
+			}
+			if ((buf < buf_end)
+			    && ((*buf & HALCYON_FIREMASK) == HALCYON_FIRECMD))
+				buf++;
+
+			if (++(*fire_count) < dev_priv->num_fire_offsets)
+				next_fire = dev_priv->fire_offsets[*fire_count];
+		}
+		break;
+	default:
+		while (buf < buf_end) {
+
+			if (*buf == HC_HEADER2 ||
+			    (*buf & HALCYON_HEADER1MASK) == HALCYON_HEADER1 ||
+			    (*buf & VIA_VIDEOMASK) == VIA_VIDEO_HEADER5 ||
+			    (*buf & VIA_VIDEOMASK) == VIA_VIDEO_HEADER6)
+				break;
+
+			VIA_WRITE(HC_REG_TRANS_SPACE + HC_REG_BASE +
+				  (burst & 63), *buf++);
+			burst += 4;
+		}
+	}
+	*buffer = buf;
+	return state_command;
+}
+
+static __inline__ int verify_mmio_address(uint32_t address)
+{
+	if ((address > 0x3FF) && (address < 0xC00)) {
+		DRM_ERROR("Invalid VIDEO DMA command. "
+			  "Attempt to access 3D- or command burst area.\n");
+		return 1;
+	} else if ((address > 0xCFF) && (address < 0x1300)) {
+		DRM_ERROR("Invalid VIDEO DMA command. "
+			  "Attempt to access PCI DMA area.\n");
+		return 1;
+	} else if (address > 0x13FF) {
+		DRM_ERROR("Invalid VIDEO DMA command. "
+			  "Attempt to access VGA registers.\n");
+		return 1;
+	}
+	return 0;
+}
+
+static __inline__ int
+verify_video_tail(uint32_t const **buffer, const uint32_t * buf_end,
+		  uint32_t dwords)
+{
+	const uint32_t *buf = *buffer;
+
+	if (buf_end - buf < dwords) {
+		DRM_ERROR("Illegal termination of video command.\n");
+		return 1;
+	}
+	while (dwords--) {
+		if (*buf++) {
+			DRM_ERROR("Illegal video command tail.\n");
+			return 1;
+		}
+	}
+	*buffer = buf;
+	return 0;
+}
+
+static __inline__ verifier_state_t
+via_check_header1(uint32_t const **buffer, const uint32_t * buf_end)
+{
+	uint32_t cmd;
+	const uint32_t *buf = *buffer;
+	verifier_state_t ret = state_command;
+
+	while (buf < buf_end) {
+		cmd = *buf;
+		if ((cmd > ((0x3FF >> 2) | HALCYON_HEADER1)) &&
+		    (cmd < ((0xC00 >> 2) | HALCYON_HEADER1))) {
+			if ((cmd & HALCYON_HEADER1MASK) != HALCYON_HEADER1)
+				break;
+			DRM_ERROR("Invalid HALCYON_HEADER1 command. "
+				  "Attempt to access 3D- or command burst area.\n");
+			ret = state_error;
+			break;
+		} else if (cmd > ((0xCFF >> 2) | HALCYON_HEADER1)) {
+			if ((cmd & HALCYON_HEADER1MASK) != HALCYON_HEADER1)
+				break;
+			DRM_ERROR("Invalid HALCYON_HEADER1 command. "
+				  "Attempt to access VGA registers.\n");
+			ret = state_error;
+			break;
+		} else {
+			buf += 2;
+		}
+	}
+	*buffer = buf;
+	return ret;
+}
+
+static __inline__ verifier_state_t
+via_parse_header1(drm_via_private_t * dev_priv, uint32_t const **buffer,
+		  const uint32_t * buf_end)
+{
+	register uint32_t cmd;
+	const uint32_t *buf = *buffer;
+
+	while (buf < buf_end) {
+		cmd = *buf;
+		if ((cmd & HALCYON_HEADER1MASK) != HALCYON_HEADER1)
+			break;
+		VIA_WRITE((cmd & ~HALCYON_HEADER1MASK) << 2, *++buf);
+		buf++;
+	}
+	*buffer = buf;
+	return state_command;
+}
+
+static __inline__ verifier_state_t
+via_check_vheader5(uint32_t const **buffer, const uint32_t * buf_end)
+{
+	uint32_t data;
+	const uint32_t *buf = *buffer;
+
+	if (buf_end - buf < 4) {
+		DRM_ERROR("Illegal termination of video header5 command\n");
+		return state_error;
+	}
+
+	data = *buf++ & ~VIA_VIDEOMASK;
+	if (verify_mmio_address(data))
+		return state_error;
+
+	data = *buf++;
+	if (*buf++ != 0x00F50000) {
+		DRM_ERROR("Illegal header5 header data\n");
+		return state_error;
+	}
+	if (*buf++ != 0x00000000) {
+		DRM_ERROR("Illegal header5 header data\n");
+		return state_error;
+	}
+	if (eat_words(&buf, buf_end, data))
+		return state_error;
+	if ((data & 3) && verify_video_tail(&buf, buf_end, 4 - (data & 3)))
+		return state_error;
+	*buffer = buf;
+	return state_command;
+
+}
+
+static __inline__ verifier_state_t
+via_parse_vheader5(drm_via_private_t * dev_priv, uint32_t const **buffer,
+		   const uint32_t * buf_end)
+{
+	uint32_t addr, count, i;
+	const uint32_t *buf = *buffer;
+
+	addr = *buf++ & ~VIA_VIDEOMASK;
+	i = count = *buf;
+	buf += 3;
+	while (i--) {
+		VIA_WRITE(addr, *buf++);
+	}
+	if (count & 3)
+		buf += 4 - (count & 3);
+	*buffer = buf;
+	return state_command;
+}
+
+static __inline__ verifier_state_t
+via_check_vheader6(uint32_t const **buffer, const uint32_t * buf_end)
+{
+	uint32_t data;
+	const uint32_t *buf = *buffer;
+	uint32_t i;
+
+	if (buf_end - buf < 4) {
+		DRM_ERROR("Illegal termination of video header6 command\n");
+		return state_error;
+	}
+	buf++;
+	data = *buf++;
+	if (*buf++ != 0x00F60000) {
+		DRM_ERROR("Illegal header6 header data\n");
+		return state_error;
+	}
+	if (*buf++ != 0x00000000) {
+		DRM_ERROR("Illegal header6 header data\n");
+		return state_error;
+	}
+	if ((buf_end - buf) < (data << 1)) {
+		DRM_ERROR("Illegal termination of video header6 command\n");
+		return state_error;
+	}
+	for (i = 0; i < data; ++i) {
+		if (verify_mmio_address(*buf++))
+			return state_error;
+		buf++;
+	}
+	data <<= 1;
+	if ((data & 3) && verify_video_tail(&buf, buf_end, 4 - (data & 3)))
+		return state_error;
+	*buffer = buf;
+	return state_command;
+}
+
+static __inline__ verifier_state_t
+via_parse_vheader6(drm_via_private_t * dev_priv, uint32_t const **buffer,
+		   const uint32_t * buf_end)
+{
+
+	uint32_t addr, count, i;
+	const uint32_t *buf = *buffer;
+
+	i = count = *++buf;
+	buf += 3;
+	while (i--) {
+		addr = *buf++;
+		VIA_WRITE(addr, *buf++);
+	}
+	count <<= 1;
+	if (count & 3)
+		buf += 4 - (count & 3);
+	*buffer = buf;
+	return state_command;
+}
+
+int
+via_verify_command_stream(const uint32_t * buf, unsigned int size,
+			  struct drm_device * dev, int agp)
+{
+
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	drm_via_state_t *hc_state = &dev_priv->hc_state;
+	drm_via_state_t saved_state = *hc_state;
+	uint32_t cmd;
+	const uint32_t *buf_end = buf + (size >> 2);
+	verifier_state_t state = state_command;
+	int cme_video;
+	int supported_3d;
+
+	cme_video = (dev_priv->chipset == VIA_PRO_GROUP_A ||
+		     dev_priv->chipset == VIA_DX9_0);
+
+	supported_3d = dev_priv->chipset != VIA_DX9_0;
+
+	hc_state->dev = dev;
+	hc_state->unfinished = no_sequence;
+	hc_state->map_cache = NULL;
+	hc_state->agp = agp;
+	hc_state->buf_start = buf;
+	dev_priv->num_fire_offsets = 0;
+
+	while (buf < buf_end) {
+
+		switch (state) {
+		case state_header2:
+			state = via_check_header2(&buf, buf_end, hc_state);
+			break;
+		case state_header1:
+			state = via_check_header1(&buf, buf_end);
+			break;
+		case state_vheader5:
+			state = via_check_vheader5(&buf, buf_end);
+			break;
+		case state_vheader6:
+			state = via_check_vheader6(&buf, buf_end);
+			break;
+		case state_command:
+			if ((HALCYON_HEADER2 == (cmd = *buf)) && 
+			    supported_3d)
+				state = state_header2;
+			else if ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1)
+				state = state_header1;
+			else if (cme_video
+				 && (cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER5)
+				state = state_vheader5;
+			else if (cme_video
+				 && (cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER6)
+				state = state_vheader6;
+			else if ((cmd == HALCYON_HEADER2) && !supported_3d) {
+				DRM_ERROR("Accelerated 3D is not supported on this chipset yet.\n");
+				state = state_error;
+			} else {
+				DRM_ERROR
+				    ("Invalid / Unimplemented DMA HEADER command. 0x%x\n",
+				     cmd);
+				state = state_error;
+			}
+			break;
+		case state_error:
+		default:
+			*hc_state = saved_state;
+			return -EINVAL;
+		}
+	}
+	if (state == state_error) {
+		*hc_state = saved_state;
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int
+via_parse_command_stream(struct drm_device * dev, const uint32_t * buf,
+			 unsigned int size)
+{
+
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	uint32_t cmd;
+	const uint32_t *buf_end = buf + (size >> 2);
+	verifier_state_t state = state_command;
+	int fire_count = 0;
+
+	while (buf < buf_end) {
+
+		switch (state) {
+		case state_header2:
+			state =
+			    via_parse_header2(dev_priv, &buf, buf_end,
+					      &fire_count);
+			break;
+		case state_header1:
+			state = via_parse_header1(dev_priv, &buf, buf_end);
+			break;
+		case state_vheader5:
+			state = via_parse_vheader5(dev_priv, &buf, buf_end);
+			break;
+		case state_vheader6:
+			state = via_parse_vheader6(dev_priv, &buf, buf_end);
+			break;
+		case state_command:
+			if (HALCYON_HEADER2 == (cmd = *buf))
+				state = state_header2;
+			else if ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1)
+				state = state_header1;
+			else if ((cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER5)
+				state = state_vheader5;
+			else if ((cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER6)
+				state = state_vheader6;
+			else {
+				DRM_ERROR
+				    ("Invalid / Unimplemented DMA HEADER command. 0x%x\n",
+				     cmd);
+				state = state_error;
+			}
+			break;
+		case state_error:
+		default:
+			return -EINVAL;
+		}
+	}
+	if (state == state_error) {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void
+setup_hazard_table(hz_init_t init_table[], hazard_t table[], int size)
+{
+	int i;
+
+	for (i = 0; i < 256; ++i) {
+		table[i] = forbidden_command;
+	}
+
+	for (i = 0; i < size; ++i) {
+		table[init_table[i].code] = init_table[i].hz;
+	}
+}
+
+void via_init_command_verifier(void)
+{
+	setup_hazard_table(init_table1, table1,
+			   sizeof(init_table1) / sizeof(hz_init_t));
+	setup_hazard_table(init_table2, table2,
+			   sizeof(init_table2) / sizeof(hz_init_t));
+	setup_hazard_table(init_table3, table3,
+			   sizeof(init_table3) / sizeof(hz_init_t));
+}
Index: git/shared-core/via_verifier.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_verifier.h	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2004 The Unichrome Project. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE UNICHROME PROJECT, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Thomas Hellstrm 2004.
+ */
+
+#ifndef _VIA_VERIFIER_H_
+#define _VIA_VERIFIER_H_
+
+typedef enum {
+	no_sequence = 0, 
+	z_address,
+	dest_address,
+	tex_address
+} drm_via_sequence_t;
+
+
+
+typedef struct {
+	unsigned texture;
+	uint32_t z_addr; 
+	uint32_t d_addr; 
+	uint32_t t_addr[2][10];
+	uint32_t pitch[2][10];
+	uint32_t height[2][10];
+	uint32_t tex_level_lo[2]; 
+	uint32_t tex_level_hi[2];
+	uint32_t tex_palette_size[2];
+        uint32_t tex_npot[2];
+	drm_via_sequence_t unfinished;
+	int agp_texture;
+	int multitex;
+	struct drm_device *dev;
+	drm_local_map_t *map_cache;
+	uint32_t vertex_count;
+	int agp;
+	const uint32_t *buf_start;
+} drm_via_state_t;
+
+extern int via_verify_command_stream(const uint32_t * buf, unsigned int size, 
+				    struct drm_device *dev, int agp);
+extern int via_parse_command_stream(struct drm_device *dev, const uint32_t * buf,
+                                   unsigned int size);
+
+#endif
Index: git/shared-core/via_video.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/shared-core/via_video.c	2008-12-12 17:35:22.000000000 +0000
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2005 Thomas Hellstrom. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHOR(S), AND/OR THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Thomas Hellstrom 2005.
+ *
+ * Video and XvMC related functions.
+ */
+
+#include "drmP.h"
+#include "via_drm.h"
+#include "via_drv.h"
+
+void via_init_futex(drm_via_private_t * dev_priv)
+{
+	unsigned int i;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	for (i = 0; i < VIA_NR_XVMC_LOCKS; ++i) {
+		DRM_INIT_WAITQUEUE(&(dev_priv->decoder_queue[i]));
+		XVMCLOCKPTR(dev_priv->sarea_priv, i)->lock = 0;
+	}
+}
+
+void via_cleanup_futex(drm_via_private_t * dev_priv)
+{
+}
+
+void via_release_futex(drm_via_private_t * dev_priv, int context)
+{
+	unsigned int i;
+	volatile int *lock;
+
+	if (!dev_priv->sarea_priv)
+		return;
+
+	for (i = 0; i < VIA_NR_XVMC_LOCKS; ++i) {
+		lock = (volatile int *)XVMCLOCKPTR(dev_priv->sarea_priv, i);
+		if ((_DRM_LOCKING_CONTEXT(*lock) == context)) {
+			if (_DRM_LOCK_IS_HELD(*lock)
+			    && (*lock & _DRM_LOCK_CONT)) {
+				DRM_WAKEUP(&(dev_priv->decoder_queue[i]));
+			}
+			*lock = 0;
+		}
+	}
+}
+
+int via_decoder_futex(struct drm_device *dev, void *data, struct drm_file *file_priv)
+{
+	drm_via_futex_t *fx = data;
+	volatile int *lock;
+	drm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;
+	drm_via_sarea_t *sAPriv = dev_priv->sarea_priv;
+	int ret = 0;
+
+	DRM_DEBUG("%s\n", __FUNCTION__);
+
+	if (fx->lock > VIA_NR_XVMC_LOCKS)
+		return -EFAULT;
+
+	lock = (volatile int *)XVMCLOCKPTR(sAPriv, fx->lock);
+
+	switch (fx->func) {
+	case VIA_FUTEX_WAIT:
+		DRM_WAIT_ON(ret, dev_priv->decoder_queue[fx->lock],
+			    (fx->ms / 10) * (DRM_HZ / 100), *lock != fx->val);
+		return ret;
+	case VIA_FUTEX_WAKE:
+		DRM_WAKEUP(&(dev_priv->decoder_queue[fx->lock]));
+		return 0;
+	}
+	return 0;
+}
