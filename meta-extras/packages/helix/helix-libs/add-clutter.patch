Index: helix-libs/clientapps/clutter/LICENSE.txt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/LICENSE.txt	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,30 @@
+ Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.  
+        
+ The contents of this directory, and (except where otherwise
+ indicated) the directories included within this directory, are
+ subject to the current version of the RealNetworks Public Source
+ License (the "RPSL") available at RPSL.txt in this directory, unless
+ you have licensed the directory under the current version of the
+ RealNetworks Community Source License (the "RCSL") available at
+ RCSL.txt in this directory, in which case the RCSL will apply. You
+ may also obtain the license terms directly from RealNetworks.  You
+ may not use the files in this directory except in compliance with the
+ RPSL or, if you have a valid RCSL with RealNetworks applicable to
+ this directory, the RCSL.  Please see the applicable RPSL or RCSL for
+ the rights, obligations and limitations governing use of the contents
+ of the directory.
+ 
+ This directory is part of the Helix DNA Technology. RealNetworks is
+ the developer of the Original Code and owns the copyrights in the
+ portions it created.
+   
+ This directory, and the directories included with this directory, are
+ distributed and made available on an 'AS IS' basis, WITHOUT WARRANTY
+ OF ANY KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY
+ DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY
+ WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
+ QUIET ENJOYMENT OR NON-INFRINGEMENT.
+  
+ Technology Compatibility Kit Test Suite(s) Location:  
+    http://www.helixcommunity.org/content/tck  
+
Index: helix-libs/clientapps/clutter/RCSL.txt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/RCSL.txt	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,948 @@
+The RCSL is made up of a base agreement and a few Attachments.
+
+For Research and Development use, you agree to the terms of the
+RCSL R&D License (base RCSL and Attachments A, B, and C) 
+
+For Commercial Use (either distribution or internal commercial
+deployment) of the Helix DNA with or without support for RealNetworks'
+RealAudio and RealVideo Add-on Technology, you agree to the
+terms of the same RCSL R&D license
+and execute one or more additional Commercial Use License attachments
+<see http://www.helixcommunity.org/content/rcsl-attachments>.
+
+------------------------------------------------------------------------
+
+
+    REALNETWORKS COMMUNITY SOURCE LICENSE
+
+Version 1.2 (Rev. Date: January 22, 2003).
+
+
+  RECITALS
+
+Original Contributor has developed Specifications, Source Code
+implementations and Executables of certain Technology; and
+
+Original Contributor desires to license the Technology to a large
+community to facilitate research, innovation and product development
+while maintaining compatibility of such products with the Technology as
+delivered by Original Contributor; and
+
+Original Contributor desires to license certain Trademarks for the
+purpose of branding products that are compatible with the relevant
+Technology delivered by Original Contributor; and
+
+You desire to license the Technology and possibly certain Trademarks
+from Original Contributor on the terms and conditions specified in this
+License.
+
+In consideration for the mutual covenants contained herein, You and
+Original Contributor agree as follows:
+
+
+  AGREEMENT
+
+*1. Introduction.*
+
+The RealNetworks Community Source License ("RCSL") and effective
+attachments ("License") may include five distinct licenses:
+
+i) Research Use license -- License plus Attachments A, B and C only.
+
+ii) Commercial Use and Trademark License, which may be for Internal
+Deployment Use or external distribution, or both -- License plus
+Attachments A, B, C, and D.
+
+iii) Technology Compatibility Kit (TCK) license -- Attachment C.
+
+iv) Add-On Technology License (Executable) Commercial Use License
+-Attachment F.
+
+v) Add-On Technology Source Code Porting and Optimization
+License-Attachment G.
+
+The Research Use license is effective when You click and accept this
+License. The TCK is effective when You click and accept this License,
+unless otherwise specified in the TCK attachments. The Commercial Use
+and Trademark, Add-On Technology License, and the Add-On Technology
+Source Code Porting and Optimization licenses must each be signed by You
+and Original Contributor to become effective. Once effective, these
+licenses and the associated requirements and responsibilities are
+cumulative. Capitalized terms used in this License are defined in the
+Glossary.
+
+*2. License Grants.*
+
+2.1 Original Contributor Grant.
+
+Subject to Your compliance with Sections 3, 8.10 and Attachment A of
+this License, Original Contributor grants to You a worldwide,
+royalty-free, non-exclusive license, to the extent of Original
+Contributor's Intellectual Property Rights covering the Original Code,
+Upgraded Code and Specifications, to do the following:
+
+(a) Research Use License:
+
+(i) use, reproduce and modify the Original Code, Upgraded Code and
+Specifications to create Modifications and Reformatted Specifications
+for Research Use by You;
+
+(ii) publish and display Original Code, Upgraded Code and Specifications
+with, or as part of Modifications, as permitted under Section 3.1(b) below;
+
+(iii) reproduce and distribute copies of Original Code and Upgraded Code
+to Licensees and students for Research Use by You;
+
+(iv) compile, reproduce and distribute Original Code and Upgraded Code
+in Executable form, and Reformatted Specifications to anyone for
+Research Use by You.
+
+(b) Other than the licenses expressly granted in this License, Original
+Contributor retains all right, title, and interest in Original Code and
+Upgraded Code and Specifications.
+
+2.2 Your Grants.
+
+(a) To Other Licensees. You hereby grant to each Licensee a license to
+Your Error Corrections and Shared Modifications, of the same scope and
+extent as Original Contributor's licenses under Section 2.1 a) above
+relative to Research Use and Attachment D relative to Commercial Use.
+
+(b) To Original Contributor. You hereby grant to Original Contributor a
+worldwide, royalty-free, non-exclusive, perpetual and irrevocable
+license, to the extent of Your Intellectual Property Rights covering
+Your Error Corrections, Shared Modifications and Reformatted
+Specifications, to use, reproduce, modify, display and distribute Your
+Error Corrections, Shared Modifications and Reformatted Specifications,
+in any form, including the right to sublicense such rights through
+multiple tiers of distribution.
+
+(c) Other than the licenses expressly granted in Sections 2.2(a) and (b)
+above, and the restrictions set forth in Section 3.1(d)(iv) below, You
+retain all right, title, and interest in Your Error Corrections, Shared
+Modifications and Reformatted Specifications.
+
+2.3 Contributor Modifications.
+
+You may use, reproduce, modify, display and distribute Contributor Error
+Corrections, Shared Modifications and Reformatted Specifications,
+obtained by You under this License, to the same scope and extent as with
+Original Code, Upgraded Code and Specifications.
+
+2.4 Subcontracting.
+
+You may deliver the Source Code of Covered Code to other Licensees
+having at least a Research Use license, for the sole purpose of
+furnishing development services to You in connection with Your rights
+granted in this License. All such Licensees must execute appropriate
+documents with respect to such work consistent with the terms of this
+License, and acknowledging their work-made-for-hire status or assigning
+exclusive right to the work product and associated Intellectual Property
+Rights to You.
+
+*3. Requirements and Responsibilities*.
+
+3.1 Research Use License.
+
+As a condition of exercising the rights granted under Section 2.1(a)
+above, You agree to comply with the following:
+
+(a) Your Contribution to the Community. All Error Corrections and Shared
+Modifications which You create or contribute to are automatically
+subject to the licenses granted under Section 2.2 above. You are
+encouraged to license all of Your other Modifications under Section 2.2
+as Shared Modifications, but are not required to do so. You agree to
+notify Original Contributor of any errors in the Specification.
+
+(b) Source Code Availability. You agree to provide all Your Error
+Corrections to Original Contributor as soon as reasonably practicable
+and, in any event, prior to Internal Deployment Use or Commercial Use,
+if applicable. Original Contributor may, at its discretion, post Source
+Code for Your Error Corrections and Shared Modifications on the
+Community Webserver. You may also post Error Corrections and Shared
+Modifications on a web-server of Your choice; provided, that You must
+take reasonable precautions to ensure that only Licensees have access to
+such Error Corrections and Shared Modifications. Such precautions shall
+include, without limitation, a password protection scheme limited to
+Licensees and a click-on, download certification of Licensee status
+required of those attempting to download from the server. An example of
+an acceptable certification is attached as Attachment A-2.
+
+(c) Notices. All Error Corrections and Shared Modifications You create
+or contribute to must include a file documenting the additions and
+changes You made and the date of such additions and changes. You must
+also include the notice set forth in Attachment A-1 in the file header.
+If it is not possible to put the notice in a particular Source Code file
+due to its structure, then You must include the notice in a location
+(such as a relevant directory file), where a recipient would be most
+likely to look for such a notice.
+
+(d) Redistribution.
+
+(i) Source. Covered Code may be distributed in Source Code form only to
+another Licensee (except for students as provided below). You may not
+offer or impose any terms on any Covered Code that alter the rights,
+requirements, or responsibilities of such Licensee. You may distribute
+Covered Code to students for use in connection with their course work
+and research projects undertaken at accredited educational institutions.
+Such students need not be Licensees, but must be given a copy of the
+notice set forth in Attachment A-3 and such notice must also be included
+in a file header or prominent location in the Source Code made available
+to such students.
+
+(ii) Executable. You may distribute Executable version(s) of Covered
+Code to Licensees and other third parties only for the purpose of
+evaluation and comment in connection with Research Use by You and under
+a license of Your choice, but which limits use of such Executable
+version(s) of Covered Code only to that purpose.
+
+(iii) Modified Class, Interface and Package Naming. In connection with
+Research Use by You only, You may use Original Contributor's class,
+Interface and package names only to accurately reference or invoke the
+Source Code files You modify. Original Contributor grants to You a
+limited license to the extent necessary for such purposes.
+
+(iv) You expressly agree that any distribution, in whole or in part, of
+Modifications developed by You shall only be done pursuant to the terms
+and conditions of this License.
+
+(e) Extensions.
+
+(i) Covered Code. You may not include any Source Code of Community Code
+in any Extensions. You may include the compiled Header Files of
+Community Code in an Extension provided that Your use of the Covered
+Code, including Heading Files, complies with the Commercial Use License,
+the TCK and all other terms of this License.
+
+(ii) Publication. No later than the date on which You first distribute
+such Extension for Commercial Use, You must publish to the industry, on
+a non-confidential basis and free of all copyright restrictions with
+respect to reproduction and use, an accurate and current specification
+for any Extension. In addition, You must make available an appropriate
+test suite, pursuant to the same rights as the specification,
+sufficiently detailed to allow any third party reasonably skilled in the
+technology to produce implementations of the Extension compatible with
+the specification. Such test suites must be made available as soon as
+reasonably practicable but, in no event, later than ninety (90) days
+after Your first Commercial Use of the Extension. You must use
+reasonable efforts to promptly clarify and correct the specification and
+the test suite upon written request by Original Contributor.
+
+(iii) Open. You agree to refrain from enforcing any Intellectual
+Property Rights You may have covering any interface(s) of Your
+Extension, which would prevent the implementation of such interface(s)
+by Original Contributor or any Licensee. This obligation does not
+prevent You from enforcing any Intellectual Property Right You have that
+would otherwise be infringed by an implementation of Your Extension.
+
+(iv) Interface Modifications and Naming. You may not modify or add to
+the GUID space * * "xxxxxxxx-0901-11d1-8B06-00A024406D59" or any other
+GUID space designated by Original Contributor. You may not modify any
+Interface prefix provided with the Covered Code or any other prefix
+designated by Original Contributor.* *
+
+* *
+
+(f) You agree that any Specifications provided to You by Original
+Contributor are confidential and proprietary information of Original
+Contributor. You must maintain the confidentiality of the Specifications
+and may not disclose them to any third party without Original
+Contributor's prior written consent. You may only use the Specifications
+under the terms of this License and only for the purpose of implementing
+the terms of this License with respect to Covered Code. You agree not
+use, copy or distribute any such Specifications except as provided in
+writing by Original Contributor.
+
+3.2 Commercial Use License.
+
+You may not make Commercial Use of any Covered Code unless You and
+Original Contributor have executed a copy of the Commercial Use and
+Trademark License attached as Attachment D.
+
+*4. Versions of the License.*
+
+4.1 License Versions.
+
+Original Contributor may publish revised versions of the License from
+time to time. Each version will be given a distinguishing version number.
+
+4.2 Effect.
+
+Once a particular version of Covered Code has been provided under a
+version of the License, You may always continue to use such Covered Code
+under the terms of that version of the License. You may also choose to
+use such Covered Code under the terms of any subsequent version of the
+License. No one other than Original Contributor has the right to
+promulgate License versions.
+
+4.3 Multiple-Licensed Code.
+
+Original Contributor may designate portions of the Covered Code as
+"Multiple-Licensed." "Multiple-Licensed" means that the Original
+Contributor permits You to utilize those designated portions of the
+Covered Code under Your choice of this License or the alternative
+license(s), if any, specified by the Original Contributor in an
+Attachment to this License.
+
+*5. Disclaimer of Warranty.*
+
+5.1 COVERED CODE PROVIDED AS IS.
+
+COVERED CODE IS PROVIDED UNDER THIS LICENSE "AS IS," WITHOUT WARRANTY OF
+ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
+WARRANTIES THAT THE COVERED CODE IS FREE OF DEFECTS, MERCHANTABLE, FIT
+FOR A PARTICULAR PURPOSE OR NON-INFRINGING. YOU AGREE TO BEAR THE ENTIRE
+RISK IN CONNECTION WITH YOUR USE AND DISTRIBUTION OF COVERED CODE UNDER
+THIS LICENSE. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART
+OF THIS LICENSE. NO USE OF ANY COVERED CODE IS AUTHORIZED HEREUNDER
+EXCEPT SUBJECT TO THIS DISCLAIMER.
+
+5.2 Not Designed for High Risk Activities.
+
+You acknowledge that Original Code, Upgraded Code and Specifications are
+not designed or intended for use in high risk activities including, but
+not limited to: (i) on-line control of aircraft, air traffic, aircraft
+navigation or aircraft communications; or (ii) in the design,
+construction, operation or maintenance of any nuclear facility. Original
+Contributor disclaims any express or implied warranty of fitness for
+such uses.
+
+*6. Termination.*
+
+6.1 By You.
+
+You may terminate this Research Use license at anytime by providing
+written notice to Original Contributor.
+
+6.2 By Original Contributor.
+
+This License and the rights granted hereunder will terminate:
+
+(i) automatically if You fail to comply with the terms of this License
+and fail to cure such breach within 30 days of receipt of written notice
+of the breach;
+
+(ii) immediately in the event of circumstances specified in Sections 7.1
+and 8.4; or
+
+(iii) at Original Contributor's discretion upon any action initiated by
+You (including by cross-claim or counter claim) alleging that use or
+distribution by Original Contributor or any Licensee, of Original Code,
+Upgraded Code, Error Corrections, Shared Modifications or Specifications
+infringe a patent owned or controlled by You.
+
+6.3 Effective of Termination.
+
+Upon termination, You agree to discontinue use of and destroy all copies
+of Covered Code in Your possession. All sublicenses to the Covered Code
+which You have properly granted shall survive any termination of this
+License. Provisions that, by their nature, should remain in effect
+beyond the termination of this License shall survive including, without
+limitation, Sections 2.2, 3, 5, 7 and 8.
+
+6.4 No Compensation.
+
+Each party waives and releases the other from any claim to compensation
+or indemnity for permitted or lawful termination of the business
+relationship established by this License.
+
+*7. Liability.*
+
+7.1 Infringement. Should any of the Original Code, Upgraded Code, TCK or
+Specifications ("Materials") become the subject of a claim of
+infringement, Original Contributor may, at its sole option, (i) attempt
+to procure the rights necessary for You to continue using the Materials,
+(ii) modify the Materials so that they are no longer infringing, or
+(iii) terminate Your right to use the Materials, immediately upon
+written notice, and refund to You the amount, if any, having then
+actually been paid by You to Original Contributor for the Original Code,
+Upgraded Code and TCK, depreciated on a straight line, five year basis.
+
+7.2 LIMITATION OF LIABILITY. TO THE FULL EXTENT ALLOWED BY APPLICABLE
+LAW, ORIGINAL CONTRIBUTOR'S LIABILITY TO YOU FOR CLAIMS RELATING TO THIS
+LICENSE, WHETHER FOR BREACH OR IN TORT, SHALL BE LIMITED TO ONE HUNDRED
+PERCENT (100%) OF THE AMOUNT HAVING THEN ACTUALLY BEEN PAID BY YOU TO
+ORIGINAL CONTRIBUTOR FOR ALL COPIES LICENSED HEREUNDER OF THE PARTICULAR
+ITEMS GIVING RISE TO SUCH CLAIM, IF ANY, DURING THE TWELVE MONTHS
+PRECEDING THE CLAIMED BREACH. IN NO EVENT WILL YOU (RELATIVE TO YOUR
+SHARED MODIFICATIONS OR ERROR CORRECTIONS) OR ORIGINAL CONTRIBUTOR BE
+LIABLE FOR ANY INDIRECT, PUNITIVE, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
+DAMAGES IN CONNECTION WITH OR RISING OUT OF THIS LICENSE (INCLUDING,
+WITHOUT LIMITATION, LOSS OF PROFITS, USE, DATA, OR OTHER ECONOMIC
+ADVANTAGE), HOWEVER IT ARISES AND ON ANY THEORY OF LIABILITY, WHETHER IN
+AN ACTION FOR CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE)
+OR OTHERWISE, WHETHER OR NOT YOU OR ORIGINAL CONTRIBUTOR HAS BEEN
+ADVISED OF THE POSSIBILITY OF SUCH DAMAGE AND NOTWITHSTANDING THE
+FAILURE OF ESSENTIAL PURPOSE OF ANY REMEDY.
+
+*8. Miscellaneous.*
+
+8.1 Trademark.
+
+You shall not use any Trademark unless You and Original Contributor
+execute a copy of the Commercial Use and Trademark License Agreement
+attached hereto as Attachment D. Except as expressly provided in the
+License, You are granted no right, title or license to, or interest in,
+any Trademarks. Whether or not You and Original Contributor enter into
+the Trademark License, You agree not to (i) challenge Original
+Contributor's ownership or use of Trademarks; (ii) attempt to register
+any Trademarks, or any mark or logo substantially similar thereto; or
+(iii) incorporate any Trademarks into Your own trademarks, product
+names, service marks, company names, or domain names.
+
+8.2 Integration.
+
+This License represents the complete agreement concerning the subject
+matter hereof.
+
+8.3 Assignment.
+
+Original Contributor may assign this License, and its rights and
+obligations hereunder, in its sole discretion. You may assign the
+Research Use portions of this License and the TCK license to a third
+party upon prior written notice to Original Contributor (which may be
+provided electronically via the Community Web-Server). You may not
+assign the Commercial Use and Trademark license, the Add-On Technology
+License, or the Add-On Technology Source Code Porting License, including
+by way of merger (regardless of whether You are the surviving entity) or
+acquisition, without Original Contributor's prior written consent.
+
+8.4 Severability.
+
+If any provision of this License is held to be unenforceable, such
+provision shall be reformed only to the extent necessary to make it
+enforceable. Notwithstanding the foregoing, if You are prohibited by law
+from fully and specifically complying with Sections 2.2 or 3, this
+License will immediately terminate and You must immediately discontinue
+any use of Covered Code.
+
+8.5 Governing Law.
+
+This License shall be governed by the laws of the United States and the
+State of Washington, as applied to contracts entered into and to be
+performed in Washington between Washington residents. The application of
+the United Nations Convention on Contracts for the International Sale of
+Goods is expressly excluded. You agree that the state and federal courts
+located in Seattle, Washington have exclusive jurisdiction over any
+claim relating to the License, including contract and tort claims.
+
+8.6 Dispute Resolution.
+
+a) Arbitration. Any dispute arising out of or relating to this License
+shall be finally settled by arbitration as set out herein, except that
+either party may bring any action, in a court of competent jurisdiction
+(which jurisdiction shall be exclusive), with respect to any dispute
+relating to such party's Intellectual Property Rights or with respect to
+Your compliance with the TCK license. Arbitration shall be administered:
+(i) by the American Arbitration Association (AAA), (ii) in accordance
+with the rules of the United Nations Commission on International Trade
+Law (UNCITRAL) (the "Rules") in effect at the time of arbitration as
+modified herein; and (iii) the arbitrator will apply the substantive
+laws of Washington and the United States. Judgment upon the award
+rendered by the arbitrator may be entered in any court having
+jurisdiction to enforce such award.
+
+b) Arbitration language, venue and damages. All arbitration proceedings
+shall be conducted in English by a single arbitrator selected in
+accordance with the Rules, who must be fluent in English and be either a
+retired judge or practicing attorney having at least ten (10) years
+litigation experience and be reasonably familiar with the technology
+matters relative to the dispute. Unless otherwise agreed, arbitration
+venue shall be in Seattle, Washington. The arbitrator may award monetary
+damages only and nothing shall preclude either party from seeking
+provisional or emergency relief from a court of competent jurisdiction.
+The arbitrator shall have no authority to award damages in excess of
+those permitted in this License and any such award in excess is void.
+All awards will be payable in U.S. dollars and may include, for the
+prevailing party (i) pre-judgment award interest, (ii) reasonable
+attorneys' fees incurred in connection with the arbitration, and (iii)
+reasonable costs and expenses incurred in enforcing the award. The
+arbitrator will order each party to produce identified documents and
+respond to no more than twenty-five single question interrogatories.
+
+8.7 Construction.
+
+Any law or regulation, which provides that the language of a contract
+shall be construed against the drafter, shall not apply to this License.
+
+8.8 U.S. Government End Users.
+
+The Covered Code is a "commercial item," as that term is defined in 48
+C.F.R. 2.101 (Oct. 1995), consisting of "commercial computer software"
+and "commercial computer software documentation," as such terms are used
+in 48 C.F.R. 12.212 (Sept. 1995). Consistent with 48 C.F.R. 12.212 and
+48 C.F.R. 227.7202-1 through 227.7202-4 (June 1995), all U.S. Government
+End Users acquire Covered Code with only those rights set forth herein.
+You agree to pass this notice to our licensees.
+
+8.9 Marketing Activities.
+
+Licensee hereby grants Original Contributor a non-exclusive,
+non-transferable, limited license to use the Licensee's company name and
+logo ("Licensee Marks") in any presentations, press releases, or
+marketing materials solely for the purpose of identifying Licensee as a
+member of the Helix Community. Licensee shall provide samples of
+Licensee Marks to Original Contributor upon request by Original
+Contributor. Original Contributor acknowledges that the Licensee Marks
+are the trademarks of Licensee. Original Contributor shall not use the
+Licensee Marks in a way that may imply that Original Contributor is an
+agency or branch of Licensee. Original Contributor understands and
+agrees that the use of any Licensee Marks in connection with this
+Agreement shall not create any right, title or interest, in, or to the
+Licensee Marks or any Licensee trademarks and that all such use and
+goodwill associated with any such trademarks will inure to the benefit
+of Licensee. Further the Original Contributor will stop usage of the
+Licensee Marks upon Licensee's request.
+
+8.10 Press Announcements.
+
+You may make press announcements or other public statements regarding
+this License without the prior written consent of the Original
+Contributor, if Your statement is limited to announcing the licensing of
+the Covered Code or the availability of Your Product and its
+compatibility with the Covered Code. All other public announcements
+regarding this license require the prior written consent of the Original
+Contributor. Consent requests are welcome at press@helixcommunity.org.
+
+8.11 International Use.
+
+a) Export/Import laws. Covered Code is subject to U.S. export control
+laws and may be subject to export or import regulations in other
+countries. Each party agrees to comply strictly with all such laws and
+regulations and acknowledges their responsibility to obtain such
+licenses to export, re-export, or import as may be required. You agree
+to pass these obligations to Your licensees.
+
+b) Intellectual Property Protection. Due to limited intellectual
+property protection and enforcement in certain countries, You agree not
+to redistribute the Original Code, Upgraded Code, TCK and Specifications
+to any country on the list of restricted countries on the Community Web
+Server.
+
+8.12 Language.
+
+This License is in the English language only, which language shall be
+controlling in all respects, and all versions of this License in any
+other language shall be for accommodation only and shall not be binding
+on the parties to this License. All communications and notices made or
+given pursuant to this License, and all documentation and support to be
+provided, unless otherwise noted, shall be in the English language.
+
+PLEASE READ THE TERMS OF THIS LICENSE CAREFULLY. BY CLICKING ON THE
+"ACCEPT" BUTTON BELOW YOU ARE ACCEPTING AND AGREEING TO THE TERMS AND
+CONDITIONS OF THIS LICENSE WITH REALNETWORKS, INC. IF YOU ARE AGREEING
+TO THIS LICENSE ON BEHALF OF A COMPANY, YOU REPRESENT THAT YOU ARE
+AUTHORIZED TO BIND THE COMPANY TO SUCH A LICENSE. WHETHER YOU ARE ACTING
+ON YOUR OWN BEHALF, OR REPRESENTING A COMPANY, YOU MUST BE OF MAJORITY
+AGE AND BE OTHERWISE COMPETENT TO ENTER INTO CONTRACTS. IF YOU DO NOT
+MEET THIS CRITERIA OR YOU DO NOT AGREE TO ANY OF THE TERMS AND
+CONDITIONS OF THIS LICENSE, CLICK ON THE REJECT BUTTON TO EXIT.
+
+
+    GLOSSARY
+
+1. *"Added Value"* means code which:
+
+(i) has a principal purpose which is substantially different from that
+of the stand-alone Technology;
+
+(ii) represents a significant functional and value enhancement to the
+Technology;
+
+(iii) operates in conjunction with the Technology; and
+
+(iv) is not marketed as a technology which replaces or substitutes for
+the Technology
+
+2. "*Applicable Patent Rights*" mean: (a) in the case where Original
+Contributor is the grantor of rights, claims of patents that (i) are now
+or hereafter acquired, owned by or assigned to Original Contributor and
+(ii) are necessarily infringed by using or making the Original Code or
+Upgraded Code, including Modifications provided by Original Contributor,
+alone and not in combination with other software or hardware; and (b) in
+the case where Licensee is the grantor of rights, claims of patents that
+(i) are now or hereafter acquired, owned by or assigned to Licensee and
+(ii) are infringed (directly or indirectly) by using or making
+Licensee's Modifications or Error Corrections, taken alone or in
+combination with Covered Code.
+
+3. "*Application Programming Interfaces (APIs)"* means the interfaces,
+associated header files, service provider interfaces, and protocols that
+enable a device, application, Operating System, or other program to
+obtain services from or make requests of (or provide services in
+response to requests from) other programs, and to use, benefit from, or
+rely on the resources, facilities, and capabilities of the relevant
+programs using the APIs. APIs includes the technical documentation
+describing the APIs, the Source Code constituting the API, and any
+Header Files used with the APIs.
+
+4. "*Commercial Use*" means any use (internal or external), copying,
+sublicensing or distribution (internal or external), directly or
+indirectly of Covered Code by You other than Your Research Use of
+Covered Code within Your business or organization or in conjunction with
+other Licensees with equivalent Research Use rights. Commercial Use
+includes any use of the Covered Code for direct or indirect commercial
+or strategic gain, advantage or other business purpose. Any Commercial
+Use requires execution of Attachment D by You and Original Contributor.
+
+5. "*Community Code*" means the Original Code, Upgraded Code, Error
+Corrections, Shared Modifications, or any combination thereof.
+
+6. "*Community Webserver(s)"* means the webservers designated by
+Original Contributor for access to the Original Code, Upgraded Code, TCK
+and Specifications and for posting Error Corrections and Shared
+Modifications.
+
+7. "*Compliant Covered Code*" means Covered Code that complies with the
+requirements of the TCK.
+
+8. "*Contributor*" means each Licensee that creates or contributes to
+the creation of any Error Correction or Shared Modification.
+
+9. "*Covered Code*" means the Original Code, Upgraded Code,
+Modifications, or any combination thereof.
+
+10. "*Error Correction*" means any change made to Community Code which
+conforms to the Specification and corrects the adverse effect of a
+failure of Community Code to perform any function set forth in or
+required by the Specifications.
+
+11. "*Executable*" means Covered Code that has been converted from
+Source Code to the preferred form for execution by a computer or digital
+processor (e.g. binary form).
+
+12. "*Extension(s)"* means any additional Interfaces developed by or for
+You which: (i) are designed for use with the Technology; (ii) constitute
+an API for a library of computing functions or services; and (iii) are
+disclosed or otherwise made available to third party software developers
+for the purpose of developing software which invokes such additional
+Interfaces. The foregoing shall not apply to software developed by Your
+subcontractors to be exclusively used by You.
+
+13. "*Header File(s)"* means that portion of the Source Code that
+provides the names and types of member functions, data members, class
+definitions, and interface definitions necessary to implement the APIs
+for the Covered Code. Header Files include, files specifically
+designated by Original Contributor as Header Files. Header Files do not
+include the code necessary to implement the functionality underlying the
+Interface.
+
+14. *"Helix DNA Server Technology"* means the program(s) that implement
+the Helix Universal Server streaming engine for the Technology as
+defined in the Specification.
+
+15. *"Helix DNA Client Technology"* means the Covered Code that
+implements the RealOne Player engine as defined in the Specification.
+
+16. *"Helix DNA Producer Technology"* means the Covered Code that
+implements the Helix Producer engine as defined in the Specification.
+
+17. *"Helix DNA Technology"* means the Helix DNA Server Technology, the
+Helix DNA Client Technology, the Helix DNA Producer Technology and other
+Helix technologies designated by Original Contributor.
+
+18. "*Intellectual Property Rights*" means worldwide statutory and
+common law rights associated solely with (i) Applicable Patent Rights;
+(ii) works of authorship including copyrights, copyright applications,
+copyright registrations and "moral rights"; (iii) the protection of
+trade and industrial secrets and confidential information; and (iv)
+divisions, continuations, renewals, and re-issuances of the foregoing
+now existing or acquired in the future.
+
+19. *"Interface*" means interfaces, functions, properties, class
+definitions, APIs, Header Files, GUIDs, V-Tables, and/or protocols
+allowing one piece of software, firmware or hardware to communicate or
+interoperate with another piece of software, firmware or hardware.
+
+20. "*Internal Deployment Use*" means use of Compliant Covered Code
+(excluding Research Use) within Your business or organization only by
+Your employees and/or agents on behalf of Your business or organization,
+but not to provide services, including content distribution, to third
+parties, subject to execution of Attachment D by You and Original
+Contributor, if required.
+
+21. "*Licensee*" means any party that has entered into and has in effect
+a version of this License with Original Contributor.
+
+22. "*MIME type*" means a description of what type of media or other
+content is in a file, including by way of example but not limited to
+'audio/x-pn-realaudio-plugin.'
+
+23. "*Modification(s)"* means (i) any addition to, deletion from and/or
+change to the substance and/or structure of the Covered Code, including
+Interfaces; (ii) the combination of any Covered Code and any previous
+Modifications; (iii) any new file or other representation of computer
+program statements that contains any portion of Covered Code; and/or
+(iv) any new Source Code implementing any portion of the Specifications.
+
+24. "*MP3 Patents*" means any patents necessary to make, use or sell
+technology implementing any portion of the specification developed by
+the Moving Picture Experts Group known as MPEG-1 Audio Layer-3 or MP3,
+including but not limited to all past and future versions, profiles,
+extensions, parts and amendments relating to the MP3 specification.
+
+25. "*MPEG-4 Patents*" means any patents necessary to make, use or sell
+technology implementing any portion of the specification developed by
+the Moving Pictures Experts Group known as MPEG-4, including but not
+limited to all past and future versions, profiles, extensions, parts and
+amendments relating to the MPEG-4 specification.
+
+26. "*Original Code*" means the initial Source Code for the Technology
+as described on the Community Web Server.
+
+27. "*Original Contributor*" means RealNetworks, Inc., its affiliates
+and its successors and assigns.
+
+28. "*Original Contributor MIME Type*" means the MIME registry, browser
+preferences, or local file/protocol associations invoking any Helix DNA
+Client-based application, including the RealOne Player, for playback of
+RealAudio, RealVideo, other RealMedia MIME types or datatypes (e.g.,
+.ram, .rnx, .rpm, .ra, .rm, .rp, .rt, .rf, .prx, .mpe, .rmp, .rmj, .rav,
+.rjs, .rmx, .rjt, .rms), and any other Original Contributor-specific or
+proprietary MIME types that Original Contributor may introduce in the
+future.
+
+29. "*Personal Use*" means use of Covered Code by an individual solely
+for his or her personal, private and non-commercial purposes. An
+individual's use of Covered Code in his or her capacity as an officer,
+employee, member, independent contractor or agent of a corporation,
+business or organization (commercial or non-commercial) does not qualify
+as Personal Use.
+
+30. "*RealMedia File Format*" means the file format designed and
+developed by RealNetworks for storing multimedia data and used to store
+RealAudio and RealVideo encoded streams. Valid RealMedia File Format
+extensions include: .rm, .rmj, .rmc, .rmvb, .rms.
+
+31. "*RCSL Webpage*" means the RealNetworks Community Source License
+webpage located at https://www.helixcommunity.org/content/rcsl or such
+other URL that Original Contributor may designate from time to time.
+
+32. "*Reformatted Specifications*" means any revision to the
+Specifications which translates or reformats the Specifications (as for
+example in connection with Your documentation) but which does not alter,
+subset or superset * *the functional or operational aspects of the
+Specifications.
+
+33. "*Research Use*" means use and distribution of Covered Code only for
+Your Personal Use, research or development use and expressly excludes
+Internal Deployment Use and Commercial Use. Research Use also includes
+use of Covered Code to teach individuals how to use Covered Code.
+
+34. "*Shared Modifications*" means Modifications that You distribute or
+use for a Commercial Use, in addition to any Modifications provided by
+You, at Your option, pursuant to Section 2.2, or received by You from a
+Contributor pursuant to Section 2.3.
+
+35. "*Source Code*" means the preferred form of the Covered Code for
+making modifications to it, including all modules it contains, plus any
+associated interface definition files, scripts used to control
+compilation and installation of an Executable, or source code
+differential comparisons against either the Original Code or another
+well known, available Covered Code of the Contributor's choice. The
+Source Code can be in a compressed or archival form, provided the
+appropriate decompression or de-archiving software is widely available
+for no charge.
+
+36. "*Specifications*" means the specifications for the Technology and
+other documentation, as designated on the Community Web Server, as may
+be revised by Original Contributor from time to time.
+
+37. "*Trademarks*" means Original Contributor's trademarks and logos,
+including, but not limited to, RealNetworks, RealAudio, RealVideo,
+RealOne, RealSystem, SureStream, Helix, Helix DNA and other trademarks
+whether now used or adopted in the future.
+
+38. "*Technology*" means the technology described in Attachment B, and
+Upgrades.
+
+39. "*Technology Compatibility Kit"* or *"TCK*" means the test programs,
+procedures, acceptance criteria and/or other requirements, designated by
+Original Contributor for use in verifying compliance of Covered Code
+with the Specifications, in conjunction with the Original Code and
+Upgraded Code. Original Contributor may, in its sole discretion and from
+time to time, revise a TCK to correct errors and/or omissions and in
+connection with Upgrades.
+
+40. "*Upgrade(s)"* means new versions of Technology designated
+exclusively by Original Contributor as an "Upgrade" and released by
+Original Contributor from time to time under the terms of the License.
+
+41. "*Upgraded Code*" means the Source Code and/or Executables for
+Upgrades, possibly including Modifications made by Contributors.
+
+42. *"User's Guide"* means the users guide for the TCK which Original
+Contributor makes available to You to provide direction in how to run
+the TCK and properly interpret the results, as may be revised by
+Original Contributor from time to time.
+
+43. "*You(r)*" means an individual, or a legal entity acting by and
+through an individual or individuals, exercising rights either under
+this License or under a future version of this License issued pursuant
+to Section 4.1. For legal entities, "You(r)" includes any entity that by
+majority voting interest controls, is controlled by, or is under common
+control with You.
+
+44. "*Your Products*" means any (i) hardware products You distribute
+integrating the Covered Code; (ii) any software products You distribute
+with the Covered Code that utilize the APIs of the Covered Code; or
+(iii) any services You provide using the Covered Code.
+
+
+  ATTACHMENT A
+
+REQUIRED NOTICES
+
+
+    ATTACHMENT A-1
+
+REQUIRED IN ALL CASES
+
+Notice to be included in header file of all Error Corrections and Shared
+Modifications:
+
+Portions Copyright 1994-2003 © RealNetworks, Inc. All rights reserved.
+
+The contents of this file, and the files included with this file, are
+subject to the current version of RealNetworks Community Source License
+Version 1.1 (the "License"). You may not use this file except in
+compliance with the License executed by both You and RealNetworks. You
+may obtain a copy of the License at *
+https://www.helixcommunity.org/content/rcsl.* You may also obtain a copy
+of the License by contacting RealNetworks directly. Please see the
+License for the rights, obligations and limitations governing use of the
+contents of the file.
+
+This file is part of the Helix DNA technology. RealNetworks, Inc., is
+the developer of the Original code and owns the copyrights in the
+portions it created.
+
+This file, and the files included with this file, are distributed on an
+'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
+AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
+LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+
+Contributor(s):
+
+_______________________________________________
+
+Technology Compatibility Kit Test Suite(s) Location:
+
+________________________________
+
+
+    ATTACHMENT A-2
+
+SAMPLE LICENSEE CERTIFICATION
+
+"By clicking the `Agree' button below, You certify that You are a
+Licensee in good standing under the RealNetworks Community Source
+License, ("License") and that Your access, use and distribution of code
+and information You may obtain at this site is subject to the License.
+If You are not a Licensee under the RealNetworks Community Source
+License You agree not to download, copy or use the Helix DNA technology.
+
+
+    ATTACHMENT A-3
+
+REQUIRED STUDENT NOTIFICATION
+
+"This software and related documentation has been obtained by Your
+educational institution subject to the RealNetworks Community Source
+License. You have been provided access to the software and related
+documentation for use only in connection with your course work and
+research activities as a matriculated student of Your educational
+institution. Any other use is expressly prohibited.
+
+THIS SOFTWARE AND RELATED DOCUMENTATION CONTAINS PROPRIETARY MATERIAL OF
+REALNETWORKS, INC, WHICH ARE PROTECTED BY VARIOUS INTELLECTUAL PROPERTY
+RIGHTS.
+
+You may not use this file except in compliance with the License. You may
+obtain a copy of the License on the web at
+https://www.helixcommunity.org/content/rcsl.
+
+*
+*
+
+
+  ATTACHMENT B
+
+Description of Technology
+
+Helix DNA, which consists of Helix DNA Client, Helix DNA Server and
+Helix DNA Producer.
+
+Description of "Technology"
+
+Helix DNA Technology v1.0 as described on the Community Web Server.
+
+
+  ATTACHMENT C
+
+TECHNOLOGY COMPATIBILITY KIT LICENSE
+
+The following license is effective for the *Helix DNA* Technology
+Compatibility Kit - as described on the Community Web Server. The
+Technology Compatibility Kit(s) for the Technology specified in
+Attachment B may be accessed at the Community Web Server.
+
+1. TCK License.
+
+1.1 Grants to use TCK
+
+Subject to the terms and restrictions set forth below and the
+RealNetworks Community Source License, and the Research Use license,
+Original Contributor grants to You a worldwide, non-exclusive,
+non-transferable license, to the extent of Original Contributor's
+Intellectual Property Rights in the TCK (without the right to
+sublicense), to use the TCK to develop and test Covered Code.
+
+1.2 TCK Use Restrictions.
+
+You are not authorized to create derivative works of the TCK or use the
+TCK to test any implementation of the Specification that is not Covered
+Code. You may not publish Your test results or make claims of
+comparative compatibility with respect to other implementations of the
+Specification. In consideration for the license grant in Section 1.1
+above You agree not to develop Your own tests that are intended to
+validate conformation with the Specification.
+
+2. Test Results.
+
+You agree to provide to Original Contributor or the third party test
+facility if applicable, Your test results that demonstrate that Covered
+Code is Compliant Covered Code and that Original Contributor may publish
+or otherwise distribute such test results.
+
+PLEASE READ THE TERMS OF THIS LICENSE CAREFULLY. BY CLICKING ON THE
+"ACCEPT" BUTTON BELOW YOU ARE ACCEPTING AND AGREEING TO THE TERMS AND
+CONDITIONS OF THIS LICENSE WITH THE ORIGINAL CONTRIBUTOR, REALNETWORKS,
+INC. IF YOU ARE AGREEING TO THIS LICENSE ON BEHALF OF A COMPANY, YOU
+REPRESENT THAT YOU ARE AUTHORIZED TO BIND THE COMPANY TO SUCH A LICENSE.
+WHETHER YOU ARE ACTING ON YOUR OWN BEHALF, OR REPRESENTING A COMPANY,
+YOU MUST BE OF MAJORITY AGE AND BE OTHERWISE COMPETENT TO ENTER INTO
+CONTRACTS. IF YOU DO NOT MEET THIS CRITERIA OR YOU DO NOT AGREE TO ANY
+OF THE TERMS AND CONDITIONS OF THIS LICENSE, CLICK ON THE REJECT BUTTON
+TO EXIT.
+
+*ACCEPT / REJECT
+*
+
+*
+*
+
+*To agree to the R&D/academic terms of this license, please register
+<https://www.helixcommunity.org/2002/intro/why-register> on the site --
+you will then be given a chance to agree to the clickwrap RCSL
+<https://reguseronly.helixcommunity.org/2002/clickwrap/rcsl-clickwrap>
+R&D License
+<https://reguseronly.helixcommunity.org/2002/clickwrap/rcsl-clickwrap>
+and gain access to the RCSL-licensed source code.  To build or deploy
+commercial applications based on the RCSL, you will need to agree to the
+Commercial Use license attachments
+<https://www.helixcommunity.org/content/rcsl-attachments>*
+
+
+
Index: helix-libs/clientapps/clutter/RPSL.txt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/RPSL.txt	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,518 @@
+RealNetworks Public Source License Version 1.0
+(Rev. Date October 28, 2002)
+
+1. General Definitions. This License applies to any program or other work which
+RealNetworks, Inc., or any other entity that elects to use this license,
+("Licensor") makes publicly available and which contains a notice placed by
+Licensor identifying such program or work as "Original Code" and stating that it
+is subject to the terms of this RealNetworks Public Source License version 1.0
+(or subsequent version thereof) ("License"). You are not required to accept this
+License. However, nothing else grants You permission to use, copy, modify or
+distribute the software or its derivative works. These actions are prohibited by
+law if You do not accept this License. Therefore, by modifying, copying or
+distributing the software (or any work based on the software), You indicate your
+acceptance of this License to do so, and all its terms and conditions. In
+addition, you agree to the terms of this License by clicking the Accept button
+or downloading the software. As used in this License:
+
+1.1 "Applicable Patent Rights" mean: (a) in the case where Licensor is the
+grantor of rights, claims of patents that (i) are now or hereafter acquired,
+owned by or assigned to Licensor and (ii) are necessarily infringed by using or
+making the Original Code alone and not in combination with other software or
+hardware; and (b) in the case where You are the grantor of rights, claims of
+patents that (i) are now or hereafter acquired, owned by or assigned to You and
+(ii) are infringed (directly or indirectly) by using or making Your
+Modifications, taken alone or in combination with Original Code.
+
+1.2 "Compatible Source License" means any one of the licenses listed on Exhibit
+B or at https://www.helixcommunity.org/content/complicense or other licenses
+specifically identified by Licensor in writing. Notwithstanding any term to the
+contrary in any Compatible Source License, any code covered by any Compatible
+Source License that is used with Covered Code must be made readily available in
+Source Code format for royalty-free use under the terms of the Compatible Source
+License or this License.
+
+1.3 "Contributor" means any person or entity that creates or contributes to the
+creation of Modifications.
+
+1.4 "Covered Code" means the Original Code, Modifications, the combination of
+Original Code and any Modifications, and/or any respective portions thereof.
+
+1.5 "Deploy" means to use, sublicense or distribute Covered Code other than for
+Your internal research and development (R&D) and/or Personal Use, and includes
+without limitation, any and all internal use or distribution of Covered Code
+within Your business or organization except for R&D use and/or Personal Use, as
+well as direct or indirect sublicensing or distribution of Covered Code by You
+to any third party in any form or manner.
+
+1.6 "Derivative Work" means either the Covered Code or any derivative work under
+United States copyright law, and including any work containing or including any
+portion of the Covered Code or Modifications, either verbatim or with
+modifications and/or translated into another language. Derivative Work also
+includes any work which combines any portion of Covered Code or Modifications
+with code not otherwise governed by the terms of this License.
+
+1.7 "Externally Deploy" means to Deploy the Covered Code in any way that may be
+accessed or used by anyone other than You, used to provide any services to
+anyone other than You, or used in any way to deliver any content to anyone other
+than You, whether the Covered Code is distributed to those parties, made
+available as an application intended for use over a computer network, or used to
+provide services or otherwise deliver content to anyone other than You.
+
+1.8. "Interface" means interfaces, functions, properties, class definitions,
+APIs, header files, GUIDs, V-Tables, and/or protocols allowing one piece of
+software, firmware or hardware to communicate or interoperate with another piece
+of software, firmware or hardware.
+
+1.9 "Modifications" mean any addition to, deletion from, and/or change to, the
+substance and/or structure of the Original Code, any previous Modifications, the
+combination of Original Code and any previous Modifications, and/or any
+respective portions thereof. When code is released as a series of files, a
+Modification is: (a) any addition to or deletion from the contents of a file
+containing Covered Code; and/or (b) any new file or other representation of
+computer program statements that contains any part of Covered Code.
+
+1.10 "Original Code" means (a) the Source Code of a program or other work as
+originally made available by Licensor under this License, including the Source
+Code of any updates or upgrades to such programs or works made available by
+Licensor under this License, and that has been expressly identified by Licensor
+as such in the header file(s) of such work; and (b) the object code compiled
+from such Source Code and originally made available by Licensor under this
+License.
+
+1.11 "Personal Use" means use of Covered Code by an individual solely for his or
+her personal, private and non-commercial purposes. An individual's use of
+Covered Code in his or her capacity as an officer, employee, member, independent
+contractor or agent of a corporation, business or organization (commercial or
+non-commercial) does not qualify as Personal Use.
+
+1.12 "Source Code" means the human readable form of a program or other work that
+is suitable for making modifications to it, including all modules it contains,
+plus any associated interface definition files, scripts used to control
+compilation and installation of an executable (object code).
+
+1.13 "You" or "Your" means an individual or a legal entity exercising rights
+under this License. For legal entities, "You" or "Your" includes any entity
+which controls, is controlled by, or is under common control with, You, where
+"control" means (a) the power, direct or indirect, to cause the direction or
+management of such entity, whether by contract or otherwise, or (b) ownership of
+fifty percent (50%) or more of the outstanding shares or beneficial ownership of
+such entity.
+
+2. Permitted Uses; Conditions & Restrictions. Subject to the terms and
+conditions of this License, Licensor hereby grants You, effective on the date
+You accept this License (via downloading or using Covered Code or otherwise
+indicating your acceptance of this License), a worldwide, royalty-free,
+non-exclusive copyright license, to the extent of Licensor's copyrights cover
+the Original Code, to do the following:
+
+2.1 You may reproduce, display, perform, modify and Deploy Covered Code,
+provided that in each instance:
+
+(a) You must retain and reproduce in all copies of Original Code the copyright
+and other proprietary notices and disclaimers of Licensor as they appear in the
+Original Code, and keep intact all notices in the Original Code that refer to
+this License;
+
+(b) You must include a copy of this License with every copy of Source Code of
+Covered Code and documentation You distribute, and You may not offer or impose
+any terms on such Source Code that alter or restrict this License or the
+recipients' rights hereunder, except as permitted under Section 6;
+
+(c) You must duplicate, to the extent it does not already exist, the notice in
+Exhibit A in each file of the Source Code of all Your Modifications, and cause
+the modified files to carry prominent notices stating that You changed the files
+and the date of any change;
+
+(d) You must make Source Code of all Your Externally Deployed Modifications
+publicly available under the terms of this License, including the license grants
+set forth in Section 3 below, for as long as you Deploy the Covered Code or
+twelve (12) months from the date of initial Deployment, whichever is longer. You
+should preferably distribute the Source Code of Your Deployed Modifications
+electronically (e.g. download from a web site); and
+
+(e) if You Deploy Covered Code in object code, executable form only, You must
+include a prominent notice, in the code itself as well as in related
+documentation, stating that Source Code of the Covered Code is available under
+the terms of this License with information on how and where to obtain such
+Source Code. You must also include the Object Code Notice set forth in Exhibit A
+in the "about" box or other appropriate place where other copyright notices are
+placed, including any packaging materials.
+
+2.2 You expressly acknowledge and agree that although Licensor and each
+Contributor grants the licenses to their respective portions of the Covered Code
+set forth herein, no assurances are provided by Licensor or any Contributor that
+the Covered Code does not infringe the patent or other intellectual property
+rights of any other entity. Licensor and each Contributor disclaim any liability
+to You for claims brought by any other entity based on infringement of
+intellectual property rights or otherwise. As a condition to exercising the
+rights and licenses granted hereunder, You hereby assume sole responsibility to
+secure any other intellectual property rights needed, if any. For example, if a
+third party patent license is required to allow You to make, use, sell, import
+or offer for sale the Covered Code, it is Your responsibility to acquire such
+license(s).
+
+2.3 Subject to the terms and conditions of this License, Licensor hereby grants
+You, effective on the date You accept this License (via downloading or using
+Covered Code or otherwise indicating your acceptance of this License), a
+worldwide, royalty-free, perpetual, non-exclusive patent license under
+Licensor's Applicable Patent Rights to make, use, sell, offer for sale and
+import the Covered Code, provided that in each instance you comply with the
+terms of this License.
+
+3. Your Grants. In consideration of, and as a condition to, the licenses granted
+to You under this License:
+
+(a) You grant to Licensor and all third parties a non-exclusive, perpetual,
+irrevocable, royalty free license under Your Applicable Patent Rights and other
+intellectual property rights owned or controlled by You, to make, sell, offer
+for sale, use, import, reproduce, display, perform, modify, distribute and
+Deploy Your Modifications of the same scope and extent as Licensor's licenses
+under Sections 2.1 and 2.2; and
+
+(b) You grant to Licensor and its subsidiaries a non-exclusive, worldwide,
+royalty-free, perpetual and irrevocable license, under Your Applicable Patent
+Rights and other intellectual property rights owned or controlled by You, to
+make, use, sell, offer for sale, import, reproduce, display, perform,
+distribute, modify or have modified (for Licensor and/or its subsidiaries),
+sublicense and distribute Your Modifications, in any form and for any purpose,
+through multiple tiers of distribution.
+
+(c) You agree not use any information derived from Your use and review of the
+Covered Code, including but not limited to any algorithms or inventions that may
+be contained in the Covered Code, for the purpose of asserting any of Your
+patent rights, or assisting a third party to assert any of its patent rights,
+against Licensor or any Contributor.
+
+4. Derivative Works. You may create a Derivative Work by combining Covered Code
+with other code not otherwise governed by the terms of this License and
+distribute the Derivative Work as an integrated product. In each such instance,
+You must make sure the requirements of this License are fulfilled for the
+Covered Code or any portion thereof, including all Modifications.
+
+4.1 You must cause any Derivative Work that you distribute, publish or
+Externally Deploy, that in whole or in part contains or is derived from the
+Covered Code or any part thereof, to be licensed as a whole at no charge to all
+third parties under the terms of this License and no other license except as
+provided in Section 4.2. You also must make Source Code available for the
+Derivative Work under the same terms as Modifications, described in Sections 2
+and 3, above.
+
+4.2 Compatible Source Licenses. Software modules that have been independently
+developed without any use of Covered Code and which contain no portion of the
+Covered Code, Modifications or other Derivative Works, but are used or combined
+in any way wtih the Covered Code or any Derivative Work to form a larger
+Derivative Work, are exempt from the conditions described in Section 4.1 but
+only to the extent that: the software module, including any software that is
+linked to, integrated with, or part of the same applications as, the software
+module by any method must be wholly subject to one of the Compatible Source
+Licenses. Notwithstanding the foregoing, all Covered Code must be subject to the
+terms of this License. Thus, the entire Derivative Work must be licensed under a
+combination of the RPSL (for Covered Code) and a Compatible Source License for
+any independently developed software modules within the Derivative Work. The
+foregoing requirement applies even if the Compatible Source License would
+ordinarily allow the software module to link with, or form larger works with,
+other software that is not subject to the Compatible Source License. For
+example, although the Mozilla Public License v1.1 allows Mozilla code to be
+combined with proprietary software that is not subject to the MPL, if
+MPL-licensed code is used with Covered Code the MPL-licensed code could not be
+combined or linked with any code not governed by the MPL. The general intent of
+this section 4.2 is to enable use of Covered Code with applications that are
+wholly subject to an acceptable open source license. You are responsible for
+determining whether your use of software with Covered Code is allowed under Your
+license to such software.
+
+4.3 Mere aggregation of another work not based on the Covered Code with the
+Covered Code (or with a work based on the Covered Code) on a volume of a storage
+or distribution medium does not bring the other work under the scope of this
+License. If You deliver the Covered Code for combination and/or integration with
+an application previously provided by You (for example, via automatic updating
+technology), such combination and/or integration constitutes a Derivative Work
+subject to the terms of this License.
+
+5. Exclusions From License Grant. Nothing in this License shall be deemed to
+grant any rights to trademarks, copyrights, patents, trade secrets or any other
+intellectual property of Licensor or any Contributor except as expressly stated
+herein. No right is granted to the trademarks of Licensor or any Contributor
+even if such marks are included in the Covered Code. Nothing in this License
+shall be interpreted to prohibit Licensor from licensing under different terms
+from this License any code that Licensor otherwise would have a right to
+license. Modifications, Derivative Works and/or any use or combination of
+Covered Code with other technology provided by Licensor or third parties may
+require additional patent licenses from Licensor which Licensor may grant in its
+sole discretion. No patent license is granted separate from the Original Code or
+combinations of the Original Code with other software or hardware.
+
+5.1. Trademarks. This License does not grant any rights to use the trademarks or
+trade names owned by Licensor ("Licensor Marks" defined in Exhibit C) or to any
+trademark or trade name belonging to any Contributor. No Licensor Marks may be
+used to endorse or promote products derived from the Original Code other than as
+permitted by the Licensor Trademark Policy defined in Exhibit C.
+
+6. Additional Terms. You may choose to offer, and to charge a fee for, warranty,
+support, indemnity or liability obligations and/or other rights consistent with
+the scope of the license granted herein ("Additional Terms") to one or more
+recipients of Covered Code. However, You may do so only on Your own behalf and
+as Your sole responsibility, and not on behalf of Licensor or any Contributor.
+You must obtain the recipient's agreement that any such Additional Terms are
+offered by You alone, and You hereby agree to indemnify, defend and hold
+Licensor and every Contributor harmless for any liability incurred by or claims
+asserted against Licensor or such Contributor by reason of any such Additional
+Terms.
+
+7. Versions of the License. Licensor may publish revised and/or new versions of
+this License from time to time. Each version will be given a distinguishing
+version number. Once Original Code has been published under a particular version
+of this License, You may continue to use it under the terms of that version. You
+may also choose to use such Original Code under the terms of any subsequent
+version of this License published by Licensor. No one other than Licensor has
+the right to modify the terms applicable to Covered Code created under this
+License.
+
+8. NO WARRANTY OR SUPPORT. The Covered Code may contain in whole or in part
+pre-release, untested, or not fully tested works. The Covered Code may contain
+errors that could cause failures or loss of data, and may be incomplete or
+contain inaccuracies. You expressly acknowledge and agree that use of the
+Covered Code, or any portion thereof, is at Your sole and entire risk. THE
+COVERED CODE IS PROVIDED "AS IS" AND WITHOUT WARRANTY, UPGRADES OR SUPPORT OF
+ANY KIND AND LICENSOR AND LICENSOR'S LICENSOR(S) (COLLECTIVELY REFERRED TO AS
+"LICENSOR" FOR THE PURPOSES OF SECTIONS 8 AND 9) AND ALL CONTRIBUTORS EXPRESSLY
+DISCLAIM ALL WARRANTIES AND/OR CONDITIONS, EXPRESS OR IMPLIED, INCLUDING, BUT
+NOT LIMITED TO, THE IMPLIED WARRANTIES AND/OR CONDITIONS OF MERCHANTABILITY, OF
+SATISFACTORY QUALITY, OF FITNESS FOR A PARTICULAR PURPOSE, OF ACCURACY, OF QUIET
+ENJOYMENT, AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. LICENSOR AND EACH
+CONTRIBUTOR DOES NOT WARRANT AGAINST INTERFERENCE WITH YOUR ENJOYMENT OF THE
+COVERED CODE, THAT THE FUNCTIONS CONTAINED IN THE COVERED CODE WILL MEET YOUR
+REQUIREMENTS, THAT THE OPERATION OF THE COVERED CODE WILL BE UNINTERRUPTED OR
+ERROR-FREE, OR THAT DEFECTS IN THE COVERED CODE WILL BE CORRECTED. NO ORAL OR
+WRITTEN DOCUMENTATION, INFORMATION OR ADVICE GIVEN BY LICENSOR, A LICENSOR
+AUTHORIZED REPRESENTATIVE OR ANY CONTRIBUTOR SHALL CREATE A WARRANTY. You
+acknowledge that the Covered Code is not intended for use in high risk
+activities, including, but not limited to, the design, construction, operation
+or maintenance of nuclear facilities, aircraft navigation, aircraft
+communication systems, or air traffic control machines in which case the failure
+of the Covered Code could lead to death, personal injury, or severe physical or
+environmental damage. Licensor disclaims any express or implied warranty of
+fitness for such uses.
+
+9. LIMITATION OF LIABILITY. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT
+SHALL LICENSOR OR ANY CONTRIBUTOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
+INDIRECT OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR RELATING TO THIS LICENSE OR
+YOUR USE OR INABILITY TO USE THE COVERED CODE, OR ANY PORTION THEREOF, WHETHER
+UNDER A THEORY OF CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR STRICT
+LIABILITY), PRODUCTS LIABILITY OR OTHERWISE, EVEN IF LICENSOR OR SUCH
+CONTRIBUTOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES AND
+NOTWITHSTANDING THE FAILURE OF ESSENTIAL PURPOSE OF ANY REMEDY. SOME
+JURISDICTIONS DO NOT ALLOW THE LIMITATION OF LIABILITY OF INCIDENTAL OR
+CONSEQUENTIAL DAMAGES, SO THIS LIMITATION MAY NOT APPLY TO YOU. In no event
+shall Licensor's total liability to You for all damages (other than as may be
+required by applicable law) under this License exceed the amount of ten dollars
+($10.00).
+
+10. Ownership. Subject to the licenses granted under this License, each
+Contributor retains all rights, title and interest in and to any Modifications
+made by such Contributor. Licensor retains all rights, title and interest in and
+to the Original Code and any Modifications made by or on behalf of Licensor
+("Licensor Modifications"), and such Licensor Modifications will not be
+automatically subject to this License. Licensor may, at its sole discretion,
+choose to license such Licensor Modifications under this License, or on
+different terms from those contained in this License or may choose not to
+license them at all.
+
+11. Termination. 
+
+11.1 Term and Termination. The term of this License is perpetual unless
+terminated as provided below. This License and the rights granted hereunder will
+terminate:
+
+(a) automatically without notice from Licensor if You fail to comply with any
+term(s) of this License and fail to cure such breach within 30 days of becoming
+aware of such breach;
+
+(b) immediately in the event of the circumstances described in Section 12.5(b);
+or
+
+(c) automatically without notice from Licensor if You, at any time during the
+term of this License, commence an action for patent infringement against
+Licensor (including by cross-claim or counter claim in a lawsuit);
+
+(d) upon written notice from Licensor if You, at any time during the term of
+this License, commence an action for patent infringement against any third party
+alleging that the Covered Code itself (excluding combinations with other
+software or hardware) infringes any patent (including by cross-claim or counter
+claim in a lawsuit).
+
+11.2 Effect of Termination. Upon termination, You agree to immediately stop any
+further use, reproduction, modification, sublicensing and distribution of the
+Covered Code and to destroy all copies of the Covered Code that are in your
+possession or control. All sublicenses to the Covered Code which have been
+properly granted prior to termination shall survive any termination of this
+License. Provisions which, by their nature, should remain in effect beyond the
+termination of this License shall survive, including but not limited to Sections
+3, 5, 8, 9, 10, 11, 12.2 and 13. No party will be liable to any other for
+compensation, indemnity or damages of any sort solely as a result of terminating
+this License in accordance with its terms, and termination of this License will
+be without prejudice to any other right or remedy of any party.
+
+12. Miscellaneous.
+
+12.1 Government End Users. The Covered Code is a "commercial item" as defined in
+FAR 2.101. Government software and technical data rights in the Covered Code
+include only those rights customarily provided to the public as defined in this
+License. This customary commercial license in technical data and software is
+provided in accordance with FAR 12.211 (Technical Data) and 12.212 (Computer
+Software) and, for Department of Defense purchases, DFAR 252.227-7015 (Technical
+Data -- Commercial Items) and 227.7202-3 (Rights in Commercial Computer Software
+or Computer Software Documentation). Accordingly, all U.S. Government End Users
+acquire Covered Code with only those rights set forth herein.
+
+12.2 Relationship of Parties. This License will not be construed as creating an
+agency, partnership, joint venture or any other form of legal association
+between or among You, Licensor or any Contributor, and You will not represent to
+the contrary, whether expressly, by implication, appearance or otherwise.
+
+12.3 Independent Development. Nothing in this License will impair Licensor's
+right to acquire, license, develop, have others develop for it, market and/or
+distribute technology or products that perform the same or similar functions as,
+or otherwise compete with, Modifications, Derivative Works, technology or
+products that You may develop, produce, market or distribute.
+
+12.4 Waiver; Construction. Failure by Licensor or any Contributor to enforce any
+provision of this License will not be deemed a waiver of future enforcement of
+that or any other provision. Any law or regulation which provides that the
+language of a contract shall be construed against the drafter will not apply to
+this License.
+
+12.5 Severability. (a) If for any reason a court of competent jurisdiction finds
+any provision of this License, or portion thereof, to be unenforceable, that
+provision of the License will be enforced to the maximum extent permissible so
+as to effect the economic benefits and intent of the parties, and the remainder
+of this License will continue in full force and effect. (b) Notwithstanding the
+foregoing, if applicable law prohibits or restricts You from fully and/or
+specifically complying with Sections 2 and/or 3 or prevents the enforceability
+of either of those Sections, this License will immediately terminate and You
+must immediately discontinue any use of the Covered Code and destroy all copies
+of it that are in your possession or control.
+
+12.6 Dispute Resolution. Any litigation or other dispute resolution between You
+and Licensor relating to this License shall take place in the Seattle,
+Washington, and You and Licensor hereby consent to the personal jurisdiction of,
+and venue in, the state and federal courts within that District with respect to
+this License. The application of the United Nations Convention on Contracts for
+the International Sale of Goods is expressly excluded.
+
+12.7 Export/Import Laws. This software is subject to all export and import laws
+and restrictions and regulations of the country in which you receive the Covered
+Code and You are solely responsible for ensuring that You do not export,
+re-export or import the Covered Code or any direct product thereof in violation
+of any such restrictions, laws or regulations, or without all necessary
+authorizations.
+
+12.8 Entire Agreement; Governing Law. This License constitutes the entire
+agreement between the parties with respect to the subject matter hereof. This
+License shall be governed by the laws of the United States and the State of
+Washington.
+
+Where You are located in the province of Quebec, Canada, the following clause
+applies: The parties hereby confirm that they have requested that this License
+and all related documents be drafted in English. Les parties ont exig&eacute;
+que le pr&eacute;sent contrat et tous les documents connexes soient
+r&eacute;dig&eacute;s en anglais.
+
+								EXHIBIT A.  
+
+"Copyright &copy; 1995-2002
+RealNetworks, Inc. and/or its licensors. All Rights Reserved.
+
+The contents of this file, and the files included with this file, are subject to
+the current version of the RealNetworks Public Source License Version 1.0 (the
+"RPSL") available at https://www.helixcommunity.org/content/rpsl unless you have
+licensed the file under the RealNetworks Community Source License Version 1.0
+(the "RCSL") available at https://www.helixcommunity.org/content/rcsl, in which
+case the RCSL will apply. You may also obtain the license terms directly from
+RealNetworks. You may not use this file except in compliance with the RPSL or,
+if you have a valid RCSL with RealNetworks applicable to this file, the RCSL.
+Please see the applicable RPSL or RCSL for the rights, obligations and
+limitations governing use of the contents of the file.
+
+This file is part of the Helix DNA Technology. RealNetworks is the developer of
+the Original code and owns the copyrights in the portions it created.
+
+This file, and the files included with this file, is distributed and made
+available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
+IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING
+WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+
+Contributor(s): ____________________________________ 
+
+Technology Compatibility Kit Test
+Suite(s) Location (if licensed under the RCSL): ______________________________ 
+
+Object Code Notice: Helix DNA Client technology included. Copyright (c)
+RealNetworks, Inc., 1995-2002. All rights reserved.
+
+
+								EXHIBIT B 
+
+Compatible Source Licenses for the RealNetworks Public Source License. The
+following list applies to the most recent version of the license as of October
+25, 2002, unless otherwise indicated.
+
+* Academic Free License
+* Apache Software License
+* Apple Public Source License
+* Artistic license
+* Attribution Assurance Licenses
+* BSD license
+* Common Public License (1)
+* Eiffel Forum License
+* GNU General Public License (GPL) (1)
+* GNU Library or "Lesser" General Public License (LGPL) (1)
+* IBM Public License
+* Intel Open Source License
+* Jabber Open Source License
+* MIT license
+* MITRE Collaborative Virtual Workspace License (CVW License)
+* Motosoto License
+* Mozilla Public License 1.0 (MPL)
+* Mozilla Public License 1.1 (MPL)
+* Nokia Open Source License
+* Open Group Test Suite License
+* Python Software Foundation License
+* Ricoh Source Code Public License
+* Sun Industry Standards Source License (SISSL)
+* Sun Public License
+* University of Illinois/NCSA Open Source License
+* Vovida Software License v. 1.0
+* W3C License
+* X.Net License
+* Zope Public License
+* zlib/libpng license
+
+(1) Note: because this license contains certain reciprocal licensing terms that
+purport to extend to independently developed code, You may be prohibited under
+the terms of this otherwise compatible license from using code licensed under
+its terms with Covered Code because Covered Code may only be licensed under the
+RealNetworks Public Source License. Any attempt to apply non RPSL license terms,
+including without limitation the GPL, to Covered Code is expressly forbidden.
+You are responsible for ensuring that Your use of Compatible Source Licensed
+code does not violate either the RPSL or the Compatible Source License.
+
+The latest version of this list can be found at:
+https://www.helixcommunity.org/content/complicense
+
+								EXHIBIT C 
+
+RealNetworks' Trademark policy.  
+
+RealNetworks defines the following trademarks collectively as "Licensor
+Trademarks": "RealNetworks", "RealPlayer", "RealJukebox", "RealSystem",
+"RealAudio", "RealVideo", "RealOne Player", "RealMedia", "Helix" or any other
+trademarks or trade names belonging to RealNetworks.
+
+RealNetworks "Licensor Trademark Policy" forbids any use of Licensor Trademarks
+except as permitted by and in strict compliance at all times with RealNetworks'
+third party trademark usage guidelines which are posted at
+http://www.realnetworks.com/info/helixlogo.html.
+
Index: helix-libs/clientapps/clutter/Umakefil
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/Umakefil	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,325 @@
+# 
+# ***** BEGIN LICENSE BLOCK ***** 
+# Version: RCSL 1.0/RPSL 1.0 
+#  
+# Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+#      
+# The contents of this file, and the files included with this file, are 
+# subject to the current version of the RealNetworks Public Source License 
+# Version 1.0 (the "RPSL") available at 
+# http://www.helixcommunity.org/content/rpsl unless you have licensed 
+# the file under the RealNetworks Community Source License Version 1.0 
+# (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+# in which case the RCSL will apply. You may also obtain the license terms 
+# directly from RealNetworks.  You may not use this file except in 
+# compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+# applicable to this file, the RCSL.  Please see the applicable RPSL or 
+# RCSL for the rights, obligations and limitations governing use of the 
+# contents of the file.  
+#  
+# This file is part of the Helix DNA Technology. RealNetworks is the 
+# developer of the Original Code and owns the copyrights in the portions 
+# it created. 
+#  
+# This file, and the files included with this file, is distributed and made 
+# available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+# EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+# INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+# FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+# 
+# Technology Compatibility Kit Test Suite(s) Location: 
+#    http://www.helixcommunity.org/content/tck 
+# 
+# Contributor(s): 
+#  
+# ***** END LICENSE BLOCK ***** 
+# 
+
+UmakefileVersion(2,2)
+
+project.AddModuleIncludes("common/include",
+                          "common/runtime/pub",
+                          "client/include",
+                          "client/common/system/pub",
+                          "client/common/container/pub",
+                          "client/audiosvc/pub",
+                          "common/container/pub",
+			  "video/sitelib/pub",
+			  "video/colconverter/pub",
+			  "video/sitelib/pub/platform/unix",
+			  "video/sitelib",
+                          "datatype/rm/include",
+                          "client/core")
+
+project.AddSources("player.cpp",
+                   "excontxt.cpp",
+                   "exsite.cpp",
+                   "exroot.cpp",
+                   "exadvsnk.cpp",
+                   "exerror.cpp",
+                   "iids.cpp",
+                   "exstateadvsnk.cpp",
+                   "excallback.cpp",
+		   "print.cpp")
+
+project.AddModuleLibraries(
+                           "common/runtime[runtlib]",
+                           "common/system[syslib]",
+                           "common/container[contlib]",
+                           "common/runtime[runtlib]",
+                           "client/common/system[sysclntlib]",
+                           "common/dbgtool[debuglib]",
+                           "common/util[utillib]",
+                           "video/sitelib[sitelib]",
+                           "video/sitelib[sitecreatelib]",
+                           "common/log/logutil[logutillib]",
+                           "video/vidutil[vidutillib]"
+                           )
+project.AddSystemLibraries('Xv', 'Xext')
+
+if project.IsDefined("HELIX_FEATURE_PREFERENCES"):
+    project.AddSources("preflist.cpp")
+
+if project.IsDefined("HELIX_FEATURE_AUTHENTICATION"):
+    project.AddSources("exaumgr.cpp")
+
+if project.IsDefined("HELIX_FEATURE_VIDEO"):
+	project.AddSources("exsitsup.cpp",
+                           "fivemmap.cpp")
+	project.AddModuleIncludes('video/include')
+	if project.IsDefined("HELIX_FEATURE_PNG"):
+		project.AddModuleIncludes('datatype/image/png/common/pub')
+		project.AddModuleLibraries("common/import/zlib[zlib]",
+					   "datatype/image/png/import/libpng[libpng]",
+					   "datatype/image/png/common[pngcomlib]")
+
+if project.IsDefined("HELIX_FEATURE_PROGRESSIVE_DOWNLD_STATUS"):
+	project.AddSources("exprdnld.cpp")
+
+if project.BuildOption("nodll"):
+        ## Client core
+	static_plugin_list = ["clntcore"]
+        project.AddModuleLibraries("common/runtime[runtlib]",
+                                   "common/fileio[fileiolib]",
+                                   "client/common/system[sysclntlib]",
+                                   "client/common/container[contclntlib]",
+                                   "client/core[clntcorelib]")
+        if not project.IsDefined("HELIX_FEATURE_LOGLEVEL_NONE"):
+            project.AddModuleLibraries("common/log/logutil[logutillib]")
+        if not project.IsDefined("HELIX_CONFIG_MINIMIZE_SIZE"):
+            project.AddModuleLibraries("client/common/util[utlclntlib]")
+        ## Client core libraries
+        if project.IsDefined("HELIX_FEATURE_AUDIO"):
+        	project.AddModuleLibraries("audio/device[auddevlib]",
+	        			   "client/audiosvc[audsvclib]")
+	if ('HELIX_FEATURE_VOLUME' in project.defines):
+		project.AddModuleLibraries("audio/gaintool[audgainlib]" )
+	if ('HELIX_FEATURE_VOLUME' in project.defines):
+		project.AddModuleLibraries("audio/crossfade[audxfadelib]")
+        if project.IsDefined("HELIX_FEATURE_MIXER"):
+        	project.AddModuleLibraries("audio/mixer[audmixlib]")
+        if project.IsDefined("HELIX_FEATURE_RESAMPLER"):
+        	project.AddModuleLibraries("audio/resampler[audresamplib]")
+        if project.IsDefined("HELIX_FEATURE_LIMITER"):
+        	project.AddModuleLibraries("audio/limiter[audlimiter]")
+
+        if project.IsDefined("HELIX_FEATURE_VIDEO"):
+        	project.AddModuleLibraries("client/videosvc[vidsvclib]",
+                                           "protocol/sdp[sdplib]")
+        if project.IsDefined("HELIX_FEATURE_PLAYBACK_NET"):
+        	project.AddModuleLibraries("client/netwksvc[netsvclib]",
+                                           "common/netio[netiolib]",
+        				   "client/common/netio[netioclntlib]",
+        				   "protocol/transport/common/system[systranlib]",
+        				   "protocol/transport/rtp[rtptranlib]",
+        				   "protocol/common/util[protutillib]",
+        				   "protocol/rtsp[rtsplib]")
+        if project.IsDefined("HELIX_FEATURE_RDT"):
+		project.AddLibraries(GetSDKPath("prtclrdt_lib"))
+            	project.AddModuleLibraries("protocol/transport/rdt[rdttranlib]")
+        if project.IsDefined("HELIX_FEATURE_PNA"):
+		project.AddLibraries(GetSDKPath("prtclpna_lib"))
+        if project.IsDefined("HELIX_FEATURE_XMLPARSER"):
+        	project.AddModuleLibraries("common/lang/xml[xmllib]")
+        ## Add RAM file format and renderer
+	if project.IsDefined("HELIX_FEATURE_META"):
+		static_plugin_list[-1:-1] = ["ramfformat", "ramrender"]
+                project.AddModuleLibraries("datatype/ram/renderer[ramrendrlib]")
+        ## Add local file system
+	if project.IsDefined("HELIX_FEATURE_PLAYBACK_LOCAL"):
+		static_plugin_list[-1:-1] = ["smplfsys"]
+                project.AddModuleLibraries("common/fileio[fileiolib]")
+        ## Add http file system
+	if project.IsDefined("HELIX_FEATURE_PLAYBACK_NET"):
+		static_plugin_list[-1:-1] = ["hxsdp", "httpfsys"]
+                project.AddModuleLibraries("protocol/http[httplib]",
+                                           "protocol/common/util[protutillib]",
+                                           "protocol/sdp[sdplib]",
+                                           "filesystem/data[datafsys]",
+                                           "common/fileio[fileiolib]",
+                                           "common/import/zlib[zlib]")
+        ## Add realmedia file format
+	if project.IsDefined("HELIX_FEATURE_PLAYBACK_LOCAL") and \
+	    (project.IsDefined("HELIX_FEATURE_AUDIO_REAL") or    \
+             project.IsDefined("HELIX_FEATURE_VIDEO_REAL")):
+		static_plugin_list[-1:-1] = ["rmfformat"]
+                project.AddModuleLibraries("datatype/common/util[dtutillib]",
+                                           "datatype/common/container[dtcomcontlib]")
+		project.AddLibraries(GetSDKPath("rmcom_lib"),
+                                     GetSDKPath("rmacom_lib"),
+                                     GetSDKPath("rmff_lib"),
+			             GetSDKPath("rmvidpyld_lib"))
+
+        ## Add realmedia renderer
+	if project.IsDefined("HELIX_FEATURE_AUDIO_REAL"):
+		static_plugin_list[-1:-1] = ["rarender"]
+                project.AddModuleLibraries("datatype/rm/audio/payload[rapayld]")
+                project.AddLibraries(GetSDKPath("rmarend_lib"),
+                                     GetSDKPath("rmacom_lib"))
+        ## Add mp3 file format and renderer
+	if project.IsDefined("HELIX_FEATURE_AUDIO_MPA_LAYER3") or \
+           project.IsDefined("HELIX_FEATURE_AUDIO_MPA_LAYER2") or \
+           project.IsDefined("HELIX_FEATURE_AUDIO_MPA_LAYER1"):
+		static_plugin_list[-1:-1] = ["mp3render"]
+                project.AddModuleLibraries("datatype/mp3/codec/fltpt[mp3codecfltpt]",
+                                           "datatype/mp3/common[mp3lib]",
+                                           "datatype/mp3/payload[mp3payld]",
+                                           "datatype/common/util[dtutillib]")
+		if project.IsDefined("HELIX_FEATURE_PLAYBACK_LOCAL"):
+			static_plugin_list[-1:-1] = ["mp3fformat"]
+                        project.AddModuleLibraries("datatype/mp3/common[mp3lib]")
+        ## Add gecko realmedia codec
+	if project.IsDefined("HELIX_FEATURE_AUDIO_CODEC_GECKO"):
+		static_plugin_list[-1:-1] = ["cook"]
+		if not project.IsDefined("HELIX_CONFIG_FIXEDPOINT"):
+			project.AddLibraries(GetSDKPath("ra8lbrdec_flt_lib"))
+		else:
+			project.AddLibraries(GetSDKPath("ra8lbrdec_fix_lib"))
+                project.AddModuleLibraries("datatype/rm/audio/codec/common[racompat]")
+        ## Add RAAC codec
+	if project.IsDefined("HELIX_FEATURE_AUDIO_CODEC_RAAC"):
+		static_plugin_list[-1:-1] = ["raac"]
+		project.AddModuleLibraries("datatype/mp4/common[mp4comlib]",
+                                           "datatype/aac/codec/fixpt/decoder/hxwrap[aacdeclib]")
+        ## Add sipro realmedia codec
+        ## (Right now this only works for floating-point platforms)
+	if project.IsDefined("HELIX_FEATURE_AUDIO_CODEC_SIPRO"):
+		static_plugin_list[-1:-1] = ["sipr"]
+		project.AddLibraries(GetSDKPath("sipro_flt_backend_lib"))
+        ## Add tokyo realmedia codec
+	if project.IsDefined("HELIX_FEATURE_AUDIO_CODEC_TOKYO"):
+		static_plugin_list[-1:-1] = ["atrc"]
+		project.AddLibraries(GetSDKPath("ra8hbr_lib"))
+        ##
+	if project.IsDefined("HELIX_FEATURE_VIDEO"):
+		static_plugin_list[-1:-1] = ["vidsite"]
+		static_plugin_list[-1:-1] = ["hxltcolor"]
+                project.AddModuleLibraries("datatype/common/vidrend[vidrend]",
+                                           "video/sitelib[sitelib]",
+                                           "video/site[vidsite]",
+                                           "video/colconverter[hxltcolor]",
+                                           "datatype/rm/common[rmcomlib]",
+                                           "video/vidutil[vidutillib]")
+
+		if (project.IsDefined('HELIX_FEATURE_ALTERNATE_SITE_CREATE_LIB')):
+                    project.AddLibraries(GetSDKPath("sitecreate_lib"))
+                else:
+                    project.AddModuleLibraries('video/sitelib[sitecreatelib]')
+                
+        ## Add realvideo renderer
+	if project.IsDefined("HELIX_FEATURE_VIDEO_REAL"):
+		project.AddModuleLibraries("datatype/rm/video/renderer[rvxrendlib]")
+		project.AddLibraries(GetSDKPath("rmvidcom_lib"),
+                                     GetSDKPath("rmvidpyld_lib"),
+                                     GetSDKPath("rvcodcom_lib"))
+                project.AddModuleLibraries("datatype/common/util[dtutillib]")
+		static_plugin_list[-1:-1] = ["rvrender"]
+                
+        ## Add mpeg4 file format
+	if project.IsDefined("HELIX_FEATURE_PLAYBACK_LOCAL")and \
+	   (project.IsDefined("HELIX_FEATURE_VIDEO_H263") or    \
+            project.IsDefined("HELIX_FEATURE_VIDEO_MPEG4") or   \
+            project.IsDefined("HELIX_FEATURE_AUDIO_MPEG4")):
+		static_plugin_list[-1:-1] = ["mp4fformat"]
+                project.AddModuleLibraries("datatype/common/util[dtutillib]",
+                                           "datatype/common/audrend",
+                                           "datatype/mp4/common[mp4comlib]",
+                                           "datatype/mp4/payload[mp4pyldlib]",
+                                           "datatype/mp4/fileformat[mp4fformatlib]")
+                if not project.IsDefined("HELIX_FEATURE_MP4_FILEFORMAT_M4A_ONLY"):
+                    project.AddModuleLibraries("protocol/sdp[sdplib]",
+                                               "protocol/rtsp[rtsplib]",
+                                               "protocol/common/util[protutillib]",
+                                               "datatype/rm/common[rmcomlib]",
+                                               "datatype/amr/common[amrcomlib]")
+        ## Add h.263 renderer
+	if project.IsDefined("HELIX_FEATURE_VIDEO_H263"):
+		project.AddModuleLibraries("datatype/h263/payload[h263pyldlib]")
+		static_plugin_list[-1:-1] = ["h263render"]
+        ## Add MPEG4 renderer
+#	if project.IsDefined("HELIX_FEATURE_VIDEO_MPEG4"):
+#		static_plugin_list[-1:-1] = ["mp4xrender"]
+        ## Add mpeg 4 audio renderer
+	if project.IsDefined("HELIX_FEATURE_AUDIO_MPEG4"):
+		static_plugin_list[-1:-1] = ["mp4arender"]
+		project.AddModuleLibraries("datatype/mp4/audio/renderer[mp4arenderlib]")
+                if not project.IsDefined("HELIX_FEATURE_MP4_FILEFORMAT_M4A_ONLY"):
+                    project.AddModuleLibraries("datatype/amr/common[amrcomlib]")
+        ## Add RV10 codec
+        if project.IsDefined("HELIX_FEATURE_VIDEO_CODEC_RV10"):
+            project.AddLibraries(GetSDKPath("rv1dec_libs")+"[rv10lib]",
+                                 GetSDKPath("rv1dec_libs")+"[drv1lib]")
+            static_plugin_list[-1:-1] = ["rv10", "drv1"]
+        ## Add RV20 codec
+	if project.IsDefined("HELIX_FEATURE_VIDEO_CODEC_RV20"):
+		project.AddLibraries(GetSDKPath("rvg2dec_libs")+"[rv20lib]",
+                                     GetSDKPath("rvg2dec_libs")+"[drv2lib]")
+		static_plugin_list[-1:-1] = ["rv20", "drv2"]
+
+	if project.IsDefined("HELIX_FEATURE_VIDEO_CODEC_RV30") or \
+	   project.IsDefined("HELIX_FEATURE_VIDEO_CODEC_RV40"):
+		static_plugin_list[-1:-1] = ["drvc"]
+		if project.IsDefined("HELIX_FEATURE_ANSIC_RV89COMBO"):
+			project.AddLibraries(GetSDKPath("rv89combo_c_libs")+"[drvc]")
+		else:
+			project.AddLibraries(GetSDKPath("rv89combo_libs")+"[drvclib]")
+
+	if project.IsDefined("HELIX_FEATURE_VIDEO_CODEC_RV30"):
+		static_plugin_list[-1:-1] = ["rv30"]
+		project.AddLibraries(GetSDKPath("rv89combo_libs")+"[rv3xlib]")
+                project.AddModuleLibraries("datatype/rm/video/codec/rv89combo[rv30]")
+
+	if project.IsDefined("HELIX_FEATURE_VIDEO_CODEC_RV40"):
+		static_plugin_list[-1:-1] = ["rv40"]
+		project.AddLibraries(GetSDKPath("rv89combo_libs")+"[rv4xlib]")
+                project.AddModuleLibraries("datatype/rm/video/codec/rv89combo[rv40]")
+
+#	if project.IsDefined("HELIX_FEATURE_AUDIO_CODEC_AAC"):
+#		static_plugin_list[-1:-1] = ["aac4"]
+
+	CreateStaticPluginTable(static_plugin_list)
+
+project.ExportFunction("init_main", "void")
+project.ExportFunction("deinit_main", "void")
+project.ExportFunction("get_player", "void **ppPlayer",
+                    "on_buffering_cb_t on_buffering_cb",
+                    "on_pos_length_cb_t on_pos_length_cb")
+project.ExportFunction("player_openurl", "void *pPlayerHandle",
+                    "char *pszRawURL")
+project.ExportFunction("put_player", "void *pPlayerHandle")
+project.ExportFunction("player_geturl", "void *pPlayerHandle", "char **pszURL")
+project.ExportFunction("player_begin", "void *pPlayerHandle")
+project.ExportFunction("player_stop", "void *pPlayerHandle")
+project.ExportFunction("player_pause", "void *pPlayerHandle")
+project.ExportFunction("player_seek", "void *pPlayerHandle", "int pos")
+project.ExportFunction("get_curr_playtime", "void *pPlayerHandle")
+project.ExportFunction("player_getvolume", "void *pPlayerHandle")
+project.ExportFunction("player_canseek", "void *pPlayerHandle")
+project.ExportFunction("player_setvolume", "void *pPlayerHandle", "unsigned short volumn")
+
+
+
+DLLTarget('libhelix-player')
+
+DependTarget()
+
Index: helix-libs/clientapps/clutter/exabd.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exabd.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,245 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#include <stdio.h>
+
+#include "hxtypes.h"
+
+#include "hxcom.h"
+#include "hxcomm.h"
+#include "hxmon.h"
+#include "hxcore.h"
+#include "hxengin.h"
+#include "chxpckts.h"
+#include "hxclsnk.h"
+#include "hxstrutl.h"
+#include "exabd.h"
+
+#include "print.h"
+
+#include "globals.h"
+
+struct _stGlobals*& GetGlobal(); //in main.cpp
+
+ExampleABD::ExampleABD(IUnknown* pUnknown)
+           : m_lRefCount (0)
+           , m_pUnknown (NULL)
+           , m_ulABDStartTime(0)
+           , m_ulABDResult(0)
+           , m_bABDDone(FALSE)
+{
+    if (pUnknown)
+    {
+	m_pUnknown = pUnknown;
+	m_pUnknown->AddRef();
+    }
+}
+
+ExampleABD::~ExampleABD(void)
+{
+    HX_RELEASE(m_pUnknown);
+}
+
+
+// *** IUnknown methods ***
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::QueryInterface
+//  Purpose:
+//	Implement this to export the interfaces supported by your 
+//	object.
+//
+STDMETHODIMP ExampleABD::QueryInterface(REFIID riid, void** ppvObj)
+{
+    if (IsEqualIID(riid, IID_IUnknown))
+    {
+	AddRef();
+	*ppvObj = (IUnknown*)(IHXAutoBWCalibrationAdviseSink*)this;
+	return HXR_OK;
+    }
+    else if (IsEqualIID(riid, IID_IHXAutoBWCalibrationAdviseSink))
+    {
+	AddRef();
+	*ppvObj = (IHXAutoBWCalibrationAdviseSink*)this;
+	return HXR_OK;
+    }
+
+    *ppvObj = NULL;
+    return HXR_NOINTERFACE;
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::AddRef
+//  Purpose:
+//	Everyone usually implements this the same... feel free to use
+//	this implementation.
+//
+STDMETHODIMP_(ULONG32) ExampleABD::AddRef()
+{
+    return InterlockedIncrement(&m_lRefCount);
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::Release
+//  Purpose:
+//	Everyone usually implements this the same... feel free to use
+//	this implementation.
+//
+STDMETHODIMP_(ULONG32) ExampleABD::Release()
+{
+    if (InterlockedDecrement(&m_lRefCount) > 0)
+    {
+        return m_lRefCount;
+    }
+
+    delete this;
+    return 0;
+}
+
+/*
+ *	IHXAutoBWCalibrationAdviseSink methods
+ */
+STDMETHODIMP
+ExampleABD::AutoBWCalibrationStarted (const char* pszServer)
+{
+    if (pszServer)
+    {
+        STDOUT("ABD: contacting %s\n", pszServer);        
+    }
+
+    return HXR_OK;
+}
+
+STDMETHODIMP
+ExampleABD::AutoBWCalibrationDone(HX_RESULT  status,
+                                  UINT32     ulBW)
+{
+    m_bABDDone = TRUE;
+
+    if (HXR_OK == status)
+    {
+        m_ulABDResult = ulBW;
+        STDOUT("ABD: %lu(Kbps) %lu(ms)\n", ulBW, GetTickCount() - m_ulABDStartTime);        
+    }
+    else
+    {
+        STDOUT("ABD failed: %lu\n", status);        
+    }
+
+    return HXR_OK;
+}
+
+HX_RESULT
+ExampleABD::DoABD(const char*   pszServer,
+                  UINT32        mode,
+                  UINT32        packetSize,
+                  UINT32        packetNum)
+{
+    HX_RESULT               rc = HXR_OK;
+    UINT32                  length = 0;
+    IHXAutoBWCalibration*   pABD = NULL;
+    IHXValues*              pValues = NULL;
+    IHXBuffer*              pBuffer = NULL;
+
+    m_ulABDStartTime = GetTickCount();
+    m_ulABDResult = 0;
+    m_bABDDone = FALSE;
+
+    if (m_pUnknown &&
+        HXR_OK == m_pUnknown->QueryInterface(IID_IHXAutoBWCalibration, (void**)&pABD))
+    {
+        pValues = (IHXValues*) new CHXHeader();
+        pValues->AddRef();
+
+	pBuffer = (IHXBuffer*) new CHXBuffer();
+	pBuffer->AddRef();
+
+	pBuffer->Set((UCHAR*)pszServer, strlen(pszServer)+1);        
+        pValues->SetPropertyCString("ABDServers", pBuffer);
+
+        pValues->SetPropertyULONG32("AutoBWDetectionMode", mode);
+        pValues->SetPropertyULONG32("AutoBWDetectionPacketSize", packetSize);
+        pValues->SetPropertyULONG32("AutoBWDetectionPackets", packetNum);       
+
+        pABD->AddAutoBWCalibrationSink((IHXAutoBWCalibrationAdviseSink*)this);
+        pABD->InitAutoBWCalibration(pValues);
+
+        pABD->StartAutoBWCalibration();
+
+        while (!m_bABDDone)
+        {
+            MSG msg;
+            DWORD starttime, endtime, i;
+            BOOL sleep = TRUE;
+            static const int checkinterval = 10;
+
+            starttime = GetTickCount();
+            endtime = starttime + (20);
+            i = 0;
+            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
+            {
+                DispatchMessage(&msg);
+                if ((i % checkinterval) == 0)
+                {
+                    if (GetTickCount() > endtime)
+                        break;
+                    ++i;
+                }
+                sleep = FALSE;
+            }
+
+            if (sleep)
+                Sleep(10);
+        }
+    }
+
+cleanup:
+
+    if (pABD)
+    {
+        pABD->RemoveAutoBWCalibrationSink((IHXAutoBWCalibrationAdviseSink*)this);
+    }
+
+    HX_RELEASE(pBuffer);
+    HX_RELEASE(pValues);
+    HX_RELEASE(pABD);
+
+    return rc;
+}
+
+
Index: helix-libs/clientapps/clutter/exabd.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exabd.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,85 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#ifndef _EXAMPLEABD_
+#define _EXAMPLEABD_
+
+struct IHXAutoBWCalibrationAdviseSink;
+struct IUnknown;
+
+class ExampleABD : public IHXAutoBWCalibrationAdviseSink
+{
+  private:
+    LONG32          m_lRefCount;    
+    IUnknown*       m_pUnknown;    
+    UINT32          m_ulABDStartTime;
+    UINT32          m_ulABDResult;
+    BOOL            m_bABDDone;
+    
+    ~ExampleABD();
+
+  public:
+
+    ExampleABD(IUnknown* /*IN*/ pUnknown);
+
+    /*
+     *  IUnknown methods
+     */
+    STDMETHOD(QueryInterface) (THIS_
+                               REFIID riid,
+                               void** ppvObj);
+    
+    STDMETHOD_(ULONG32,AddRef) (THIS);
+
+    STDMETHOD_(ULONG32,Release) (THIS);
+
+    /*
+     *	IHXAutoBWCalibrationAdviseSink methods
+     */
+    STDMETHOD(AutoBWCalibrationStarted) (THIS_
+                                         const char* pszServer);
+    STDMETHOD(AutoBWCalibrationDone)	(THIS_
+                                         HX_RESULT  status,
+                                         UINT32     ulBW);
+
+    HX_RESULT   DoABD(const char*   pszServer,
+                      UINT32        mode,
+                      UINT32        packetSize,
+                      UINT32        packetNum);
+
+    UINT32      GetABD(void) { return m_ulABDResult; };
+};
+
+#endif /* _EXAMPLEABDSNK_ */
Index: helix-libs/clientapps/clutter/exadvsnk.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exadvsnk.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,1116 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#include <stdio.h>
+
+#include "hxtypes.h"
+
+#include "hxcom.h"
+#include "hxcomm.h"
+#include "hxmon.h"
+#include "hxcore.h"
+#include "hxengin.h"
+#include "hxclsnk.h"
+#include "hxgroup.h"
+#include "hxstrutl.h"
+#include "exadvsnk.h"
+#include "hxstring.h"
+#include "hxprefs.h"
+#include "excontxt.h"
+
+#include "print.h"
+
+#include "globals.h"
+#include "player.h"
+
+struct _stGlobals*& GetGlobal(); //in main.cpp
+
+#ifdef __TCS__
+extern unsigned long   gStreamTime;
+ 
+static int		iOpened = 0;
+
+
+#if	defined(__cplusplus)
+extern	"C"	{
+#endif	/* defined(__cplusplus) */
+
+typedef enum hookBuffering {
+	eContacting = 0,
+	eConnecting = 1,
+	eBuffering = 2,
+	ePlaying = 3
+}hookBuffering;
+
+void hookRealAudio_Buffering(hookBuffering connectState, int pct);
+
+void hookRealAudio_PlayPosition(unsigned long current,unsigned long duration);
+
+typedef enum hookState {
+	ePlay = 0,
+	ePause = 1,
+	eStop = 2,
+	eResume = 3,
+	eComplete				// Clip is done playing
+}hookState;
+void hookRealAudio_State(hookState newState);
+
+
+#if	defined(__cplusplus)
+}
+#endif	/* defined(__cplusplus) */
+
+#endif // __TCS__
+
+void PrintBuffer(const char* pszName,const unsigned char* pbBuf, unsigned int dwBytes);
+
+ExampleClientAdviceSink::ExampleClientAdviceSink(IUnknown* pUnknown, LONG32 lClientIndex, on_buffering_cb_t on_buffering_cb, on_pos_length_cb_t on_pos_length_cb, void *context)
+    : m_lRefCount (0)
+    , m_lClientIndex (lClientIndex)
+    , m_pUnknown (NULL)
+    , m_pRegistry (NULL)
+    , m_pScheduler (NULL)
+    , m_lCurrentBandwidth(0)
+    , m_lAverageBandwidth(0)
+    , m_bOnStop(0)
+	, m_pPlayer(0)
+    , m_bWaitForTrackStart(0)
+    , m_on_buffering_cb(on_buffering_cb)
+    , m_on_pos_length_cb(on_pos_length_cb)
+    , m_context(context)
+{
+    if (pUnknown)
+    {
+	m_pUnknown = pUnknown;
+	m_pUnknown->AddRef();
+
+	if (HXR_OK != m_pUnknown->QueryInterface(IID_IHXRegistry, (void**)&m_pRegistry))
+	{
+	    m_pRegistry = NULL;
+	}
+
+	if (HXR_OK != m_pUnknown->QueryInterface(IID_IHXScheduler, (void**)&m_pScheduler))
+	{
+	    m_pScheduler = NULL;
+	}
+
+	IHXPlayer* pPlayer;
+	if(HXR_OK == m_pUnknown->QueryInterface(IID_IHXPlayer,
+						(void**)&pPlayer))
+	{
+		m_pPlayer = pPlayer;
+
+            IHXGroupManager* pGroupMgr = NULL;
+            if(HXR_OK == m_pPlayer->QueryInterface(IID_IHXGroupManager,
+                                                   (void**)&pGroupMgr))
+            {
+                pGroupMgr->AddSink((IHXGroupSink*)this);
+                pGroupMgr->Release();
+            }
+
+	    pPlayer->AddAdviseSink(this);
+
+	}
+    }
+
+#ifdef __TCS__
+    bEnableAdviceSink = TRUE;
+    iOpened = 0;
+#endif 
+}
+
+ExampleClientAdviceSink::~ExampleClientAdviceSink(void)
+{
+    if (m_pScheduler)
+    {
+        m_pScheduler->Release();
+        m_pScheduler = NULL;
+    }
+
+    if (m_pRegistry)
+    {
+	m_pRegistry->Release();
+	m_pRegistry = NULL;
+    }
+
+    if (m_pPlayer)
+    {
+	m_pPlayer->Release();
+	m_pPlayer = NULL;
+    }
+    if (m_pUnknown)
+    {
+	m_pUnknown->Release();
+	m_pUnknown = NULL;
+    }
+}
+
+
+// *** IUnknown methods ***
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::QueryInterface
+//  Purpose:
+//	Implement this to export the interfaces supported by your 
+//	object.
+//
+STDMETHODIMP ExampleClientAdviceSink::QueryInterface(REFIID riid, void** ppvObj)
+{
+    if (IsEqualIID(riid, IID_IUnknown))
+    {
+	AddRef();
+	*ppvObj = (IUnknown*)(IHXClientAdviseSink*)this;
+	return HXR_OK;
+    }
+    else if (IsEqualIID(riid, IID_IHXClientAdviseSink))
+    {
+	AddRef();
+	*ppvObj = (IHXClientAdviseSink*)this;
+	return HXR_OK;
+    }
+    else if (IsEqualIID(riid, IID_IHXGroupSink))
+    {
+	AddRef();
+	*ppvObj = (IHXGroupSink*)this;
+	return HXR_OK;
+    }
+
+    *ppvObj = NULL;
+    return HXR_NOINTERFACE;
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::AddRef
+//  Purpose:
+//	Everyone usually implements this the same... feel free to use
+//	this implementation.
+//
+STDMETHODIMP_(ULONG32) ExampleClientAdviceSink::AddRef()
+{
+    return InterlockedIncrement(&m_lRefCount);
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::Release
+//  Purpose:
+//	Everyone usually implements this the same... feel free to use
+//	this implementation.
+//
+STDMETHODIMP_(ULONG32) ExampleClientAdviceSink::Release()
+{
+    if (InterlockedDecrement(&m_lRefCount) > 0)
+    {
+        return m_lRefCount;
+    }
+
+    delete this;
+    return 0;
+}
+
+/*
+ *	IHXClientAdviseSink methods
+ */
+
+/************************************************************************
+ *	Method:
+ *	    IHXClientAdviseSink::OnPosLength
+ *	Purpose:
+ *	    Called to advise the client that the position or length of the
+ *	    current playback context has changed.
+ */
+
+#ifdef __TCS__
+static long	lastPosition = -1;
+#endif
+
+STDMETHODIMP
+ExampleClientAdviceSink::OnPosLength(UINT32	  ulPosition,
+				   UINT32	  ulLength)
+{
+    // Are we doing a multi-seek?
+    if (GetGlobal()->g_bMultiSeek)
+    {
+        // Have we run out of seek times?
+        if (GetGlobal()->g_ulMultiSeekIndex < GetGlobal()->g_ulNumMultiSeeks)
+        {
+            STDOUT("Multi-seeking the first player to %lu\n",
+                   GetGlobal()->g_ulMultiSeekTime[GetGlobal()->g_ulMultiSeekIndex]);
+            GetGlobal()->g_Players[0]->Seek(GetGlobal()->g_ulMultiSeekTime[GetGlobal()->g_ulMultiSeekIndex++]);
+        }
+        else
+        {
+            // We've run out - stop the multi-seek
+            GetGlobal()->g_bMultiSeek       = FALSE;
+            GetGlobal()->g_ulNumMultiSeeks  = 0;
+            GetGlobal()->g_ulMultiSeekIndex = 0;
+        }
+    }
+
+    if (m_on_pos_length_cb)
+        m_on_pos_length_cb(ulPosition, ulLength, m_context);
+
+    return HXR_OK;
+}
+
+/************************************************************************
+ *	Method:
+ *	    IHXClientAdviseSink::OnPresentationOpened
+ *	Purpose:
+ *	    Called to advise the client a presentation has been opened.
+ */
+STDMETHODIMP ExampleClientAdviceSink::OnPresentationOpened()
+{
+#ifdef __TCS__
+    iOpened = 1;
+    lastPosition = -1;
+#else
+    if (GetGlobal()->bEnableAdviceSink)
+    {
+        STDOUT("OnPresentationOpened()\n");
+    }
+#if defined(HELIX_FEATURE_PLAYBACK_VELOCITY)
+    // Try to get the IHXPlaybackVelocity interface
+    // from the first player
+    if (GetGlobal()->g_nPlayers > 0 && GetGlobal()->g_Players[0])
+    {
+        IHXPlaybackVelocity* pVel = NULL;
+        HX_RESULT rv = GetGlobal()->g_Players[0]->QueryInterface(IID_IHXPlaybackVelocity, (void**) &pVel);
+        if (SUCCEEDED(rv))
+        {
+            // Get the capabilities object from the player
+            rv = pVel->QueryVelocityCaps(GetGlobal()->g_pVelocityCaps);
+            if (SUCCEEDED(rv) && GetGlobal()->bEnableAdviceSink)
+            {
+                STDOUT("Available Velocity Ranges:");
+                UINT32 ulNumRanges = GetGlobal()->g_pVelocityCaps->GetNumRanges();
+                for (UINT32 i = 0; i < ulNumRanges && SUCCEEDED(rv); i++)
+                {
+                    INT32 lMin = 0;
+                    INT32 lMax = 0;
+                    rv = GetGlobal()->g_pVelocityCaps->GetRange(i, lMin, lMax);
+                    if (SUCCEEDED(rv))
+                    {
+                        STDOUT(" [%ld,%ld]", lMin, lMax);
+                    }
+                }
+                STDOUT("\n");
+            }
+        }
+        HX_RELEASE(pVel);
+    }
+#endif /* #if defined(HELIX_FEATURE_PLAYBACK_VELOCITY) */
+#endif
+
+    UINT32 sourceCount = m_pPlayer->GetSourceCount();	
+    for (UINT32 sourceID = 0; sourceID < sourceCount; sourceID ++)
+    {
+	// get HXSource
+        IUnknown* pUnkSource = NULL;
+        IHXStreamSource* pStreamSrc = NULL;
+
+        if (HXR_OK != m_pPlayer->GetSource (sourceID, pUnkSource))
+        {
+            continue;
+        }
+
+        pUnkSource->QueryInterface(IID_IHXStreamSource, (void **)&pStreamSrc);
+
+        HX_RELEASE(pUnkSource);
+
+        if (!pStreamSrc)
+        {
+            continue;
+        }
+
+        UINT32 num_streams = pStreamSrc->GetStreamCount();
+
+        // get information from Streams
+        for (UINT32 streamID = 0; streamID < num_streams ; streamID++)
+        {
+            IUnknown* pUnkStream = NULL;
+
+            if (HXR_OK == pStreamSrc->GetStream(streamID, pUnkStream))
+            {
+                IHXStream* pStream = NULL;
+
+                if (HXR_OK == pUnkStream->QueryInterface(IID_IHXStream,
+                                                         (void**)&pStream))
+                {
+                    const char* pMimeType = pStream->GetStreamType();
+                    if( 0 == strcmp(pMimeType, "application/ram"))
+                    {
+		        m_bWaitForTrackStart = TRUE;
+                    }
+                    else
+               	    {
+                        m_bWaitForTrackStart = FALSE;
+                    }
+                }
+                HX_RELEASE(pStream);
+            }
+            HX_RELEASE(pUnkStream);
+            if (!m_bWaitForTrackStart)
+            {
+                break;
+            }
+        }
+
+        if (!m_bWaitForTrackStart)
+        {
+            break;
+        }
+        HX_RELEASE(pStreamSrc);
+    }
+
+    if (!m_bWaitForTrackStart)
+    {
+	STDOUT("----------------clip info--------------------\n");
+	if(m_pScheduler)	{
+		m_hCallback = m_pScheduler->RelativeEnter(this,50);
+	}
+    }
+    return HXR_OK;
+}
+
+
+/************************************************************************
+ *	Method:
+ *	    IHXClientAdviseSink::OnPresentationClosed
+ *	Purpose:
+ *	    Called to advise the client a presentation has been closed.
+ */
+STDMETHODIMP ExampleClientAdviceSink::OnPresentationClosed()
+{
+#ifdef __TCS__
+    iOpened = 0;
+    lastPosition = -1;
+#else
+    if (GetGlobal()->bEnableAdviceSink)
+    {
+        STDOUT("OnPresentationClosed()\n");
+    }
+#endif
+
+    return HXR_OK;
+}
+
+void ExampleClientAdviceSink::GetStatistics (char* pszRegistryKey)
+{
+    char    szRegistryValue[MAX_DISPLAY_NAME] = {0}; /* Flawfinder: ignore */
+    INT32   lValue = 0;
+    INT32   i = 0;
+    INT32   lStatistics = 8;
+    UINT32 *plValue;
+    
+#ifdef __TCS__    
+    return;	  // DISABLED FOR NOW
+#endif
+
+    // collect statistic
+    for (i = 0; i < lStatistics; i++)
+    {
+	plValue = NULL;
+	switch (i)
+	{
+	case 0:
+	    SafeSprintf(szRegistryValue, MAX_DISPLAY_NAME, "%s.Normal", pszRegistryKey);
+	    break;
+	case 1:
+	    SafeSprintf(szRegistryValue, MAX_DISPLAY_NAME, "%s.Recovered", pszRegistryKey);
+	    break;
+	case 2:
+	    SafeSprintf(szRegistryValue, MAX_DISPLAY_NAME, "%s.Received", pszRegistryKey);
+	    break;
+	case 3:
+	    SafeSprintf(szRegistryValue, MAX_DISPLAY_NAME, "%s.Lost", pszRegistryKey);
+	    break;
+	case 4:
+	    SafeSprintf(szRegistryValue, MAX_DISPLAY_NAME, "%s.Late", pszRegistryKey);
+	    break;
+	case 5:
+	    SafeSprintf(szRegistryValue, MAX_DISPLAY_NAME, "%s.ClipBandwidth", pszRegistryKey);
+	    break;
+	case 6:
+	    SafeSprintf(szRegistryValue, MAX_DISPLAY_NAME, "%s.AverageBandwidth", pszRegistryKey);
+	    plValue = &m_lAverageBandwidth;
+	    break;
+	case 7:
+	    SafeSprintf(szRegistryValue, MAX_DISPLAY_NAME, "%s.CurrentBandwidth", pszRegistryKey);
+	    plValue = &m_lCurrentBandwidth;
+	    break;
+	default:
+	    break;
+	}
+
+	m_pRegistry->GetIntByName(szRegistryValue, lValue);
+	if (plValue)
+	{
+	    if (m_bOnStop || lValue == 0)
+	    {
+		lValue = *plValue;
+	    }
+	    else
+	    {
+		*plValue = lValue;
+	    }
+	}
+	if (GetGlobal()->bEnableAdviceSink || (GetGlobal()->bEnableVerboseMode && m_bOnStop))
+	{
+	    STDOUT("%s = %ld\n", szRegistryValue, lValue);
+	}
+    }
+}
+
+void ExampleClientAdviceSink::GetAllStatistics(void)
+{
+    UINT32  unPlayerIndex = 0;
+    UINT32  unSourceIndex = 0;
+    UINT32  unStreamIndex = 0;
+
+    char*   pszRegistryPrefix = "Statistics";
+    char    szRegistryName[MAX_DISPLAY_NAME] = {0}; /* Flawfinder: ignore */
+
+#ifdef __TCS__    
+    return;	  // DISABLED FOR NOW
+#endif
+    
+    // display the content of whole statistic registry
+    if (m_pRegistry)
+    {
+	// ok, let's start from the top (player)
+	SafeSprintf(szRegistryName, MAX_DISPLAY_NAME, "%s.Player%ld", pszRegistryPrefix, m_lClientIndex);
+	if (PT_COMPOSITE == m_pRegistry->GetTypeByName(szRegistryName))
+	{
+	    // display player statistic
+	    GetStatistics(szRegistryName);
+
+	    SafeSprintf(szRegistryName, MAX_DISPLAY_NAME, "%s.Source%ld", szRegistryName, unSourceIndex);
+	    while (PT_COMPOSITE == m_pRegistry->GetTypeByName(szRegistryName))
+	    {
+		// display source statistic
+		GetStatistics(szRegistryName);
+
+		SafeSprintf(szRegistryName, MAX_DISPLAY_NAME, "%s.Stream%ld", szRegistryName, unStreamIndex);
+		while (PT_COMPOSITE == m_pRegistry->GetTypeByName(szRegistryName))
+		{
+		    // display stream statistic
+		    GetStatistics(szRegistryName);
+
+		    unStreamIndex++;
+
+		    SafeSprintf(szRegistryName, MAX_DISPLAY_NAME, "%s.Player%ld.Source%ld.Stream%ld", 
+			pszRegistryPrefix, unPlayerIndex, unSourceIndex, unStreamIndex);
+		}
+
+		unSourceIndex++;
+
+		SafeSprintf(szRegistryName, MAX_DISPLAY_NAME, "%s.Player%ld.Source%ld",
+		    pszRegistryPrefix, unPlayerIndex, unSourceIndex);
+	    }
+
+	    unPlayerIndex++;
+
+	    SafeSprintf(szRegistryName, MAX_DISPLAY_NAME, "%s.Player%ld", pszRegistryPrefix, unPlayerIndex);
+	}
+    }
+}
+
+/************************************************************************
+ *	Method:
+ *	    IHXClientAdviseSink::OnStatisticsChanged
+ *	Purpose:
+ *	    Called to advise the client that the presentation statistics
+ *	    have changed. 
+ */
+STDMETHODIMP ExampleClientAdviceSink::OnStatisticsChanged(void)
+{
+    char        szBuff[1024]; /* Flawfinder: ignore */
+    HX_RESULT   res     = HXR_OK;
+    UINT16      uPlayer = 0;
+
+#ifdef __TCS__    
+    return HXR_OK;	  // DISABLED FOR NOW
+#endif
+
+    if(GetGlobal()->bEnableAdviceSink)
+    {
+        STDOUT("OnStatisticsChanged():\n");
+
+        SafeSprintf(szBuff, 1024, "Statistics");        
+        res = DumpRegTree( szBuff );
+    }
+
+    return HXR_OK;
+}
+
+HX_RESULT ExampleClientAdviceSink::DumpRegTree(const char* pszTreeName )
+{
+    const char* pszName = NULL;
+    ULONG32     ulRegID   = 0;
+    HX_RESULT   res     = HXR_OK;
+    INT32       nVal    = 0;
+    IHXBuffer* pBuff   = NULL;
+    IHXValues* pValues = NULL;
+
+    //See if the name exists in the reg tree.
+    res = m_pRegistry->GetPropListByName( pszTreeName, pValues);
+    if( HXR_OK!=res || !pValues )
+        return HXR_FAIL;
+
+    //make sure this is a PT_COMPOSITE type reg entry.
+    if( PT_COMPOSITE != m_pRegistry->GetTypeByName(pszTreeName))
+        return HXR_FAIL;
+
+    //Print out the value of each member of this tree.
+    res = pValues->GetFirstPropertyULONG32( pszName, ulRegID );
+    while( HXR_OK == res )
+    {
+        //We have at least one entry. See what type it is.
+        HXPropType pt = m_pRegistry->GetTypeById(ulRegID);
+        switch(pt)
+        {
+           case PT_COMPOSITE:
+               DumpRegTree(pszName);
+               break;
+           case PT_INTEGER :
+               nVal = 0;
+               m_pRegistry->GetIntById( ulRegID, nVal );
+               STDOUT("%s : %d\n", pszName, nVal ); 
+               break;
+           case PT_INTREF :
+               nVal = 0;
+               m_pRegistry->GetIntById( ulRegID, nVal );
+               STDOUT("%s : %d\n", pszName, nVal ); 
+               break;
+           case PT_STRING :
+               pBuff = NULL;
+               m_pRegistry->GetStrById( ulRegID, pBuff );
+               STDOUT("%s : \"", pszName ); 
+               if( pBuff )
+                   STDOUT("%s", (const char *)(pBuff->GetBuffer()) );
+               STDOUT("\"\n" ); 
+               HX_RELEASE(pBuff);
+               break;
+           case PT_BUFFER :
+               STDOUT("%s : BUFFER TYPE NOT SHOWN\n",
+                        pszName, nVal ); 
+               break;
+           case PT_UNKNOWN:
+               STDOUT("%s Unkown registry type entry\n", pszName );
+               break;
+           default:
+               STDOUT("%s Unkown registry type entry\n", pszName );
+               break;
+        }
+        res = pValues->GetNextPropertyULONG32( pszName, ulRegID);
+    }
+
+    HX_RELEASE( pValues );
+    
+    return HXR_OK;
+}
+
+
+/************************************************************************
+ *	Method:
+ *	    IHXClientAdviseSink::OnPreSeek
+ *	Purpose:
+ *	    Called by client engine to inform the client that a seek is
+ *	    about to occur. The render is informed the last time for the 
+ *	    stream's time line before the seek, as well as the first new
+ *	    time for the stream's time line after the seek will be completed.
+ *
+ */
+STDMETHODIMP ExampleClientAdviceSink::OnPreSeek(	ULONG32	ulOldTime,
+						ULONG32	ulNewTime)
+{
+#if !defined(__TCS__)
+    if (GetGlobal()->bEnableAdviceSink)
+    {
+        STDOUT("OnPreSeek(%ld, %ld)\n", ulOldTime, ulNewTime);
+    }
+#endif
+
+    return HXR_OK;
+}
+
+
+/************************************************************************
+ *	Method:
+ *	    IHXClientAdviseSink::OnPostSeek
+ *	Purpose:
+ *	    Called by client engine to inform the client that a seek has
+ *	    just occured. The render is informed the last time for the 
+ *	    stream's time line before the seek, as well as the first new
+ *	    time for the stream's time line after the seek.
+ *
+ */
+STDMETHODIMP ExampleClientAdviceSink::OnPostSeek(	ULONG32	ulOldTime,
+						ULONG32	ulNewTime)
+{
+#ifdef __TCS__
+    lastPosition = -1;
+#else
+    if (GetGlobal()->bEnableAdviceSink)
+    {
+        STDOUT("OnPostSeek(%ld, %ld)\n", ulOldTime, ulNewTime);
+    }
+#endif
+
+    return HXR_OK;
+}
+
+
+/************************************************************************
+ *	Method:
+ *	    IHXClientAdviseSink::OnStop
+ *	Purpose:
+ *	    Called by client engine to inform the client that a stop has
+ *	    just occured. 
+ *
+ */
+STDMETHODIMP ExampleClientAdviceSink::OnStop(void)
+{
+    HXTimeval now;
+
+#ifdef __TCS__
+    hookRealAudio_State(eStop);
+#else
+    if (GetGlobal()->bEnableAdviceSink)
+    {
+        STDOUT("OnStop()\n");
+    }
+
+    if (GetGlobal()->bEnableVerboseMode)
+    {
+        STDOUT("Player %ld stopped.\n", m_lClientIndex);
+        m_bOnStop = TRUE;
+	GetAllStatistics();
+    }
+#endif
+
+    // Find out the current time and subtract the beginning time to
+    // figure out how many seconds we played
+    now = m_pScheduler->GetCurrentSchedulerTime();
+    m_ulStopTime = now.tv_sec;
+
+    GetGlobal()->g_ulNumSecondsPlayed = m_ulStopTime - m_ulStartTime;
+
+    return HXR_OK;
+}
+
+/************************************************************************
+ *	Method:
+ *	    IHXClientAdviseSink::OnPause
+ *	Purpose:
+ *	    Called by client engine to inform the client that a pause has
+ *	    just occured. The render is informed the last time for the 
+ *	    stream's time line before the pause.
+ *
+ */
+STDMETHODIMP ExampleClientAdviceSink::OnPause(ULONG32 ulTime)
+{
+#ifdef __TCS__
+    hookRealAudio_State(ePause);
+#else
+    if (GetGlobal()->bEnableAdviceSink)
+    {
+        STDOUT("OnPause(%ld)\n", ulTime);
+    }
+#endif 
+
+    return HXR_OK;
+}
+
+
+/************************************************************************
+ *	Method:
+ *	    IHXClientAdviseSink::OnBegin
+ *	Purpose:
+ *	    Called by client engine to inform the client that a begin or
+ *	    resume has just occured. The render is informed the first time 
+ *	    for the stream's time line after the resume.
+ *
+ */
+STDMETHODIMP ExampleClientAdviceSink::OnBegin(ULONG32 ulTime)
+{
+    HXTimeval now;
+
+#if !defined(__TCS__)
+    if (GetGlobal()->bEnableAdviceSink)
+    {
+        STDOUT("OnBegin(%ld)\n", ulTime);
+    }
+
+    if (GetGlobal()->bEnableVerboseMode)
+    {
+        STDOUT("Player %ld beginning playback...\n", m_lClientIndex);
+    }
+#endif
+
+    GetGlobal()->g_bOnBeginOccurred = TRUE;
+
+    // Record the current time, so we can figure out many seconds we played
+    now = m_pScheduler->GetCurrentSchedulerTime();
+    m_ulStartTime = now.tv_sec;
+
+    return HXR_OK;
+}
+
+
+/************************************************************************
+ *	Method:
+ *	    IHXClientAdviseSink::OnBuffering
+ *	Purpose:
+ *	    Called by client engine to inform the client that buffering
+ *	    of data is occuring. The render is informed of the reason for
+ *	    the buffering (start-up of stream, seek has occured, network
+ *	    congestion, etc.), as well as percentage complete of the 
+ *	    buffering process.
+ *
+ */
+STDMETHODIMP ExampleClientAdviceSink::OnBuffering(ULONG32	ulFlags,
+						UINT16	unPercentComplete)
+{
+#ifdef __TCS__
+static UINT16	lastPct = 0;
+    if (unPercentComplete > 0)
+    {
+	UINT16	nextPct = lastPct + 10;
+	if (unPercentComplete < lastPct)
+	{
+	    lastPct = 0;
+	    nextPct = lastPct + 10;
+	}
+	if (unPercentComplete >= nextPct)
+	{
+	    lastPct = (unPercentComplete / 10) * 10;
+	    nextPct = lastPct + 10;
+	    hookRealAudio_Buffering(eBuffering,lastPct);
+	}
+    }
+#else
+    if (GetGlobal()->bEnableAdviceSink)
+    {
+        STDOUT("OnBuffering(%ld, %d)\n", ulFlags, unPercentComplete);
+    }
+#endif
+    if (m_on_buffering_cb)
+        m_on_buffering_cb(ulFlags, unPercentComplete, m_context);
+
+    return HXR_OK;
+}
+
+
+/************************************************************************
+ *	Method:
+ *	    IHXClientAdviseSink::OnContacting
+ *	Purpose:
+ *	    Called by client engine to inform the client is contacting
+ *	    hosts(s).
+ *
+ */
+STDMETHODIMP ExampleClientAdviceSink::OnContacting(const char* pHostName)
+{
+#ifdef __TCS__
+    printf("Contacting\n");
+    hookRealAudio_Buffering(eContacting,0);
+#else
+    if (GetGlobal()->bEnableAdviceSink)
+    {
+        STDOUT("OnContacting(\"%s\")\n", pHostName);
+    }
+#endif
+
+    return HXR_OK;
+}
+
+void ExampleClientAdviceSink::PrintPropName( IHXValues* pHeader )
+{
+    if ( pHeader == NULL )
+    {
+        return ;
+    }
+
+    const char *pChar;
+    ULONG32 pValue;
+    if(HXR_OK == pHeader->GetFirstPropertyULONG32(pChar, pValue))
+    {
+        do
+        {
+            STDOUT("%s %d\n", pChar, pValue);
+        }
+        while(HXR_OK == pHeader->GetNextPropertyULONG32(pChar, pValue));
+    }
+
+    IHXBuffer *pBuffer;
+
+    if(HXR_OK == pHeader->GetFirstPropertyBuffer(pChar, pBuffer))
+    {
+        do
+        {
+            STDOUT("%s %s\n", pChar, (const char *) ( pBuffer->GetBuffer() ));
+		PrintBuffer(pChar, pBuffer->GetBuffer() ,pBuffer->GetSize());
+            HX_RELEASE(pBuffer);
+        } while(HXR_OK == pHeader->GetNextPropertyBuffer(pChar, pBuffer ));
+    }
+    
+	if(HXR_OK == pHeader->GetFirstPropertyCString(pChar, pBuffer))
+    {
+        do
+        {
+            STDERR("%s %s\n", pChar, (const char *) ( pBuffer->GetBuffer() ));
+            HX_RELEASE(pBuffer);
+        } while(HXR_OK == pHeader->GetNextPropertyCString(pChar, pBuffer ));
+    }
+    
+    fflush(stdout);
+}
+
+
+void ExampleClientAdviceSink::SetClipInfo( IHXPlayer* m_pRMAPlayer)
+{
+    bool bSendOnClipInfo = false;
+
+    // Get HXSource and try to get clip infor. 
+    UINT32 sourceCount = m_pRMAPlayer->GetSourceCount();	
+    for (UINT32 sourceID = 0; sourceID < sourceCount; sourceID ++)
+    {
+	// get HXSource
+        STDOUT("========Source %d========\n",sourceID);
+        IUnknown* pUnkSource = NULL;
+        IHXStreamSource* pStreamSrc = NULL;
+
+        if (HXR_OK != m_pRMAPlayer->GetSource (sourceID, pUnkSource))
+        {
+            continue;
+        }
+
+        pUnkSource->QueryInterface(IID_IHXStreamSource, (void **)&pStreamSrc);
+
+        HX_RELEASE(pUnkSource);
+
+        if (!pStreamSrc)
+        {
+            continue;
+        }
+
+	UINT32 num_streams = pStreamSrc->GetStreamCount();
+	
+	STDOUT("====File Header====\n");
+
+        IHXValues* pFileHdr = NULL;
+        pStreamSrc->QueryInterface(IID_IHXValues, (void**)&pFileHdr);
+
+        if ( pFileHdr)
+        {
+	    PrintPropName(pFileHdr);
+        }
+        HX_RELEASE(pFileHdr);
+
+        // get information from Streams
+        for (UINT32 streamID = 0; streamID < num_streams ; streamID++)
+        {
+            STDOUT("====Stream %d====\n",streamID);
+            IUnknown* pUnkStream = NULL;
+
+            if (HXR_OK == pStreamSrc->GetStream(streamID, pUnkStream))
+            {
+                IHXStream* pStream = NULL;
+
+                if (HXR_OK == pUnkStream->QueryInterface(IID_IHXStream,
+                                                         (void**)&pStream))
+                {
+                    IHXValues* pStreamHdr = pStream->GetHeader();
+                    if (pStreamHdr)
+                    {
+                        PrintPropName(pStreamHdr);
+                    }
+                    HX_RELEASE(pStreamHdr);
+                }
+                HX_RELEASE(pStream);
+            }
+            HX_RELEASE(pUnkStream);
+        }
+        STDOUT("---------------------------------------------\n");
+
+        HX_RELEASE(pStreamSrc);
+    }
+}
+
+
+STDMETHODIMP ExampleClientAdviceSink::Func()
+{
+    m_hCallback = 0;
+
+    // set clip info
+	if(m_pPlayer)
+	    SetClipInfo(m_pPlayer);
+
+    return HXR_OK;
+}
+
+void PrintBuffer(const char* pszName,const unsigned char* pbBuf, unsigned int dwBytes)
+{
+	if(pszName == NULL || pbBuf == NULL)
+		return;
+
+	STDOUT("    ");
+	for(unsigned int i= 0; i<dwBytes; i++)	{
+		STDOUT("0x%02x  ",*pbBuf++);
+		if(i % 15 == 0 && i!=0)
+			STDOUT("\n    ");
+	}
+	STDOUT("\n");
+	return;
+}
+
+/*
+ *  IHXGroupSink methods
+ */
+/************************************************************************
+ *  Method:
+ *      IHXGroupSink::GroupAdded
+ *  Purpose:
+ *		Notification of a new group being added to the presentation.
+ */
+STDMETHODIMP ExampleClientAdviceSink::GroupAdded( UINT16 /*IN*/ uGroupIndex,
+			    IHXGroup* /*IN*/ pGroup)
+{
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *      IHXGroupSink::GroupRemoved
+ *  Purpose:
+ *		Notification of a group being removed from the presentation.
+ */
+STDMETHODIMP ExampleClientAdviceSink::GroupRemoved( UINT16 /*IN*/ uGroupIndex,
+				IHXGroup*  /*IN*/ pGroup)
+{
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *      IHXGroupSink::AllGroupsRemoved
+ *  Purpose:
+ *		Notification that all groups have been removed from the 
+ *		current presentation.
+ */
+STDMETHODIMP ExampleClientAdviceSink::AllGroupsRemoved()
+{
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *      IHXGroupSink::TrackAdded
+ *  Purpose:
+ *		Notification of a new track being added to a group.
+ */
+STDMETHODIMP ExampleClientAdviceSink::TrackAdded( UINT16 /*IN*/ uGroupIndex,
+			    UINT16     /*IN*/ uTrackIndex,
+			    IHXValues* /*IN*/ pTrack)
+{
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *      IHXGroupSink::TrackRemoved
+ *  Purpose:
+ *		Notification of a track being removed from a group.
+ */
+STDMETHODIMP ExampleClientAdviceSink::TrackRemoved( UINT16 /*IN*/ uGroupIndex,
+				UINT16     /*IN*/ uTrackIndex,
+				IHXValues* /*IN*/ pTrack)
+{
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *      IHXGroupSink::TrackStarted
+ *  Purpose:
+ *		Notification of a track being started (to get duration, for
+ *		instance...)
+ */
+STDMETHODIMP ExampleClientAdviceSink::TrackStarted( UINT16 /*IN*/ uGroupIndex,
+				UINT16     /*IN*/ uTrackIndex,
+				IHXValues* /*IN*/ pTrack)
+{
+    if ( m_bWaitForTrackStart )
+    {
+        STDOUT("----------------clip info--------------------\n");
+        if(m_pScheduler)
+        {
+            m_hCallback = m_pScheduler->RelativeEnter(this,50);
+        }
+	m_bWaitForTrackStart = FALSE;
+    }
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *      IHXGroupSink::TrackStopped
+ *  Purpose:
+ *		Notification of a track being stopped
+ *
+ */
+STDMETHODIMP ExampleClientAdviceSink::TrackStopped( UINT16 /*IN*/ uGroupIndex,
+				UINT16     /*IN*/ uTrackIndex,
+				IHXValues* /*IN*/ pTrack)
+{
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *      IHXGroupSink::CurrentGroupSet
+ *  Purpose:
+ *		This group is being currently played in the presentation.
+ */
+STDMETHODIMP ExampleClientAdviceSink::CurrentGroupSet( UINT16 /*IN*/ uGroupIndex,
+				IHXGroup* /*IN*/ pGroup)
+{
+    return HXR_OK;
+}
+
Index: helix-libs/clientapps/clutter/exadvsnk.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exadvsnk.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,324 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#ifndef _EXAMPLECLSNK_
+#define _EXAMPLECLSNK_
+
+#include "player.h"
+
+struct IHXClientAdviseSink;
+struct IHXGroupSink;
+struct IUnknown;
+struct IHXRegistry;
+struct IHXScheduler;
+struct IHXCallback;
+struct IHXPlayer;
+struct IHXGroup;
+
+class ExampleClientAdviceSink : public IHXClientAdviseSink,
+                                public IHXGroupSink,
+                                public IHXCallback
+{
+  private:
+    LONG32          m_lRefCount;
+    LONG32          m_lClientIndex;
+    
+    IUnknown*       m_pUnknown;
+    IHXRegistry*    m_pRegistry;
+    IHXScheduler*   m_pScheduler;
+    
+    UINT32          m_ulStartTime;
+    UINT32          m_ulStopTime;
+    
+    UINT32    m_lCurrentBandwidth;
+    UINT32    m_lAverageBandwidth;
+    HXBOOL      m_bOnStop;
+  
+    HXBOOL      m_bWaitForTrackStart;
+   
+    on_buffering_cb_t m_on_buffering_cb;
+    on_pos_length_cb_t m_on_pos_length_cb; 
+    void *m_context;    /* a argument passed by texture-helix lib */
+
+    // IHXCallback
+	IHXPlayer*		m_pPlayer;
+    ULONG32         m_hCallback;
+    ~ExampleClientAdviceSink();
+    HX_RESULT DumpRegTree(const char* pszTreeName );
+
+
+        void GetStatistics (char* /*IN*/ pszRegistryKey);
+    void GetAllStatistics (void);
+	void SetClipInfo( IHXPlayer* m_pRMAPlayer);
+	void PrintPropName( IHXValues* pHeader );
+
+  public:
+
+    ExampleClientAdviceSink(IUnknown* /*IN*/ pUnknown, LONG32 /*IN*/ lClientIndex, on_buffering_cb_t on_buffer_cb, on_pos_length_cb_t on_pos_length_cb, void *context);
+
+    /*
+     *  IUnknown methods
+     */
+    STDMETHOD(QueryInterface) (THIS_
+                               REFIID riid,
+                               void** ppvObj);
+    
+    STDMETHOD_(ULONG32,AddRef) (THIS);
+
+    STDMETHOD_(ULONG32,Release) (THIS);
+
+    /*
+     *  IHXClientAdviseSink methods
+     */
+
+    /************************************************************************
+     *  Method:
+     *      IHXClientAdviseSink::OnPosLength
+     *  Purpose:
+     *      Called to advise the client that the position or length of the
+     *      current playback context has changed.
+     */
+    STDMETHOD(OnPosLength) (THIS_
+                            UINT32    ulPosition,
+                            UINT32    ulLength);
+    
+    /************************************************************************
+     *  Method:
+     *      IHXClientAdviseSink::OnPresentationOpened
+     *  Purpose:
+     *      Called to advise the client a presentation has been opened.
+     */
+    STDMETHOD(OnPresentationOpened) (THIS);
+
+    /************************************************************************
+     *  Method:
+     *      IHXClientAdviseSink::OnPresentationClosed
+     *  Purpose:
+     *      Called to advise the client a presentation has been closed.
+     */
+    STDMETHOD(OnPresentationClosed) (THIS);
+
+    /************************************************************************
+     *  Method:
+     *      IHXClientAdviseSink::OnStatisticsChanged
+     *  Purpose:
+     *      Called to advise the client that the presentation statistics
+     *      have changed. 
+     */
+    STDMETHOD(OnStatisticsChanged) (THIS);
+
+    /************************************************************************
+     *  Method:
+     *      IHXClientAdviseSink::OnPreSeek
+     *  Purpose:
+     *      Called by client engine to inform the client that a seek is
+     *      about to occur. The render is informed the last time for the 
+     *      stream's time line before the seek, as well as the first new
+     *      time for the stream's time line after the seek will be completed.
+     *
+     */
+    STDMETHOD (OnPreSeek) (THIS_
+                           ULONG32 ulOldTime,
+                           ULONG32  ulNewTime);
+
+    /************************************************************************
+     *  Method:
+     *      IHXClientAdviseSink::OnPostSeek
+     *  Purpose:
+     *      Called by client engine to inform the client that a seek has
+     *      just occured. The render is informed the last time for the 
+     *      stream's time line before the seek, as well as the first new
+     *      time for the stream's time line after the seek.
+     *
+     */
+    STDMETHOD (OnPostSeek) (THIS_
+                            ULONG32 ulOldTime,
+                            ULONG32 ulNewTime);
+
+    /************************************************************************
+     *  Method:
+     *      IHXClientAdviseSink::OnStop
+     *  Purpose:
+     *      Called by client engine to inform the client that a stop has
+     *      just occured. 
+     *
+     */
+    STDMETHOD (OnStop) (THIS);
+
+    /************************************************************************
+     *  Method:
+     *      IHXClientAdviseSink::OnPause
+     *  Purpose:
+     *      Called by client engine to inform the client that a pause has
+     *      just occured. The render is informed the last time for the 
+     *      stream's time line before the pause.
+     *
+     */
+    STDMETHOD (OnPause) (THIS_
+                         ULONG32 ulTime);
+
+    /************************************************************************
+     *  Method:
+     *      IHXClientAdviseSink::OnBegin
+     *  Purpose:
+     *      Called by client engine to inform the client that a begin or
+     *      resume has just occured. The render is informed the first time 
+     *      for the stream's time line after the resume.
+     *
+     */
+    STDMETHOD (OnBegin) (THIS_
+                         ULONG32 ulTime);
+
+    /************************************************************************
+     *  Method:
+     *      IHXClientAdviseSink::OnBuffering
+     *  Purpose:
+     *      Called by client engine to inform the client that buffering
+     *      of data is occuring. The render is informed of the reason for
+     *      the buffering (start-up of stream, seek has occured, network
+     *      congestion, etc.), as well as percentage complete of the 
+     *      buffering process.
+     *
+     */
+    STDMETHOD (OnBuffering) (THIS_
+                             ULONG32 ulFlags,
+                             UINT16 unPercentComplete);
+
+
+    /************************************************************************
+     *  Method:
+     *      IHXClientAdviseSink::OnContacting
+     *  Purpose:
+     *      Called by client engine to inform the client is contacting
+     *      hosts(s).
+     *
+     */
+    STDMETHOD (OnContacting) (THIS_
+                              const char* pHostName);
+
+    // IHXCallback
+    STDMETHOD(Func)            (THIS);
+
+    /*
+     *  IHXGroupSink methods
+     */
+    /************************************************************************
+    *  Method:
+    *      IHXGroupSink::GroupAdded
+    *  Purpose:
+    *		Notification of a new group being added to the presentation.
+    */
+    STDMETHOD(GroupAdded)    (THIS_
+			    UINT16 	    /*IN*/ uGroupIndex,
+			    IHXGroup*	    /*IN*/ pGroup);
+
+    /************************************************************************
+    *  Method:
+    *      IHXGroupSink::GroupRemoved
+    *  Purpose:
+    *		Notification of a group being removed from the presentation.
+    */
+    STDMETHOD(GroupRemoved)    (THIS_
+				UINT16 	    /*IN*/ uGroupIndex,
+				IHXGroup*  /*IN*/ pGroup);
+
+    /************************************************************************
+    *  Method:
+    *      IHXGroupSink::AllGroupsRemoved
+    *  Purpose:
+    *		Notification that all groups have been removed from the 
+    *		current presentation.
+    */
+    STDMETHOD(AllGroupsRemoved)  (THIS);
+
+    /************************************************************************
+    *  Method:
+    *      IHXGroupSink::TrackAdded
+    *  Purpose:
+    *		Notification of a new track being added to a group.
+    */
+    STDMETHOD(TrackAdded)  (THIS_
+			    UINT16 	    /*IN*/ uGroupIndex,
+			    UINT16 	    /*IN*/ uTrackIndex,
+			    IHXValues*	    /*IN*/ pTrack);
+
+    /************************************************************************
+    *  Method:
+    *      IHXGroupSink::TrackRemoved
+    *  Purpose:
+    *		Notification of a track being removed from a group.
+    */
+    STDMETHOD(TrackRemoved)    (THIS_
+				UINT16 		/*IN*/ uGroupIndex,
+				UINT16 		/*IN*/ uTrackIndex,
+				IHXValues*	/*IN*/ pTrack);
+
+    /************************************************************************
+    *  Method:
+    *      IHXGroupSink::TrackStarted
+    *  Purpose:
+    *		Notification of a track being started (to get duration, for
+    *		instance...)
+    */
+    STDMETHOD (TrackStarted)	(THIS_
+				UINT16	    /*IN*/ uGroupIndex,
+				UINT16	    /*IN*/ uTrackIndex,
+				IHXValues* /*IN*/ pTrack) ;
+    
+    /************************************************************************
+    *  Method:
+    *      IHXGroupSink::TrackStopped
+    *  Purpose:
+    *		Notification of a track being stopped
+    *
+    */
+    STDMETHOD(TrackStopped)	(THIS_
+				UINT16	    /*IN*/ uGroupIndex,
+				UINT16	    /*IN*/ uTrackIndex,
+				IHXValues* /*IN*/ pTrack);
+
+    /************************************************************************
+    *  Method:
+    *      IHXGroupSink::CurrentGroupSet
+    *  Purpose:
+    *		This group is being currently played in the presentation.
+    */
+    STDMETHOD(CurrentGroupSet)	(THIS_
+				UINT16 	    /*IN*/ uGroupIndex,
+				IHXGroup*  /*IN*/ pGroup);
+
+};
+
+#endif /* _EXAMPLECLSNK_ */
Index: helix-libs/clientapps/clutter/exaumgr.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exaumgr.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,137 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#include <stdio.h>
+#include "hxtypes.h"
+#include "hxcom.h"
+#include "hxauth.h"
+#include "hxstrutl.h"
+#include "exaumgr.h"
+#include <ctype.h>
+#include "print.h"
+
+
+#include "globals.h"
+struct _stGlobals*& GetGlobal(); //in main.cpp
+
+
+
+ExampleAuthenticationManager::ExampleAuthenticationManager() :
+    m_lRefCount(0),
+    m_bSentPassword(FALSE)
+{
+}
+
+ExampleAuthenticationManager::~ExampleAuthenticationManager()
+{
+}
+
+STDMETHODIMP
+ExampleAuthenticationManager::QueryInterface(REFIID riid, void**ppvObj)
+{
+    if(IsEqualIID(riid, IID_IUnknown))
+    {
+        AddRef();
+        *ppvObj = (IUnknown*)(IHXAuthenticationManager*)this;
+        return HXR_OK;
+    }
+    else if(IsEqualIID(riid, IID_IHXAuthenticationManager))
+    {
+        AddRef();
+        *ppvObj = (IHXAuthenticationManager*)this;
+        return HXR_OK;
+    }
+    *ppvObj = NULL;
+    return HXR_NOINTERFACE;
+}
+
+STDMETHODIMP_(UINT32)
+ExampleAuthenticationManager::AddRef()
+{
+    return InterlockedIncrement(&m_lRefCount);
+}
+
+STDMETHODIMP_(UINT32)
+ExampleAuthenticationManager::Release()
+{
+    if (InterlockedDecrement(&m_lRefCount) > 0)
+    {
+        return m_lRefCount;
+    }
+
+    delete this;
+    return 0;
+}
+
+STDMETHODIMP
+ExampleAuthenticationManager::HandleAuthenticationRequest(IHXAuthenticationManagerResponse* pResponse)
+{
+    char      username[1024] = ""; /* Flawfinder: ignore */
+    char      password[1024] = ""; /* Flawfinder: ignore */
+    HX_RESULT res = HXR_FAIL;
+    
+    if( !m_bSentPassword )
+    {
+        res = HXR_OK;
+        if (GetGlobal()->bEnableVerboseMode)
+            STDOUT("\nSending Username and Password...\n");
+
+        SafeStrCpy(username,  GetGlobal()->g_pszUsername, 1024);
+        SafeStrCpy(password,  GetGlobal()->g_pszPassword, 1024);
+
+        //strip trailing whitespace
+        char* c;
+        for(c = username + strlen(username) - 1; 
+            c > username && isspace(*c);
+            c--)
+            ;
+        *(c+1) = 0;
+    
+        for(c = password + strlen(password) - 1; 
+            c > password && isspace(*c);
+            c--)
+            ;
+        *(c+1) = 0;
+        
+        m_bSentPassword = TRUE;
+    }
+
+    if (GetGlobal()->bEnableVerboseMode && FAILED(res) )
+        STDOUT("\nInvalid Username and/or Password.\n");
+    
+    pResponse->AuthenticationRequestDone(res, username, password);
+    return res;
+}
+
Index: helix-libs/clientapps/clutter/exaumgr.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exaumgr.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,56 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#ifndef _EXAUMGR_H_
+#define _EXAUMGR_H_
+
+#include "hxauth.h"
+
+class ExampleAuthenticationManager : public IHXAuthenticationManager
+{
+private:
+    INT32 m_lRefCount;
+    HXBOOL  m_bSentPassword;
+    ~ExampleAuthenticationManager();
+
+public:
+    ExampleAuthenticationManager();
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void** ppvObj);
+    STDMETHOD_(UINT32,AddRef) (THIS);
+    STDMETHOD_(UINT32,Release) (THIS);
+
+    STDMETHOD(HandleAuthenticationRequest) (IHXAuthenticationManagerResponse* pResponse);
+};
+#endif
Index: helix-libs/clientapps/clutter/excallback.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/excallback.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,38 @@
+#include "excallback.h"
+
+STDMETHODIMP ExCallback::QueryInterface(REFIID riid, void** ppvObj)
+{
+	if (IsEqualIID(riid, IID_IHXCallback))
+	{
+		AddRef();
+		*ppvObj = (IHXCallback*)this;
+		return HXR_OK;
+	}
+	else if (IsEqualIID(riid, IID_IUnknown))
+	{
+		AddRef();
+		*ppvObj = this;
+		return HXR_OK;
+	}
+
+	*ppvObj = NULL;
+	return HXR_NOINTERFACE;
+}
+
+STDMETHODIMP_(ULONG32) ExCallback::AddRef()
+{
+	return HXR_OK;
+}
+
+STDMETHODIMP_(ULONG32) ExCallback::Release()
+{
+	return HXR_OK;
+}
+
+STDMETHODIMP ExCallback::Func(void)
+{
+	UINT32 sleepTime = 0;
+	m_pKicker->Kick(HXGetCurrentThreadID, &sleepTime);
+	printf("Get called, sleeptime:%d\n", sleepTime);
+	m_pScheduler->RelativeEnter(this, sleepTime/1000);
+}
Index: helix-libs/clientapps/clutter/excallback.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/excallback.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,32 @@
+#ifndef _EX_CALLBACK_H_
+#define _EX_CALLBACK_H_
+
+#include "hxcom.h"
+#include "hxengin.h"
+#include "ihxmedpltfm.h"
+#include "thrdutil.h"
+
+class ExCallback : public IHXCallback
+{
+	public:
+		ExCallback(IHXScheduler *pIHXScheduler, IHXMediaPlatformKicker *pKicker) : m_pScheduler(pIHXScheduler), m_pKicker(pKicker){};
+
+		/*
+		 *      *  IUnknown methods
+		 *           */
+		STDMETHOD(QueryInterface) (THIS_ REFIID riid, void** ppvObj);
+		STDMETHOD_(ULONG32,AddRef) (THIS);
+		STDMETHOD_(ULONG32,Release) (THIS);
+
+		/*
+		 *      *  IHXCallback methods
+		 *           */
+		STDMETHOD(Func) (THIS);
+	private:
+		IHXScheduler *m_pScheduler;
+		IHXMediaPlatformKicker* m_pKicker;
+
+};
+
+
+#endif 
Index: helix-libs/clientapps/clutter/excontxt.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/excontxt.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,315 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#include "hxtypes.h"
+
+#include "hxwintyp.h"
+#include "hxcom.h"
+#include "hxcomm.h"
+#include "hxwin.h"
+#include "fivemmap.h"
+
+#include "hxbuffer.h"
+#include "hxmangle.h"
+
+#include "hxclsnk.h"
+#include "hxgroup.h"
+#include "hxerror.h"
+#include "hxprefs.h"
+#include "hxstrutl.h"
+
+#include "exadvsnk.h"
+#include "exstateadvsnk.h"
+#include "exerror.h"
+#include "exsitsup.h"
+#include "exaumgr.h"
+#include "hxprdnld.h"
+#include "exprdnld.h"
+
+#include "excontxt.h"
+
+extern HXBOOL bEnableAdviceSink;
+
+
+ExampleClientContext::ExampleClientContext(LONG32 lClientIndex)
+    : m_lRefCount(0)
+    , m_lClientIndex(lClientIndex)
+    , m_pClientSink(NULL)
+    , m_pClientStateSink(NULL)
+    , m_pErrorSink(NULL)
+    , m_pAuthMgr(NULL)
+    , m_pSiteSupplier(NULL)
+    , m_pDefaultPrefs(NULL)
+#if defined(HELIX_FEATURE_PROGRESSIVE_DOWNLD_STATUS)
+    , m_pPrgDnldStatusObserver(NULL)
+#endif // /HELIX_FEATURE_PROGRESSIVE_DOWNLD_STATUS.
+{
+}
+
+
+ExampleClientContext::~ExampleClientContext()
+{
+    Close();
+};
+
+void ExampleClientContext::Init(IUnknown*	 /*IN*/ pUnknown,
+				IHXPreferences* /*IN*/ pPreferences,
+				char*		 /*IN*/ pszGUID,
+                on_buffering_cb_t   on_buffering_cb,
+                on_pos_length_cb_t on_pos_length_cb,
+                on_state_change_cb_t on_state_change_cb,
+                on_new_frame_cb_t   on_new_frame_cb,
+                void *context)
+{
+    char* pszCipher = NULL;
+
+	
+    m_pClientSink	= new ExampleClientAdviceSink(pUnknown, m_lClientIndex, on_buffering_cb, on_pos_length_cb, context);
+
+    m_pClientStateSink	= new ExampleClientStateAdviceSink(pUnknown, m_lClientIndex, on_state_change_cb, context);
+    m_pErrorSink	= new ExampleErrorSink(pUnknown);
+#if defined(HELIX_FEATURE_AUTHENTICATION)
+    m_pAuthMgr          = new ExampleAuthenticationManager();
+    if(m_pAuthMgr)
+    {
+	m_pAuthMgr->AddRef();
+    }
+
+#endif /* #if defined(HELIX_FEATURE_AUTHENTICATION) */
+#if defined(HELIX_FEATURE_VIDEO)
+    m_pSiteSupplier	= new ExampleSiteSupplier(pUnknown, on_new_frame_cb, context);
+#endif 
+
+#if defined(HELIX_FEATURE_PROGRESSIVE_DOWNLD_STATUS)
+    m_pPrgDnldStatusObserver = new ExamplePDStatusObserver(pUnknown);
+#endif // /HELIX_FEATURE_PROGRESSIVE_DOWNLD_STATUS.
+
+    if (m_pClientSink)
+    {
+	m_pClientSink->AddRef();
+    }
+    
+    if (m_pErrorSink)
+    {
+	m_pErrorSink->AddRef();
+    }
+
+    if (m_pClientStateSink)
+        m_pClientStateSink->AddRef();
+
+    if(m_pSiteSupplier)
+    {
+	m_pSiteSupplier->AddRef();
+    }
+
+    if (pPreferences)
+    {
+	m_pDefaultPrefs = pPreferences;
+	m_pDefaultPrefs->AddRef();
+    }
+
+    if (pszGUID && *pszGUID)
+    {
+	// Encode GUID
+	pszCipher = Cipher(pszGUID);
+	SafeStrCpy(m_pszGUID,  pszCipher, 256);
+    }
+    else
+    {
+	m_pszGUID[0] = '\0';
+    }
+}
+
+void ExampleClientContext::Close()
+{
+    HX_RELEASE(m_pClientSink);
+    HX_RELEASE(m_pClientStateSink);
+    HX_RELEASE(m_pErrorSink);
+#if defined(HELIX_FEATURE_AUTHENTICATION)
+    HX_RELEASE(m_pAuthMgr);
+#endif /* #if defined(HELIX_FEATURE_AUTHENTICATION) */
+    HX_RELEASE(m_pSiteSupplier);
+    HX_RELEASE(m_pDefaultPrefs);
+#if defined(HELIX_FEATURE_PROGRESSIVE_DOWNLD_STATUS)
+    HX_RELEASE(m_pPrgDnldStatusObserver);
+#endif // /HELIX_FEATURE_PROGRESSIVE_DOWNLD_STATUS.
+}
+
+
+
+// *** IUnknown methods ***
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::QueryInterface
+//  Purpose:
+//	Implement this to export the interfaces supported by your 
+//	object.
+//
+STDMETHODIMP ExampleClientContext::QueryInterface(REFIID riid, void** ppvObj)
+{
+    if (IsEqualIID(riid, IID_IUnknown))
+    {
+	AddRef();
+	*ppvObj = this;
+	return HXR_OK;
+    }
+    else if (IsEqualIID(riid, IID_IHXPreferences))
+    {
+	AddRef();
+	*ppvObj = (IHXPreferences*)this;
+	return HXR_OK;
+    }
+    else if (m_pClientSink && 
+	     m_pClientSink->QueryInterface(riid, ppvObj) == HXR_OK)
+    {
+	return HXR_OK;
+    }
+    else if (m_pErrorSink && 
+	     m_pErrorSink->QueryInterface(riid, ppvObj) == HXR_OK)
+    {
+	return HXR_OK;
+    }
+    else if (m_pClientStateSink &&
+            m_pClientStateSink->QueryInterface(riid, ppvObj) == HXR_OK)
+    {
+        return HXR_OK;
+    }
+#if defined(HELIX_FEATURE_AUTHENTICATION)
+    else if(m_pAuthMgr &&
+	    m_pAuthMgr->QueryInterface(riid, ppvObj) == HXR_OK)
+    {
+	return HXR_OK;
+    }
+#endif /* #if defined(HELIX_FEATURE_AUTHENTICATION) */
+    else if(m_pSiteSupplier &&
+	    m_pSiteSupplier->QueryInterface(riid, ppvObj) == HXR_OK)
+    {
+	return HXR_OK;
+    }
+    *ppvObj = NULL;
+    return HXR_NOINTERFACE;
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::AddRef
+//  Purpose:
+//	Everyone usually implements this the same... feel free to use
+//	this implementation.
+//
+STDMETHODIMP_(ULONG32) ExampleClientContext::AddRef()
+{
+    return InterlockedIncrement(&m_lRefCount);
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::Release
+//  Purpose:
+//	Everyone usually implements this the same... feel free to use
+//	this implementation.
+//
+STDMETHODIMP_(ULONG32) ExampleClientContext::Release()
+{
+    if (InterlockedDecrement(&m_lRefCount) > 0)
+    {
+        return m_lRefCount;
+    }
+
+    delete this;
+    return 0;
+}
+
+
+// *** IUnknown methods ***
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IHXPreferences::ReadPref
+//  Purpose:
+//	Read a Preference from the registry.
+//
+STDMETHODIMP
+ExampleClientContext::ReadPref(const char* pref_key, IHXBuffer*& buffer)
+{
+    HX_RESULT hResult	= HXR_OK;
+    char*     pszCipher = NULL;
+    
+    if ((stricmp(pref_key, CLIENT_GUID_REGNAME) == 0) &&
+	(*m_pszGUID))
+    {
+	// Create a Buffer 
+	buffer = new CHXBuffer();
+	buffer->AddRef();
+
+	// Copy the encoded GUID into the buffer
+	buffer->Set((UCHAR*)m_pszGUID, strlen(m_pszGUID) + 1);
+    }
+    else if (m_pDefaultPrefs)
+    {
+	hResult = m_pDefaultPrefs->ReadPref(pref_key, buffer);
+    }
+    else
+    {
+	hResult = HXR_NOTIMPL;
+    }
+
+    return hResult;
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IHXPreferences::WritePref
+//  Purpose:
+//	Write a Preference to the registry.
+//
+STDMETHODIMP
+ExampleClientContext::WritePref(const char* pref_key, IHXBuffer* buffer)
+{
+    if (m_pDefaultPrefs)
+    {
+	return m_pDefaultPrefs->WritePref(pref_key, buffer);
+    }
+    else	
+    {
+	return HXR_OK;
+    }
+}
+
+EHXClientState ExampleClientContext::GetState()
+{
+    return m_pClientStateSink->GetState();
+};
Index: helix-libs/clientapps/clutter/excontxt.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/excontxt.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,106 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+#ifndef _EXCONTXT_H_
+#define _EXCONTXT_H_
+
+#include "exerror.h"
+#include "exsitsup.h"
+#include "hxprefs.h"
+#include "player.h"
+#include "hxclsnk.h"
+
+struct IUnknown;
+struct IHXPreferences;
+class ExampleClientAdviceSink;
+class ExampleClientStateAdviceSink;
+class ExampleErrorMessages;
+class ExampleAuthenticationManager;
+class ExamplePDStatusObserver;
+
+
+class ExampleClientContext : public IHXPreferences
+{
+private:
+    LONG32			    m_lRefCount;
+    LONG32                          m_lClientIndex;
+
+    ExampleClientAdviceSink*	    m_pClientSink;
+    ExampleClientStateAdviceSink*    m_pClientStateSink;
+    ExampleErrorSink*		    m_pErrorSink;
+    ExampleAuthenticationManager*   m_pAuthMgr;
+
+    ExampleSiteSupplier*	    m_pSiteSupplier;
+    ExamplePDStatusObserver*        m_pPrgDnldStatusObserver;
+    IHXPreferences*		    m_pDefaultPrefs;
+    char			    m_pszGUID[256]; /* Flawfinder: ignore */
+
+
+public:
+
+    ExampleClientContext(LONG32 /*IN*/ lClientIndex);
+    ~ExampleClientContext();
+
+    void Init(IUnknown*	       /*IN*/ pUnknown,
+	      IHXPreferences* /*IN*/ pPreferences,
+	      char*	       /*IN*/ pszGUID,
+          on_buffering_cb_t on_buffering_cb = NULL,
+          on_pos_length_cb_t on_pos_length_cb = NULL,
+          on_state_change_cb_t on_state_change_cb = NULL,
+          on_new_frame_cb_t on_new_frame_cb = NULL,
+          void *context = NULL);
+    void Close();
+
+    EHXClientState GetState(); 
+
+    /*
+     * IUnknown methods
+     */
+    STDMETHOD(QueryInterface)	(THIS_
+				REFIID riid,
+				void** ppvObj);
+
+    STDMETHOD_(ULONG32,AddRef)	(THIS);
+    STDMETHOD_(ULONG32,Release)	(THIS);
+
+    /*
+     * IHXPreferences methods
+     */
+    STDMETHOD(ReadPref)		(THIS_ const char* pref_key, 
+				 IHXBuffer*& buffer);
+    STDMETHOD(WritePref)	(THIS_ const char* pref_key,
+				 IHXBuffer* buffer);
+};
+
+#endif
Index: helix-libs/clientapps/clutter/exerror.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exerror.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,230 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#include "hxtypes.h"
+
+#include "hxcom.h"
+#include "hxcomm.h"
+#include "hxerror.h"
+#include "hxstrutl.h"
+#include "hxcore.h"
+#include "hxassert.h"
+#include "hxbuffer.h"
+
+#ifdef __TCS__
+#include "hxresult.h"
+#endif
+
+#if !defined(HELIX_CONFIG_MINIMIZE_SIZE)
+#include "HXErrorCodeStrings.h"
+#endif
+
+#include "exerror.h"
+
+#include <stdio.h>
+#include "print.h"
+
+#include "globals.h"
+struct _stGlobals*& GetGlobal(); //in main.cpp
+
+#ifdef __TCS__
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+void hookRealAudio_ReportError(int err, long errVal);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
+ExampleErrorSink::ExampleErrorSink(IUnknown* pUnknown) 
+    : m_lRefCount(0),
+      m_pPlayer(NULL)
+{
+    IHXClientEngine* pEngine = NULL;
+    pUnknown->QueryInterface(IID_IHXClientEngine, (void**)&pEngine );
+    if( pEngine )
+    {
+        IUnknown* pTmp = NULL;
+        pEngine->GetPlayer(0, pTmp);
+        m_pPlayer = (IHXPlayer*)pTmp;
+    }
+    
+    HX_RELEASE( pEngine );
+    HX_ASSERT(m_pPlayer);
+}
+
+ExampleErrorSink::~ExampleErrorSink()
+{
+    HX_RELEASE(m_pPlayer);
+}
+
+// *** IUnknown methods ***
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//  IUnknown::QueryInterface
+//  Purpose:
+//  Implement this to export the interfaces supported by your 
+//  object.
+//
+STDMETHODIMP ExampleErrorSink::QueryInterface(REFIID riid, void** ppvObj)
+{
+    if (IsEqualIID(riid, IID_IUnknown))
+    {
+        AddRef();
+        *ppvObj = (IUnknown*)(IHXErrorSink*)this;
+        return HXR_OK;
+    }
+    else if (IsEqualIID(riid, IID_IHXErrorSink))
+    {
+        AddRef();
+        *ppvObj = (IHXErrorSink*) this;
+        return HXR_OK;
+    }
+
+    *ppvObj = NULL;
+    return HXR_NOINTERFACE;
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//  IUnknown::AddRef
+//  Purpose:
+//  Everyone usually implements this the same... feel free to use
+//  this implementation.
+//
+STDMETHODIMP_(ULONG32) ExampleErrorSink::AddRef()
+{
+    return InterlockedIncrement(&m_lRefCount);
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//  IUnknown::Release
+//  Purpose:
+//  Everyone usually implements this the same... feel free to use
+//  this implementation.
+//
+STDMETHODIMP_(ULONG32) ExampleErrorSink::Release()
+{
+    if (InterlockedDecrement(&m_lRefCount) > 0)
+    {
+        return m_lRefCount;
+    }
+
+    delete this;
+    return 0;
+}
+
+/*
+ *  IHXErrorSink methods
+ */
+
+STDMETHODIMP 
+ExampleErrorSink::ErrorOccurred(const UINT8 unSeverity,  
+                                const ULONG32   ulHXCode,
+                                const ULONG32   ulUserCode,
+                                const char* pUserString,
+                                const char* pMoreInfoURL
+                                )
+{
+    char HXDefine[256]; /* Flawfinder: ignore */
+
+    // Store the code, so we can return it from main()
+    GetGlobal()->g_Error = ulHXCode;
+
+    ConvertErrorToString(ulHXCode, HXDefine, 256);
+
+#ifdef __TCS__
+    hookRealAudio_ReportError(ulHXCode,ulUserCode);
+#else
+    STDOUT("Report(%d, %ld, \"%s\", %ld, \"%s\", \"%s\")\n",
+           unSeverity,
+           ulHXCode,
+           (pUserString && *pUserString) ? pUserString : "(NULL)",
+           ulUserCode,
+           (pMoreInfoURL && *pMoreInfoURL) ? pMoreInfoURL : "(NULL)",
+           HXDefine);
+#endif
+
+    return HXR_OK;
+}
+
+void
+ExampleErrorSink::ConvertErrorToString(const ULONG32 ulHXCode, char* pszBuffer, UINT32 ulBufLen)
+{
+    IHXErrorMessages* pErrMsg = NULL;
+
+    if( !pszBuffer)
+        return;
+    
+    pszBuffer[0]='\0';
+
+    HX_ASSERT(m_pPlayer);
+    if( m_pPlayer)
+    {
+        m_pPlayer->QueryInterface(IID_IHXErrorMessages, (void**)&pErrMsg);
+        if( pErrMsg )
+        {
+            IHXBuffer* pMessage = pErrMsg->GetErrorText(ulHXCode);
+            if( pMessage )
+            {
+                SafeStrCpy( pszBuffer, (const char*)pMessage->GetBuffer(), ulBufLen);
+                pMessage->Release();
+            }
+        }
+        HX_RELEASE(pErrMsg);
+    }
+ 
+    if( strlen(pszBuffer)==0 )
+    {
+#if !defined(HELIX_CONFIG_MINIMIZE_SIZE)        
+	const char* pszHXCodeString = HXErrorCodeToString(ulHXCode);
+        if (pszHXCodeString)
+        {   
+            SafeSprintf( pszBuffer, ulBufLen, "%s", pszHXCodeString);
+        }
+        else
+#endif        
+        {
+            HX_ASSERT(FALSE);
+            SafeSprintf( pszBuffer, ulBufLen, "Can't convert error code %p - make sure it's defined in common/util/HXErrorCodeStrings.c", ulHXCode );
+        }
+    }
+}
+
Index: helix-libs/clientapps/clutter/exerror.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exerror.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,92 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#ifndef _EXAMPLEERRORMESSAGES_
+#define _EXAMPLEERRORMESSAGES_
+
+#include "hxerror.h"
+
+struct IUnknown;
+struct IHXErrorMessages;
+struct IHXPlayer;
+
+class ExampleErrorSink : public IHXErrorSink
+{
+public:
+
+    ExampleErrorSink(IUnknown* pUnknown);
+    ~ExampleErrorSink();
+
+    /*
+     *  IUnknown methods
+     */
+    STDMETHOD(QueryInterface)	(THIS_
+				REFIID riid,
+				void** ppvObj);
+
+    STDMETHOD_(ULONG32,AddRef)	(THIS);
+
+    STDMETHOD_(ULONG32,Release)	(THIS);
+
+    /*
+     *  IHXErrorSink methods
+     */
+
+    /************************************************************************
+     *	Method:
+     *	    IHXErrorSink::ErrorOccurred
+     *	Purpose:
+     *	    After you have registered your error sink with an IHXErrorSinkControl 
+     *	    (either in the server or player core) this method will be called to 
+     *	    report an error, event, or status message.
+     *
+     *	    The meaning of the arguments is exactly as described in
+     *	    hxerror.h
+     */
+    STDMETHOD(ErrorOccurred)	(THIS_
+				const UINT8	unSeverity,  
+				const ULONG32	ulHXCode,
+				const ULONG32	ulUserCode,
+				const char*	pUserString,
+				const char*	pMoreInfoURL
+				);
+
+protected:
+    LONG32 m_lRefCount;
+    IHXPlayer* m_pPlayer;
+
+    void   ConvertErrorToString (const ULONG32 ulHXCode, char* pszBuffer, UINT32 ulBufLen);
+};
+#endif /*_EXAMPLEERRORMESSAGES_*/
Index: helix-libs/clientapps/clutter/exprdnld.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exprdnld.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,468 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#include "hxcom.h"
+#include "hxtypes.h"
+#include "hxcore.h"
+#include "hxprdnld.h"
+#include "exprdnld.h"
+#include "print.h"
+
+#include "globals.h"
+struct _stGlobals*& GetGlobal();
+
+UINT32 GetTime(); // /In main.cpp.
+
+// /#if defined(HELIX_FEATURE_PROGRESSIVE_DOWNLD_STATUS)
+/************************************************************************
+ *  Method:
+ *    Constructor
+ */
+ExamplePDStatusObserver::ExamplePDStatusObserver(IUnknown* pUnkPlayer)
+    : m_lRefCount(0)
+    , m_pPrgDnldStatusMgr(NULL)
+    , m_pUnkPlayer(pUnkPlayer)
+    , m_pHXPlayer(NULL)
+    , m_bPlayerIsPausedByThis(FALSE)
+    , m_bFirstPDStatusMessage(TRUE)
+    , m_ulTotalDurReported(HX_PROGDOWNLD_UNKNOWN_DURATION)
+    , m_ulDurSoFar(HX_PROGDOWNLD_UNKNOWN_DURATION)
+    , m_ulCurStatusUpdateGranularity(
+            HX_PROGDOWNLD_DEFAULT_STATUSREPORT_INTERVAL_MSEC)
+    , m_bInitialPrerollUpateGranularitySet(FALSE)
+    , m_bDownloadIsComplete(FALSE)
+{
+    if (m_pUnkPlayer)
+    {
+	m_pUnkPlayer->QueryInterface(IID_IHXPlayer,
+			(void**)&m_pHXPlayer);
+
+	m_pUnkPlayer->QueryInterface(IID_IHXPDStatusMgr,
+			(void**)&m_pPrgDnldStatusMgr);
+
+        if (m_pPrgDnldStatusMgr)
+        {
+            // /Add ourselves as an observer of progressive download playback:
+            m_pPrgDnldStatusMgr->AddObserver(this);
+            // /Set granularity of status reports to 10 per second until we
+            // know enough about the situation to go back to getting reports
+            // at the default interval (every 5 seconds).  Do that as soon
+            // as we receive the first progress report:
+            m_ulCurStatusUpdateGranularity = 100;
+        }
+
+	m_pUnkPlayer->AddRef();
+    }
+};
+
+/************************************************************************
+ *  Method:
+ *    Destructor
+ */
+ExamplePDStatusObserver::~ExamplePDStatusObserver()
+{
+    if (m_pPrgDnldStatusMgr)
+    {
+        m_pPrgDnldStatusMgr->RemoveObserver(this);
+    }
+    HX_RELEASE(m_pPrgDnldStatusMgr);
+    HX_RELEASE(m_pHXPlayer);
+    HX_RELEASE(m_pUnkPlayer);
+}
+
+/************************************************************************
+ *  Method:
+ *    IUnknown::QueryInterface
+ */
+STDMETHODIMP 
+ExamplePDStatusObserver::QueryInterface(REFIID riid, void** ppvObj)
+{
+    if (IsEqualIID(riid, IID_IUnknown))
+    {
+	AddRef();
+	*ppvObj = (IUnknown*)(IHXPDStatusObserver*)this;
+	return HXR_OK;
+    }
+    else if (IsEqualIID(riid, IID_IHXPDStatusObserver))
+    {
+	AddRef();
+	*ppvObj = (IHXPDStatusObserver*)this;
+	return HXR_OK;
+    }
+
+    *ppvObj = NULL;
+    return HXR_NOINTERFACE;
+}
+
+/************************************************************************
+ *  Method:
+ *    IUnknown::AddRef
+ */
+STDMETHODIMP_(ULONG32) 
+ExamplePDStatusObserver::AddRef()
+{
+    return InterlockedIncrement(&m_lRefCount);
+}
+
+/************************************************************************
+ *  Method:
+ *    IUnknown::Release
+ */
+STDMETHODIMP_(ULONG32) 
+ExamplePDStatusObserver::Release()
+{
+    if (InterlockedDecrement(&m_lRefCount) > 0)
+    {
+        return m_lRefCount;
+    }
+
+    delete this;
+    return 0;
+}
+
+
+/*
+ *  IHXPDStatusObserver methods
+ */
+
+/************************************************************************
+ *  Method:
+ *      IHXPDStatusObserver::OnDownloadProgress
+ *
+ *  Purpose:
+ *      Notification from IHXPDStatusMgr of download progress when
+ *      file size changes.
+ *
+ *      lTimeSurplus:
+ *      - When negative, the absolute value of it is the estimated number
+ *      of milliseconds of wall-clock time that need to pass while
+ *      downloading continues before reaching the point at which playback
+ *      can resume and play the remainder of the stream without having to
+ *      buffer, assuming that playback is paused and remains so during
+ *      that period.
+ *      - When positive, it is the estimated number of milliseconds of
+ *      wall-clock time between when the download should complete and when
+ *      the natural content play-out duration will be reached, assuming
+ *      playback is currently progressing and that no pause will occur.
+ *
+ *      Note: ulNewDurSoFar can be HX_PROGDOWNLD_UNKNOWN_DURATION if the
+ *      IHXMediaBytesToMediaDur was not available to, or was unable to
+ *      convert the bytes to a duration for the IHXPDStatusMgr calling this:
+ */
+STDMETHODIMP
+ExamplePDStatusObserver::OnDownloadProgress(
+              IHXStreamSource* /*IN*/ /*NULL is valid value*/ pStreamSource,
+              UINT32 /*IN*/ ulNewDurSoFar,
+              UINT32 /*IN*/ ulNewBytesSoFar,
+              INT32  /*IN*/ lTimeSurplus)
+{
+    m_ulDurSoFar = ulNewDurSoFar;
+
+    if (m_ulCurStatusUpdateGranularity <
+            HX_PROGDOWNLD_DEFAULT_STATUSREPORT_INTERVAL_MSEC)
+    {
+        if (m_bInitialPrerollUpateGranularitySet)
+        {
+            if (HX_PROGDOWNLD_UNKNOWN_DURATION != ulNewDurSoFar  &&
+                    // /Preroll is done, so reset update interval back to default:
+                    GetGlobal()->g_bOnBeginOccurred)
+            {
+                m_ulCurStatusUpdateGranularity =
+                        HX_PROGDOWNLD_DEFAULT_STATUSREPORT_INTERVAL_MSEC;
+                m_pPrgDnldStatusMgr->SetStatusUpdateGranularityMsec(
+                        m_ulCurStatusUpdateGranularity);
+            }
+        }
+        else if (!GetGlobal()->g_bOnBeginOccurred)
+        {
+            if (HXR_OK == m_pPrgDnldStatusMgr->SetStatusUpdateGranularityMsec(
+                    m_ulCurStatusUpdateGranularity))
+            {
+                m_bInitialPrerollUpateGranularitySet = TRUE;
+            }
+        }
+    }
+
+    UINT32 ulCurPlayTime = 0;
+
+    HXBOOL bPauseWasAttempted = FALSE;
+    HXBOOL bPauseOccurred     = FALSE;
+    HXBOOL bResumeWasAttempted = FALSE;
+    HXBOOL bResumeOccurred = FALSE;
+
+    
+    if (m_pHXPlayer)
+    {
+        ulCurPlayTime = m_pHXPlayer->GetCurrentPlayTime();
+
+        if (GetGlobal()->g_bEnableSlowStart  &&
+                lTimeSurplus != HX_PROGDOWNLD_UNKNOWN_TIME_SURPLUS)
+        {
+            // /"slow start" is enabled so if we have run dry of data,
+            // pause and wait for more data:
+            if (!m_bPlayerIsPausedByThis)
+            {
+                if (!m_bDownloadIsComplete  &&  lTimeSurplus<0)
+                {
+                    // /Use a 1000-millisecond allowance for variation:
+                    if (lTimeSurplus < -1000)
+                    {
+                        bPauseWasAttempted = TRUE;
+                        bPauseOccurred = m_bPlayerIsPausedByThis =
+                                (HXR_OK == m_pHXPlayer->Pause());
+                    }
+                }
+            }
+            else // /paused; see if we can resume yet:
+            {
+                if (lTimeSurplus > 0)
+                {
+                    // /Use a 1000-millisecond allowance for variation:
+                    if (lTimeSurplus > 1000)
+                    {
+                        bResumeWasAttempted = TRUE;
+                        bResumeOccurred = (HXR_OK == m_pHXPlayer->Begin());
+                        m_bPlayerIsPausedByThis = !bResumeOccurred;
+                    }
+                }
+            }
+        }
+    }
+
+    if (GetGlobal()->bEnableVerboseMode  &&  !m_bDownloadIsComplete)
+    {
+        STDOUT("\nDownload progress: (play time=%lu,",
+                ulCurPlayTime);
+        if (HX_PROGDOWNLD_UNKNOWN_TIME_SURPLUS == lTimeSurplus)
+        {
+            STDOUT(" UNKNOWN surplus|deficit)");
+        }
+        else if (HX_PROGDOWNLD_MIN_TIME_SURPLUS == lTimeSurplus)
+        {
+            STDOUT(" deficit exceeds maximum");
+        }
+        else if (HX_PROGDOWNLD_MAX_TIME_SURPLUS == lTimeSurplus)
+        {
+            STDOUT(" surplus exceeds maximum)");
+        }
+        else
+        {
+            STDOUT(" surplus=%ld milliseconds)", lTimeSurplus);
+        }
+        if (HX_PROGDOWNLD_UNKNOWN_DURATION == ulNewDurSoFar)
+        {
+            STDOUT("\n\thave UNKNOWN");
+        }
+        else
+        {
+            STDOUT("\n\thave %lu", ulNewDurSoFar);
+        }
+        
+        if (HX_PROGDOWNLD_UNKNOWN_DURATION != m_ulTotalDurReported)
+        {
+            STDOUT(" of %lu msec", m_ulTotalDurReported);
+        }
+        else
+        {
+            STDOUT(" of UNKNOWN msec of media");
+        }
+        if (HX_PROGDOWNLD_UNKNOWN_FILE_SIZE != ulNewBytesSoFar)
+        {
+            STDOUT(" (%lu", ulNewBytesSoFar);
+        }
+        else
+        {
+            STDOUT(" (UNKNOWN");
+        }
+        STDOUT(" bytes downloaded so far)\n", ulNewBytesSoFar);
+
+        if (bPauseOccurred  ||  bPauseWasAttempted)
+        {
+            STDOUT("# Waiting for more data: %splayback.\n "
+                    "    Should take %ld milliseconds before playback resumes.\n",
+                    bPauseOccurred? "Pausing " :
+                        (bPauseWasAttempted? "Failed attempting to pause "
+                                              : " "), -lTimeSurplus);
+        }
+        if (bResumeOccurred  ||  bResumeWasAttempted)
+        {
+            STDOUT("# Data available: %splayback\n "
+                    "    Time surplus is now %ld",
+                    bResumeOccurred? "Resuming " :
+                        (bResumeWasAttempted? "Failed attempting to resume "
+                                              : " "), lTimeSurplus);
+        }
+    }
+
+    m_bFirstPDStatusMessage = FALSE;
+
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *      IHXPDStatusObserver::OnTotalDurChanged
+ *  Purpose:
+ *      This is a notification if the total file duration becomes known
+ *      or becomes better-known during download/playback
+ *      
+ *      Note: pStreamSource can be NULL.  This will be true when
+ *      IHXPDStatusMgr calling this is upstream of the IHXStreamSource
+ *      object.
+ */
+STDMETHODIMP
+ExamplePDStatusObserver::OnTotalDurChanged(
+            IHXStreamSource* /*IN*/ /*NULL is valid value*/ pStreamSource,
+            UINT32 ulNewTotalDur)
+{
+    m_ulTotalDurReported = ulNewTotalDur;
+
+    if (GetGlobal()->bEnableVerboseMode)
+    {
+        STDOUT("\nOnTotalDurChanged(): to %lu milliseconds\n", ulNewTotalDur);
+    }
+
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *      IHXPDStatusObserver::OnDownloadComplete
+ *
+ *  Purpose:
+ *      Notification that the entire file has been downloaded.
+ *
+ *      Note: pStreamSource can be NULL.  This will be true when
+ *      IHXPDStatusMgr calling this is upstream of the IHXStreamSource
+ *      object.
+ *      
+ */
+STDMETHODIMP
+ExamplePDStatusObserver::OnDownloadComplete(
+            IHXStreamSource* /*IN*/ /*NULL is valid value*/ pStreamSource)
+{
+    m_bDownloadIsComplete = TRUE;
+
+    HXBOOL bResumeWasAttempted = FALSE;
+    HXBOOL bResumeOccurred = FALSE;
+
+    // /In case we're paused, resume now that there is no more data to get:
+    if (m_pHXPlayer  &&  m_bPlayerIsPausedByThis)
+    {
+        bResumeWasAttempted = TRUE;
+        bResumeOccurred = (HXR_OK == m_pHXPlayer->Begin());
+        m_bPlayerIsPausedByThis = !bResumeOccurred;
+    }
+    
+    if (GetGlobal()->bEnableVerboseMode)
+    {
+        STDOUT("\nOnDownloadComplete()\n");
+        if (bResumeOccurred  ||  bResumeWasAttempted)
+        {
+            STDOUT("\n%splayback now that bytes are available for "
+                    "uninterrupted playback\n",
+                    bResumeOccurred? "Resuming " :
+                        (bResumeWasAttempted? "Failed attempting to resume "
+                                              : " "));
+        }
+    }
+
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *      IHXPDStatusObserver::SrcClaimsSeekSupport         ref: hxprdnld.h
+ *  Purpose:
+ *      Passes along notification from file sys that seek support
+ *      is or is not claimed to be available (although sometimes HTTP
+ *      server claims this when it doesn't actually support it).
+ */
+STDMETHODIMP
+ExamplePDStatusObserver::SrcClaimsSeekSupport(IHXStreamSource* pStreamSource,
+                                              HXBOOL bClaimsSupport)
+{
+    if (GetGlobal()->bEnableVerboseMode)
+    {
+        STDOUT("\nSrcClaimsSeekSupport(%sE)\n", bClaimsSupport?"TRU":"FALS");
+    }
+    return HXR_OK;
+}
+
+
+/************************************************************************
+ *  Method:
+ *      IHXPDStatusObserver::OnDownloadPause
+ *  Purpose:
+ *      Notification that the file-download process has purposefully
+ *      and temporarily halted downloading of the file
+ *      
+ *      Note: pStreamSource can be NULL.  This will be true when
+ *      IHXPDStatusMgr calling this is upstream of the IHXStreamSource
+ *      object.
+ */
+STDMETHODIMP
+ExamplePDStatusObserver::OnDownloadPause(
+            IHXStreamSource* /*IN*/ /*NULL is valid value*/ pStreamSource)
+{
+    if (GetGlobal()->bEnableVerboseMode)
+    {
+        STDOUT("\nOnDownloadPause()\n");
+    }
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *      IHXPDStatusObserver::OnDownloadResume
+ *  Purpose:
+ *      Notification that the file-download process has resumed
+ *      the process of downloading the remainder of the file
+ *      
+ *      Note: pStreamSource can be NULL.  This will be true when
+ *      IHXPDStatusMgr calling this is upstream of the IHXStreamSource
+ *      object.
+ */
+STDMETHODIMP
+ExamplePDStatusObserver::OnDownloadResume(
+            IHXStreamSource* /*IN*/ /*NULL is valid value*/ pStreamSource)
+{
+    if (GetGlobal()->bEnableVerboseMode)
+    {
+        STDOUT("\nOnDownloadResume()\n");
+    }
+    return HXR_OK;
+}
+// /#endif // /HELIX_FEATURE_PROGRESSIVE_DOWNLD_STATUS.
Index: helix-libs/clientapps/clutter/exprdnld.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exprdnld.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,196 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#ifndef _EXPRDNLD_H_
+#define _EXPRDNLD_H_
+
+// /#if defined(HELIX_FEATURE_PROGRESSIVE_DOWNLD_STATUS)
+
+/****************************************************************************
+ * 
+ *  Class:
+ *
+ *	ExamplePDStatusObserver
+ *
+ *  Purpose:
+ *
+ *	Implementation for IHXPDStatusObserver which receives progressive-
+ *      download status reports:
+ *
+ */
+class ExamplePDStatusObserver : 
+	public IHXPDStatusObserver
+{
+private:
+    INT32		    m_lRefCount;
+    IHXPDStatusMgr*         m_pPrgDnldStatusMgr;
+    IUnknown*		    m_pUnkPlayer;
+    IHXPlayer*              m_pHXPlayer;
+    HXBOOL                  m_bPlayerIsPausedByThis;
+    HXBOOL                  m_bFirstPDStatusMessage;
+    UINT32                  m_ulTotalDurReported;
+    UINT32                  m_ulDurSoFar;
+    UINT32                  m_ulCurStatusUpdateGranularity;
+    HXBOOL                  m_bInitialPrerollUpateGranularitySet;
+    HXBOOL                  m_bDownloadIsComplete;
+
+    ExamplePDStatusObserver();
+    ~ExamplePDStatusObserver();
+
+public:
+    ExamplePDStatusObserver(IUnknown* pUnkPlayer);
+    
+    /*
+     * IUnknown methods
+     */
+    STDMETHOD(QueryInterface)	(THIS_
+				REFIID riid,
+				void** ppvObj);
+
+    STDMETHOD_(ULONG32,AddRef)	(THIS);
+
+    STDMETHOD_(ULONG32,Release)	(THIS);
+
+    /*
+     *  IHXPDStatusObserver methods
+     */
+
+    /************************************************************************
+     *  Method:
+     *      IHXPDStatusObserver::OnDownloadProgress
+     *
+     *  Purpose:
+     *      Notification from IHXPDStatusMgr of download progress when
+     *      file size changes.
+     *
+     *      lTimeSurplus:
+     *      - When negative, the absolute value of it is the estimated number
+     *      of milliseconds of wall-clock time that need to pass while
+     *      downloading continues before reaching the point at which playback
+     *      can resume and play the remainder of the stream without having to
+     *      buffer, assuming that playback is paused and remains so during
+     *      that period.
+     *      - When positive, it is the estimated number of milliseconds of
+     *      wall-clock time between when the download should complete and when
+     *      the natural content play-out duration will be reached, assuming
+     *      playback is currently progressing and that no pause will occur.
+     *
+     *      Note: ulNewDurSoFar can be HX_PROGDOWNLD_UNKNOWN_DURATION if the
+     *      IHXMediaBytesToMediaDurConverter was not available to, or was
+     *      unable to convert the bytes to a duration for the IHXPDStatusMgr
+     *      calling this:
+     */
+    STDMETHOD(OnDownloadProgress) (THIS_
+            IHXStreamSource* /*IN*/  /*NULL is valid value*/ pStreamSource,
+            UINT32 /*IN*/ ulNewDurSoFar,
+            UINT32 /*IN*/ ulNewBytesSoFar,
+            INT32  /*IN*/ lTimeSurplus);
+
+    /************************************************************************
+     *  Method:
+     *      IHXPDStatusObserver::OnTotalDurChanged
+     *  Purpose:
+     *      This is a notification if the total file duration becomes known
+     *      or becomes better-known during download/playback
+     *      
+     *      Note: pStreamSource can be NULL.  This will be true when
+     *      IHXPDStatusMgr calling this is upstream of the IHXStreamSource
+     *      object.
+     */
+    STDMETHOD(OnTotalDurChanged)  (THIS_
+            IHXStreamSource* /*IN*/ /*NULL is valid value*/ pStreamSource,
+            UINT32 /*IN*/ ulNewDur);
+
+    /************************************************************************
+     *  Method:
+     *      IHXPDStatusObserver::OnDownloadComplete
+     *
+     *  Purpose:
+     *      Notification that the entire file has been downloaded.
+     *
+     *      Note: pStreamSource can be NULL.  This will be true when
+     *      IHXPDStatusMgr calling this is upstream of the IHXStreamSource
+     *      object.
+     *      
+     */
+    STDMETHOD(OnDownloadComplete)    (THIS_
+            IHXStreamSource* /*IN*/ /*NULL is valid value*/ pStreamSource);
+
+    /************************************************************************
+     *  Method:
+     *      IHXPDStatusObserver::SrcClaimsSeekSupport
+     *
+     *  Purpose:
+     *      Passes along notification from file sys that seek support
+     *      is claimed to be available (although sometimes HTTP server
+     *      claims this when it doesn't actually support it).
+     *
+     */
+    STDMETHOD(SrcClaimsSeekSupport)    (THIS_
+            IHXStreamSource* pStreamSource,
+            HXBOOL /*IN*/ bSrcClaimsSeekSupport);
+
+    /************************************************************************
+     *  Method:
+     *      IHXPDStatusObserver::OnDownloadPause
+     *  Purpose:
+     *      Notification that the file-download process has purposefully
+     *      and temporarily halted downloading of the file
+     *      
+     *      Note: pStreamSource can be NULL.  This will be true when
+     *      IHXPDStatusMgr calling this is upstream of the IHXStreamSource
+     *      object.
+     */
+    STDMETHOD(OnDownloadPause)    (THIS_
+            IHXStreamSource* /*IN*/ /*NULL is valid value*/ pStreamSource);
+
+    /************************************************************************
+     *  Method:
+     *      IHXPDStatusObserver::OnDownloadResume
+     *  Purpose:
+     *      Notification that the file-download process has resumed
+     *      the process of downloading the remainder of the file
+     *      
+     *      Note: pStreamSource can be NULL.  This will be true when
+     *      IHXPDStatusMgr calling this is upstream of the IHXStreamSource
+     *      object.
+     */
+    STDMETHOD(OnDownloadResume)    (THIS_
+            IHXStreamSource* /*IN*/ /*NULL is valid value*/ pStreamSource);
+};
+// /#endif // /HELIX_FEATURE_PROGRESSIVE_DOWNLD_STATUS.
+
+#endif // _EXPRDNLD_H_
+
Index: helix-libs/clientapps/clutter/exroot.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exroot.cpp	2008-10-13 06:54:08.000000000 -0700
@@ -0,0 +1,672 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Source last modified: $Id: unixroot.cpp,v 1.9 2007/07/06 20:54:01 jfinnecy Exp $
+ * 
+ * Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.
+ * 
+ * The contents of this file, and the files included with this file,
+ * are subject to the current version of the RealNetworks Public
+ * Source License (the "RPSL") available at
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed
+ * the file under the current version of the RealNetworks Community
+ * Source License (the "RCSL") available at
+ * http://www.helixcommunity.org/content/rcsl, in which case the RCSL
+ * will apply. You may also obtain the license terms directly from
+ * RealNetworks.  You may not use this file except in compliance with
+ * the RPSL or, if you have a valid RCSL with RealNetworks applicable
+ * to this file, the RCSL.  Please see the applicable RPSL or RCSL for
+ * the rights, obligations and limitations governing use of the
+ * contents of the file.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 (the
+ * "GPL") in which case the provisions of the GPL are applicable
+ * instead of those above. If you wish to allow use of your version of
+ * this file only under the terms of the GPL, and not to allow others
+ * to use your version of this file under the terms of either the RPSL
+ * or RCSL, indicate your decision by deleting the provisions above
+ * and replace them with the notice and other provisions required by
+ * the GPL. If you do not delete the provisions above, a recipient may
+ * use your version of this file under the terms of any one of the
+ * RPSL, the RCSL or the GPL.
+ * 
+ * This file is part of the Helix DNA Technology. RealNetworks is the
+ * developer of the Original Code and owns the copyrights in the
+ * portions it created.
+ * 
+ * This file, and the files included with this file, is distributed
+ * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY
+ * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS
+ * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET
+ * ENJOYMENT OR NON-INFRINGEMENT.
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location:
+ *    http://www.helixcommunity.org/content/tck
+ * 
+ * Contributor(s):
+ * 
+ * ***** END LICENSE BLOCK ***** */
+
+// for shared memory
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <sys/utsname.h>
+
+#include "hxcom.h"
+#include "hxwintyp.h"
+#include "hxvsurf.h"
+#include "hxslist.h"
+#include "colormap.h"
+#include "hxprefs.h"
+#include "hxtick.h"
+#include "hxthread.h"
+#include "basesite.h"
+#include "exroot.h"
+#include "exsite.h"
+#include "unixcmap.h"
+#include "shmhelp.h"
+
+//  #ifdef _DEBUG
+//  #include <X11/extensions/xf86vmode.h> //for debug video sync rates..
+//  #endif
+
+//Work around AIX problem.
+#ifdef _AIX
+#  define MAX_SHARED_REGIONS ((UINT32)1)
+#else
+#  define MAX_SHARED_REGIONS ((UINT32)9999)
+#endif
+
+CExRootSurf::CExRootSurf(IUnknown* pContext, CHXBaseSite* pSite, on_new_frame_cb_t on_new_frame_cb, void *context )
+   : CBaseRootSurface(pContext, pSite)
+   , m_bUseShm(FALSE)
+   , m_nShmId(0)
+   , m_pDisplay(NULL)
+   , m_GC(0)
+   , m_nScreenNumber(0)
+   , m_pXImage(NULL)
+   , m_pVisual(NULL)
+   , m_unDepth(0)
+   , m_pScreen(NULL)
+   , m_pYUVScratchBits(NULL)
+   , m_nYUVScratchPitch(0)
+   , m_pScratchBits(NULL)
+   , m_nScratchPitch(0)
+   , m_nBitsPerPixel(0)
+   , m_nCompositionSize(0)
+   , m_on_new_frame_cb(on_new_frame_cb)
+   , m_context(context)
+{
+}
+
+HX_RESULT CExRootSurf::Init()
+{
+   //get window and display from main Site.
+   HXxWindow* pWindow = m_pSite->GetWindow();
+   HX_ASSERT(pWindow);
+
+   m_pDisplay = (Display*)pWindow->display;
+   m_window   = (Window)pWindow->window;
+
+   HX_ASSERT( m_pDisplay );
+   HX_ASSERT( m_window );
+
+   //
+   // Now see if our X11 server supports the Shared Memory extension.
+   //
+  // ShmHelp::Init(m_pDisplay);
+  // m_bUseShm = ShmHelp::ShmAvailable();
+
+   //Create the graphics context
+   XGCValues values;
+
+   XLockDisplay(m_pDisplay);
+   m_GC = XCreateGC(m_pDisplay, m_window, 0, &values);
+
+    //Get X window attributes & visual
+   XWindowAttributes attr;
+   XGetWindowAttributes(m_pDisplay, m_window, &attr);
+   XUnlockDisplay(m_pDisplay);
+   m_pVisual = attr.visual;
+
+   // get visual info & depth
+   int nv=0;
+   XVisualInfo visInfo;
+   memset(&visInfo, 0, sizeof(XVisualInfo));
+   XLockDisplay(m_pDisplay);
+   visInfo.visualid = XVisualIDFromVisual(m_pVisual);
+   XVisualInfo* pVisualInfo = XGetVisualInfo (m_pDisplay, VisualIDMask, &visInfo, &nv);
+//   m_unDepth       = pVisualInfo->depth;
+   m_unDepth       = 24;
+   m_nScreenNumber = DefaultScreen(m_pDisplay);
+   m_pScreen       = XScreenOfDisplay(m_pDisplay, m_nScreenNumber);
+   XUnlockDisplay(m_pDisplay);
+   m_colormap      = HXGetXColormap(m_pDisplay, m_window);
+
+   // get pixmap (blt) information for the best depth we can display
+   int i=0;
+   int nNum=0;
+   XLockDisplay(m_pDisplay);
+   XPixmapFormatValues *pixmap_formats = XListPixmapFormats(m_pDisplay, &nNum);
+   XUnlockDisplay(m_pDisplay);
+   if(pixmap_formats)
+   {
+      for (i=0 ; i<nNum; i++)
+      {
+         if (pixmap_formats[i].depth == m_unDepth)
+         {
+            m_nBitsPerPixel = pixmap_formats[i].bits_per_pixel;
+         }
+      }
+      XFree(pixmap_formats);
+      pixmap_formats = NULL;
+   }
+
+   memset(&m_bmiSave, 0, sizeof(HXBitmapInfo));
+#if 0
+   m_bmiSave.bmiHeader.biBitCount    = m_nBitsPerPixel;
+   m_bmiSave.bmiHeader.biCompression = (m_unDepth==8 ? BI_RGB : BI_BITFIELDS);
+   m_bmiSave.un.dwBitMask[0]         = pVisualInfo->red_mask;
+   m_bmiSave.un.dwBitMask[1]         = pVisualInfo->green_mask;
+   m_bmiSave.un.dwBitMask[2]         = pVisualInfo->blue_mask;
+#else
+   /* Fake a RGB24 */
+   m_nBitsPerPixel = 24;
+   m_bmiSave.bmiHeader.biBitCount    = m_nBitsPerPixel;
+   m_bmiSave.bmiHeader.biCompression = BI_RGB;
+#endif
+   //Set primary surface CID.
+   m_nCompositionSurfaceCID = GetBitmapColor(&m_bmiSave);
+   XFree( pVisualInfo );
+
+//  #ifdef _DEBUG
+//     //Lets find out what Hsync and Vsync rates we have for this display.
+//     //Ripped from xvidtune.c
+//     XF86VidModeModeLine mode_line;
+//     int    scrn=0;
+//     int    dot_clock;
+//     double vsync_hz, HSyncRate,HTotal, VTotal, PixelClock;
+//     if(XF86VidModeGetModeLine(m_pDisplay, scrn, &dot_clock, &mode_line))
+//     {
+//        PixelClock=dot_clock;
+//        HTotal = mode_line.htotal;
+//        VTotal = mode_line.vtotal;
+//        HSyncRate = PixelClock*1000.0/HTotal;
+//        vsync_hz = HSyncRate/VTotal;
+//        fprintf( stderr, "This Display's Hsync rate is: %f and Vsync: %f\n",
+//                 HSyncRate, vsync_hz );
+//     }
+
+//  #endif
+
+   return HXR_OK;
+}
+
+CExRootSurf::~CExRootSurf()
+{
+   _DestroyCompositionSurface();
+
+   if( m_GC )
+   {
+      XLockDisplay(m_pDisplay);
+      XFreeGC( m_pDisplay, m_GC );
+      XUnlockDisplay(m_pDisplay);
+      m_GC=0;
+   }
+   if (m_pVisual)
+   {
+      /* PJG: don't have to free visuals */
+      m_pVisual = NULL;
+   }
+
+   if(m_bUseShm)
+   {
+      if( m_pCompositionSurface != NULL )
+         ShmHelp::DetachSharedRegion(&m_pCompositionSurface, &m_shmInfo);
+   }
+   else
+   {
+      HX_DELETE(m_pCompositionSurface);
+      m_nCompositionSize=0;
+      m_bCompositionSurfaceCreated=FALSE;
+   }
+
+   //XXXgfw any more clean up for these two?
+   HX_VECTOR_DELETE( m_pScratchBits );
+   HX_VECTOR_DELETE( m_pYUVScratchBits );
+
+}
+
+HX_RESULT CExRootSurf::_ResizeVideoBuffer( INT32 nSize)
+{
+   HX_RESULT retVal=HXR_OK;
+
+   if(nSize <= m_nCompositionSize)
+      return retVal;
+
+   if(m_bUseShm)
+   {
+      if( m_pCompositionSurface != NULL )
+         retVal = ShmHelp::DetachSharedRegion(&m_pCompositionSurface, &m_shmInfo);
+      if( retVal==HXR_OK )
+      {
+         retVal = ShmHelp::CreateSharedRegion( nSize,
+                                               &m_pCompositionSurface,
+                                               &m_nShmId,
+                                               &m_shmInfo
+                                               );
+
+      }
+      if( retVal != HXR_OK )
+      {
+         m_bCompositionSurfaceCreated = FALSE;
+         m_nCompositionSize           = 0;
+         m_bUseShm = FALSE;
+      }
+      else
+      {
+         //It all worked
+         m_nCompositionSize           = nSize;
+         m_bCompositionSurfaceCreated = TRUE;
+         return retVal;
+      }
+
+   }
+
+   //We need to fall through here so that if the shared memory stuff
+   //above fails we can create it the old fashioned way.
+   if(m_pCompositionSurface == NULL)
+   {
+      m_pCompositionSurface = (UCHAR*) malloc(nSize);
+   }
+   else
+   {
+      m_pCompositionSurface = (UCHAR*) realloc(m_pCompositionSurface, nSize);
+   }
+   if( m_pCompositionSurface )
+   {
+      m_nCompositionSize = nSize;
+   }
+   else
+   {
+      HX_ASSERT("We can't alloc the composition surface." == NULL );
+      m_nCompositionSize = 0;
+   }
+
+   return retVal;
+}
+
+HX_RESULT CExRootSurf::_DebugBlt( UCHAR* pImageData, HXBitmapInfoHeader* pBitmapInfo,
+                     HXxRect& rDestRect, HXxRect& rSrcRect)
+{
+   HX_ASSERT( m_window );
+   HX_ASSERT( m_pDisplay );
+   HX_ASSERT( m_GC );
+   XLockDisplay(m_pDisplay);
+   XSetForeground( m_pDisplay, m_GC, WhitePixel(m_pDisplay, 0 ));
+   XSetBackground( m_pDisplay, m_GC, BlackPixel(m_pDisplay, 0 ));
+   XSetLineAttributes(m_pDisplay, m_GC, 5, LineSolid, CapRound, JoinRound );
+   XSetForeground( m_pDisplay, m_GC, WhitePixel(m_pDisplay, 0) );
+   XFillRectangle( m_pDisplay, m_window, m_GC,
+                   rDestRect.left, rDestRect.top,
+                   rDestRect.right-rDestRect.left,
+                   rDestRect.bottom-rDestRect.top
+                   );
+   XDrawRectangle( m_pDisplay, m_window, m_GC,
+                   rDestRect.left, rDestRect.top,
+                   rDestRect.right-rDestRect.left,
+                   rDestRect.bottom-rDestRect.top
+                   );
+   XUnlockDisplay(m_pDisplay);
+   return HXR_OK;
+}
+
+void CExRootSurf::_GetYUVScratchWidthHeight(UINT32* pWidth, UINT32* pHeight)
+{
+   *pWidth     = m_bmiYUVScratch.bmiHeader.biWidth;
+   *pHeight    = m_bmiYUVScratch.bmiHeader.biHeight;
+}
+
+XImage* CExRootSurf::_GetCompositionSurfaceDrawable()
+{
+   return m_pXImage;
+}
+
+
+
+//Not used except for XING.....
+void CExRootSurf::_CreateYUVScratchSurface(UINT32 width, UINT32 height)
+{
+   //Remove old bits....
+   HX_DELETE(m_pYUVScratchBits);
+
+   //Clear BitmapInfo struct....
+   memset(&m_bmiYUVScratch, 0, sizeof(HXBitmapInfo));
+   int nResult = MakeBitmap( &m_bmiYUVScratch,
+                             sizeof(m_bmiYUVScratch),
+                             CID_YUY2,
+                             width,
+                             height,
+                             NULL,
+                             0);
+   if( nResult )
+   {
+      m_pYUVScratchBits  = new UCHAR[m_bmiYUVScratch.bmiHeader.biSizeImage];
+      m_nYUVScratchPitch = GetBitmapPitch(&m_bmiYUVScratch);
+   }
+}
+
+
+void CExRootSurf::_GetYUVScratchSurfacePointer(UCHAR** pYUVBits, INT32* YUVPitch)
+{
+   *pYUVBits = m_pYUVScratchBits;
+   *YUVPitch = m_nYUVScratchPitch;
+}
+
+HX_RESULT CExRootSurf::CreateScratchSurface( int nCompositionSurfaceCID, HXxSize* pSize)
+{
+   //Remove old bits....
+   HX_DELETE(m_pScratchBits);
+
+   //Clear BitmapInfo struct....
+   memset(&m_bmiScratch, 0, sizeof(HXBitmapInfo));
+   int nResult = MakeBitmap( &m_bmiScratch,
+                             sizeof(m_bmiScratch),
+                             nCompositionSurfaceCID,
+                             pSize->cx,
+                             pSize->cy,
+                             NULL,
+                             0);
+   if( nResult )
+   {
+      m_pScratchBits  = new UCHAR[m_bmiScratch.bmiHeader.biSizeImage];
+      m_nScratchPitch = GetBitmapPitch(&m_bmiScratch);
+   }
+
+   return nResult? HXR_OK : HXR_FAIL;
+}
+
+HX_RESULT CExRootSurf::ScratchLock(UCHAR** pBits, INT32* pPitch)
+{
+   *pBits  = m_pScratchBits;
+   *pPitch = m_nScratchPitch;
+   return HXR_OK;
+}
+
+HX_RESULT CExRootSurf::ScratchUnlock(UCHAR* pBits)
+{
+   return HXR_OK;
+}
+
+HX_RESULT CExRootSurf::_MinimalUnlock(HXxWindow* pWindow)
+{
+//     Window win = m_window;
+//     HX_ASSERT(win);
+//     HXxSize hxxSize;
+//     m_pSite->GetSize(hxxSize);
+
+//     if (m_bUseShm)
+//     {
+//        XShmPutImage(m_pDisplay,
+//                     win,
+//                     m_GC,
+//                     m_pXImage,
+//                     0,
+//                     0,
+//                     0,
+//                     0,
+//                     hxxSize.cx,
+//                     hxxSize.cy,
+//                     False
+//                     );
+//     }
+//     else
+//     {
+//        XPutImage(m_pDisplay,
+//                  win,
+//                  m_GC,
+//                  m_pXImage,
+//                  0,
+//                  0,
+//                  0,
+//                  0,
+//                  hxxSize.cx,
+//                  hxxSize.cy
+//                  );
+//     }
+     return HXR_OK;
+}
+
+HX_RESULT CExRootSurf::_LockComposition(UCHAR** pBits, INT32* pPitch)
+{
+   HX_RESULT retVal = HXR_OK;
+   if( !m_bCompositionSurfaceCreated || m_pCompositionSurface==NULL )
+   {
+      retVal = _CreateCompositionSurface();
+   }
+   HX_ASSERT( m_pCompositionSurface );
+   *pBits  = m_pCompositionSurface;
+   *pPitch = m_nCompositionPitch;
+   return HXR_OK;
+}
+
+
+void CExRootSurf::_BltFromScratchToComposition( HXxRect& rDestRect, HXxRect& rSrcRect)
+{
+   HX_ASSERT( "Not implemented on unix yet...."==NULL );
+}
+
+HX_RESULT CExRootSurf::_CreateCompositionSurface()
+{
+   HX_RESULT retVal = HXR_FAIL;
+
+   if(m_bCompositionSurfaceCreated)
+   {
+      return HXR_OK;
+   }
+
+   HX_ASSERT( !m_bCompositionSurfaceCreated );
+   HX_ASSERT( m_pSite );
+
+   //Create a BMI to describe the composition surface
+   HXxSize hxxSize;
+   m_pSite->GetSize(hxxSize);
+   memcpy(&m_compositionSize, &hxxSize, sizeof(HXxSize)); /* Flawfinder: ignore */
+
+   // find out how big we want to allocate.
+   if (m_pSite->IsFullScreen())
+   {
+      UINT16 unDummy=0;
+      UINT16 unHorzRes=0;
+      UINT16 unVertRes=0;
+      m_pSite->_GetDeviceCaps(NULL, unDummy, unHorzRes, unVertRes );
+      m_allocatedCompositionSize.cx = unHorzRes;
+      m_allocatedCompositionSize.cy = unVertRes;
+   }
+   else
+   {
+        // we use root surface for BASIC_BLT and it assumes the offset(position) 
+        // of the root site it cooresponding to is (0, 0).
+        //
+        // this is not true for "windowless" mode where the root site can be given
+        // an offset, as a result, we fail to blt the video.
+        //
+        // to fix this, we'll take the m_positionOrg into consideration when
+        // creating the composition surface, this may not be optimal but good enough
+        // for now.
+        //
+        // similar logic is also added for other platforms, we need to move this
+        // common code to the base class when we have chance to clean it up
+        if (m_compositionSize.cx && m_compositionSize.cy)
+        {
+            m_compositionSize.cx += m_pSite->m_positionOrig.x;
+            m_compositionSize.cy += m_pSite->m_positionOrig.y;
+        }
+
+        m_allocatedCompositionSize.cx = m_compositionSize.cx;
+        m_allocatedCompositionSize.cy = m_compositionSize.cy;
+   }
+
+   //XXXgfw uhhhh, OK.
+   if( m_compositionSize.cx > m_allocatedCompositionSize.cx ||
+       m_compositionSize.cy > m_allocatedCompositionSize.cy )
+   {
+      m_allocatedCompositionSize.cx = m_compositionSize.cx;
+      m_allocatedCompositionSize.cy = m_compositionSize.cy;
+   }
+
+   //Make the bitmap header struct.
+   m_bmiComposition.bmiHeader.biBitCount    = m_bmiSave.bmiHeader.biBitCount;
+   m_bmiComposition.bmiHeader.biCompression = m_bmiSave.bmiHeader.biCompression;
+   m_bmiComposition.un.dwBitMask[0]         = m_bmiSave.un.dwBitMask[0];
+   m_bmiComposition.un.dwBitMask[1]         = m_bmiSave.un.dwBitMask[1];
+   m_bmiComposition.un.dwBitMask[2]         = m_bmiSave.un.dwBitMask[2];
+   int nResult = MakeBitmap( &m_bmiComposition,
+                             sizeof(m_bmiComposition),
+                             m_nCompositionSurfaceCID,
+                             m_allocatedCompositionSize.cx,
+                             m_allocatedCompositionSize.cy,
+                             NULL,
+                             0
+                             );
+   m_bmiComposition.bmiHeader.biBitCount    = m_bmiSave.bmiHeader.biBitCount;
+   m_bmiComposition.bmiHeader.biCompression = m_bmiSave.bmiHeader.biCompression;
+   m_bmiComposition.un.dwBitMask[0]         = m_bmiSave.un.dwBitMask[0];
+   m_bmiComposition.un.dwBitMask[1]         = m_bmiSave.un.dwBitMask[1];
+   m_bmiComposition.un.dwBitMask[2]         = m_bmiSave.un.dwBitMask[2];
+
+   //Now create the bits....
+   _ResizeVideoBuffer( m_bmiComposition.bmiHeader.biSizeImage );
+   m_nCompositionPitch = GetBitmapPitch( &m_bmiComposition );
+
+   if( m_pXImage )
+   {
+      XFree( m_pXImage );
+   }
+    
+   if( m_bUseShm )
+   {
+      XLockDisplay(m_pDisplay);
+      m_pXImage  = XShmCreateImage( m_pDisplay,
+                                    m_pVisual,
+                                    m_unDepth,
+                                    ZPixmap,
+                                    (char*)m_pCompositionSurface,
+                                    &m_shmInfo,
+                                    m_allocatedCompositionSize.cx,
+                                    m_allocatedCompositionSize.cy
+                                    );
+      XUnlockDisplay(m_pDisplay);
+   }
+   else
+   {
+      XLockDisplay(m_pDisplay);
+      m_pXImage  = XCreateImage( m_pDisplay,
+                                 m_pVisual,
+                                 m_unDepth,
+                                 ZPixmap,
+                                 0,
+                                 (char*)m_pCompositionSurface,
+                                 m_allocatedCompositionSize.cx,
+                                 m_allocatedCompositionSize.cy,
+                                 32,
+                                 0);
+      XUnlockDisplay(m_pDisplay);
+   }
+
+   if( m_pXImage )
+   {
+      m_bCompositionSurfaceCreated = TRUE;
+#ifdef _BIG_ENDIAN
+      m_pXImage->byte_order = MSBFirst;
+#else
+      m_pXImage->byte_order = LSBFirst;
+#endif
+      retVal = HXR_OK;
+   }
+   return retVal;
+}
+
+void CExRootSurf::_MinimalBlt(HXxRect& destRect)
+{
+    if (m_on_new_frame_cb) 
+    {
+	PlayerImgInfo Info;
+	Info.Rect.left = destRect.left;
+	Info.Rect.right = destRect.right;
+	Info.Rect.top = destRect.top;
+	Info.Rect.bottom = destRect.bottom;
+	Info.cx = m_allocatedCompositionSize.cx;
+	Info.cy = m_allocatedCompositionSize.cy; 
+	m_on_new_frame_cb(m_pCompositionSurface, 
+			  m_bmiComposition.bmiHeader.biSizeImage, 
+			  &Info, 
+			  m_context);
+    }
+}
+
+HX_RESULT CExRootSurf::_DestroyCompositionSurface()
+{
+   HX_RESULT retVal = HXR_OK;
+   if( m_bCompositionSurfaceCreated )
+   {
+      if( m_pXImage )
+      {
+         XFree(m_pXImage);
+         m_pXImage = NULL;
+      }
+      m_bCompositionSurfaceCreated = FALSE;
+   }
+
+   return retVal;
+}
+
+
+
+HX_RESULT CExRootSurf::BeginOptimizedBlt(HXBitmapInfoHeader* pBitmapInfo)
+{
+#ifdef _DEBUG
+   fprintf(stderr, "CExRootSurf::BeginOptimizedBlt Needs to be written\n" );
+#endif
+   return HXR_NOTIMPL;
+}
+
+HX_RESULT CExRootSurf::OptimizedBlt( UCHAR*   pImageBits,
+                                       HXxRect& rDestRect,
+                                       HXxRect& rSrcRect)
+{
+#ifdef _DEBUG
+   fprintf(stderr, "CExRootSurf::OptimizedBlt Needs to be written\n" );
+#endif
+   return HXR_NOTIMPL;
+}
+
+HX_RESULT CExRootSurf::EndOptimizedBlt(void)
+{
+#ifdef _DEBUG
+   fprintf(stderr, "CExRootSurf::EndOptimizedBlt Needs to be written\n" );
+#endif
+   return HXR_NOTIMPL;
+}
+
+HX_RESULT CExRootSurf::GetOptimizedFormat(HX_COMPRESSION_TYPE& ulType)
+{
+#ifdef _DEBUG
+   fprintf(stderr, "CExRootSurf::GetOptimizedFormat Needs to be written\n" );
+#endif
+   return HXR_NOTIMPL;
+}
+
+HX_RESULT CExRootSurf::GetPreferredFormat(HX_COMPRESSION_TYPE& ulType)
+{
+#ifdef _DEBUG
+   fprintf(stderr, "CExRootSurf::GetPreferredFormat Needs to be written\n" );
+#endif
+   return HXR_NOTIMPL;
+}
+
+GC CExRootSurf::GetGC()
+{
+   return m_GC;
+}
Index: helix-libs/clientapps/clutter/exroot.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exroot.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,155 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Source last modified: $Id: unixroot.h,v 1.8 2007/07/06 20:54:05 jfinnecy Exp $
+ * 
+ * Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.
+ * 
+ * The contents of this file, and the files included with this file,
+ * are subject to the current version of the RealNetworks Public
+ * Source License (the "RPSL") available at
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed
+ * the file under the current version of the RealNetworks Community
+ * Source License (the "RCSL") available at
+ * http://www.helixcommunity.org/content/rcsl, in which case the RCSL
+ * will apply. You may also obtain the license terms directly from
+ * RealNetworks.  You may not use this file except in compliance with
+ * the RPSL or, if you have a valid RCSL with RealNetworks applicable
+ * to this file, the RCSL.  Please see the applicable RPSL or RCSL for
+ * the rights, obligations and limitations governing use of the
+ * contents of the file.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 (the
+ * "GPL") in which case the provisions of the GPL are applicable
+ * instead of those above. If you wish to allow use of your version of
+ * this file only under the terms of the GPL, and not to allow others
+ * to use your version of this file under the terms of either the RPSL
+ * or RCSL, indicate your decision by deleting the provisions above
+ * and replace them with the notice and other provisions required by
+ * the GPL. If you do not delete the provisions above, a recipient may
+ * use your version of this file under the terms of any one of the
+ * RPSL, the RCSL or the GPL.
+ * 
+ * This file is part of the Helix DNA Technology. RealNetworks is the
+ * developer of the Original Code and owns the copyrights in the
+ * portions it created.
+ * 
+ * This file, and the files included with this file, is distributed
+ * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY
+ * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS
+ * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET
+ * ENJOYMENT OR NON-INFRINGEMENT.
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location:
+ *    http://www.helixcommunity.org/content/tck
+ * 
+ * Contributor(s):
+ * 
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef _UNIXROOT_H
+#define _UNIXROOT_H
+
+#include "baseroot.h"
+#if defined(USE_XWINDOWS)
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Xos.h>
+#include <X11/Intrinsic.h>
+#include <X11/extensions/XShm.h>
+#endif
+
+#include "player.h"
+
+class CExRootSurf : public CBaseRootSurface
+{
+public:
+   CExRootSurf(IUnknown* pContext, CHXBaseSite* pSite, on_new_frame_cb_t on_new_frame_cb = NULL, void *context = NULL);
+
+   //Helpers....
+   HX_RESULT Init();
+   GC        GetGC();
+
+   //public inherited stuff
+   virtual HX_RESULT CreateScratchSurface(int nCompositionSurfaceCID, 
+                                          HXxSize* pSize);
+   virtual HX_RESULT ScratchLock(UCHAR** pBits, INT32* pPitch);
+   virtual HX_RESULT ScratchUnlock(UCHAR* pBits);
+
+   virtual HX_RESULT BeginOptimizedBlt(HXBitmapInfoHeader* pBitmapInfo);
+   virtual HX_RESULT OptimizedBlt( UCHAR*   pImageBits,
+                                   HXxRect& rDestRect,
+                                   HXxRect& rSrcRect);
+   virtual HX_RESULT EndOptimizedBlt(void);
+   virtual HX_RESULT GetOptimizedFormat(HX_COMPRESSION_TYPE& ulType);
+   virtual HX_RESULT GetPreferredFormat(HX_COMPRESSION_TYPE& ulType);
+
+   XImage* _GetCompositionSurfaceDrawable();
+
+   //Shared Memory helper func for the basesurf to use.
+//     HX_RESULT _DetachSharedRegion();
+//     HX_RESULT _CreateSharedRegion(INT32 nSize);
+   
+protected:
+
+   //Smartly handle resizing of shm buffer.
+   HX_RESULT _ResizeVideoBuffer(INT32 nSize);
+
+   //Inherited from CBaseRootSurface....
+   virtual void _BltFromScratchToComposition(HXxRect& rDestRect,
+                                             HXxRect& rSrcRect);
+   virtual HX_RESULT _DebugBlt( UCHAR*               pImageData,
+                                HXBitmapInfoHeader* pBitmapInfo,
+                                HXxRect&             rDestRect,
+                                HXxRect&             rSrcRect);
+   virtual void _GetYUVScratchWidthHeight(UINT32* pWidth, UINT32* pHeight);
+   virtual void _CreateYUVScratchSurface(UINT32 width, UINT32 height);
+   virtual void _GetYUVScratchSurfacePointer(UCHAR** pYUVBits, INT32* YUVPitch);
+   virtual HX_RESULT _MinimalUnlock(HXxWindow* pWindow);
+   virtual HX_RESULT _LockComposition(UCHAR** pBits, INT32* pPitch);
+   virtual HX_RESULT _CreateCompositionSurface();
+   virtual HX_RESULT _DestroyCompositionSurface();
+   virtual void      _MinimalBlt(HXxRect& dest);
+
+   
+private:
+
+   virtual ~CExRootSurf();
+   
+   //Protect unintentional copy and default ctors.
+   CExRootSurf();
+   CExRootSurf( const CExRootSurf& );
+   CExRootSurf& operator=( const CExRootSurf& it );
+
+   //Shared memory members.
+   HXBOOL            m_bUseShm;
+   XShmSegmentInfo m_shmInfo;
+   int             m_nShmId;
+
+   //General display and GC stuff.
+   Display*     m_pDisplay;
+   GC           m_GC;
+   int          m_nScreenNumber;
+   XImage*      m_pXImage;
+   Window       m_window;
+   Visual*      m_pVisual;
+   unsigned int m_unDepth;
+   Screen*      m_pScreen;
+   Colormap     m_colormap;
+   int          m_nBitsPerPixel;
+
+   //Bitmap stuff.
+   UCHAR*         m_pYUVScratchBits;
+   HXBitmapInfo  m_bmiYUVScratch;
+   int            m_nYUVScratchPitch;
+   UCHAR*         m_pScratchBits;
+   HXBitmapInfo  m_bmiScratch;
+   int            m_nScratchPitch;
+   HXBitmapInfo  m_bmiSave;
+   ULONG32        m_nCompositionSize;
+   on_new_frame_cb_t m_on_new_frame_cb;
+   void *   m_context;
+};
+
+#endif
Index: helix-libs/clientapps/clutter/exsite.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exsite.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,2915 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Source last modified: $Id: unixsite.cpp,v 1.18.2.6 2008/06/05 14:24:30 lovish Exp $
+ * 
+ * Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.
+ * 
+ * The contents of this file, and the files included with this file,
+ * are subject to the current version of the RealNetworks Public
+ * Source License (the "RPSL") available at
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed
+ * the file under the current version of the RealNetworks Community
+ * Source License (the "RCSL") available at
+ * http://www.helixcommunity.org/content/rcsl, in which case the RCSL
+ * will apply. You may also obtain the license terms directly from
+ * RealNetworks.  You may not use this file except in compliance with
+ * the RPSL or, if you have a valid RCSL with RealNetworks applicable
+ * to this file, the RCSL.  Please see the applicable RPSL or RCSL for
+ * the rights, obligations and limitations governing use of the
+ * contents of the file.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 (the
+ * "GPL") in which case the provisions of the GPL are applicable
+ * instead of those above. If you wish to allow use of your version of
+ * this file only under the terms of the GPL, and not to allow others
+ * to use your version of this file under the terms of either the RPSL
+ * or RCSL, indicate your decision by deleting the provisions above
+ * and replace them with the notice and other provisions required by
+ * the GPL. If you do not delete the provisions above, a recipient may
+ * use your version of this file under the terms of any one of the
+ * RPSL, the RCSL or the GPL.
+ * 
+ * This file is part of the Helix DNA Technology. RealNetworks is the
+ * developer of the Original Code and owns the copyrights in the
+ * portions it created.
+ * 
+ * This file, and the files included with this file, is distributed
+ * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY
+ * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS
+ * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET
+ * ENJOYMENT OR NON-INFRINGEMENT.
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location:
+ *    http://www.helixcommunity.org/content/tck
+ * 
+ * Contributor(s):
+ *                 Phil Dibowitz
+ * 
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef _UNIX
+#error This is the UNIX platform specific implementation.
+#endif
+
+//
+// System includes...
+//
+#include <stdio.h>
+#include "hlxclib/string.h"
+#if defined(USE_XWINDOWS)
+#include <X11/Intrinsic.h>
+#include <X11/Shell.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/keysym.h>
+#include <X11/Xos.h>
+#include <X11/cursorfont.h>
+#include <X11/extensions/XShm.h>
+#endif
+
+
+//
+// RMA includes...
+//
+#include "hxcom.h"
+#include "hxcore.h"
+#include "hxevent.h"
+#include "hxwintyp.h"
+#include "hxwin.h"
+#include "hxsite2.h"
+#include "hxtypes.h"
+#include "exsite.h"
+#include "unixcmap.h"
+#include "visuals.h"
+#include "region.h"
+#include "basesurf.h"
+#include "exroot.h"
+#include "hxthread.h"
+#include "hxtick.h"
+#include "sitetext.h"
+
+#include "unixsurf.h"
+
+#include "hxprefs.h"
+
+//
+// Global & Static global/member data....
+//
+Display *CHXExSite::zm_display = NULL;
+static CHXMapPtrToPtr z_mapSiteToWindow;
+
+//
+// Scroll bar support
+//
+#define SCROLL_BAR_WIDTH 13        //Width of scroll bar.
+//#define _ARROWS_SIDE_BY_SIDE 1   //Regular or side by side arrows?
+
+
+
+
+//
+// CHXExSite only Methods...
+//
+CHXExSite::CHXExSite( IUnknown* pContext, IUnknown* pUnkOuter, INT32 lInitialZorder, on_new_frame_cb_t on_new_frame_cb, void *context)
+    : CHXBaseSite( pContext, pUnkOuter, lInitialZorder )
+    , m_pUnixEventHandler(NULL)
+    , m_ScrollHorizButtonL(0)
+    , m_ScrollHorizButtonR(0)
+    , m_ScrollVertButtonT(0)
+    , m_ScrollVertButtonB(0)
+    , m_winFullScreenWindow(0)
+    , m_winOldParent(0)
+    , m_bScrollingInProgress(FALSE)
+    , m_nScrollDir(0)
+    , m_bLastPointInSite(FALSE)
+    , m_bDamaged(FALSE)
+    , m_bIgnoreFocusOutInFS(FALSE)
+    , m_bReparent(FALSE)
+    , m_on_new_frame_cb(on_new_frame_cb)
+    , m_context(context)
+#if defined(HELIX_CONFIG_MOBLIN)
+    , m_pAttachWindowCallback(NULL)
+    , m_pForceRedrawCallback(NULL)
+#endif    
+{
+    m_ptScrollVertPosT.x   = m_ptScrollVertPosT.y   = 0;
+    m_ptScrollVertPosB.x   = m_ptScrollVertPosB.y   = 0;
+    m_ptScrollHorizPosR.x  = m_ptScrollHorizPosR.y  = 0;
+    m_ptScrollHorizPosL.x  = m_ptScrollHorizPosL.y  = 0;
+    m_ptFullScreenOffset.x = m_ptFullScreenOffset.y = 0;
+    memset( &m_PreFullScreenSize, 0, sizeof( m_PreFullScreenSize ) );
+
+    HX_ASSERT( m_pContext );
+
+    /* Replace m_pVideoSurface with my own */
+/*    HX_RELEASE(m_pVideoSurface);
+    m_pVideoSurface = new CUnixSurf(m_pContext, this);
+    HX_ASSERT( m_pVideoSurface );
+    m_pVideoSurface->InitSurface(m_pContext);
+    m_pVideoSurface->AddRef();
+*/
+    IHXPreferences* pPreferences = NULL;
+    if( m_pContext && HXR_OK == m_pContext->QueryInterface( IID_IHXPreferences, (void **) &pPreferences))
+    {
+        IHXBuffer *pBuffer = NULL;
+        pPreferences->ReadPref("IgnoreFocusOutInFS", pBuffer);
+        if(pBuffer)
+        {
+            m_bIgnoreFocusOutInFS = (::atoi((const char*)pBuffer->GetBuffer()) == 1);
+            HX_RELEASE(pBuffer);
+        }
+    }
+}
+
+CHXExSite::~CHXExSite()
+{
+#if defined(HELIX_CONFIG_MOBLIN)
+    RemovePendingCallback(m_pAttachWindowCallback);
+    HX_RELEASE(m_pAttachWindowCallback);
+	
+    RemovePendingCallback(m_pForceRedrawCallback);
+    HX_RELEASE(m_pForceRedrawCallback);	
+#endif	
+    void* pDummy;
+    if (z_mapSiteToWindow.Lookup((void*)this, pDummy))
+    {
+        z_mapSiteToWindow.RemoveKey((void*)this);
+    }
+
+    if( m_pUnixEventHandler )
+    {
+        m_pUnixEventHandler->CancelCallback();
+        HX_RELEASE(m_pUnixEventHandler);
+    }
+}
+
+HX_RESULT CHXExSite::_OpenXDisplay(char* pszDisplayString)
+{
+    HX_RESULT retVal = HXR_OK;
+
+    //Is the connection open already?
+    if( NULL==zm_display )
+    {
+        zm_display = XOpenDisplay(pszDisplayString);
+
+        //If you can't open the display your done.
+        if(NULL == zm_display )
+        {
+            HX_ASSERT("Can't open X Display..."==NULL);
+            retVal = HXR_FAIL;
+        }
+        else
+        {
+            HX_ASSERT(m_pScheduler);
+            if( m_pScheduler )
+            {
+                //UnixEventHandler scheduls itself for init callback
+                //in the ctor.
+                m_pUnixEventHandler = new UnixEventHandler(this);
+                m_pUnixEventHandler->AddRef();
+            }
+        }
+    }
+    return retVal;
+}
+
+Window CHXExSite::CreateXWindow( Window win )
+{
+    Window     parentWindow;
+    HXxWindow* pWindow = NULL;
+    //If parentWin is NULL then we belong to the root window.
+    if( win )
+    {
+        parentWindow = win;
+    }
+    else
+    {
+        HX_ASSERT(zm_display);
+        XLockDisplay(zm_display);
+        parentWindow = RootWindow(zm_display, DefaultScreen(zm_display));
+        XUnlockDisplay(zm_display);
+    }
+
+    //Find the best visual to use on this display.
+    Visual* visual = GetBestVisual(zm_display);
+
+    //Get the visual info.
+    int         nNotUsed=0;
+    XVisualInfo stVisInfo;
+
+    memset(&stVisInfo, 0, sizeof(XVisualInfo));
+    stVisInfo.visualid = XVisualIDFromVisual(visual);
+    XLockDisplay(zm_display);
+    XVisualInfo* pVisual = XGetVisualInfo( zm_display,
+                                           VisualIDMask,
+                                           &stVisInfo,
+                                           &nNotUsed );
+    XUnlockDisplay(zm_display);
+
+    // Set up attributes of the window.
+    int                  attrMask = CWBackPixel | CWBorderPixel;
+    XSetWindowAttributes attr;
+
+    memset(&attr, 0, sizeof(XSetWindowAttributes));
+    XLockDisplay(zm_display);
+    attr.background_pixel = BlackPixel(zm_display, DefaultScreen(zm_display));
+    attr.border_pixel     = BlackPixel(zm_display, DefaultScreen(zm_display));
+    XUnlockDisplay(zm_display);
+
+    //See if the default visaul of hte screen is the same one we Want
+    //to use. If not, create a new one and install it.
+    Colormap cmap;
+    XLockDisplay(zm_display);
+    Visual*  defVisual = DefaultVisual(zm_display, DefaultScreen(zm_display));
+    XUnlockDisplay(zm_display);
+    if( defVisual->visualid != stVisInfo.visualid )
+    {
+        //XXXgfw Are we leaking this colormap????
+        XLockDisplay(zm_display);
+        cmap = XCreateColormap(zm_display, parentWindow, visual, AllocNone);
+        XUnlockDisplay(zm_display);
+        attr.colormap = cmap;
+        attrMask |= CWColormap;
+    }
+
+    // Set the size/position of the window before creating.
+    XSizeHints size_hints;
+
+    size_hints.flags  = PPosition | PSize;
+    size_hints.x      = m_position.x;
+    size_hints.y      = m_position.y;
+    size_hints.width  = 1;
+    size_hints.height = 1;
+
+    //Create it.
+    XLockDisplay(zm_display);
+    Window window = XCreateWindow(zm_display,
+                                  parentWindow,
+                                  size_hints.x,
+                                  size_hints.y,
+                                  size_hints.width,
+                                  size_hints.height,
+                                  0,
+                                  pVisual->depth,
+                                  InputOutput,
+                                  visual,
+                                  attrMask,
+                                  &attr);
+    XUnlockDisplay(zm_display);
+    XFree(pVisual);
+
+    //Tell the WM about this window.
+#if 0
+    XSetStandardProperties( zm_display,
+                            window,
+                            "CHXExSite",
+                            "CHXExSite",
+                            None,
+                            NULL, 0,
+                            &size_hints
+                            );
+#endif
+
+    //Select all input events on the window since the other platforms
+    //we work with have no concept of event masks
+    XLockDisplay(zm_display);
+#if 0
+    int result = XSelectInput( zm_display, window,
+                               ButtonPressMask   | ButtonReleaseMask | KeyPressMask    |
+                               KeyReleaseMask    | EnterWindowMask   | LeaveWindowMask |
+                               PointerMotionMask | ButtonMotionMask  | KeymapStateMask |
+                               ExposureMask      | StructureNotifyMask | FocusChangeMask
+                               );
+#else
+    int result = XSelectInput( zm_display, window, 0 );
+
+
+#endif
+    XUnlockDisplay(zm_display);
+    if( BadWindow == result )
+    {
+#ifdef _DEBUG
+        fprintf( stderr, "Can select events.\n" );
+#endif
+    }
+
+    //Map the window.
+    XLockDisplay(zm_display);
+ /*   XMapWindow(zm_display, window);   */
+
+    //Flush event queue.
+    XFlush(zm_display);
+    XUnlockDisplay(zm_display);
+
+
+    return window;
+}
+
+void CHXExSite::_MapHorzScroll()
+{
+#if 0
+    if( GetWindow() && GetWindow()->display && m_ScrollHorizButtonL)
+    {
+        Display* pDis = (Display*)GetWindow()->display;
+        XLockDisplay(pDis);
+        XMapWindow( pDis, m_ScrollHorizButtonL );
+        XMapWindow( pDis, m_ScrollHorizButtonR );
+        XUnlockDisplay(pDis);
+    }
+    _DrawArrows();
+#endif
+}
+
+void CHXExSite::_MapVertScroll()
+{
+#if 0
+    if( GetWindow() && GetWindow()->display && m_ScrollVertButtonT)
+    {
+        Display* pDis = (Display*)GetWindow()->display;
+        XLockDisplay(pDis);
+        XMapWindow( pDis, m_ScrollVertButtonT );
+        XMapWindow( pDis, m_ScrollVertButtonB );
+        XUnlockDisplay(pDis);
+    }
+    _DrawArrows();
+#endif
+}
+
+void CHXExSite::_MapScrollButtons()
+{
+#if 0
+    _MapHorzScroll();
+    _MapVertScroll();
+#endif
+}
+
+void CHXExSite::_UnmapHorzScroll()
+{
+#if 0
+    HX_ASSERT( GetWindow() );
+    if( m_ScrollHorizButtonL && GetWindow()->display )
+    {
+        Display* pDis = (Display*)GetWindow()->display;
+        XLockDisplay(pDis);
+        XUnmapWindow( pDis, m_ScrollHorizButtonL );
+        XUnmapWindow( pDis, m_ScrollHorizButtonR );
+        XUnlockDisplay(pDis);
+    }
+#endif
+}
+void CHXExSite::_UnmapVertScroll()
+{
+#if 0
+    HX_ASSERT( GetWindow() );
+    if( m_ScrollVertButtonT && GetWindow()->display )
+    {
+        Display* pDis = (Display*)GetWindow()->display;
+        XLockDisplay(pDis);
+        XUnmapWindow( pDis, m_ScrollVertButtonT );
+        XUnmapWindow( pDis, m_ScrollVertButtonB );
+        XUnlockDisplay(pDis);
+    }
+#endif
+}
+
+void CHXExSite::_UnmapScrollButtons()
+{
+#if 0
+    if( GetWindow() )
+    {
+        _UnmapVertScroll();
+        _UnmapHorzScroll();
+    }
+#endif
+}
+
+void CHXExSite::_DestroyScrollButtons()
+{
+    HXxWindow* pWin = GetWindow();
+    Display*   pDis = (Display*)(pWin?pWin->display:NULL);
+
+    if( m_ScrollHorizButtonL && pDis )
+    {
+        XLockDisplay(pDis);
+        XDestroyWindow( pDis, m_ScrollHorizButtonL );
+        m_ScrollHorizButtonL = 0;
+        XDestroyWindow( pDis, m_ScrollHorizButtonR );
+        XUnlockDisplay(pDis);
+        m_ScrollHorizButtonR = 0;
+    }
+
+    if( m_ScrollVertButtonT && pDis)
+    {
+        XLockDisplay(pDis);
+        XDestroyWindow( pDis, m_ScrollVertButtonT );
+        m_ScrollVertButtonT = 0;
+        XDestroyWindow( pDis, m_ScrollVertButtonB );
+        XUnlockDisplay(pDis);
+        m_ScrollVertButtonB = 0;
+    }
+    m_ptScrollVertPosT.x = m_ptScrollVertPosT.y = 0;
+    m_ptScrollVertPosB.x = m_ptScrollVertPosB.y = 0;
+    m_ptScrollHorizPosR.x = m_ptScrollHorizPosR.y = 0;
+    m_ptScrollHorizPosL.x = m_ptScrollHorizPosL.y = 0;
+}
+
+void CHXExSite::_DrawArrows()
+{
+#if 0 //Paul Debug
+    //only do the work if our site is visible.
+    if( !IsSiteVisible() )
+        return;
+
+    //Draw an arrow on this window.
+    XPoint points[4];
+    int offset = SCROLL_BAR_WIDTH/10;
+    GC tmpGC;
+    XGCValues values;
+    Display* dis = (Display*)GetWindow()->display;
+
+    if( m_ScrollVertButtonB )
+    {
+        XLockDisplay(dis);
+        tmpGC = XCreateGC( dis, m_ScrollVertButtonB, 0, &values );
+        XUnlockDisplay(dis);
+    }
+    else if( m_ScrollHorizButtonL )
+    {
+        XLockDisplay(dis);
+        tmpGC = XCreateGC( dis, m_ScrollHorizButtonL, 0, &values );
+        XUnlockDisplay(dis);
+    }
+    else
+    {
+        //We don't have any scroll bars to draw....
+        return;
+    }
+
+
+    XLockDisplay(dis);
+    XSetForeground( dis, tmpGC, WhitePixel(dis, 0 ));
+    XSetBackground( dis, tmpGC, BlackPixel(dis, 0 ));
+    XUnlockDisplay(dis);
+    Colormap cmap = HXGetXColormap((Display*)GetWindow()->display,
+                                   (Window)GetWindow()->window);
+    XColor color;
+
+    memset(&color, 0, sizeof(XColor));
+    XLockDisplay(dis);
+    XParseColor(dis, cmap, "blue", &color);
+    XUnlockDisplay(dis);
+    HXFindBestXColor(dis, cmap, &color);
+    XLockDisplay(dis);
+    XSetForeground( dis, tmpGC, color.pixel);
+    XSetLineAttributes(dis, tmpGC, 1, LineSolid, CapRound, JoinRound );
+    XUnlockDisplay(dis);
+
+
+    //Draw up Vertical arrow.
+    if( m_ScrollVertButtonT )
+    {
+        points[0].x = offset;
+        points[0].y = SCROLL_BAR_WIDTH-offset;
+        points[1].x = SCROLL_BAR_WIDTH/2;
+        points[1].y = offset;
+        points[2].x = SCROLL_BAR_WIDTH-offset;
+        points[2].y = SCROLL_BAR_WIDTH-offset;
+        points[3].x = points[0].x;
+        points[3].y = points[0].y;
+        XLockDisplay(dis);
+        XFillPolygon( dis, m_ScrollVertButtonT, tmpGC, points, 4, Convex, CoordModeOrigin);
+        XUnlockDisplay(dis);
+    }
+
+    //Draw down Vertical arrow.
+    if( m_ScrollVertButtonB )
+    {
+        points[0].x = offset;
+        points[0].y = offset;
+        points[1].x = SCROLL_BAR_WIDTH-offset;
+        points[1].y = offset;
+        points[2].x = SCROLL_BAR_WIDTH/2;
+        points[2].y = SCROLL_BAR_WIDTH-offset;
+        points[3].x = points[0].x;
+        points[3].y = points[0].y;
+        XLockDisplay(dis);
+        XFillPolygon( dis, m_ScrollVertButtonB, tmpGC, points, 4, Convex, CoordModeOrigin);
+        XUnlockDisplay(dis);
+    }
+
+    //Draw Left Horizontal arrow.
+    if( m_ScrollHorizButtonL )
+    {
+        points[0].x = SCROLL_BAR_WIDTH-offset;
+        points[0].y = offset;
+        points[1].x = SCROLL_BAR_WIDTH-offset;
+        points[1].y = SCROLL_BAR_WIDTH-offset;
+        points[2].x = offset;
+        points[2].y = SCROLL_BAR_WIDTH/2;
+        points[3].x = points[0].x;
+        points[3].y = points[0].y;
+        XLockDisplay(dis);
+        XFillPolygon( dis, m_ScrollHorizButtonL, tmpGC, points, 4, Convex, CoordModeOrigin);
+        XUnlockDisplay(dis);
+    }
+
+    //Draw Right Horizontal arrow.
+    if( m_ScrollHorizButtonR )
+    {
+        points[0].x = offset;
+        points[0].y = SCROLL_BAR_WIDTH-offset;
+        points[1].x = offset;
+        points[1].y = offset;
+        points[2].x = SCROLL_BAR_WIDTH-offset;
+        points[2].y = SCROLL_BAR_WIDTH/2;
+        points[3].x = points[0].x;
+        points[3].y = points[0].y;
+        XLockDisplay(dis);
+        XFillPolygon( dis, m_ScrollHorizButtonR, tmpGC, points, 4, Convex, CoordModeOrigin);
+        XUnlockDisplay(dis);
+    }
+
+    //Free the GC and go.
+    XLockDisplay(dis);
+    XFreeGC( dis, tmpGC );
+    XUnlockDisplay(dis);
+#endif
+}
+
+HXBOOL CHXExSite::_InButton( HXxPoint& pt, int x, int y )
+{
+    HXBOOL retVal =FALSE;
+    if( x>= pt.x && x< pt.x+SCROLL_BAR_WIDTH && y>=pt.y && y<pt.y+SCROLL_BAR_WIDTH )
+        retVal=TRUE;
+    else
+        retVal=FALSE;
+
+    return retVal;
+}
+
+void CHXExSite::_CreateHorizScrollBar()
+{
+    HX_ASSERT( m_ScrollHorizButtonL == 0 );
+    HX_ASSERT( m_ScrollHorizButtonR == 0 );
+
+    HXxSize  mySize;
+
+    HXxWindow* pParentWindow = NULL;
+    if(GetParentSite())
+    {
+        pParentWindow = GetParentSite()->GetWindow();
+    }
+    if(pParentWindow)
+    {
+        GetParentSite()->GetSize(mySize);
+    }
+
+    HX_ASSERT( pParentWindow );
+    HX_ASSERT( pParentWindow->window != 0 );
+
+    if( m_ScrollVertButtonB )
+    {
+        // if the other bar already exists, don't overlap it!
+        mySize.cx -= SCROLL_BAR_WIDTH;
+    }
+
+    m_ptScrollHorizPosL.x = m_topleft.x;
+    m_ptScrollHorizPosL.y = m_topleft.y+mySize.cy-SCROLL_BAR_WIDTH;
+
+#ifndef _ARROWS_SIDE_BY_SIDE
+    m_ptScrollHorizPosR.x = m_topleft.x+mySize.cx-SCROLL_BAR_WIDTH;
+#else
+    m_ptScrollHorizPosR.x = m_topleft.x+SCROLL_BAR_WIDTH;
+#endif
+    m_ptScrollHorizPosR.y = m_topleft.y+mySize.cy-SCROLL_BAR_WIDTH;
+
+    Display* dis     = (Display*)GetWindow()->display;
+    XLockDisplay(dis);
+    Pixel blackPixel = BlackPixel( dis, DefaultScreen(dis) );
+    XUnlockDisplay(dis);
+    Pixel greyPixel  = blackPixel;
+
+    Colormap cmap = HXGetXColormap(dis, (Window)GetWindow()->window);
+    XColor color;
+
+    XLockDisplay(dis);
+    XParseColor(dis, cmap, "gray", &color);
+    XUnlockDisplay(dis);
+    HXFindBestXColor(dis, cmap, &color);
+    greyPixel = color.pixel;
+
+    XLockDisplay(dis);
+    m_ScrollHorizButtonL = XCreateSimpleWindow( dis,
+                                                (Window)pParentWindow->window,
+                                                m_ptScrollHorizPosL.x, m_ptScrollHorizPosL.y,
+                                                SCROLL_BAR_WIDTH, SCROLL_BAR_WIDTH,
+                                                1,
+                                                blackPixel,
+                                                greyPixel
+                                                );
+    m_ScrollHorizButtonR = XCreateSimpleWindow( dis,
+                                                (Window)pParentWindow->window,
+                                                m_ptScrollHorizPosR.x, m_ptScrollHorizPosR.y,
+                                                SCROLL_BAR_WIDTH, SCROLL_BAR_WIDTH,
+                                                1,
+                                                blackPixel,
+                                                greyPixel
+                                                );
+    XUnlockDisplay(dis);
+    HX_ASSERT( m_ScrollHorizButtonR && m_ScrollHorizButtonL );
+
+}
+
+void CHXExSite::_CreateVertScrollBar()
+{
+    HX_ASSERT( m_ScrollVertButtonB == 0 );
+    HX_ASSERT( m_ScrollVertButtonT == 0 );
+
+    HXxSize  mySize;
+
+    HXxWindow* pParentWindow = NULL;
+    if(GetParentSite())
+    {
+        pParentWindow = GetParentSite()->GetWindow();
+    }
+    if(pParentWindow)
+    {
+        GetParentSite()->GetSize(mySize);
+    }
+
+    HX_ASSERT( pParentWindow );
+    HX_ASSERT( pParentWindow->window != 0 );
+
+    if( m_ScrollHorizButtonR )
+    {
+        // if the other bar already exists, don't overlap it!
+        mySize.cy -= SCROLL_BAR_WIDTH;
+    }
+
+
+    m_ptScrollVertPosT.x = m_topleft.x+mySize.cx-SCROLL_BAR_WIDTH;
+    m_ptScrollVertPosT.y = m_topleft.y;
+
+    m_ptScrollVertPosB.x = m_topleft.x+mySize.cx-SCROLL_BAR_WIDTH;
+#ifndef _ARROWS_SIDE_BY_SIDE
+    m_ptScrollVertPosB.y = m_topleft.y+mySize.cy-SCROLL_BAR_WIDTH;
+#else
+    m_ptScrollVertPosB.y = m_topleft.y+SCROLL_BAR_WIDTH;
+#endif
+
+    Display* dis     = (Display*)GetWindow()->display;
+    XLockDisplay(dis);
+    Pixel blackPixel = BlackPixel( dis, DefaultScreen(dis) );
+    XUnlockDisplay(dis);
+    Pixel greyPixel  = blackPixel;
+    Colormap cmap = HXGetXColormap((Display*)GetWindow()->display,
+                                   (Window)GetWindow()->window);
+    XColor color;
+    XLockDisplay(dis);
+    XParseColor(dis, cmap, "gray", &color);
+    XUnlockDisplay(dis);
+    HXFindBestXColor(dis, cmap, &color);
+    greyPixel = color.pixel;
+
+    HX_ASSERT( GetWindow() );
+    XLockDisplay(dis);
+    m_ScrollVertButtonT = XCreateSimpleWindow( dis,
+                                               (Window)pParentWindow->window,
+                                               m_ptScrollVertPosT.x, m_ptScrollVertPosT.y,
+                                               SCROLL_BAR_WIDTH, SCROLL_BAR_WIDTH,
+                                               1,
+                                               blackPixel,
+                                               greyPixel
+                                               );
+    m_ScrollVertButtonB = XCreateSimpleWindow( dis,
+                                               (Window)pParentWindow->window,
+                                               m_ptScrollVertPosB.x, m_ptScrollVertPosB.y,
+                                               SCROLL_BAR_WIDTH, SCROLL_BAR_WIDTH,
+                                               1,
+                                               blackPixel,
+                                               greyPixel
+                                               );
+    XUnlockDisplay(dis);
+
+    HX_ASSERT( m_ScrollVertButtonB && m_ScrollVertButtonT );
+
+}
+
+//
+// Inherited CHXBaseSite methods.
+//
+void CHXExSite::_NeedWindowedSite()
+{
+#ifdef _DEBUG
+    fprintf( stderr, "CHXExSite::_NeedWindowedSite do something here....\n" );
+#endif
+    //Nothing to do on unix....
+}
+
+void CHXExSite::_AttachWindow()
+{
+#if 1
+    void* pDummy=NULL;
+
+    if (m_pRootSurface)
+    {	/* Replace CUnixRootSurf with my own CExRootSurf */
+	    HX_RELEASE(m_pRootSurface);
+	    m_pRootSurface = new CExRootSurf(m_pContext, this, m_on_new_frame_cb, m_context);
+	    m_pRootSurface->AddRef();
+    }
+
+    if(!z_mapSiteToWindow.Lookup((void*)this, pDummy))
+    {
+        z_mapSiteToWindow.SetAt((void*)this, (void*)m_pWindow);
+    }
+
+    //Set the display variable.
+    if( m_pWindow->display == NULL )
+    {
+        HX_ASSERT(zm_display);
+        m_pWindow->display = zm_display;
+    }
+
+    //Now that we have a window be sure to init the CExRootSurf.
+    //this lets it set up the display, colormap, etc.
+    ((CExRootSurf*)m_pRootSurface)->Init();
+#endif
+}
+
+void CHXExSite::_DetachWindow()
+{
+#if 1
+    void* pDummy;
+
+    if (z_mapSiteToWindow.Lookup((void*)this, pDummy))
+    {
+        z_mapSiteToWindow.RemoveKey((void*)this);
+    }
+#endif
+}
+
+void* CHXExSite::_Create(void* pParentWindow, UINT32 style)
+{
+    HRESULT result = HXR_OK;
+    if( m_pWindow && m_pWindow->window )
+    {
+        HX_ASSERT( "We already have created a window"==NULL);
+        return NULL;
+    }
+
+    if (pParentWindow==NULL || style)
+    {
+        m_bIsChildWindow = FALSE;
+    }
+    else
+    {
+        m_bIsChildWindow = TRUE;
+    }
+
+    if( _OpenXDisplay(NULL) != HXR_OK )
+    {
+        return NULL;
+    }
+    return (void*)CreateXWindow((Window)pParentWindow);
+}
+
+
+void CHXExSite::_Destroy(HXxWindow* pWindow)
+{
+    _DestroySliders();
+    HXxWindow* pWin = GetWindow();
+    Display*   pDis = (Display*)(pWin?pWin->display:NULL);
+    if( pDis )
+    {
+        XLockDisplay(pDis);
+        XDestroyWindow( pDis, (Window)pWindow->window );
+        XUnlockDisplay(pDis);
+    }
+}
+
+void CHXExSite::_SetSize(HXxSize size)
+{
+    HX_ASSERT( m_pWindow && m_pWindow->display && m_pWindow->window);
+    //The scroll bars get resized also...
+    _DestroySliders();
+    Display* pDis = (Display*)GetWindow()->display;
+    XLockDisplay(pDis);
+    XResizeWindow(pDis,
+                  (Window) m_pWindow->window,
+                  size.cx,
+                  size.cy);
+    XUnlockDisplay(pDis);
+}
+
+void CHXExSite::_SetPosition(HXxPoint position)
+{
+    HX_ASSERT( m_pWindow && m_pWindow->display && m_pWindow->window);
+    _DestroyScrollButtons();
+    XLockDisplay((Display*) m_pWindow->display);
+    XMoveWindow((Display*)m_pWindow->display,
+                (Window)m_pWindow->window,
+                position.x,
+                position.y);
+    XUnlockDisplay((Display*) m_pWindow->display);
+}
+
+void CHXExSite::_DamageRect(HXxRect rect)
+{
+    if(GetWindow())
+    {
+        m_bDamaged = TRUE;
+    }
+    return;
+}
+
+void CHXExSite::_DamageRegion(HXxRegion rect)
+{
+    if(GetWindow())
+    {
+        m_bDamaged = TRUE;
+    }
+    return;
+}
+
+void CHXExSite::_SendOSUpdateMessage()
+{
+    //We need to redraw our window here, m_pWindow.
+}
+
+void CHXExSite::_ShowSite(HXBOOL bShow)
+{
+    if( bShow )
+    {
+        _MapScrollButtons();
+    }
+    else
+    {
+        _UnmapScrollButtons();
+    }
+    //do nothing....
+}
+
+HXBOOL CHXExSite::_AtSystemTime()
+{
+    return TRUE;
+}
+
+void CHXExSite::_GetDeviceCaps( void* hdc,
+                                  UINT16& uBitsPerPixel,
+                                  UINT16& uHorzRes,
+                                  UINT16& uVertRes )
+{
+    Screen* pScreen = NULL;
+    HXxWindow* pWin = GetWindow();
+    HX_ASSERT( pWin );
+    if( pWin )
+    {
+        Display* dis = (Display*)pWin->display;
+        HX_ASSERT( dis );
+        if( dis )
+        {
+            Display* pDisp = (Display*)GetWindow()->display;
+            XLockDisplay(pDisp);
+            pScreen = DefaultScreenOfDisplay(pDisp);
+            XUnlockDisplay(pDisp);
+
+            uBitsPerPixel = pScreen->root_depth;
+            uHorzRes      = pScreen->width;
+            uVertRes      = pScreen->height;
+        }
+    }
+}
+
+void CHXExSite::_GetWindowRect(HXxRect* destRect)
+{
+    HX_ASSERT( "Doesn't seem to be used anywhere"==NULL );
+}
+
+void CHXExSite::_DestroySliders()
+{
+    _DestroyScrollButtons();
+}
+
+void CHXExSite::_ForwardUpdateEvent(HXxEvent* pEvent)
+{
+    GC gc = NULL;
+    AddRef();
+
+    HX_ASSERT(GetWindow()->window);
+    HX_ASSERT(m_pUser);
+    if(m_bIsChildWindow)
+    {
+        //Create a clip region that excludes our higher z-order
+        //siblings and is clipped to our parent.
+        if( !m_bRegionIsValid )
+        {
+            RecomputeClip();
+        }
+
+        // The problem is that regions are locked to the origin so we
+        // will need to reverse shift the region before we set the
+        // origin of the graph port! get the GC from the video surface
+        gc = ((CExRootSurf*)m_pRootSurface)->GetGC();
+        HX_ASSERT( gc );
+
+        //Actually setup our clip region
+        Display* pDis = (Display*)GetWindow()->display;
+        XLockDisplay(pDis);
+        XSetRegion( pDis, gc, (Region) m_Region );
+        XUnlockDisplay(pDis);
+    }
+
+    XEvent* pXEvent = (XEvent*) pEvent->param2;
+    XExposeEvent* exposeEvent = (XExposeEvent*) pXEvent;
+
+    // get the rect for this site with respect to our parent
+    HXRECTANGLE exposedRect = { exposeEvent->x,
+                                exposeEvent->y,
+                                exposeEvent->width,
+                                exposeEvent->height };
+    HXREGION* exposedRegion = HXCreateRegion();
+    HXUnionRectWithRegion(&exposedRect, exposedRegion,  exposedRegion);
+
+    // does the site intersect the current clipping region?
+    HXREGION* resultRegion = HXCreateRegion();
+    HXIntersectRegion(exposedRegion, m_Region, resultRegion);
+    HXBOOL bSiteIntersectsExposed = (HXEmptyRegion(resultRegion)==FALSE);
+
+    HXDestroyRegion(resultRegion);
+    HXDestroyRegion(exposedRegion);
+
+    // if the exposed region intersects the sites clipping region
+    if(bSiteIntersectsExposed)
+    {
+        m_pUser->HandleEvent(pEvent);
+    }
+
+    //If the user doesn't handle the standard update event then send
+    //them the cross platform HX_SURFACE_UPDATE event don't damage the
+    //original event structure
+    if(!pEvent->handled && m_pUser )
+    {
+        HX_ASSERT(GetWindow());
+        HXxEvent event;
+        event.event   = HX_SURFACE_UPDATE;
+        event.window  = GetWindow()->window;
+        event.param1  = m_pVideoSurface;
+        event.param2  = GetWindow();
+        event.result  = 0;
+        event.handled = FALSE;
+        m_pUser->HandleEvent(&event);
+        pEvent->handled = event.handled;
+    }
+
+
+    //reset the gc to use no region
+    if(m_bIsChildWindow && gc)
+    {
+        Display* pDisp = (Display*)GetWindow()->display;
+        XLockDisplay(pDisp);
+        XSetClipMask(pDisp, gc, None);
+        XUnlockDisplay(pDisp);
+    }
+
+    //Handle the drawing of our arrows...
+    _DrawArrows();
+
+    //Now do all our children....
+    CHXMapPtrToPtr::Iterator i = m_ChildrenMap.Begin();
+    for(;i!=m_ChildrenMap.End();++i)
+    {
+        CHXExSite* pSite = (CHXExSite*) *i;
+        pSite->_ForwardUpdateEvent(pEvent);
+    }
+
+    Release();
+}
+
+UINT32 CHXExSite::_MapKeySymToHXVK(KeySym sym, UINT32& uFlags )
+{
+    //XXXgfw if we add the extended flag in the HX_KEYBOARD event
+    //structure then we can modify the flags here to show that these
+    //keys are 'extended' in the windows sense.
+    UINT32 ulRet = 0;
+    switch( sym )
+    {
+       case XK_Shift_R:
+           ulRet = XK_Shift_L;
+           break;
+       case XK_Alt_R:
+           ulRet = XK_Alt_L;
+           break;
+       case XK_KP_Home:
+           ulRet = XK_Home;
+           break;
+       case XK_KP_Next:
+           ulRet = XK_Next;
+           break;
+       case XK_KP_Prior:
+           ulRet = XK_Prior;
+           break;
+       case XK_KP_Enter:
+           ulRet = XK_Return;
+           break;
+       case XK_KP_End:
+           ulRet = XK_End;
+           break;
+       case XK_KP_Begin:
+           ulRet = XK_Begin;
+           break;
+       case XK_KP_Left:
+           ulRet = XK_Left;
+           break;
+       case XK_KP_Up:
+           ulRet = XK_Up;
+           break;
+       case XK_Control_R:
+           ulRet = XK_Control_L;
+           break;
+       case XK_KP_Right:
+           ulRet = XK_Right;
+           break;
+       case XK_KP_Down:
+           ulRet = XK_Down;
+           break;
+       case XK_KP_Insert:
+           ulRet = XK_Insert;
+           break;
+       case XK_KP_Delete:
+           ulRet = XK_Delete;
+           break;
+       default:
+           ulRet = sym;
+           break;
+    }
+    if( ulRet != sym )
+    {
+        //We have mapped a key from Right hand side, keypad, arrows
+        //or other parts of an extended keyboard. Set the flag.
+        uFlags |= HX_EXTENDED_KEY_MASK;
+    }
+    return ulRet;
+}
+
+
+HXBOOL CHXExSite::_ConvertToHXEvent(HXxEvent* pEvent )
+{
+    // get original events info from pEvent
+    XEvent* pXEvent = (XEvent*) pEvent->param2;
+    XButtonEvent* buttonEvent = (XButtonEvent*) pXEvent;
+
+
+    //===============================================================
+    //   Convert all other event to RMA generic events and pass back.
+    //===============================================================
+    if( ((pEvent->event == ButtonPress)   ||
+         (pEvent->event == ButtonRelease) ||
+         (pEvent->event == MotionNotify ) ||
+         (pEvent->event == EnterNotify)   ||
+         (pEvent->event == FocusIn)       ||
+         (pEvent->event == FocusOut)      ||
+         (pEvent->event == KeyPress)      ||
+         (pEvent->event == KeyRelease)    ||
+         (pEvent->event == LeaveNotify))
+        )
+    {
+        // set modifier flags for all events....
+        UINT32 flags = 0;
+
+        // create new HXxEvent
+        HXxEvent theEvent;
+
+        //XXXgfw ouch....
+        static HXxPoint realPt = {0,0};
+
+        //Init certain members.
+        memset(&theEvent, 0, sizeof(HXxEvent));
+        theEvent.window  = pEvent->window;
+        theEvent.handled = FALSE;
+
+        //
+        // NOTE:
+        //
+        // theEvent must be filled in by *ALL* event types.
+        // theEvent will be memcopied into the pEvent passed
+        // back to the basesite at the end of the method.
+        //
+
+        //==================================================
+        // LEAVE NOTIFY EVENT
+        //==================================================
+        if( pEvent->event==LeaveNotify)
+        {
+            if( m_pTopLevelSite->m_pMouseInSite )
+            {
+                HXxPoint oobPoint;
+                oobPoint.x = -1;
+                oobPoint.y = -1;
+                HXxEvent Outevent = { HX_MOUSE_LEAVE,
+                                      m_pWindow->window,
+                                      (void*)&oobPoint,
+                                      0, 0,
+                                      FALSE };
+                m_pTopLevelSite->m_pMouseInSite->EventOccurred(&Outevent);
+                m_pTopLevelSite->m_pMouseInSite = NULL;
+            }
+            pEvent->handled=TRUE;
+            return TRUE;
+        }
+
+        //==================================================
+        // ENTER NOTIFY EVENT
+        //==================================================
+        if( pEvent->event==EnterNotify)
+        {
+            pEvent->handled=TRUE;
+            return TRUE;
+        }
+
+        //==================================================
+        // KEY PRESS/RELEASE EVENT
+        //==================================================
+        if ( pEvent->event == KeyPress || pEvent->event==KeyRelease )
+        {
+            XKeyEvent* pKeyEvent = (XKeyEvent*)pEvent->param2;
+
+            //
+            //Set the event type
+            //
+            theEvent.event = pEvent->event==KeyPress?HX_KEY_DOWN:HX_KEY_UP;
+
+            //
+            // Fill in the scan/key code.
+            //
+            flags =  pKeyEvent->keycode;
+            flags &= 0x000000ff; //the scan code only gets bits 0-7
+
+            //
+            // build key modifier list...
+            //
+            if( pKeyEvent->state & ShiftMask )
+                flags |= HX_SHIFT_MASK;
+
+            if( pKeyEvent->state & ControlMask )
+                flags |= HX_CTRL_MASK;
+
+            if( pKeyEvent->state & LockMask )
+                flags |= HX_CAPS_LOCK_MASK;
+
+            if( pKeyEvent->state & Mod1Mask)
+                flags |= HX_ALT_MASK;
+
+            if( pKeyEvent->state & Mod2Mask)
+                flags |= HX_NUM_LOCK_MASK;
+
+            if( pKeyEvent->state & Mod5Mask)
+                flags |= HX_SCROLL_LOCK_MASK;
+
+            //
+            //Store the char pressed.
+            //
+            KeySym sym;
+            char   szBuf[10]; /* Flawfinder: ignore */
+            int    nNum;
+
+            //Save the state of the keys...
+            unsigned int unSave = pKeyEvent->state;
+            pKeyEvent->state=0;
+
+            //Lookup the key without any state.
+            nNum = XLookupString( pKeyEvent, szBuf, 10, &sym, NULL );
+            if( nNum > 0 )
+            {
+                theEvent.param1 = (void*)*szBuf;
+            }
+            else
+            {
+                theEvent.param1 = (void*)_MapKeySymToHXVK(sym, flags);
+                flags |= HX_VIRTUAL_KEY_MASK;
+            }
+            //restore the state of the event
+            pKeyEvent->state = unSave;
+
+            //Set the flags...
+            theEvent.param2 = (void*)flags;
+
+            //Check for HX_CHAR needed or not.
+            if( theEvent.event == HX_KEY_DOWN )
+            {
+                //We have to send an extra HX_CHAR event
+                HXxEvent extraEvent;
+                memcpy( &extraEvent, &theEvent, sizeof( extraEvent ) ); /* Flawfinder: ignore */
+
+                //Change the type.
+                extraEvent.event = HX_CHAR;
+
+                //
+                //Change the keycode to an translated ascii char.
+                //
+                KeySym sym;
+                char   szBuf[10]; /* Flawfinder: ignore */
+                int    nNum;
+
+                nNum = XLookupString( pKeyEvent, szBuf, 10, &sym, NULL );
+
+                if( nNum > 0 )
+                {
+                    extraEvent.param1 = (void*)*szBuf;
+                }
+                else
+                {
+                    extraEvent.param1 = (void*)_MapKeySymToHXVK(sym, flags);
+                    flags |= HX_VIRTUAL_KEY_MASK;
+                }
+                extraEvent.param2 = (void*)flags;
+
+                //
+                // Now send the extra event....
+                //
+                CHXBaseSite::EventOccurred(&extraEvent);
+            }
+        }
+
+        //==================================================
+        // FOCUS OUT EVENT
+        //==================================================
+        if ( pEvent->event == FocusOut )
+        {
+            theEvent.event = HX_LOSE_FOCUS;
+        }
+
+        if ( pEvent->event == FocusIn )
+        {
+            theEvent.event = HX_SET_FOCUS;
+        }
+
+        //==================================================
+        // MOUSE MOVE EVENT
+        //==================================================
+        if( pEvent->event == MotionNotify )
+        {
+            XMotionEvent* pp = (XMotionEvent*)pEvent->param2;
+            theEvent.event = HX_MOUSE_MOVE;
+
+            if( pp->state&Button1Mask )
+                flags |= HX_PRIMARY_BUTTON;
+
+            if( pp->state&Button2Mask )
+                flags |= HX_CONTEXT_BUTTON;
+
+            if( pp->state&Button3Mask )
+                flags |= HX_THIRD_BUTTON;
+
+            if(pp->state & ShiftMask)
+                flags |= HX_SHIFT_KEY;
+
+            if(pp->state & ControlMask)
+                flags |= HX_CTRL_KEY;
+
+            if(pp->state & Mod1Mask)
+                flags |= HX_ALT_COMMAND_KEY;
+
+            theEvent.param2 = (void*) flags;
+
+            //Grab the X and Y.
+            theEvent.param1 = (void*) &realPt;
+            realPt.x = pp->x;
+            realPt.y = pp->y;
+        }
+
+        //==================================================
+        // BUTTON PRESS/RELEASE EVENT
+        //==================================================
+        if((pEvent->event == ButtonPress) || (pEvent->event == ButtonRelease))
+        {
+            // remap event
+            if (pEvent->event == ButtonPress)
+            {
+                if (buttonEvent->button == Button3)
+                    theEvent.event = HX_CONTEXT_BUTTON_DOWN;
+                else
+                    theEvent.event = HX_PRIMARY_BUTTON_DOWN;
+            }
+            else if (pEvent->event == ButtonRelease)
+            {
+                if (buttonEvent->button == Button3)
+                    theEvent.event = HX_CONTEXT_BUTTON_UP;
+                else
+                    theEvent.event = HX_PRIMARY_BUTTON_UP;
+            }
+
+            if(buttonEvent->state & ShiftMask)
+                flags |= HX_SHIFT_KEY;
+
+            if(buttonEvent->state & ControlMask)
+                flags |= HX_CTRL_KEY;
+
+            theEvent.param2 = (void*) flags;
+
+            //Grab the X and Y.
+            theEvent.param1 = (void*) &realPt;
+            realPt.x = buttonEvent->x;
+            realPt.y = buttonEvent->y;
+        }
+
+        //Copy the new event back into the passed in one for
+        //all events that fall through here...
+        memcpy( pEvent, &theEvent, sizeof(HXxEvent) ); /* Flawfinder: ignore */
+
+#if defined(_DEBUG)
+        //If the users presses control-primary button
+        //dump info on all sites. If shift-context, then
+        //just this site.
+        if( (buttonEvent->state&ControlMask)&&
+            (theEvent.event==HX_PRIMARY_BUTTON_DOWN))
+        {
+            DisplayAllSiteData();
+        }
+        if( (buttonEvent->state&ShiftMask)&&
+            (theEvent.event==HX_PRIMARY_BUTTON_DOWN))
+        {
+            DisplaySiteData("");
+        }
+#endif
+    }
+    return pEvent->handled;
+}
+
+
+void CHXExSite::CheckColorSettings()
+{
+#if !defined(HELIX_FEATURE_HARDWARE_COLOR_CONTROLS)
+    CHXBaseSite::CheckColorSettings();
+#else
+    CUnixSurf* pSurf = (CUnixSurf*)m_pVideoSurface;
+    if( !pSurf->HasHWColorConrols() )
+    {
+        CHXBaseSite::CheckColorSettings();
+    }
+    else
+    {
+        pSurf->SetHWColorControls();
+        
+        //We do all color stuff except sharpmess in hardware.
+        float fCurrentSharpness;
+        INT16 bInterpolate;
+        zm_pColorAcc->GetSharpnessAdjustments(&fCurrentSharpness, &bInterpolate);
+        
+        if (fCurrentSharpness != m_fSharpness)
+        {
+            zm_pColorAcc->SetSharpnessAdjustments(m_fSharpness, FALSE);
+        }
+    }
+#endif
+}
+
+//
+// OK, here it is. Take care of any OS specific duties, like scrollbar
+// stuff and expose events. Then, if the event isn't handled, convert
+// to an RMA event and return.
+HXBOOL CHXExSite::_HandleOSEvents(HXxEvent* pEvent)
+{
+    HXxPoint position = {0, 0};
+    HXxPoint point;
+
+    if( NULL==pEvent )
+    {
+        return FALSE;
+    }
+
+    return TRUE;
+
+#if defined(_DEBUG) && 0
+//   fprintf( stderr, "this: %p m_pUser: %p ", this, m_pUser );
+    switch( pEvent->event )
+    {
+       case HX_MOUSE_LEAVE:
+           fprintf( stderr, "HX_MOUSE_LEAVE\n" );
+           break;
+//        case HX_MOUSE_MOVE:
+//           point.x = ((HXxPoint*)pEvent->param1)->x;
+//           point.y = ((HXxPoint*)pEvent->param1)->y;
+//           fprintf( stderr, "HX_MOUSE_MOVE: %d %d\n", point.x, point.y );
+//           break;
+       case HX_MOUSE_ENTER:
+           fprintf( stderr, "HX_MOUSE_ENTER\n" );
+           break;
+//        case MotionNotify:
+//           point.x = ((XMotionEvent*)pEvent->param2)->x;
+//           point.y = ((XMotionEvent*)pEvent->param2)->y;
+//           fprintf( stderr, "MotionNotify: %d %d\n", point.x, point.y );
+//           break;
+       case Expose:
+           fprintf( stderr, "Expose\n" );
+           break;
+       case EnterNotify :
+           fprintf( stderr, "EnterNotify\n" );
+           break;
+       case LeaveNotify:
+           fprintf( stderr, "LeaveNotify\n" );
+           break;
+       case KeyPress:
+           fprintf( stderr, "this: %p m_pUser: %p ", this, m_pUser );
+           fprintf( stderr, "Keypress\n\n" );
+           break;
+       case KeyRelease:
+           fprintf( stderr, "this: %p m_pUser: %p ", this, m_pUser );
+           fprintf( stderr, "KeyRelease\n" );
+           break;
+       default:
+           fprintf( stderr, "Other\n" );
+           break;
+    }
+#endif
+
+    //Find the ConfigureNotify events so we can drop to RGB from
+    //overlay while we move....
+//     if( pEvent->event == ConfigureNotify && this==m_pTopLevelSite )
+//     {
+//        XConfigureEvent* pev = (XConfigureEvent*)pEvent->param2;
+//        if( m_pWindow && pev->window == (Window)m_pWindow->window )
+//        {
+//           HXxPoint p;
+//           _GetPositionRelativeToActualWindow( p );
+//  //           fprintf( stderr, "wint %p  -- x,y width, height: %d %d %d %d \n",
+//  //                    pev->window,
+//  //                    pev->x, pev->y, pev->width, pev->height);
+//  //           fprintf( stderr, "size of site: %d %d\n", m_size.cx, m_size.cy);
+//  //           fprintf( stderr, "pos of site: %d %d\n", m_topleft.x, m_topleft.y);
+//           m_pTopLevelSite->m_pMutex->Lock();
+//           m_pTopLevelSite->SiteMoving(0, 0);
+//           m_pTopLevelSite->m_nLastMoveTime = HX_GET_TICKCOUNT();
+//           m_pTopLevelSite->ScheduleCallback(MOUSE, 100);
+//           m_pTopLevelSite->m_pMutex->Unlock();
+//        }
+//     }
+
+    //See if we should drop out of full screen
+    if( pEvent->event == FocusOut && IsFullScreen() && !m_bIgnoreFocusOutInFS )
+    {
+//         fprintf( stderr, "_HandleOSEvents: focus out: " );
+//         XEvent* pXEvent = (XEvent*) pEvent->param2;
+//         XFocusChangeEvent* event = (XFocusChangeEvent*) pXEvent;
+//         switch( event->mode )
+//         {
+//            case NotifyAncestor:
+//                fprintf( stderr, "NotifyAncestor\n" );
+//                break;
+//            case NotifyVirtual:
+//                fprintf( stderr, "NotifyVirtual\n" );
+//                break;
+//            case NotifyInferior:
+//                fprintf( stderr, "NotifyInferior\n" );
+//                break;
+//            case NotifyNonlinear:
+//                fprintf( stderr, "NotifyNonlinear\n" );
+//                break;
+//            case NotifyNonlinearVirtual:
+//                fprintf( stderr, "NotifyNonlinearVirtual\n" );
+//                break;
+//            case NotifyPointer:
+//                fprintf( stderr, "NotifyPointer\n" );
+//                break;
+//            case NotifyPointerRoot:
+//                fprintf( stderr, "NotifyPointerRoot\n" );
+//                break;
+//            case NotifyDetailNone:
+//                fprintf( stderr, "NotifyDetailNone\n" );
+//                break;
+//            default:
+//                fprintf( stderr, "screwed.....\n" );
+//         }
+        ExitFullScreen();
+    }
+
+
+#if defined(_DEBUG) && defined(TEST_FULL_SCREEN)
+    if( pEvent->event == KeyPress )
+    {
+        KeySym sym;
+        char   szBuf[10]; /* Flawfinder: ignore */
+        int    nNum;
+
+        //Lookup the key without any state.
+        nNum = XLookupString( (XKeyEvent*)(pEvent->param2), szBuf, 10, &sym, NULL );
+        if( nNum > 0 )
+        {
+            if( 'f' == szBuf[0] && IsFullScreen() )
+            {
+                //Exit full screen if 'f' is pressed.....
+                m_pTopLevelSite->ExitFullScreen();
+            }
+            else if( 'f' == szBuf[0] && !IsFullScreen() )
+            {
+                //Enter full screen if 'f' is pressed.....
+                m_pTopLevelSite->EnterFullScreen();
+            }
+
+        }
+
+    }
+#endif
+
+#if defined(_DEBUG) && defined(_TEST_COLOR_CONTROLS)
+    if( pEvent->event == KeyPress )
+    {
+        KeySym sym;
+        char   szBuf[10]; /* Flawfinder: ignore */
+        int    nNum;
+
+        //Lookup the key without any state.
+        nNum = XLookupString( (XKeyEvent*)(pEvent->param2), szBuf, 10, &sym, NULL );
+        if( nNum > 0 )
+        {
+            if( 'b' == szBuf[0] )
+            {
+                SetBrightness( GetBrightness()-.05);
+            }
+            if( 'B' == szBuf[0] )
+            {
+                SetBrightness( GetBrightness()+.05);
+            }
+
+            if( 'c' == szBuf[0] )
+            {
+                SetContrast( GetContrast()-.05);
+            }
+            if( 'C' == szBuf[0] )
+            {
+                SetContrast( GetContrast()+.05);
+            }
+
+            if( 'h' == szBuf[0] )
+            {
+                SetHue( GetHue()-.05);
+            }
+            if( 'H' == szBuf[0] )
+            {
+                SetHue( GetHue()+.05 );
+            }
+
+            if( 's' == szBuf[0] )
+            {
+                SetSaturation( GetSaturation()-.05);
+            }
+            if( 'S' == szBuf[0] )
+            {
+                SetSaturation( GetSaturation()+.05);
+            }
+            fprintf( stderr, "colors %f %f %f %f\n",
+                     GetBrightness(),
+                     GetContrast(),
+                     GetSaturation(),
+                     GetHue());
+        }
+
+    }
+#endif
+
+    //Exit full screen on ESC pressed......
+    if( pEvent->event == KeyPress )
+    {
+        KeySym sym;
+        char   szBuf[10]; /* Flawfinder: ignore */
+        int    nNum;
+
+        //Lookup the key without any state.
+        nNum = XLookupString( (XKeyEvent*)(pEvent->param2), szBuf, 10, &sym, NULL );
+        if( nNum > 0 )
+        {
+            if( 27 == (int)szBuf[0] && IsFullScreen() )
+            {
+                //Exit full screen if esc is pressed.....
+                m_pTopLevelSite->ExitFullScreen();
+            }
+        }
+    }
+
+    //Find out if this is an event we are interested in.  Make sure we
+    //are visible, it isn't a button, expose or FocusIn event and also
+    //make sure it is headed for our window.
+    if (!_ShouldProcess(pEvent))
+    {
+        return FALSE;
+    }
+
+
+    if(m_pUser && GetWindow() && GetWindow()->window)
+    {
+        //Do not send an update event to a hidden site.
+        if( pEvent->event == Expose ||
+            pEvent->event == FocusIn  ||
+            pEvent->event == HX_SURFACE_UPDATE )
+        {
+            if( (m_ScrollVertButtonT || m_ScrollHorizButtonR) && IsSiteVisible() )
+            {
+                _DrawArrows();
+            }
+            _ForwardUpdateEvent(pEvent);
+            return TRUE;
+        }
+        else
+        {
+            // get original events info from pEvent
+            XEvent* pXEvent = (XEvent*) pEvent->param2;
+            XButtonEvent* buttonEvent = (XButtonEvent*) pXEvent;
+
+
+            //XXXgfw all this code sucks! It really need to be written
+            //for just native events or RMA events. With the change to a
+            //common site it is all screwed up. I am leaving it for now
+            //so we can get on with transparancy but get back to it!
+
+            //If the user clicks MB1 on a scroll button, handle it here and
+            //don't pass it up or let the user handle the event.
+            //Hit detection here.
+
+            ////////////////////////////////////////////////////////
+            // BEGIN SCROLLING GARBAGE
+            ////////////////////////////////////////////////////////
+            if(
+                ((pEvent->event==ButtonPress || pEvent->event==ButtonRelease) &&
+                 buttonEvent->button==Button1) &&
+                (m_ScrollHorizButtonL || m_ScrollVertButtonB )
+                )
+            {
+                int buttonX=0;
+                int buttonY=0;
+
+                if( pEvent->event==ButtonRelease )
+                {
+                    if( m_bScrollingInProgress )
+                    {
+                        m_bScrollingInProgress = FALSE;
+                        m_nScrollDir = 0;
+                        return TRUE ;
+                    }
+                }
+                else
+                {
+                    buttonX = buttonEvent->x;
+                    buttonY = buttonEvent->y;
+
+                    HXBOOL bPointInSite = FALSE;
+                    if( m_Region )
+                        bPointInSite = HXPointInRegion(m_Region, buttonX, buttonY);
+
+                    if( bPointInSite )
+                    {
+                        if( m_ScrollHorizButtonL )
+                        {
+                            if( _InButton( m_ptScrollHorizPosL, buttonX, buttonY ))
+                            {
+                                m_bScrollingInProgress = TRUE;
+                                m_nScrollDir = 1;
+                            }
+                            if( _InButton( m_ptScrollHorizPosR, buttonX, buttonY ))
+                            {
+                                m_bScrollingInProgress = TRUE;
+                                m_nScrollDir = 2;
+                            }
+                        }
+                        if( m_ScrollVertButtonT )
+                        {
+                            if( _InButton( m_ptScrollVertPosT, buttonX, buttonY ))
+                            {
+                                m_bScrollingInProgress = TRUE;
+                                m_nScrollDir = 3;
+                            }
+                            if( _InButton( m_ptScrollVertPosB, buttonX, buttonY ))
+                            {
+                                m_bScrollingInProgress = TRUE;
+                                m_nScrollDir = 4;
+                            }
+                        }
+                    }
+                }
+
+                if( (m_ScrollHorizButtonL||m_ScrollVertButtonT) && m_bScrollingInProgress)
+                {
+                    int xx=0;
+                    int yy=0;
+                    HXxWindow* pParentWindow = GetParentSite()->GetWindow();
+                    //Make it scroll 10% of the parent window each click.
+                    HXxSize sizeTmp;
+                    GetParentSite()->GetSize(sizeTmp);
+
+                    //Set it to a percentage of the slider range.
+                    int incX = sizeTmp.cx/10;
+                    int incY = sizeTmp.cy/10;
+
+                    HX_ASSERT( pParentWindow );
+
+                    xx = m_XSliderPos;
+                    yy = m_YSliderPos;
+
+                    if( m_nScrollDir == 1 )
+                        xx-=incX;
+                    if( m_nScrollDir == 2 )
+                        xx+=incX;
+                    if( m_nScrollDir == 3 )
+                        yy-=incY;
+                    if( m_nScrollDir == 4 )
+                        yy+=incY;
+
+                    if( xx > m_size.cx-sizeTmp.cx )
+                        xx = m_size.cx-sizeTmp.cx;
+                    if( yy > m_size.cy-sizeTmp.cy)
+                        yy = m_size.cy-sizeTmp.cy;
+
+                    if( xx < 0 )
+                        xx = 0;
+                    if( yy < 0 )
+                        yy = 0;
+
+                    m_XSliderPos = xx;
+                    m_YSliderPos = yy;
+
+                    HXxRect rect;
+                    DamageRect(rect);
+
+                    InternalForceRedraw();
+                }
+                //Only throw away the event if it had something to do with
+                //scolling.
+                if( m_bScrollingInProgress )
+                {
+                    m_bScrollingInProgress = FALSE;
+                    m_nScrollDir = 0;
+                    return TRUE;
+                }
+            }
+            ////////////////////////////////////////////////////////
+            // END SCROLLING GARBAGE
+            ////////////////////////////////////////////////////////
+            point.x = -1;
+            point.y = -1;
+
+            if( pEvent->event == MotionNotify)
+            {
+                point.x = ((XMotionEvent*)pXEvent)->x;
+                point.y = ((XMotionEvent*)pXEvent)->y;
+            }
+            else if( pEvent->event == ButtonPress )
+            {
+                point.x = ((XMotionEvent*)pXEvent)->x;
+                point.y = ((XMotionEvent*)pXEvent)->y;
+            }
+
+            //
+            //Give the user a chance at the native event.
+            //
+            if( m_RegionWithoutChildren && HXPointInRegion(m_RegionWithoutChildren, point.x, point.y ))
+            {
+                if( m_Region && HXPointInRegion(m_Region, point.x, point.y) )
+                {
+                    if (m_pUser)
+                        m_pUser->HandleEvent(pEvent);
+                }
+                else
+                {
+                    INT32 handledCount = 0;
+                    INT32 mapCount     = 0;
+
+                    //try send this to all of our children
+                  _unixsitecpp1:
+                    mapCount = m_ChildrenMap.GetCount();
+                    CHXMapPtrToPtr::Iterator i;
+                    for(i=m_ChildrenMap.Begin() ; i!=m_ChildrenMap.End() ; ++i)
+                    {
+                        CHXBaseSite* pSite = (CHXBaseSite*) *i;
+                        pSite->_HandleOSEvents(pEvent);
+                        if (pEvent->handled)
+                        {
+                            break;
+                        }
+                        handledCount+=pEvent->handled;
+                        pEvent->handled=0;
+
+                        if (m_ChildrenMap.GetCount() != mapCount)
+                        {
+                            goto _unixsitecpp1;
+                        }
+                    }
+                    if (handledCount)
+                    {
+                        pEvent->handled = 1;
+                    }
+                    HX_ASSERT(handledCount<2);
+                }
+            }
+            pEvent->handled=FALSE;
+        }
+    }
+
+    return FALSE;
+}
+
+void CHXExSite::_GenerateOSEvent(HXxEvent* pEvent, HXxEvent* pEvent2)
+{
+    //XXXgfw Not needed on UNIX I guess???
+}
+
+void CHXExSite::_GenerateSetCursorEvent()
+{
+#ifdef _DEBUG
+    fprintf( stderr, "CHXExSite::_GenerateSetCursorEvent\n" );
+#endif
+    //XXXgfw do we need this??
+}
+
+void CHXExSite::_TryCreateXSlider()
+{
+#if 0
+    if( !m_ScrollHorizButtonL && IsSiteVisible() )
+        _CreateHorizScrollBar();
+#endif
+}
+
+void CHXExSite::_SetXSliderValues(INT32 range, INT32 pageSize)
+{
+    //XXXgfw this is a do nothing as long as we only have
+    //scroll buttons on unix and not real scroll bars.
+}
+
+void CHXExSite::_TryCreateYSlider()
+{
+#if 0
+    if( !m_ScrollVertButtonT && IsSiteVisible() )
+        _CreateVertScrollBar();
+#endif
+}
+
+void CHXExSite::_SetYSliderValues(INT32 range, INT32 pageSize)
+{
+    //XXXgfw this is a do nothing as long as we only have
+    //scroll buttons on unix and not real scroll bars.
+}
+
+void CHXExSite::_GetSystemSizeOfSliders(INT32* pWidth, INT32* pHeight)
+{
+#if 0
+    *pWidth = *pHeight = SCROLL_BAR_WIDTH;
+#endif
+}
+
+HXBOOL CHXExSite::_IsWindowVisible()
+{
+#if 0
+    HX_RESULT retVal = FALSE;
+    //XXXgfw do this for now...
+    retVal = IsSiteVisible();
+    return retVal;
+#else
+    return FALSE;
+#endif
+
+}
+
+void CHXExSite::_ShowXSlider(HXBOOL bShow)
+{
+#if 0
+    if( GetWindow() )
+    {
+        if( bShow )
+            _MapHorzScroll();
+        else
+            _UnmapHorzScroll();
+    }
+#endif
+}
+
+void CHXExSite::_MoveXSlider( INT32 left,
+                                INT32 top,
+                                INT32 right,
+                                INT32 bottom,
+                                HXBOOL bRedraw )
+{
+    //Do nothing right now....
+}
+
+void CHXExSite::_ShowYSlider(HXBOOL bShow)
+{
+#if 0
+    if( GetWindow() )
+    {
+        if( bShow )
+            _MapVertScroll();
+        else
+            _UnmapVertScroll();
+    }
+#endif
+}
+
+void CHXExSite::_MoveYSlider( INT32 left,
+                                INT32 top,
+                                INT32 right,
+                                INT32 bottom,
+                                HXBOOL bRedraw)
+{
+    //do nothing right now...
+}
+
+HXBOOL CHXExSite::_DoesXSliderExist()
+{
+    return FALSE;
+//    return (m_ScrollHorizButtonL!=0);
+}
+
+void* CHXExSite::_GetContainingWindow()
+{
+    //XXXgfw Do we need this???
+    return NULL;
+}
+
+void CHXExSite::_GetCursorPos(HXxPoint* pPoint)
+{
+    //Return the cursor pos in screen coords.
+    Window rootWin;
+    Window childWin;
+    int rootX=0;
+    int rootY=0;
+    int childX=0;
+    int childY=0;
+    unsigned int mask=0;
+    Bool ret=FALSE;
+
+    HX_ASSERT(GetWindow());
+    Display* pDis = (Display*)GetWindow()->display;
+    XLockDisplay(pDis);
+    ret = XQueryPointer(pDis,
+                        (Window)GetWindow()->window,
+                        &rootWin,
+                        &childWin,
+                        &rootX, &rootY,
+                        &childX, &childY,
+                        &mask);
+    XUnlockDisplay(pDis);
+
+    if(ret)
+    {
+        pPoint->x = rootX;
+        pPoint->y = rootY;
+    }
+}
+void* CHXExSite::_GetWindowWithCursor()
+{
+#if 0
+    //Return the cursor pos in screen coords.
+    void*        pRet  = NULL;
+    int          rootX = 0;
+    int          rootY = 0;
+    int          childX= 0;
+    int          childY= 0;
+    unsigned int mask  = 0;
+    Bool         ret   = FALSE;
+    Window       rootWin;
+    Window       childWin;
+
+    HX_ASSERT(GetWindow());
+    Display* pDis = (Display*)GetWindow()->display;
+    XLockDisplay(pDis);
+    ret = XQueryPointer(pDis,
+                        (Window)GetWindow()->window,
+                        &rootWin,
+                        &childWin,
+                        &rootX, &rootY,
+                        &childX, &childY,
+                        &mask);
+    XUnlockDisplay(pDis);
+
+    if(ret)
+    {
+        pRet = (void*)childWin;
+    }
+    return pRet;
+#else
+     HX_ASSERT( "Not implemented..." == NULL );
+     return NULL;
+#endif
+}
+
+void CHXExSite::_MapPointToOSWindow(HXxPoint* pPt, void** pWindowHandle)
+{
+    //XXXgfw we could query the window tree and traverse down but that
+    //is really slow and this isn't used right now.
+    HX_ASSERT( "Not implemented..." == NULL );
+}
+
+void CHXExSite::_ReInitPrimarySurface()
+{
+    //Nothing to do in unix here right?
+}
+
+HXBOOL CHXExSite::_MoveWindow( void* win,
+                               INT32 X,
+                               INT32 Y,
+                               INT32 nWidth,
+                               INT32 nHeight,
+                               HXBOOL bRepaint)
+{
+#if 0
+    //XXXgfw we still have to do bRepaint....
+    HX_ASSERT( m_pWindow && m_pWindow->window && m_pWindow->display);
+    _DestroyScrollButtons();
+    XLockDisplay((Display*) m_pWindow->display);
+    XMoveResizeWindow( (Display*)m_pWindow->display,
+                       (Window)m_pWindow->window,
+                       X,
+                       Y,
+                       nWidth,
+                       nHeight
+                       );
+    XUnlockDisplay((Display*) m_pWindow->display);
+#else
+    HX_ASSERT( "Not implemented..." == NULL );
+#endif
+    return TRUE;
+}
+
+HXBOOL CHXExSite::_UpdateWindow(void* hWnd)
+{
+    //We need to generate a repaint here of the window....
+    return TRUE;
+}
+
+HXBOOL CHXExSite::_ShowWindow(void* hWnd, INT32 nCmdShow)
+{
+#if 0
+    HX_ASSERT( nCmdShow==HX_SHOW_WINDOW || nCmdShow==HX_HIDE_WINDOW);
+    if( !m_pWindow || !m_pWindow->window || !m_pWindow->display )
+        return FALSE;
+
+    if( nCmdShow == HX_SHOW_WINDOW )
+    {
+        _MapScrollButtons();
+        XLockDisplay((Display*) m_pWindow->display);
+        XMapWindow( (Display*)m_pWindow->display, (Window)m_pWindow->window );
+        XUnlockDisplay((Display*) m_pWindow->display);
+    }
+    else
+    {
+        _UnmapScrollButtons();
+        XLockDisplay((Display*) m_pWindow->display);
+        XUnmapWindow( (Display*)m_pWindow->display, (Window)m_pWindow->window );
+        XUnlockDisplay((Display*) m_pWindow->display);
+    }
+#endif
+    return TRUE;
+}
+
+HXBOOL CHXExSite::_SetWindowPos(void* hWnd,
+                                void* hWndInsertAfter,
+                                INT32 X,
+                                INT32 Y,
+                                INT32 cx,
+                                INT32 cy,
+                                INT32 uFlags)
+{
+#ifdef _DEBUG
+    fprintf( stderr, "Now what on earth is this suppose to do??\n" );
+#endif
+    return TRUE;
+}
+
+HXBOOL CHXExSite::_SetWindowRgn(void* hWnd, HXREGION* hRgn, HXBOOL bRedraw)
+{
+#if 0
+    HX_ASSERT( GetWindow() );
+    Display* pDis = (Display*)GetWindow()->display;
+    XLockDisplay(pDis);
+    XSetRegion( pDis,
+                (GC)m_pVideoSurface->_GetDC(NULL),
+                (Region)hRgn
+                );
+    XUnlockDisplay(pDis);
+    if( bRedraw )
+    {
+        HX_ASSERT("Redraw asked for here"==NULL );
+    }
+#endif
+    return TRUE;
+}
+
+void CHXExSite::_SetFocus(void* pWindow)
+{
+#if 0
+    XWindowAttributes attr;
+    HXxWindow*        pWin = GetWindow();
+
+    HX_ASSERT(pWin);
+    HX_ASSERT(pWindow);
+
+    XLockDisplay((Display*) pWin->display);
+    XGetWindowAttributes((Display*)pWin->display, (Window)pWindow, &attr);
+    XUnlockDisplay((Display*) pWin->display);
+    if( attr.map_state == IsViewable )
+    {
+        XLockDisplay((Display*) pWin->display);
+        XSetInputFocus( (Display*)pWin->display,
+                        (Window)pWindow,
+                        RevertToParent,
+                        CurrentTime
+                        );
+        XUnlockDisplay((Display*) pWin->display);
+    }
+
+    return;
+#endif
+}
+
+HX_RESULT CHXExSite::_EnterFullScreen(HXxWindow* pWindow)
+{
+#if 0
+    HXxWindow* pWin = GetWindow();
+    HX_ASSERT( pWin && pWin->display && pWin->display);
+    HX_ASSERT( this == m_pTopLevelSite );
+
+    if( 0 != m_winFullScreenWindow || IsFullScreen() )
+    {
+        //We are already in full screen
+        return HXR_FAIL;
+    }
+
+    //Create a override redirect window to fill the root.
+    XSizeHints           size_hints;
+    XLockDisplay((Display*) pWin->display);
+    Screen*              pScreen = XDefaultScreenOfDisplay((Display*)pWin->display);
+    XUnlockDisplay((Display*) pWin->display);
+    UINT16               uHorzRes = WidthOfScreen(pScreen);
+    UINT16               uVertRes = HeightOfScreen(pScreen);
+    int                  attrMask = 0;
+    XSetWindowAttributes attr;
+
+    memset(&attr, 0, sizeof(XSetWindowAttributes));
+    attrMask = CWOverrideRedirect | CWBorderPixel |
+        CWBackPixel | CWCursor;
+    attr.cursor = None;
+    attr.override_redirect = True;
+    XLockDisplay((Display*)pWin->display);
+    attr.background_pixel = BlackPixel((Display*)pWin->display,
+                                       DefaultScreen((Display*)pWin->display));
+    attr.border_pixel     = BlackPixel((Display*)pWin->display,
+                                       DefaultScreen((Display*)pWin->display));
+    XUnlockDisplay((Display*)pWin->display);
+
+    size_hints.flags  = PPosition | PSize;
+    size_hints.x      = 0;
+    size_hints.y      = 0;
+    size_hints.width  = uHorzRes;
+    size_hints.height = uVertRes;
+
+    //Create it.
+    XLockDisplay((Display*) pWin->display);
+    Window window = XCreateWindow((Display*)pWin->display,
+                                  DefaultRootWindow((Display*)pWin->display),
+                                  size_hints.x,
+                                  size_hints.y,
+                                  size_hints.width,
+                                  size_hints.height,
+                                  0,
+                                  CopyFromParent,
+                                  InputOutput,
+                                  CopyFromParent,
+                                  attrMask,
+                                  &attr);
+
+    //Tell the WM about this window.
+    XSetStandardProperties( (Display*)pWin->display,
+                            window,
+                            "unixfullscreen",
+                            "unixfullscreen",
+                            None,
+                            NULL, 0,
+                            &size_hints
+                            );
+
+    int result = XSelectInput( zm_display, window,
+                               ButtonPressMask   | ButtonReleaseMask | KeyPressMask    |
+                               KeyReleaseMask    | EnterWindowMask   | LeaveWindowMask |
+                               PointerMotionMask | ButtonMotionMask  | KeymapStateMask |
+                               ExposureMask      | StructureNotifyMask | FocusChangeMask
+                               );
+
+    //Map the window.
+    XMapWindow((Display*)pWin->display, window);
+    XUnlockDisplay((Display*) pWin->display);
+
+
+    //Get ready to resize the presentation....
+    if(m_pTopLevelSite)
+    {
+        m_pTopLevelSite->m_bDisableForceRedraw = TRUE;
+    }
+
+    //Maintain aspect ratio and Scale it.
+    float fXScale   = (float)uHorzRes/(float)(m_size.cx);
+    float fYScale   = (float)uVertRes/(float)(m_size.cy);
+    float fScale    = (fXScale<fYScale) ? fXScale : fYScale;
+    int nWidth      = (int)(fScale*m_size.cx+.5);
+    int nHeight     = (int)(fScale*m_size.cy+.5);
+
+    //Center the presentation and save the old size
+    memcpy( &m_PreFullScreenSize, &m_size, sizeof( HXxSize) ); /* Flawfinder: ignore */
+    HXxSize size = {nWidth, nHeight};
+
+    if( nWidth<uHorzRes )
+        m_ptFullScreenOffset.x = (uHorzRes-nWidth)/2;
+
+    if( nHeight<uVertRes )
+        m_ptFullScreenOffset.y = (uVertRes-nHeight)/2;
+
+    //Reparent our main window.......
+    Window       winRootParent = 0;
+    Window       winParent     = 0;
+    Window*      pwinChildren  = NULL;
+    unsigned int nNumChildren  = 0;
+    XLockDisplay((Display*) pWin->display);
+    XQueryTree( (Display*)pWin->display,
+                (Window)pWin->window,
+                &winRootParent,
+                &winParent,
+                &pwinChildren,
+                &nNumChildren
+                );
+    //Free unused children list.
+    XFree( pwinChildren );
+    XUnlockDisplay((Display*) pWin->display);
+
+    HX_ASSERT( winParent );
+    m_winOldParent = winParent;
+    XLockDisplay((Display*) pWin->display);
+    XReparentWindow( (Display*)pWin->display,
+                     (Window)pWin->window,
+                     window,
+                     m_ptFullScreenOffset.x,
+                     m_ptFullScreenOffset.y
+                     );
+
+    //Flush event queue.
+    XSync((Display*)pWin->display, False);
+    XUnlockDisplay((Display*) pWin->display);
+
+    //Save it
+    m_winFullScreenWindow = window;
+    m_bInFullScreen = TRUE;
+
+    //Now resize it...
+    SetSize(m_size);
+    //Redraw the presentation....
+    m_pTopLevelSite->m_bDisableForceRedraw = FALSE;
+    _ForceRedrawAll();
+
+    //Give it focus....
+    _SetFocus( (void*)pWin->window );
+
+    // now eat all the focusouts that came as a result of this reparent...
+    XEvent event;
+    XLockDisplay((Display*) pWin->display);
+    HXBOOL status   =  XCheckTypedWindowEvent((Display*)pWin->display, (Window)pWin->window,
+                                            FocusOut, &event);
+    XUnlockDisplay((Display*) pWin->display);
+    while (m_bWindowCreatedByCreate && status)
+    {
+        // just discarding these
+        XLockDisplay((Display*) pWin->display);
+        status   =  XCheckTypedWindowEvent((Display*)pWin->display, (Window)pWin->window,
+                                           FocusOut, &event);
+        XUnlockDisplay((Display*) pWin->display);
+    }
+
+    //Update the status text...
+    if(m_pStatusText)
+    {
+        m_pStatusText->ParentChangedSize();
+        m_pStatusText->Show();
+    }
+
+#else
+    HX_ASSERT( "Not implemented..." == NULL );
+#endif
+    return HXR_OK;
+}
+
+HX_RESULT CHXExSite::_ExitFullScreen()
+{
+#if 0
+    HX_ASSERT( this == m_pTopLevelSite );
+
+    HXxWindow* pWin = GetWindow();
+
+    HX_ASSERT( pWin && pWin->display && pWin->window );
+
+    //Give the window back to the TLC.
+
+    XLockDisplay((Display*) pWin->display);
+    XReparentWindow( (Display*)pWin->display,
+                     (Window)pWin->window,
+                     m_winOldParent,
+                     m_position.x, m_position.y
+                     );
+    XUnlockDisplay((Display*) pWin->display);
+
+    //Just kill our window and take us out of full screen....
+    if( 0 != m_winFullScreenWindow )
+    {
+        XLockDisplay((Display*) pWin->display);
+        XDestroyWindow( (Display*)pWin->display, m_winFullScreenWindow );
+        XUnlockDisplay((Display*) pWin->display);
+        m_winFullScreenWindow = 0;
+    }
+
+    m_bDisableForceRedraw = TRUE;
+
+    m_bInFullScreen = FALSE;
+    HXxSize size = {0,0};
+    memcpy( &size, &m_PreFullScreenSize, sizeof(HXxSize) ); /* Flawfinder: ignore */
+    m_PreFullScreenSize.cx = m_PreFullScreenSize.cy = 0;
+
+    SetSize(size);
+    _SetFocus( (void*)pWin->window );
+    m_ptFullScreenOffset.x = 0;
+    m_ptFullScreenOffset.y = 0;
+
+
+    m_bDisableForceRedraw = FALSE;
+    _ForceRedrawAll();
+
+    if(m_pStatusText)
+    {
+        m_pStatusText->ParentChangedSize();
+        m_pStatusText->Hide();
+    }
+
+    //move the site back to where it was.
+    if( m_pTopLevelSite )
+    {
+        m_pTopLevelSite->_SetPosition(m_CreateWindowPos);
+    }
+
+    return HXR_OK;
+#else
+    HX_ASSERT( "Not implemented..." == NULL );
+#endif
+}
+
+HX_RESULT CHXExSite::_EnterFullScreenNoNewWindow()
+{
+#if 0
+    HXxWindow* pWin = GetWindow();
+
+    HX_ASSERT( pWin && pWin->display && pWin->display);
+    HX_ASSERT( this == m_pTopLevelSite );
+
+    if(IsFullScreen() || !pWin)
+    {
+        //We are already in full screen
+        return HXR_FAIL;
+    }
+
+    //Get the screen size.
+    XLockDisplay((Display*) pWin->display);
+    Screen*              pScreen = XDefaultScreenOfDisplay((Display*)pWin->display);
+    UINT16               uHorzRes = WidthOfScreen(pScreen);
+    UINT16               uVertRes = HeightOfScreen(pScreen);
+    XUnlockDisplay((Display*)pWin->display);
+
+    //Get ready to resize the presentation....
+    if( m_pTopLevelSite )
+    {
+        m_pTopLevelSite->m_bDisableForceRedraw = TRUE;
+    }
+
+    //Maintain aspect ratio and Scale it.
+    float fXScale   = (float)uHorzRes/(float)(m_size.cx);
+    float fYScale   = (float)uVertRes/(float)(m_size.cy);
+    float fScale    = (fXScale<fYScale) ? fXScale : fYScale;
+    int nWidth      = (int)(fScale*m_size.cx+.5);
+    int nHeight     = (int)(fScale*m_size.cy+.5);
+
+    //Center the presentation and save the old size
+    memcpy( &m_PreFullScreenSize, &m_size, sizeof( HXxSize) ); /* Flawfinder: ignore */
+    
+    HXxSize size = {nWidth, nHeight};
+
+    if( nWidth < uHorzRes )
+    {
+        m_ptFullScreenOffset.x = (uHorzRes - nWidth)/2;
+    }
+    
+    if( nHeight < uVertRes )
+    {
+        m_ptFullScreenOffset.y = (uVertRes - nHeight)/2;
+    }
+
+    //Reparent our main window.......
+    Window       winRootParent = 0;
+    Window       winParent     = 0;
+    Window*      pwinChildren  = NULL;
+    unsigned int nNumChildren  = 0;
+    XLockDisplay((Display*) pWin->display);
+    XQueryTree( (Display*)pWin->display,
+				(Window)pWin->window,
+				&winRootParent,
+				&winParent,
+				&pwinChildren,
+				&nNumChildren
+				);
+
+    //Free unused children list.
+    XFree( pwinChildren );
+    XUnlockDisplay((Display*) pWin->display);
+    
+    HX_ASSERT( winParent );
+    m_winOldParent = winParent;
+
+    m_bInFullScreen = TRUE;
+
+    //Now resize it...
+    SetSize(m_size);
+
+    //Redraw the presentation....
+    if( m_pTopLevelSite )
+    {
+        m_pTopLevelSite->m_bDisableForceRedraw = FALSE;
+    }
+
+    _ForceRedrawAll();
+
+    //Give it focus....
+    _SetFocus( (void*)pWin->window );
+
+    // now eat all the focusouts that came as a result of this reparent...
+    XEvent event;
+    XLockDisplay((Display*) pWin->display);
+    HXBOOL status   =  XCheckTypedWindowEvent((Display*)pWin->display, (Window)pWin->window,
+        											FocusOut, &event);
+    XUnlockDisplay((Display*) pWin->display);
+    while (m_bWindowCreatedByCreate && status)
+    {
+        // just discarding these
+        XLockDisplay((Display*) pWin->display);
+        status   =  XCheckTypedWindowEvent((Display*)pWin->display, (Window)pWin->window,
+										   FocusOut, &event);
+        XUnlockDisplay((Display*) pWin->display);
+    }
+    
+	//Update the status text...
+    if(m_pStatusText)
+    {
+        m_pStatusText->ParentChangedSize();
+        m_pStatusText->Show();
+    }
+#if defined(HELIX_CONFIG_MOBLIN)
+    if(!m_pAttachWindowCallback)
+    {
+        m_pAttachWindowCallback = new CHXGenericCallback((void*)this, (fGenericCBFunc)AttachWindowCallback);
+        m_pAttachWindowCallback->AddRef();
+    }
+    if(!m_pForceRedrawCallback)
+    {
+        m_pForceRedrawCallback = new CHXGenericCallback((void*)this, (fGenericCBFunc)ForceRedrawCallback);
+        m_pForceRedrawCallback->AddRef();
+    }
+
+    // schedule callback for Attaching Window
+    if(m_pAttachWindowCallback)
+    {
+    	m_pAttachWindowCallback->CallbackScheduled(m_pScheduler->RelativeEnter(m_pAttachWindowCallback, 100));
+    }
+    if(m_pForceRedrawCallback)
+    {
+    	m_pForceRedrawCallback->CallbackScheduled(m_pScheduler->RelativeEnter(m_pForceRedrawCallback, 500));
+    }
+	
+#endif
+#else
+    HX_ASSERT( "Not implemented..." == NULL );
+#endif
+    return HXR_OK;
+}
+
+#if defined(HELIX_CONFIG_MOBLIN)    
+void CHXExSite::AttachWindowCallback(void* pParam)
+{
+    CHXExSite* pObj = (CHXExSite*)pParam;
+    if (pObj)
+    {
+        pObj->_AttachWindow();
+    }
+}
+
+
+void CHXExSite::ForceRedrawCallback(void* pParam)
+{
+    CHXExSite* pObj = (CHXExSite*)pParam;
+
+    if (pObj)
+    {
+        UINT32 ulNumOfChildren = pObj->GetNumberOfChildSites();
+        if(pObj->m_pTopLevelSite)
+        {
+            pObj->m_pTopLevelSite->m_bDisableForceRedraw = FALSE;
+        }
+        for ( UINT32 i = 0; i < ulNumOfChildren; ++i )
+        {
+            SPIHXSite spChildSite;
+            if ( SUCCEEDED( pObj->GetNthChildSite( i, *spChildSite.AsInOutParam() ) ) 
+			&& spChildSite.IsValid() )
+            {
+                spChildSite->DamageRegion( NULL );
+                spChildSite->ForceRedraw();
+            }
+            
+        }
+    }
+}
+
+void CHXExSite::RemovePendingCallback(CHXGenericCallback* pCB)
+{
+    if (pCB && 
+        pCB->GetPendingCallback() &&
+        m_pScheduler)
+    {
+        m_pScheduler->Remove(pCB->GetPendingCallback());
+        pCB->CallbackCanceled();
+    }
+}
+#endif
+
+HX_RESULT CHXExSite::_EnterFullScreenExt(HXxWindow* pWindow, IHXValues* pValues)
+{
+#if 0
+    m_bReparent = FALSE;
+    HX_RESULT res = HXR_OK;
+    UINT32 ulReparent = 0;
+
+    if (pValues)
+    {
+        pValues->GetPropertyULONG32("Reparent", ulReparent);
+    }
+
+    m_bReparent = (HXBOOL)ulReparent;
+
+    if (m_bReparent)
+    {
+        res = _EnterFullScreen(pWindow);
+    }
+    else
+    {
+        res = _EnterFullScreenNoNewWindow();
+    }
+    
+    CHXBaseSite::FullScreenEntered(res);
+    return res;
+#else
+    HX_ASSERT( "Not implemented..." == NULL );
+    return HXR_OK;  /* this makes compiler happy */
+#endif
+}
+
+HX_RESULT CHXExSite::_ExitFullScreenExt()
+{
+#if 0
+    HX_RESULT res = _ExitFullScreen();
+#if defined(HELIX_CONFIG_MOBLIN)	
+    // schedule callback for attaching window
+    if(m_pAttachWindowCallback)
+    {
+        m_pAttachWindowCallback->CallbackScheduled(m_pScheduler->RelativeEnter(m_pAttachWindowCallback, 100));
+    }
+    // schedule callback for Force Redraw the window
+    if(m_pForceRedrawCallback)
+    {
+        m_pForceRedrawCallback->CallbackScheduled(m_pScheduler->RelativeEnter(m_pForceRedrawCallback, 500));
+    }
+#endif	
+    CHXBaseSite::FullScreenExited(res);
+
+    return res;
+#else
+    HX_ASSERT( "Not implemented..." == NULL );
+    return HXR_OK;  /* this makes compiler happy */
+#endif
+
+}
+
+HX_RESULT CHXExSite::_EventOccurred(HXxEvent* pEvent)
+{
+    return HXR_OK;
+}
+
+HX_RESULT CHXExSite::_TestFullScreen( void* hTestBitmap,
+                                        const char* pszStatusText )
+{
+#ifdef _DEBUG
+    fprintf( stderr, "Going to test full screen....\n" );
+#endif
+    return HXR_OK;
+}
+
+void CHXExSite::ProcessEvent(HXxEvent* pEvent)
+{
+    if(pEvent)
+    {
+        //Expose event compression. Combine all outstanding expose events
+        //into one big region.
+        if(Expose==pEvent->event)
+        {
+            _CollapseExposeEvents((XEvent*)pEvent->param2);
+        }
+    }
+
+    //Send the event to each registered UnixSite.
+    void* pSite   = NULL;
+    void* pWindow = NULL;
+    POSITION  pos = z_mapSiteToWindow.GetStartPosition();
+    while( pos )
+    {
+        z_mapSiteToWindow.GetNextAssoc(pos, pSite, pWindow);
+        CHXExSite* pSiteWindowed = (CHXExSite*)pSite;
+        CHXExSite* pTopLevel = NULL;
+        HX_ASSERT(pSiteWindowed);
+        pSiteWindowed->AddRef();
+        pTopLevel = (CHXExSite*)pSiteWindowed->GetTopLevelSite();
+
+        if(pEvent)
+        {
+            //Call back into the basesite's event loop.
+            pTopLevel->EventOccurred(pEvent);
+        }
+
+        //XXXgfw As a workaround for the overlay not moving while the
+        //player is paused, we will check it here and update it if needed.
+
+        //XXXRGG We might be able to use X's ConfigureNotify messages instead
+        //of doing a refresh every 50 ms.
+        pTopLevel->_UpdateOverlayIfNeeded();
+
+        pSiteWindowed->Release();
+    }
+}
+
+void CHXExSite::_CollapseExposeEvents(XEvent* xevent)
+{
+    Display*      display = xevent->xany.display;
+    Window        window  = xevent->xany.window;
+    XExposeEvent* expose_event = (XExposeEvent*)xevent;
+    XEvent        new_event;
+    XExposeEvent* new_expose_event = (XExposeEvent*)&new_event;
+    ushort        x1;
+    ushort        y1;
+    ushort        x2;
+    ushort        y2;
+    ushort        x3;
+    ushort        y3;
+
+    x1 = expose_event->x;
+    y1 = expose_event->y;
+    x2 = x1 + expose_event->width;
+    y2 = y1 + expose_event->height;
+    XLockDisplay(display);
+    HXBOOL status = XCheckWindowEvent(display, window, ExposureMask, &new_event);
+    XUnlockDisplay(display);
+    while( status)
+    {
+        if (new_expose_event->x < x1)
+            x1 = new_expose_event->x;
+
+        if (new_expose_event->y < y1)
+            y1 = new_expose_event->y;
+
+        x3 = new_expose_event->x + new_expose_event->width;
+        if (x3 > x2)
+            x2 = x3;
+
+        y3 = new_expose_event->y + new_expose_event->height;
+        if (y3 > y2)
+            y2 = y3;
+        XLockDisplay(display);
+        status = XCheckWindowEvent(display, window, ExposureMask, &new_event);
+        XUnlockDisplay(display);
+
+    }
+
+    expose_event->x = x1;
+    expose_event->y = y1;
+    expose_event->width = x2 - x1;
+    expose_event->height = y2 - y1;
+    expose_event->count = new_expose_event->count;
+}
+
+
+HXBOOL CHXExSite::_ShouldProcess(HXxEvent* pEvent)
+{
+    HXBOOL bShouldProcessThisEvent = TRUE;
+
+
+    if( !IsSiteVisible() )
+    {
+        switch (pEvent->event)
+        {
+           case ButtonPress:
+           case ButtonRelease:
+           case Expose:
+           case FocusIn:
+               bShouldProcessThisEvent = FALSE;
+               break;
+           default:
+               break;
+        }
+    }
+
+    if(m_pWindow && m_pWindow->window!=pEvent->window)
+    {
+        bShouldProcessThisEvent = FALSE;
+    }
+    return bShouldProcessThisEvent;
+}
+
+
+///////////////////////////////////////////////////////
+//
+// UnixEventHandler methods...
+//
+CHXExSite::UnixEventHandler::UnixEventHandler(CHXExSite* pParent)
+    : m_pParent(pParent),
+      m_lRefCount(0),
+      m_cbHandle(0)
+{
+    HX_ASSERT(m_pParent);
+    HX_ASSERT(m_pParent->m_pScheduler);
+    m_cbHandle = m_pParent->m_pScheduler->RelativeEnter((IHXCallback*)this, 30);
+}
+
+CHXExSite::UnixEventHandler::~UnixEventHandler()
+{
+    CancelCallback();
+}
+
+void
+CHXExSite::UnixEventHandler::CancelCallback()
+{
+    if( m_cbHandle && m_pParent && m_pParent->m_pScheduler )
+    {
+        UINT32 tempHandle = m_cbHandle;
+        m_cbHandle = 0;
+        m_pParent->m_pScheduler->Remove(tempHandle);
+    }
+}
+
+HX_RESULT CHXExSite::UnixEventHandler::QueryInterface(REFIID riid, void** ppvObj)
+{
+    if (IsEqualIID(riid, IID_IHXCallback))
+    {
+        AddRef();
+        *ppvObj = (IHXCallback*)this;
+        return HXR_OK;
+    }
+    else if (IsEqualIID(riid, IID_IUnknown))
+    {
+        AddRef();
+        *ppvObj = this;
+        return HXR_OK;
+    }
+
+    *ppvObj = NULL;
+    return HXR_NOINTERFACE;
+}
+
+ULONG32 CHXExSite::UnixEventHandler::AddRef()
+{
+    return InterlockedIncrement(&m_lRefCount);
+}
+
+ULONG32 CHXExSite::UnixEventHandler::Release()
+{
+    HX_ASSERT(m_lRefCount>0);
+    if( InterlockedDecrement(&m_lRefCount)>0 )
+    {
+        return m_lRefCount;
+    }
+    delete this;
+    return 0;
+}
+
+//IHXCallback methods
+HX_RESULT CHXExSite::UnixEventHandler::Func()
+{
+    XEvent xevent;
+    static HXxEvent pnevent;
+
+    m_cbHandle = 0;
+    XLockDisplay(m_pParent->zm_display);
+    int status = XPending(m_pParent->zm_display);
+    XUnlockDisplay(m_pParent->zm_display);
+    while(status)
+    {
+        XLockDisplay(m_pParent->zm_display);
+        XNextEvent(m_pParent->zm_display, &xevent);
+        XUnlockDisplay(m_pParent->zm_display);
+
+        // package native event in HXxEvent and send to dispatcher
+        pnevent.event = xevent.type;
+        pnevent.window = (void *)xevent.xany.window;
+        pnevent.param1 = xevent.xany.display;
+        pnevent.param2 = &xevent;
+
+        m_pParent->ProcessEvent(&pnevent);
+        XLockDisplay(m_pParent->zm_display);
+        status = XPending(m_pParent->zm_display);
+        XUnlockDisplay(m_pParent->zm_display);
+    }
+
+    if (m_pParent && m_pParent->m_pScheduler)
+    {
+        m_cbHandle = m_pParent->m_pScheduler->RelativeEnter((IHXCallback*)this, 30);
+    }
+    return HXR_OK;
+}
+
+void CHXExSite::_UpdateOverlayIfNeeded()
+{
+    if( m_pVideoSurface )
+    {
+        if( m_pVideoSurface->m_nBltMode == HX_OVERLAY_BLT )
+        {
+            ULONG32 ulNow = HX_GET_BETTERTICKCOUNT();
+            CUnixSurf* pSurf = (CUnixSurf*)m_pVideoSurface;
+            if( ulNow- pSurf->m_ulLastOverlayUpdateTime > 50 )
+            {
+                SiteMoving(0,0);
+            }
+        }
+    }
+    LISTPOSITION pos = m_ChildrenInZOrder.GetHeadPosition();
+    while(pos)
+    {
+        CHXExSite* pSite = (CHXExSite*)m_ChildrenInZOrder.GetNext(pos);
+        pSite->_UpdateOverlayIfNeeded();
+    }
+}
+
+
+HXBOOL  CHXExSite::_ShouldEnterForceRedraw()
+{
+    if( !m_bDamaged || !m_pUser || !IsSiteVisible() )
+    {
+        return FALSE;
+    }
+
+    if(InterlockedIncrement(&m_lBltEntryCount)>1)
+    {
+        InterlockedDecrement(&m_lBltEntryCount);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+void  CHXExSite::_ExitForceRedraw()
+{
+    InterlockedDecrement(&m_lBltEntryCount);
+}
+
Index: helix-libs/clientapps/clutter/exsite.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exsite.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,272 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Source last modified: $Id: unixsite.h,v 1.10.2.3 2008/06/05 14:24:30 lovish Exp $
+ * 
+ * Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.
+ * 
+ * The contents of this file, and the files included with this file,
+ * are subject to the current version of the RealNetworks Public
+ * Source License (the "RPSL") available at
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed
+ * the file under the current version of the RealNetworks Community
+ * Source License (the "RCSL") available at
+ * http://www.helixcommunity.org/content/rcsl, in which case the RCSL
+ * will apply. You may also obtain the license terms directly from
+ * RealNetworks.  You may not use this file except in compliance with
+ * the RPSL or, if you have a valid RCSL with RealNetworks applicable
+ * to this file, the RCSL.  Please see the applicable RPSL or RCSL for
+ * the rights, obligations and limitations governing use of the
+ * contents of the file.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 (the
+ * "GPL") in which case the provisions of the GPL are applicable
+ * instead of those above. If you wish to allow use of your version of
+ * this file only under the terms of the GPL, and not to allow others
+ * to use your version of this file under the terms of either the RPSL
+ * or RCSL, indicate your decision by deleting the provisions above
+ * and replace them with the notice and other provisions required by
+ * the GPL. If you do not delete the provisions above, a recipient may
+ * use your version of this file under the terms of any one of the
+ * RPSL, the RCSL or the GPL.
+ * 
+ * This file is part of the Helix DNA Technology. RealNetworks is the
+ * developer of the Original Code and owns the copyrights in the
+ * portions it created.
+ * 
+ * This file, and the files included with this file, is distributed
+ * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY
+ * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS
+ * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET
+ * ENJOYMENT OR NON-INFRINGEMENT.
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location:
+ *    http://www.helixcommunity.org/content/tck
+ * 
+ * Contributor(s):
+ *                 Phil Dibowitz (jaymzh)
+ * 
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef _UNIXSITE_H
+#define _UNIXSITE_H
+
+#if defined(USE_XWINDOWS)
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Xos.h>
+#include <X11/Intrinsic.h>
+#include <X11/extensions/XShm.h>
+#endif
+
+#include "basesite.h"
+#include "hxcbobj.h"
+#include "player.h"
+
+class CHXExSite : public CHXBaseSite
+{
+public:
+
+   friend class CExSurf;
+   friend class CExRootSurf;
+   
+   CHXExSite( IUnknown* pContext,
+                IUnknown* pUnkOuter,
+                INT32 lInitialZorder,
+                on_new_frame_cb_t on_new_frame_cb = NULL,
+                void *context = NULL);
+   
+   static void ProcessEvent(HXxEvent* pEvent);
+   Window CreateXWindow( Window win ); 
+
+   void _ForwardUpdateEvent(HXxEvent* pEvent);
+
+   //static member vars.
+   static Display* zm_display;
+   void _UpdateOverlayIfNeeded();
+   HXBOOL m_bIgnoreFocusOutInFS;
+
+   //We override this.
+   void CheckColorSettings();
+
+protected:
+   
+   virtual ~CHXExSite();
+   
+   //
+   // CHXExSite only methods....
+   //
+   HX_RESULT   _OpenXDisplay(char* DiplayString);
+   static void _CollapseExposeEvents(XEvent* xevent);
+   HXBOOL        _ShouldProcess(HXxEvent* pEvent);
+   void        _DrawArrows();
+   void        _CreateHorizScrollBar(void);
+   void        _CreateVertScrollBar(void);
+   HXBOOL        _InButton(HXxPoint& pt, int x, int y );
+   void        _DestroyScrollButtons();
+   void        _MapScrollButtons();
+   void        _MapHorzScroll();
+   void        _MapVertScroll();
+   void        _UnmapHorzScroll();
+   void        _UnmapVertScroll();
+   void        _UnmapScrollButtons();
+   void        _BuildClipRegion();
+   void        _ReleaseClippingRegion();
+
+   //
+   // Seperate object for our callbacks to keep the events flowing.
+   //
+   class UnixEventHandler : public IHXCallback
+   {
+   public:
+      UnixEventHandler(CHXExSite* pParent);
+        
+      //IUnknown methods
+      virtual HX_RESULT QueryInterface(REFIID riid, void** ppvObj);
+      virtual ULONG32 AddRef();
+      virtual ULONG32 Release();
+
+      //IHXCallback methods
+      virtual HX_RESULT Func(); 
+      void CancelCallback();
+        
+   private:
+      virtual ~UnixEventHandler();
+       
+      UnixEventHandler();
+      UnixEventHandler(const UnixEventHandler&);
+      UnixEventHandler& operator=(const UnixEventHandler& it );
+        
+      CHXExSite*   m_pParent;
+      LONG32         m_lRefCount;
+      CallbackHandle m_cbHandle;
+
+      IUnknown* m_pUnkPlayer;
+   };
+    
+
+   //
+   // CHXBaseSite inherited methods
+   //
+   virtual void  _NeedWindowedSite();
+   virtual void  _AttachWindow();
+   virtual void  _DetachWindow();
+   virtual void* _Create(void* ParentWindow, UINT32 style);
+   virtual void  _Destroy(HXxWindow* pWindow); 
+   virtual void  _SetSize(HXxSize size); 
+   virtual void  _SetPosition(HXxPoint position); 
+   virtual void  _DamageRect(HXxRect rect);
+   virtual void  _DamageRegion(HXxRegion rect);
+   virtual HXBOOL  _ShouldEnterForceRedraw(); 
+   virtual void  _ExitForceRedraw(); 
+   virtual void  _SendOSUpdateMessage(); 
+   virtual void  _ShowSite(HXBOOL bShow); 
+   virtual HXBOOL  _AtSystemTime(); 
+   virtual void  _GetDeviceCaps( void* hdc,
+                                 UINT16& uBitesPerPixel,
+                                 UINT16& uHorzRes,
+                                 UINT16& uVertRes ); 
+   virtual void  _GetWindowRect(HXxRect* destRect);
+   virtual void  _DestroySliders();
+   virtual HXBOOL  _HandleOSEvents(HXxEvent* pEvent);
+   virtual HXBOOL  _ConvertToHXEvent(HXxEvent* pEvent);
+   virtual void  _GenerateOSEvent(HXxEvent* pEvent, HXxEvent* pEvent2);
+   virtual void  _GenerateSetCursorEvent();
+   virtual void  _TryCreateXSlider();
+   virtual void  _SetXSliderValues(INT32 range, INT32 pageSize);
+   virtual void  _TryCreateYSlider();
+   virtual void  _SetYSliderValues(INT32 range, INT32 pageSize);
+   virtual void  _GetSystemSizeOfSliders(INT32* pWidth, INT32* pHeight);
+   virtual HXBOOL  _IsWindowVisible();
+   virtual void  _ShowXSlider(HXBOOL bShow);
+   virtual void  _MoveXSlider( INT32 left,
+                               INT32 top,
+                               INT32 right,
+                               INT32 bottom,
+                               HXBOOL bRedraw );
+   virtual void  _ShowYSlider(HXBOOL bShow);
+   virtual void  _MoveYSlider( INT32 left,
+                               INT32 top,
+                               INT32 right,
+                               INT32 bottom,
+                               HXBOOL bRedraw);
+   virtual HXBOOL  _DoesXSliderExist();
+   virtual void* _GetContainingWindow();
+   virtual void  _GetCursorPos(HXxPoint* pPoint);
+   virtual void  _MapPointToOSWindow(HXxPoint* pPt, void** pWindowHandle);
+   virtual void* _GetWindowWithCursor();
+   virtual void  _ReInitPrimarySurface();
+   virtual HXBOOL  _MoveWindow( void* ,
+                              INT32 X,
+                              INT32 Y,
+                              INT32 nWidth,
+                              INT32 nHeight,
+                              HXBOOL bRepaint);
+   virtual HXBOOL  _UpdateWindow(void* hWnd);
+   virtual HXBOOL  _ShowWindow(void* hWnd, INT32 nCmdShow);
+   virtual HXBOOL  _SetWindowPos(void* hWnd,
+                               void* hWndInsertAfter,
+                               INT32 X,
+                               INT32 Y,
+                               INT32 cx,
+                               INT32 cy,
+                               INT32 uFlags);
+   virtual HXBOOL  _SetWindowRgn(void* hWnd, HXREGION* hRgn, HXBOOL bRedraw);
+   virtual void _SetFocus(void* pWindow);
+    
+   virtual HX_RESULT _EnterFullScreen(HXxWindow* pWindow = NULL);
+   virtual HX_RESULT _EventOccurred(HXxEvent* pEvent);
+   virtual HX_RESULT _ExitFullScreen();
+   virtual HX_RESULT _TestFullScreen( void* hTestBitmap,
+                                      const char* pszStatusText );
+   virtual HX_RESULT _EnterFullScreenExt(HXxWindow* pWindow, IHXValues* pValues);
+   virtual HX_RESULT _ExitFullScreenExt();
+#if defined(HELIX_CONFIG_MOBLIN)
+   static void	        AttachWindowCallback(void *pParam);
+   static void	        ForceRedrawCallback(void *pParam);
+   void                    RemovePendingCallback(CHXGenericCallback* pCB);
+   
+   CHXGenericCallback*     m_pAttachWindowCallback;
+   CHXGenericCallback*     m_pForceRedrawCallback;
+#endif   
+   HXBOOL                  m_bReparent;   
+
+private:
+
+   //Protect unintentional copy and default ctors.
+   CHXExSite();
+   CHXExSite( const CHXExSite& );
+   CHXExSite& operator=( const CHXExSite& it );
+   HX_RESULT _EnterFullScreenNoNewWindow();
+    
+   //member vars.
+   UnixEventHandler* m_pUnixEventHandler;
+   static Cursor zm_GrabCursor;
+   Window        m_ScrollHorizButtonL;
+   Window        m_ScrollHorizButtonR;
+   Window        m_ScrollVertButtonT;
+   Window        m_ScrollVertButtonB;
+   Window        m_winFullScreenWindow;
+   Window        m_winOldParent;
+   HXxPoint      m_ptScrollHorizPosL;
+   HXxPoint      m_ptScrollHorizPosR;
+   HXxPoint      m_ptScrollVertPosT;
+   HXxPoint      m_ptScrollVertPosB;
+   HXxPoint      m_ptFullScreenOffset;
+   HXxSize       m_PreFullScreenSize;
+   HXBOOL          m_bScrollingInProgress;
+   int           m_nScrollDir;
+   HXBOOL          m_bLastPointInSite;
+   HXBOOL          m_bDamaged;
+   //
+   //Private helpers...
+   //
+
+   //returns the HX_VK associated with this keysym....
+   UINT32 _MapKeySymToHXVK(KeySym tmpSym, UINT32& uFlags);
+   on_new_frame_cb_t m_on_new_frame_cb;
+   void *m_context;
+};
+
+#endif //_UNIXSITE_H
Index: helix-libs/clientapps/clutter/exsitsup.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exsitsup.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,455 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#ifdef _WIN16
+#include <windows.h>
+#endif
+
+#include "hxcom.h"
+#include "hxtypes.h"
+#include "hxwintyp.h"
+#include "hxwin.h"
+#include "ihxpckts.h"
+#include "hxcomm.h"
+#include "fivemmap.h"
+#include "hxstring.h" // CHXString
+#include "exsite.h"
+#include "exsitsup.h"
+#include "pckunpck.h" // CreateBufferCCF
+#include "ciddefs.h"  // CID_RGB32
+#if defined(HELIX_FEATURE_PNG)
+#include "pxpngenc.h" // PXPNGEncode::EncodeToPNGBuffer
+#endif //  HELIX_FEATURE_PNG
+#include "print.h"
+
+
+#include "globals.h"
+struct _stGlobals*& GetGlobal();
+
+/************************************************************************
+ *  Method:
+ *    Constructor
+ */
+	ExampleSiteSupplier::ExampleSiteSupplier(IUnknown* pUnkPlayer, on_new_frame_cb_t on_new_frame_cb = NULL, void *context = NULL)
+	: m_lRefCount(0)
+	, m_pSiteManager(NULL)
+	, m_pSite(NULL)
+	, m_pSiteCapture(NULL)
+	, m_pCaptureBuffer(NULL)
+	, m_pCCF(NULL)
+	  , m_pUnkPlayer(pUnkPlayer)
+	  , m_on_new_frame_cb(on_new_frame_cb)
+      , m_context(context)
+{
+	if (m_pUnkPlayer)
+	{
+		m_pUnkPlayer->QueryInterface(IID_IHXSiteManager,
+				(void**)&m_pSiteManager);
+
+		//printf("pauldebug:m_pUnkplayer->QueryInterface for m_pCCF calling\n");
+		m_pUnkPlayer->QueryInterface(IID_IHXCommonClassFactory,
+				(void**)&m_pCCF);
+		//printf("pauldebug:m_pUnkplayer->QueryInterface for m_pCCF called\n");
+
+		m_pUnkPlayer->AddRef();
+	}
+};
+
+/************************************************************************
+ *  Method:
+ *    Destructor
+ */
+ExampleSiteSupplier::~ExampleSiteSupplier()
+{
+	HX_RELEASE(m_pSiteManager);
+	HX_RELEASE(m_pSite);
+	HX_RELEASE(m_pSiteCapture);
+	HX_RELEASE(m_pCaptureBuffer);
+	HX_RELEASE(m_pCCF);
+	HX_RELEASE(m_pUnkPlayer);
+}
+
+/************************************************************************
+ *  Method:
+ *    IUnknown::QueryInterface
+ */
+	STDMETHODIMP 
+ExampleSiteSupplier::QueryInterface(REFIID riid, void** ppvObj)
+{
+	if (IsEqualIID(riid, IID_IUnknown))
+	{
+		AddRef();
+		*ppvObj = (IUnknown*)(IHXSiteSupplier*)this;
+		return HXR_OK;
+	}
+	else if (IsEqualIID(riid, IID_IHXSiteSupplier))
+	{
+		AddRef();
+		*ppvObj = (IHXSiteSupplier*)this;
+		return HXR_OK;
+	}
+
+	*ppvObj = NULL;
+	return HXR_NOINTERFACE;
+}
+
+/************************************************************************
+ *  Method:
+ *    IUnknown::AddRef
+ */
+	STDMETHODIMP_(ULONG32) 
+ExampleSiteSupplier::AddRef()
+{
+	return InterlockedIncrement(&m_lRefCount);
+}
+
+/************************************************************************
+ *  Method:
+ *    IUnknown::Release
+ */
+	STDMETHODIMP_(ULONG32) 
+ExampleSiteSupplier::Release()
+{
+	if (InterlockedDecrement(&m_lRefCount) > 0)
+	{
+		return m_lRefCount;
+	}
+
+	delete this;
+	return 0;
+}
+
+/************************************************************************
+ *  Method:
+ *    IHXSiteSupplier::SitesNeeded
+ *  Purpose:
+ *    Called to inform the site supplier that a site with a particular
+ *    set of characteristics is needed. If the site supplier can 
+ *    fulfill the request it should call the site manager and add one
+ *    or more new sites.
+ *    Note that the request for sites is associated with a Request ID
+ *    the client core will inform the site supplier when this requested
+ *    site is no longer needed.
+ */
+STDMETHODIMP 
+ExampleSiteSupplier::SitesNeeded
+(
+ UINT32	uRequestID,
+ IHXValues*	pProps
+ )
+{
+	/*
+	 * Don't create a site if the -NULL_RENDER command line option
+	 * was given. - jfarr
+	 */
+	if (GetGlobal()->g_bNullRender)
+	{
+		return (HXR_OK);
+	}
+
+	/*
+	 * If there are no properties, then we can't really create a
+	 * site, because we have no idea what type of site is desired!
+	 */
+	if (!pProps)
+	{
+		return HXR_INVALID_PARAMETER;
+	}
+
+	HRESULT		hres		= HXR_OK;
+	IHXValues*		pSiteProps	= NULL;
+	IHXSiteWindowed*	pSiteWindowed	= NULL;
+	IHXBuffer*		pValue		= NULL;
+	UINT32		style		= 0;
+	IHXSite*		pSite		= NULL;
+
+#if 0
+	// Just let the RMA client core create a windowed site for us.
+	hres = m_pCCF->CreateInstance(CLSID_IHXSiteWindowed,(void**)&pSiteWindowed);
+	if (HXR_OK != hres)
+	{
+		goto exit;
+	}
+#else
+	{
+		*(void **)&pSiteWindowed = (IUnknown*)(IHXSiteWindowed*)(new CHXExSite(GetGlobal()->pMediaPlatform, NULL, 0, m_on_new_frame_cb, m_context));
+		hres = ((IUnknown*)*(void **)&pSiteWindowed)->QueryInterface(IID_IHXSiteWindowed, (void**)&pSiteWindowed);
+		if (HXR_OK != hres)
+		{
+			goto exit;
+		}
+	}
+#endif
+
+	hres = pSiteWindowed->QueryInterface(IID_IHXSite,(void**)&pSite);
+	if (HXR_OK != hres)
+	{
+		goto exit;
+	}
+
+	if( !m_pSite )
+	{
+		m_pSite = pSite;
+		m_pSite->AddRef();
+	}
+
+
+	hres = pSiteWindowed->QueryInterface(IID_IHXValues,(void**)&pSiteProps);
+	if (HXR_OK != hres)
+	{
+		goto exit;
+	}
+
+	/*
+	 * We need to figure out what type of site we are supposed to
+	 * to create. We need to "switch" between site user and site
+	 * properties. So look for the well known site user properties
+	 * that are mapped onto sites...
+	 */
+	hres = pProps->GetPropertyCString("playto",pValue);
+	if (HXR_OK == hres)
+	{
+		pSiteProps->SetPropertyCString("channel",pValue);
+		HX_RELEASE(pValue);
+	}
+	else
+	{
+		hres = pProps->GetPropertyCString("name",pValue);
+		if (HXR_OK == hres)
+		{
+			pSiteProps->SetPropertyCString("LayoutGroup",pValue);
+			HX_RELEASE(pValue);
+		}
+	}
+
+#ifdef _WINDOWS
+	style = WS_OVERLAPPED | WS_VISIBLE | WS_CLIPCHILDREN;
+#endif
+
+	hres = pSiteWindowed->Create(NULL, style);
+	if (HXR_OK != hres)
+	{
+		goto exit;
+	}
+
+	/*
+	 * We need to wait until we have set all the properties before
+	 * we add the site.
+	 */
+	hres = m_pSiteManager->AddSite(pSite);
+	if (HXR_OK != hres)
+	{
+		goto exit;
+	}
+#ifdef _WINDOWS
+	{
+		HXxWindow* pWindow = pSiteWindowed->GetWindow();
+		if (pWindow && pWindow->window) ::SetForegroundWindow( (HWND)(pWindow->window) );
+	}
+#endif
+	m_CreatedSites.SetAt((void*)uRequestID,pSite);
+	pSite->AddRef();
+
+exit:
+
+	HX_RELEASE(pSiteProps);
+	HX_RELEASE(pSiteWindowed);
+	HX_RELEASE(pSite);
+
+	return hres;
+}
+
+/************************************************************************
+ *  Method:
+ *    IHXSiteSupplier::SitesNotNeeded
+ *  Purpose:
+ *    Called to inform the site supplier that all sites from a previos
+ *    site request are no longer needed. If the site supplier had 
+ *    previously created non-persistant sites (like popup windows)
+ *    to fulfill a request for sites it should call the site manager 
+ *    and remove those sites.
+ */
+STDMETHODIMP 
+ExampleSiteSupplier::SitesNotNeeded(UINT32 uRequestID)
+{
+    IHXSite*		pSite = NULL;
+    IHXSiteWindowed*	pSiteWindowed = NULL;
+    void*		pVoid = NULL;
+
+    if (!m_CreatedSites.Lookup((void*)uRequestID,pVoid))
+    {
+	return HXR_INVALID_PARAMETER;
+    }
+    pSite = (IHXSite*)pVoid;
+
+    m_pSiteManager->RemoveSite(pSite);
+
+    // Need to actually do the work on destroying the window
+    // and all that jazz.
+    pSite->QueryInterface(IID_IHXSiteWindowed,(void**)&pSiteWindowed);
+
+    pSiteWindowed->Destroy();
+
+    // ref count = 2
+    pSiteWindowed->Release();
+
+    // ref count = 1; deleted from this object's view!
+    pSite->Release();
+
+    m_CreatedSites.RemoveKey((void*)uRequestID);
+
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *    IHXSiteSupplier::BeginChangeLayout
+ *  Purpose:
+ *    Called to inform the site supplier a layout change has beginning
+ *    it can expect to recieve SitesNeeded() and SitesNotNeeded() calls
+ *    while a layout change is in progress,
+ */
+STDMETHODIMP 
+ExampleSiteSupplier::BeginChangeLayout()
+{
+    return HXR_OK;
+}
+
+/************************************************************************
+ *  Method:
+ *    IHXSiteSupplier::DoneChangeLayout
+ *  Purpose:
+ *    Called to inform the site supplier the layout change has been
+ *    completed.
+ */
+STDMETHODIMP 
+ExampleSiteSupplier::DoneChangeLayout()
+{
+    return HXR_OK;
+}
+
+HX_RESULT
+ExampleSiteSupplier::CaptureImage(CHXString pszFileName, INT32 dWidth, INT32 dHeight)
+{
+    HX_RESULT res=HXR_FAIL;
+
+    // Get the IHXSiteCapture object from the site
+    if (m_pSiteCapture == NULL)
+    {
+	if (m_pSite && m_pSite->QueryInterface(IID_IHXSiteCapture, (void**)&m_pSiteCapture) == HXR_OK)
+	{
+	    m_pSiteCapture->AddRef();
+	}
+    }
+
+    // Create the buffer that will receive the image data
+    if (m_pCaptureBuffer == NULL)
+    {
+    	CreateBufferCCF(m_pCaptureBuffer, m_pCCF);
+	if (!m_pCaptureBuffer)
+	{
+	    return HXR_OUTOFMEMORY;
+	}
+    }
+
+    HXBOOL bCanCapture = FALSE;
+
+    // Check if the site is available to capture an image
+    if (m_pSiteCapture && (res = m_pSiteCapture->CanCapture(bCanCapture)) == HXR_OK && bCanCapture)
+    {
+	HX_RESULT res;
+	HXxSize outputSize;
+	outputSize.cx  = dWidth;
+	outputSize.cy  = dHeight;
+	m_strFileName = pszFileName;
+
+	// Asynchronous call. CaptureDone() will be called with result.
+	res = m_pSiteCapture->Capture((IHXSiteCaptureResponse*)this, m_pCaptureBuffer, &outputSize, CID_RGB32);
+    }
+
+    return res;
+
+}
+
+//
+// IHXSiteCaptureResponse::CaptureDone
+//
+// Called when the site has captured the next frame.
+// bmiOutputFormat points to image format description which
+// is valid until the completion of CaptureDone.
+// bmiOutputFormat can be different for every capture.
+// pCaptureBuffer holds the image if supplied in
+// Capture() method.  pCaptureBuffer is automatically
+// resized if it has insufficient size to hold the image
+// data.
+//
+// status may be:
+//   HXR_FAIL  -- No capture was done. General Error. All data is invalid.
+//   HXR_OK    -- Capture was done. Both variables are valid.
+STDMETHODIMP
+ExampleSiteSupplier::CaptureDone(REF(HX_RESULT) status,
+			REF(HXBitmapInfoHeader) bmiOutputFormat,
+			REF(IHXBuffer*) pCaptureBuffer)
+{
+    if (status == HXR_OK)
+    {
+#if defined(HELIX_FEATURE_PNG)
+	// Convert capture buffer into PNG
+	IHXBuffer* pConvertedBuffer=NULL;
+	HX_RESULT res = HXR_OK;
+	res = PXPNGEncode::EncodeToPNGBuffer(pCaptureBuffer, &bmiOutputFormat, m_pCCF, pConvertedBuffer);
+	if (res == HXR_OK && !m_strFileName.IsEmpty())
+	{
+	    CHXString strTail = m_strFileName.Right(4);
+	    if (strTail.CompareNoCase(".png") != 0)
+	    {
+		m_strFileName += ".png";
+	    }
+
+	    FILE* fp = fopen(m_strFileName, "wb");
+	    if (fp)
+	    {
+	        fwrite(pConvertedBuffer->GetBuffer(), 1, pConvertedBuffer->GetSize(), fp);
+	        fclose(fp);
+		STDOUT("Captured image to PNG file: %s\n", (const char*)m_strFileName);
+		STDOUT("File size: %ld\n", pConvertedBuffer->GetSize());
+	    }
+	    HX_RELEASE(pConvertedBuffer);
+	}
+#endif //  HELIX_FEATURE_PNG
+    }
+
+    return status;
+}
Index: helix-libs/clientapps/clutter/exsitsup.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exsitsup.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,154 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#ifndef _EXSITSUP_H_
+#define _EXSITSUP_H_
+
+#include "fivemmap.h"
+#include "player.h"
+
+/****************************************************************************
+ * 
+ *  Class:
+ *
+ *	ExampleSiteSupplier
+ *
+ *  Purpose:
+ *
+ *	Implementation for ragui's IHXSiteSupplier
+ *
+ */
+class ExampleSiteSupplier : 
+	public IHXSiteSupplier
+	, public IHXSiteCaptureResponse
+{
+private:
+    LONG32		    m_lRefCount;
+    IHXSiteManager*	    m_pSiteManager;
+    IHXSite*		    m_pSite;
+    IHXSiteCapture*	    m_pSiteCapture;
+    IHXBuffer*		    m_pCaptureBuffer;
+    IHXCommonClassFactory*  m_pCCF;
+    IUnknown*		    m_pUnkPlayer;
+    FiveMinuteMap	    m_CreatedSites;
+    CHXString		    m_strFileName;
+    on_new_frame_cb_t   m_on_new_frame_cb;
+    void *              m_context;
+
+    ~ExampleSiteSupplier();
+
+public:
+    ExampleSiteSupplier(IUnknown* pUnkPlayer, on_new_frame_cb_t new_frame_cb = NULL, void *context = NULL);
+    
+    /*
+     * IUnknown methods
+     */
+    STDMETHOD(QueryInterface)	(THIS_
+				REFIID riid,
+				void** ppvObj);
+
+    STDMETHOD_(ULONG32,AddRef)	(THIS);
+
+    STDMETHOD_(ULONG32,Release)	(THIS);
+
+    /*
+     * IHXSiteSupplier methods
+     */
+
+    /************************************************************************
+     *	Method:
+     *	    IHXSiteSupplier::SitesNeeded
+     *	Purpose:
+     *	  Called to inform the site supplier that a site with a particular
+     *	  set of characteristics is needed. If the site supplier can 
+     *	  fulfill the request it should call the site manager and add one
+     *	  or more new sites.
+     *    Note that the request for sites is associated with a Request ID
+     *    the client core will inform the site supplier when this requested
+     *    site is no longer needed.
+     */
+    STDMETHOD(SitesNeeded)	(THIS_
+				UINT32			uRequestID,
+				IHXValues*		pSiteProps);
+
+    /************************************************************************
+     *  Method:
+     *    IHXSiteSupplier::SitesNotNeeded
+     *  Purpose:
+     *    Called to inform the site supplier that all sites from a previos
+     *	  site request are no longer needed. If the site supplier had 
+     *	  previously created non-persistant sites (like popup windows)
+     *    to fulfill a request for sites it should call the site manager 
+     *    and remove those sites.
+     */
+    STDMETHOD(SitesNotNeeded)
+				(THIS_
+				UINT32			uRequestID);
+
+
+    /************************************************************************
+     *  Method:
+     *    IHXSiteSupplier::BeginChangeLayout
+     *  Purpose:
+     *    Called to inform the site supplier a layout change has beginning
+     *	  it can expect to recieve SitesNeeded() and SitesNotNeeded() calls
+     *	  while a layout change is in progress,
+     */
+    STDMETHOD(BeginChangeLayout) (THIS);
+
+    /************************************************************************
+     *  Method:
+     *    IHXSiteSupplier::DoneChangeLayout
+     *  Purpose:
+     *    Called to inform the site supplier the layout change has been
+     *	  completed.
+     */
+    STDMETHOD(DoneChangeLayout) (THIS);
+
+    /*
+     * IHXSiteCaptureResponse
+     */
+    STDMETHOD(CaptureDone)	(THIS_
+				REF(HX_RESULT) 		 status,
+                        	REF(HXBitmapInfoHeader)  bmiOutputFormat,
+                        	REF(IHXBuffer*)          pImageDataBuffer
+				);
+
+    HX_RESULT CaptureImage(CHXString pFileName, INT32 dWidth, INT32 dHeight);
+
+};
+
+#endif // _EXSITSUP_H_
+
Index: helix-libs/clientapps/clutter/exstateadvsnk.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exstateadvsnk.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,229 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#include <stdio.h>
+
+#include "hxtypes.h"
+
+#include "hxcom.h"
+#include "hxcomm.h"
+#include "hxmon.h"
+#include "hxcore.h"
+#include "hxengin.h"
+#include "hxclsnk.h"
+#include "hxgroup.h"
+#include "hxstrutl.h"
+#include "exstateadvsnk.h"
+#include "hxstring.h"
+#include "hxprefs.h"
+#include "excontxt.h"
+
+#include "print.h"
+
+#include "globals.h"
+#include "player.h"
+
+struct _stGlobals*& GetGlobal(); //in main.cpp
+
+#ifdef __TCS__
+extern unsigned long   gStreamTime;
+ 
+static int		iOpened = 0;
+
+
+#if	defined(__cplusplus)
+extern	"C"	{
+#endif	/* defined(__cplusplus) */
+
+typedef enum hookBuffering {
+	eContacting = 0,
+	eConnecting = 1,
+	eBuffering = 2,
+	ePlaying = 3
+}hookBuffering;
+
+void hookRealAudio_Buffering(hookBuffering connectState, int pct);
+
+void hookRealAudio_PlayPosition(unsigned long current,unsigned long duration);
+
+typedef enum hookState {
+	ePlay = 0,
+	ePause = 1,
+	eStop = 2,
+	eResume = 3,
+	eComplete				// Clip is done playing
+}hookState;
+void hookRealAudio_State(hookState newState);
+
+
+#if	defined(__cplusplus)
+}
+#endif	/* defined(__cplusplus) */
+
+#endif // __TCS__
+
+void PrintBuffer(const char* pszName,const unsigned char* pbBuf, unsigned int dwBytes);
+
+ExampleClientStateAdviceSink::ExampleClientStateAdviceSink(IUnknown* pUnknown, LONG32 lClientIndex, on_state_change_cb_t on_state_change_cb, void *context)
+    : m_lRefCount (0)
+    , m_lClientIndex (lClientIndex)
+    , m_pUnknown (NULL)
+    , m_State (HX_CLIENT_STATE_READY)
+    , m_state_change_cb(on_state_change_cb)
+    , m_context(context)
+{
+    if (pUnknown)
+    {
+        m_pUnknown = pUnknown;
+        m_pUnknown->AddRef();
+
+        IHXPlayer* pPlayer;
+        IHXClientStateAdviseSinkControl *pStateControl;
+        if(HXR_OK == m_pUnknown->QueryInterface(IID_IHXPlayer,
+                    (void**)&pPlayer))
+        {
+            m_pPlayer = pPlayer;
+
+
+        }
+
+        if (HXR_OK == m_pUnknown->QueryInterface(IID_IHXClientStateAdviseSinkControl, (void **)&pStateControl))
+        {
+            pStateControl->AddClientStateAdviseSink(this);
+        }
+    }
+
+#ifdef __TCS__
+    bEnableAdviceSink = TRUE;
+    iOpened = 0;
+#endif 
+}
+
+ExampleClientStateAdviceSink::~ExampleClientStateAdviceSink(void)
+{
+
+    if (m_pPlayer)
+    {
+	m_pPlayer->Release();
+	m_pPlayer = NULL;
+    }
+    if (m_pUnknown)
+    {
+	m_pUnknown->Release();
+	m_pUnknown = NULL;
+    }
+}
+
+
+// *** IUnknown methods ***
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::QueryInterface
+//  Purpose:
+//	Implement this to export the interfaces supported by your 
+//	object.
+//
+STDMETHODIMP ExampleClientStateAdviceSink::QueryInterface(REFIID riid, void** ppvObj)
+{
+    if (IsEqualIID(riid, IID_IUnknown))
+    {
+	AddRef();
+	*ppvObj = (IUnknown*)(IHXClientStateAdviseSink *)this;
+	return HXR_OK;
+    }
+    else if (IsEqualIID(riid, IID_IHXClientStateAdviseSink))
+    {
+	AddRef();
+	*ppvObj = (IHXClientStateAdviseSink*)this;
+	return HXR_OK;
+    }
+
+    *ppvObj = NULL;
+    return HXR_NOINTERFACE;
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::AddRef
+//  Purpose:
+//	Everyone usually implements this the same... feel free to use
+//	this implementation.
+//
+STDMETHODIMP_(ULONG32) ExampleClientStateAdviceSink::AddRef()
+{
+    return InterlockedIncrement(&m_lRefCount);
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Method:
+//	IUnknown::Release
+//  Purpose:
+//	Everyone usually implements this the same... feel free to use
+//	this implementation.
+//
+STDMETHODIMP_(ULONG32) ExampleClientStateAdviceSink::Release()
+{
+    if (InterlockedDecrement(&m_lRefCount) > 0)
+    {
+        return m_lRefCount;
+    }
+
+    delete this;
+    return 0;
+}
+
+
+/************************************************************************
+ *      Method:
+ *          IHXClientStateAdviseSink::OnStateChange
+ *      Purpose:
+ *          Called to advise the client state has changed state
+ */
+STDMETHODIMP ExampleClientStateAdviceSink::OnStateChange(UINT16 uOldState, UINT16 uNewState)
+{
+    if (m_state_change_cb)
+        m_state_change_cb(uOldState, uNewState, m_context);
+
+    m_State = uNewState;
+    return HXR_OK;
+}
+
+EHXClientState ExampleClientStateAdviceSink::GetState()
+{
+    return m_State;
+}
+
+
Index: helix-libs/clientapps/clutter/exstateadvsnk.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/exstateadvsnk.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,108 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#ifndef _EXAMPLE_CLIENT_STATE_ADVISE_SNK_H_
+#define _EXAMPLE_CLIENT_STATE_ADVISE_SNK_H_
+
+#include "player.h"
+
+struct IHXClientStateAdviseSink;
+struct IHXGroupSink;
+struct IUnknown;
+struct IHXRegistry;
+struct IHXScheduler;
+struct IHXCallback;
+struct IHXPlayer;
+struct IHXGroup;
+
+class ExampleClientStateAdviceSink : public IHXClientStateAdviseSink
+{
+    private:
+        LONG32          m_lRefCount;
+        LONG32          m_lClientIndex;
+
+        IUnknown*       m_pUnknown;
+
+        UINT32          m_ulStartTime;
+        UINT32          m_ulStopTime;
+
+        UINT32    m_lCurrentBandwidth;
+        UINT32    m_lAverageBandwidth;
+        HXBOOL      m_bOnStop;
+
+        HXBOOL      m_bWaitForTrackStart;
+
+        on_state_change_cb_t m_state_change_cb;
+        void *m_context;
+        EHXClientState m_State;
+
+        // IHXCallback
+        IHXPlayer*		m_pPlayer;
+        ULONG32         m_hCallback;
+        ~ExampleClientStateAdviceSink();
+
+
+    public:
+
+        ExampleClientStateAdviceSink(IUnknown* /*IN*/ pUnknown, LONG32 /*IN*/ lClientIndex, on_state_change_cb_t on_state_change_cb = NULL, void *context = NULL);
+
+        /*
+         *  IUnknown methods
+         */
+        STDMETHOD(QueryInterface) (THIS_
+                REFIID riid,
+                void** ppvObj);
+
+        STDMETHOD_(ULONG32,AddRef) (THIS);
+
+        STDMETHOD_(ULONG32,Release) (THIS);
+
+        /***********************************************************************
+         *  Method:
+         *     IHXClientStateAdviseSink::OnStateChange
+         *    Purpose:
+         *       Called by client engine to inform the client that the state has changed.
+         *      States are defined in the enum EHXClientState, defined in this file.
+         *
+         */
+        STDMETHOD(OnStateChange)    (THIS_
+                UINT16 uOldState,
+                UINT16 uNewState
+                ) ;
+
+        EHXClientState GetState();
+};
+
+#endif /* _EXAMPLECLSNK_ */
Index: helix-libs/clientapps/clutter/fivemmap.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/fivemmap.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,175 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#include <string.h>
+#include "hxtypes.h"
+#include "fivemmap.h"
+
+void* FiveMinuteMap::GetFirstValue()
+{
+    m_nCursor = 0;
+
+    if (m_nMapSize)
+    {
+       return m_pValueArray[m_nCursor];
+    }
+    else
+    {
+       return NULL;
+    }
+}
+
+void* FiveMinuteMap::GetNextValue()
+{
+    m_nCursor++;
+
+    if (m_nCursor < m_nMapSize)
+    {
+       return m_pValueArray[m_nCursor];
+    }
+    else
+    {
+       return NULL;
+    }
+}
+
+HXBOOL FiveMinuteMap::Lookup(void* Key, void*& Value) const
+{
+    HXBOOL bFound = FALSE;
+    int nIndex = 0;
+
+    // If Key is alrady in the list, replace value
+    for (; nIndex < m_nMapSize; nIndex++)
+    {
+	if (m_pKeyArray[nIndex] == Key)
+	{
+	    Value = m_pValueArray[nIndex];
+	    bFound = TRUE;
+	    goto exit;
+	}
+    }
+
+exit:
+    return bFound;    
+}
+
+void FiveMinuteMap::RemoveKey(void* Key)
+{
+    HXBOOL bFound = FALSE;
+    int nIndex = 0;
+
+    // If Key is alrady in the list, replace value
+    for (; nIndex < m_nMapSize; nIndex++)
+    {
+	if (m_pKeyArray[nIndex] == Key)
+	{
+	    if (nIndex < (m_nMapSize-1))
+	    {
+		memmove(&(m_pKeyArray[nIndex]),&(m_pKeyArray[nIndex+1]),sizeof(void*)*(m_nMapSize-(nIndex+1)));
+		memmove(&(m_pValueArray[nIndex]),&(m_pValueArray[nIndex+1]),sizeof(void*)*(m_nMapSize-(nIndex+1)));
+	    }
+	    m_nMapSize--;
+	    goto exit;
+	}
+    }
+
+exit:
+    (NULL); // We're done!
+}
+
+void FiveMinuteMap::RemoveValue(void* Value)
+{
+    HXBOOL bFound = FALSE;
+    int nIndex = 0;
+
+    // If Value is alrady in the list, replace value
+    for (; nIndex < m_nMapSize; nIndex++)
+    {
+	if (m_pValueArray[nIndex] == Value)
+	{
+	    if (nIndex < (m_nMapSize-1))
+	    {
+		memmove(&(m_pKeyArray[nIndex]),&(m_pKeyArray[nIndex+1]),sizeof(void*)*(m_nMapSize-(nIndex+1)));
+		memmove(&(m_pValueArray[nIndex]),&(m_pValueArray[nIndex+1]),sizeof(void*)*(m_nMapSize-(nIndex+1)));
+	    }
+	    m_nMapSize--;
+	    goto exit;
+	}
+    }
+
+exit:
+    (NULL); // We're done!
+}
+
+
+void FiveMinuteMap::SetAt(void* Key, void* Value)
+{
+    int nIndex = 0;
+
+    // If Key is alrady in the list, replace value
+    for (; nIndex < m_nMapSize; nIndex++)
+    {
+	if (m_pKeyArray[nIndex] == Key)
+	{
+	    m_pValueArray[nIndex] = Value;
+	    goto exit;
+	}
+    }
+
+    // If we have room, add it to the end!
+    if (m_nAllocSize == m_nMapSize)
+    {
+	m_nAllocSize += AllocationSize;
+	void** pNewKeys   = new void*[m_nAllocSize];
+	void** pNewValues = new void*[m_nAllocSize];
+
+	memcpy(pNewKeys,m_pKeyArray,sizeof(void*)*m_nMapSize); /* Flawfinder: ignore */
+	memcpy(pNewValues,m_pValueArray,sizeof(void*)*m_nMapSize); /* Flawfinder: ignore */
+
+	delete [] m_pKeyArray;
+	delete [] m_pValueArray;
+
+	m_pKeyArray = pNewKeys;
+	m_pValueArray = pNewValues;
+    }
+
+    m_pKeyArray[m_nMapSize] = Key;
+    m_pValueArray[m_nMapSize] = Value;
+    m_nMapSize++;
+
+exit:
+    (NULL); // We're done!
+}
+
Index: helix-libs/clientapps/clutter/fivemmap.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/fivemmap.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,79 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#ifndef _FIVEMMAP_H_
+#define _FIVEMMAP_H_
+
+#ifndef _HXTYPES_H_
+#error FiveMinuteMap assumes pntypes.h.
+#endif
+
+class FiveMinuteMap
+{
+    const int AllocationSize;
+
+    void**  m_pKeyArray;
+    void**  m_pValueArray;
+    int	    m_nMapSize;
+    int	    m_nAllocSize;
+    int     m_nCursor;
+public:
+    FiveMinuteMap()
+	: m_pKeyArray(NULL)
+	, m_pValueArray(NULL)
+	, m_nMapSize(0)
+	, m_nAllocSize(0)
+        , m_nCursor(0)
+	, AllocationSize(10)
+	{};
+
+    ~FiveMinuteMap()
+	{
+	    delete [] m_pKeyArray;
+	    delete [] m_pValueArray;
+	};
+
+    int  GetCount() {return m_nMapSize;}
+
+    void* GetFirstValue();
+    void* GetNextValue();
+
+    HXBOOL Lookup(void* Key, void*& Value) const;
+    void RemoveKey(void* Key);
+    void RemoveValue(void* Value);
+    void SetAt(void* Key, void* Value);
+};
+
+#endif /* _FIVEMMAP_H_ */
Index: helix-libs/clientapps/clutter/globals.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/globals.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,150 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+/****************************************************************************
+ * 
+ *  Test Client:
+ *  
+ *
+ *  This is an test client running on Windows, Mac, and Unix without a GUI.
+ *
+ */ 
+
+#ifndef _SPLAY_GLOBALS_H
+#define _SPLAY_GLOBALS_H
+
+#include "dllacces.h"
+#include "dllpath.h"
+#include "hxengin.h"
+#include "hxplayvelocity.h"
+#include "hxcore.h"
+#include "ihxmedpltfm.h"
+#include "excontxt.h"
+#include "preflist.h"
+
+#define HX_COMMAND_BUFFER_SIZE 256
+#define HX_MAX_NUM_MULTI_SEEKS 10
+struct _stGlobals
+{
+    _stGlobals()
+        : g_pDLLAccess(NULL),
+	  g_nPlayers(0),
+	  m_fpHXMediaPlatformOpen(NULL),
+	  m_fpHXCreateMediaPlatform(NULL),
+	  m_fpHXMediaPlatformClose(NULL),
+	  m_fpCreateEngine(NULL),
+	  m_fpCloseEngine(NULL),
+	  m_fpSetDLLAccessPath(NULL),
+	  bEnableAdviceSink(FALSE),
+          bEnableVerboseMode(FALSE),
+          g_bEnableSlowStart(TRUE),
+          g_bOnBeginOccurred(FALSE),
+          g_pszUsername( NULL),
+          g_pszPassword(NULL),
+          g_pszGUIDFile(NULL),
+          g_pszGUIDList(NULL),
+          g_Error(HXR_OK),
+	  g_ulNumSecondsPlayed(0),
+	  pMediaPlatform(NULL),
+          g_pIHXKicker(NULL),
+          bUseLegacyAPIs(FALSE),
+	  pEngine(NULL),
+          g_pQuickSeek(NULL),
+          g_bNullRender(FALSE),
+          g_bUserStop(FALSE),
+          g_bInitVelocity(FALSE),
+          g_bABD(FALSE),
+          g_pVelocityCaps(NULL),
+          g_ulNumMultiSeeks(0),
+          g_ulMultiSeekIndex(0),
+          g_bMultiSeek(FALSE),
+    	  g_uThreadIDForKicker(-1)
+    {
+        memset(g_szCommandBuffer, 0, HX_COMMAND_BUFFER_SIZE);
+        memset(g_szPriorCommandBuffer, 0, HX_COMMAND_BUFFER_SIZE);
+        memset(g_Players, 0, sizeof(g_Players));
+        memset(g_pszURLs, 0, sizeof(g_pszURLs));
+        memset(g_pClientContexts, 0, sizeof(g_pClientContexts));
+    }
+
+    #define MAX_NUM_PLAYERS     256
+    IHXPlayer*              g_Players[MAX_NUM_PLAYERS];
+    char                    *g_pszURLs[MAX_NUM_PLAYERS];
+    ExampleClientContext    *g_pClientContexts[MAX_NUM_PLAYERS];
+    int                      g_nPlayers;
+    DLLAccessPath            g_statclnt;
+    DLLAccess*              g_pDLLAccess;
+    CHXPrefList             g_prefList;
+
+    FPHXMEDIAPLATFORMOPEN    m_fpHXMediaPlatformOpen;
+    FPHXCREATEMEDIAPLATFORM  m_fpHXCreateMediaPlatform;
+    FPHXMEDIAPLATFORMCLOSE   m_fpHXMediaPlatformClose;
+
+    FPRMCREATEENGINE         m_fpCreateEngine;
+    FPRMCLOSEENGINE          m_fpCloseEngine;
+    FPRMSETDLLACCESSPATH     m_fpSetDLLAccessPath;
+
+    HXBOOL                   bEnableAdviceSink;
+    HXBOOL                   bEnableVerboseMode;
+    HXBOOL                   g_bEnableSlowStart;
+    HXBOOL                   g_bOnBeginOccurred;
+    char*                    g_pszUsername;
+    char*                    g_pszPassword;
+    char*                    g_pszGUIDFile;
+    char*                    g_pszGUIDList;
+    HX_RESULT                g_Error;
+    UINT32                   g_ulNumSecondsPlayed;
+    IHXMediaPlatform*	     pMediaPlatform;
+    IHXMediaPlatformKicker*  g_pIHXKicker;
+    UINT32	             g_uThreadIDForKicker;
+    pthread_t	             g_pThreadKickmanId;
+    HXBOOL                   bUseLegacyAPIs;
+    IHXClientEngine*         pEngine;
+    IHXQuickSeek*            g_pQuickSeek;
+    HXBOOL                   g_bNullRender;
+    HXBOOL                   g_bUserStop;
+    HXBOOL                   g_bInitVelocity;
+    HXBOOL                   g_bABD;
+    IHXPlaybackVelocityCaps* g_pVelocityCaps;
+    HXBOOL                   g_bMultiSeek;
+    UINT32                   g_ulMultiSeekTime[HX_MAX_NUM_MULTI_SEEKS];
+    UINT32                   g_ulNumMultiSeeks;
+    UINT32                   g_ulMultiSeekIndex;
+    char                     g_szCommandBuffer[HX_COMMAND_BUFFER_SIZE];
+    char                     g_szPriorCommandBuffer[HX_COMMAND_BUFFER_SIZE];
+};
+
+
+#endif // _SPLAY_GLOBALS_H
Index: helix-libs/clientapps/clutter/iids.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/iids.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,50 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+// define all guids here once...
+#define INITGUID
+#define NCIHACK
+#include "hxtypes.h"
+#include "hxcom.h"
+#include "hxiids.h"
+#include "hxpiids.h"
+#if defined _WINDOWS
+#if defined (HELIX_FEATURE_DIRECT_SOUND)
+#include "dsound.h"
+#endif /* HELIX_FEATURE_DIRECT_SOUND */
+#if defined (HELIX_FEATURE_VIDEO) && !defined(_WINCE)
+#include "ddraw.h"
+#endif /* HELIX_FEATURE_VIDEO */
+#endif
Index: helix-libs/clientapps/clutter/linux2.pcf
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/linux2.pcf	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,42 @@
+# 
+# ***** BEGIN LICENSE BLOCK ***** 
+# Version: RCSL 1.0/RPSL 1.0 
+#  
+# Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+#      
+# The contents of this file, and the files included with this file, are 
+# subject to the current version of the RealNetworks Public Source License 
+# Version 1.0 (the "RPSL") available at 
+# http://www.helixcommunity.org/content/rpsl unless you have licensed 
+# the file under the RealNetworks Community Source License Version 1.0 
+# (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+# in which case the RCSL will apply. You may also obtain the license terms 
+# directly from RealNetworks.  You may not use this file except in 
+# compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+# applicable to this file, the RCSL.  Please see the applicable RPSL or 
+# RCSL for the rights, obligations and limitations governing use of the 
+# contents of the file.  
+#  
+# This file is part of the Helix DNA Technology. RealNetworks is the 
+# developer of the Original Code and owns the copyrights in the portions 
+# it created. 
+#  
+# This file, and the files included with this file, is distributed and made 
+# available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+# EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+# INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+# FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+# 
+# Technology Compatibility Kit Test Suite(s) Location: 
+#    http://www.helixcommunity.org/content/tck 
+# 
+# Contributor(s): 
+#  
+# ***** END LICENSE BLOCK ***** 
+# 
+
+project.AddSystemLibraries("dl", "m", "pthread")
+
+if (project.IsDefined("HELIX_FEATURE_VIDEO") and
+    project.IsDefined("USE_XWINDOWS")):
+	project.AddSystemLibraries("X11")
Index: helix-libs/clientapps/clutter/player.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/player.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,1057 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: RCSL 1.0/RPSL 1.0
+ *
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved.
+ *
+ * The contents of this file, and the files included with this file, are
+ * subject to the current version of the RealNetworks Public Source License
+ * Version 1.0 (the "RPSL") available at
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed
+ * the file under the RealNetworks Community Source License Version 1.0
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl,
+ * in which case the RCSL will apply. You may also obtain the license terms
+ * directly from RealNetworks.  You may not use this file except in
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or
+ * RCSL for the rights, obligations and limitations governing use of the
+ * contents of the file.
+ *
+ * This file is part of the Helix DNA Technology. RealNetworks is the
+ * developer of the Original Code and owns the copyrights in the portions
+ * it created.
+ *
+ * This file, and the files included with this file, is distributed and made
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ *
+ * Technology Compatibility Kit Test Suite(s) Location:
+ *    http://www.helixcommunity.org/content/tck
+ *
+ * Contributor(s):
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/****************************************************************************
+ *
+ *  Test Client:
+ *
+ *
+ *  This is an test client running on Windows, Mac, and Unix without a GUI.
+ *
+ */
+#include "hxtypes.h"
+
+#include <stdlib.h>
+
+#include "hlxclib/time.h"
+#include "ihxmedpltfm.h"
+#include "hxwintyp.h"
+#include "hxcom.h"
+#include "ihxpckts.h"
+#include "hxcomm.h"
+#include "hxmon.h"
+#include "hxfiles.h"
+#include "hxengin.h"
+#include "hxcore.h"
+#include "hxclsnk.h"
+#include "hxgroup.h"
+#include "hxerror.h"
+#include "hxauth.h"
+#include "hxwin.h"
+#include "hxprefs.h"
+#include "hxtbuf.h"
+#include "fivemmap.h"
+#include "dllacces.h"
+#include "hxausvc.h"
+#include "hxstrutl.h"
+#include "hxgroup.h"
+#include "hxwin.h"
+#include "hxtick.h"
+#include "hxbuffer.h"
+#include "hxplayvelocity.h"
+#include "pckunpck.h"  //  For CreateAndSetBufferCCF()
+#include "hxvctrl.h"
+#include "hxbsrc.h"
+#include "excallback.h"
+#include "pthread.h"
+
+#if defined(HELIX_FEATURE_PRESENTATION_FEATURE_SELECTION)
+#include "hxpfs.h"
+#endif //  HELIX_FEATURE_PRESENTATION_FEATURE_SELECTION.
+
+#if defined(HELIX_FEATURE_PREFERENCES)
+#include "preflist.h"
+#endif /* #if defined(HELIX_FEATURE_PREFERENCES) */
+#include "exadvsnk.h"
+#include "exerror.h"
+#include "exsitsup.h"
+#include "exaumgr.h"
+#if defined(_WIN32)
+#include "exabd.h"
+#endif
+#include "excontxt.h"
+#include "print.h"
+#if defined(USE_XWINDOWS)
+#include <X11/Xlib.h>
+#endif
+#if defined (_UNIX)
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <termios.h>
+#endif
+#if defined(_WINDOWS)
+#include <conio.h>
+#endif
+
+#ifdef __TCS__
+#include <unistd.h>
+#if defined(__cplusplus)
+extern      "C"     {
+#endif      /* defined(__cplusplus) */
+    extern      unsigned long  tmosTimSleep(unsigned long ticks);
+    unsigned long       gForcePlayerToStop = 0;
+#if defined(__cplusplus)
+}
+#endif      /* defined(__cplusplus) */
+#endif
+
+#if defined (_MACINTOSH) || defined (_MAC_UNIX)
+bool gMacPlayerIsDone = false;
+#endif
+
+
+#if defined _VXWORKS
+#include "sys/times.h"
+#include "string.h"
+#include "hxtime.h"
+#endif
+
+#if defined(_MACINTOSH)
+#ifndef _MAC_MACHO
+#include <sioux.h>
+#include <console.h>
+#endif
+#endif
+
+#include "dllpath.h"
+
+#ifdef _SYMBIAN
+#include <e32svr.h>
+#include "platform/symbian/symbian_event_hndlr.h"
+#endif
+
+ENABLE_DLLACCESS_PATHS(g_SPlayAccessPath);
+
+// typedef for SetDLLAccessPath
+
+
+#include "thrdutil.h"
+
+#if defined(_AIX)
+#include <strings.h>
+#endif
+
+#if defined _DEBUG || defined DEBUG
+#include "debug.h"
+#endif
+
+#ifndef MAX_PATH
+#define MAX_PATH    256
+#endif //!MAX_PATH
+
+#if defined(HELIX_CONFIG_NOSTATICS)
+# include "globals/hxglobals.h"
+#endif
+
+#define MAX_NUM_URLS 10
+
+#include "globals.h" //for global struct.
+
+#include "player.h"
+
+#if defined(_WINDOWS) && defined(_STATICALLY_LINKED)
+HINSTANCE g_hInstance = NULL;
+#endif
+
+struct _stGlobals*& GetGlobal()
+{
+#if defined(HELIX_CONFIG_NOSTATICS)
+    static const struct _stGlobals* const _g_pstGlobals = NULL;
+    struct _stGlobals*& g_pstGlobals = (struct _stGlobals*&)HXGlobalPtr::Get(&_g_pstGlobals);
+#else
+    static struct _stGlobals* g_pstGlobals = NULL;
+#endif
+    if( g_pstGlobals == NULL )
+    {
+        g_pstGlobals = new struct _stGlobals();
+    }
+    return g_pstGlobals;
+
+}
+
+
+// Constants
+const int DEFAULT_TIME_DELTA = 2000;
+const int DEFAULT_STOP_TIME  = -1;
+const int SLEEP_TIME         = 5;
+const int GUID_LEN           = 64;
+
+// Function prototypes
+void  PrintUsage(const char* pszAppName);
+HXBOOL  AllPlayersDone(int nNumPlayers, IHXPlayer** ppPlayers);
+void  StopAllPlayers(int nNumPlayers, IHXPlayer** ppPlayers);
+HXBOOL  ReadGUIDFile();
+char* GetAppName(char* pszArgv0);
+
+#ifdef __TCS__
+#if defined(__cplusplus)
+extern      "C"     {
+#endif      /* defined(__cplusplus) */
+
+    extern      void    _alloc_stats(int verbose);
+#if defined(__cplusplus)
+}
+#endif      /* defined(__cplusplus) */
+
+static  IHXPlayer** g_Players;
+static  int         g_nPlayers = 0;
+static  long        evtCount = 0;
+static  long        evtFullCount = 0;
+#endif
+
+
+
+#if defined(HELIX_FEATURE_PRESENTATION_FEATURE_SELECTION)
+HX_RESULT
+DumpPFdata(IHXPresentationFeatureManager* pPFMgr,
+           const char* pszPFName)
+{
+    HX_RESULT hxr = HXR_OK;
+
+    IHXBuffer* pFeatureCurrentSetting = NULL;
+    IHXValues* pFeatureOptions = NULL;
+
+    if (!pPFMgr  ||  !pszPFName)
+    {
+        hxr = HXR_INVALID_PARAMETER;
+    }
+    else
+    {
+        //  List all the options for this PF:
+        HX_RESULT hxr = pPFMgr->GetPresentationFeature(
+                pszPFName,
+                pFeatureCurrentSetting,
+                pFeatureOptions);
+
+        if (FAILED(hxr))
+        {
+            //  PF doesn't exist!
+            STDOUT("\t%s - No such presentation feature\n\n", pszPFName);
+        }
+        else
+        {
+            //  Now, go through pFeatureOptions and display
+            // them and their "is-selectable"-flag values:
+            const char* pszPFOptionName = NULL;
+            const char* pszPFCurSetting = pFeatureCurrentSetting?
+                    (const char*)pFeatureCurrentSetting->GetBuffer() : NULL;
+            UINT32 bPFOptionIsSelectableFlag = FALSE;
+            IHXBuffer* pPFOptionIsSelectableFlag = NULL;
+
+            HX_ASSERT(pszPFCurSetting);
+            STDOUT("\t%s\t(Current setting == \"%s\")\n", pszPFName, pszPFCurSetting?
+                    pszPFCurSetting : "<ERROR: THIS PF HAS NO CURRENT SETTING!>");
+            
+            if (!pFeatureOptions) //  NULL is OK; that means freeform (open-ended):
+            {
+                STDOUT("\t\t(%s's options are freeform, i.e., open-ended)\n",
+                        pszPFName);
+            }
+            else //  List all the options and their flags:
+            {
+                if (HXR_OK == pFeatureOptions->GetFirstPropertyCString(pszPFOptionName,
+                        pPFOptionIsSelectableFlag)  &&  *pszPFOptionName)
+                {
+                    do
+                    {
+                        const UCHAR* pIsSelFlag = pPFOptionIsSelectableFlag->GetBuffer();
+                        if (pIsSelFlag  &&  *pIsSelFlag)
+                        {
+                            //  Anything but '0' (zero) is treated as '1' (is selectable):
+                            bPFOptionIsSelectableFlag = (HXBOOL)('0' != *pIsSelFlag  &&
+                                    '\0' == *(pIsSelFlag+1));
+                        }
+                        else
+                        {
+                            //  Set the error, but we'll go ahead and treat it as '0':
+                            hxr = HXR_INVALID_PARAMETER;
+                            bPFOptionIsSelectableFlag = FALSE;
+                        }
+
+                        STDOUT("\t\t%s\t\tIs selectable: %s\n",
+                                pszPFOptionName, bPFOptionIsSelectableFlag? "yes":"no");
+                        //  Release it to get the next PF:
+                        HX_RELEASE(pPFOptionIsSelectableFlag);
+                    } while (HXR_OK == pFeatureOptions->GetNextPropertyCString(
+                                    pszPFOptionName, pPFOptionIsSelectableFlag));
+                }
+            }
+
+            HX_RELEASE(pPFOptionIsSelectableFlag);
+        }
+    }
+
+    HX_RELEASE(pFeatureCurrentSetting);
+    HX_RELEASE(pFeatureOptions);
+
+    return hxr;
+}
+#endif //  HELIX_FEATURE_PRESENTATION_FEATURE_SELECTION.
+
+
+char* RemoveWrappingQuotes(char* str)
+{
+    int len = strlen(str);
+    if (len > 0)
+    {
+        if (str[len-1] == '"') str[--len] = 0;
+        if (str[0] == '"') { int i = 0; do { str[i++] = str[i+1]; } while(--len); }
+    }
+    return str;
+}
+
+void *kickman(void *dummy)
+{
+	while(1) {
+		UINT32 sleepTime = 0;
+		IHXMediaPlatformKicker* pKicker = GetGlobal()->g_pIHXKicker;
+		if( pKicker )
+		{
+			pKicker->Kick(GetGlobal()->g_uThreadIDForKicker, &sleepTime);
+		}
+		usleep(sleepTime);
+	}
+}
+
+PLAYER_API int init_main( )
+{
+#if defined(_WIN32) && !defined(WIN32_PLATFORM_PSPC)
+    setvbuf(stdout, NULL, _IONBF, 0);
+#endif /* defined(_WIN32) && !defined(WIN32_PLATFORM_PSPC) */
+
+    FPHXMEDIAPLATFORMOPEN   fpHXMediaPlatformOpen   = NULL;
+    FPHXCREATEMEDIAPLATFORM fpHXCreateMediaPlatform = NULL;
+    FPHXMEDIAPLATFORMCLOSE  fpHXMediaPlatformClose  = NULL;
+
+    FPRMCREATEENGINE        fpCreateEngine          = NULL;
+    FPRMCLOSEENGINE         fpCloseEngine           = NULL;
+    FPRMSETDLLACCESSPATH    fpSetDll                = NULL;
+
+    HX_RESULT               theErr                  = HXR_OK;
+    ExampleClientContext**  ppExContexts            = NULL;
+#if defined(HELIX_FEATURE_AUTO_BANDWIDTH_DETECTION) && defined(_WIN32)
+    ExampleABD*             pABD                    = NULL;
+#endif
+    IHXPlayer**             ppPlayers               = NULL;
+    IHXQuickSeek*           ppQuickSeek             = NULL;
+    IHXErrorSink*           pErrorSink              = NULL;
+    IHXErrorSinkControl*    pErrorSinkControl       = NULL;
+    UINT32                  ulABDResult             = 0;
+    UINT32                  ulProbPktSize           = 0;
+    UINT32                  ulProbPktNum            = 0;
+#if defined(HELIX_FEATURE_PLAYBACK_VELOCITY)
+    INT32                   lVelocity               = 100;
+    INT32                   lKeyFrameMode           = 0;
+    INT32                   lAutoSwitch             = 0;
+#endif /* #if defined(HELIX_FEATURE_PLAYBACK_VELOCITY) */
+    CHXString*              pABDServer              = NULL;
+    char*                   pszURL[MAX_NUM_URLS];
+    char*                   pszURLOrig[MAX_NUM_URLS];
+    UINT32                  ulNumURLsFound          = 0;
+    int                     nNumPlayers             = 1;
+    int                     nNumPlayRepeats         = 1;
+    int                     nTimeDelta              = DEFAULT_TIME_DELTA;
+    int                     nStopTime               = DEFAULT_STOP_TIME;
+    bool                    bStopTime               = true;
+    int                     i                       = 0;
+    char*                   pszGUIDList             = NULL;
+#ifdef _MACINTOSH
+    char                    dllhome[MAX_PATH]       = {'\0'}; /* Flawfinder: ignore */
+#elif defined(_SYMBIAN)
+    char                    dllhome[MAX_PATH]       = "c:"; /* Flawfinder: ignore */
+#else
+    char                    dllhome[MAX_PATH]       = {'.','\0'}; /* Flawfinder: ignore */
+#endif
+    DLLAccess*              pDLLAccess              = NULL;
+    char                    staticLibPath[MAX_PATH] = {0}; /* Flawfinder: ignore */
+#ifdef _WINDOWS
+    HINSTANCE               hDll                    = NULL;
+#endif
+    bool                    bStopping = false;
+    int                     nPlay = 0;
+
+    // NULL out the URL arrays
+    memset(pszURL, 0, MAX_NUM_URLS * sizeof(char*));
+    memset(pszURLOrig, 0, MAX_NUM_URLS * sizeof(char*));
+
+
+    //See if the user has set their HELIX_LIBS env var. This is overridden by the
+    //-l option.
+    const char* pszHelixLibs = getenv("HELIX_LIBS");
+    if( pszHelixLibs )
+        SafeStrCpy( dllhome,  pszHelixLibs, MAX_PATH);
+
+
+
+    GetGlobal()->bEnableAdviceSink = TRUE;
+    GetGlobal()->g_prefList.Add("UseOverlay", "0");
+
+    SafeSprintf(staticLibPath, MAX_PATH, "%s/%s", dllhome, "hxmedpltfm.so");
+
+	if (dllhome)
+    {
+        GetDLLAccessPath()->SetPath(DLLTYPE_COMMON, dllhome);
+        GetDLLAccessPath()->SetPath(DLLTYPE_PLUGIN, dllhome);
+        GetDLLAccessPath()->SetPath(DLLTYPE_CODEC, dllhome);
+    }
+
+    // initialize the globals
+    GetGlobal()->m_fpCreateEngine    = NULL;
+    GetGlobal()->m_fpCloseEngine = NULL;
+    GetGlobal()->g_nPlayers = 0;
+
+  // prepare/load the HXCore module
+    pDLLAccess = new DLLAccess();
+
+    STDOUT("Simpleplayer is looking for the client core at %s\n", staticLibPath );
+
+    if (DLLAccess::DLL_OK != pDLLAccess->open(staticLibPath))
+    {
+        const char* pErrorString = NULL;
+        pErrorString = pDLLAccess->getErrorString();
+        STDERR("splayer: %s\n\n", pErrorString);
+#ifndef _STATICALLY_LINKED
+#ifndef _MACINTOSH
+        //Make sure the user has told us where to find the DLLs at. Either
+        //with the -l option or with the HELIX_LIBS env var.
+        STDERR("You must tell the player where to find the client core and\n");
+        STDERR("all of its supporting DLLs and codecs. Please use the -l\n");
+        STDERR("option or set your HELIX_LIBS env variable to point the player.\n");
+        STDERR("to where you have all of the DLLs installed.\n\n" );
+        //PrintUsage(argv[0]);
+#endif
+#endif
+        goto cleanup;
+    }
+
+    GetGlobal()->m_fpHXMediaPlatformOpen = (FPHXMEDIAPLATFORMOPEN) pDLLAccess->getSymbol("HXMediaPlatformOpen");
+    GetGlobal()->m_fpHXCreateMediaPlatform = (FPHXCREATEMEDIAPLATFORM) pDLLAccess->getSymbol("HXCreateMediaPlatform");
+    GetGlobal()->m_fpHXMediaPlatformClose = (FPHXMEDIAPLATFORMCLOSE) pDLLAccess->getSymbol("HXMediaPlatformClose");
+
+    GetGlobal()->m_fpCreateEngine = (FPRMCREATEENGINE) pDLLAccess->getSymbol("CreateEngine");
+    GetGlobal()->m_fpCloseEngine  = (FPRMCLOSEENGINE)  pDLLAccess->getSymbol("CloseEngine");
+    GetGlobal()->m_fpSetDLLAccessPath = (FPRMSETDLLACCESSPATH) pDLLAccess->getSymbol("SetDLLAccessPath");
+
+    if (GetGlobal()->m_fpHXMediaPlatformOpen == NULL    ||
+        GetGlobal()->m_fpHXCreateMediaPlatform == NULL  ||
+        GetGlobal()->m_fpHXMediaPlatformClose == NULL   ||
+        GetGlobal()->m_fpCreateEngine == NULL           ||
+        GetGlobal()->m_fpCloseEngine  == NULL           ||
+        GetGlobal()->m_fpSetDLLAccessPath == NULL )
+    {
+        theErr = HXR_FAILED;
+        goto cleanup;
+    }
+
+#if defined(USE_XWINDOWS) && defined(HELIX_FEATURE_VIDEO)
+    XInitThreads();
+#endif
+    
+    {
+        fpHXMediaPlatformOpen = GetGlobal()->m_fpHXMediaPlatformOpen;
+        fpHXCreateMediaPlatform = GetGlobal()->m_fpHXCreateMediaPlatform;
+        fpHXMediaPlatformClose = GetGlobal()->m_fpHXMediaPlatformClose;
+
+        if (HXR_OK != fpHXMediaPlatformOpen())
+        {
+            theErr = HXR_FAILED;
+            goto cleanup;
+        }
+
+        if (HXR_OK != fpHXCreateMediaPlatform((IHXMediaPlatform**)&GetGlobal()->pMediaPlatform))
+        {
+            theErr = HXR_FAILED;
+            goto cleanup;
+        }
+
+        IHXMediaPlatform* pMediaPlatform = GetGlobal()->pMediaPlatform;
+        
+
+        if (HXR_OK != pMediaPlatform->AddPluginPath("HelixSimplePlayer", dllhome))
+        {
+            theErr = HXR_FAILED;
+            goto cleanup;
+        }
+
+        if (HXR_OK != pMediaPlatform->Init(NULL))
+        {
+            theErr = HXR_FAILED;
+            goto cleanup;
+        }
+    
+        IHXCommonClassFactory* pCCF = NULL;
+        if (HXR_OK != pMediaPlatform->QueryInterface(IID_IHXCommonClassFactory,
+                                                     (void**)&pCCF))
+        {
+            theErr = HXR_FAILED;
+            goto cleanup;
+        }
+
+       if (HXR_OK != pCCF->CreateInstance(CLSID_IHXClientEngine, (void**)&GetGlobal()->pEngine))
+        {
+            HX_RELEASE(pCCF);
+            theErr = HXR_FAILED;
+            goto cleanup;
+        }
+
+        HX_RELEASE(pCCF);
+
+        IHXMediaPlatformKicker* pKicker = NULL;
+        pMediaPlatform->QueryInterface(IID_IHXMediaPlatformKicker, (void**)&pKicker);
+        HX_ASSERT(pKicker);
+        GetGlobal()->g_pIHXKicker = pKicker;
+	GetGlobal()->g_uThreadIDForKicker = HXGetCurrentThreadID();
+
+	pthread_t thread_id;
+	pthread_create(&thread_id, NULL, kickman, NULL);
+	GetGlobal()->g_pThreadKickmanId = thread_id;
+    }
+
+
+
+    {
+
+
+#if defined(_WIN32) && !defined(WIN32_PLATFORM_PSPC)
+        SetConsoleCtrlHandler((PHANDLER_ROUTINE)HandlerRoutine,
+                              TRUE);
+#endif
+
+    }
+
+    return HXR_OK;
+
+  cleanup:
+    deinit_main();
+    return HXR_FAIL;
+}
+
+/* Get the least index to available entry in Getglobal()->gPlayers */
+static int get_index()
+{
+    int i;
+    /* an simple implementation */
+    for (i = 0; i < MAX_NUM_PLAYERS; i++)
+    {
+        if (GetGlobal()->g_Players[i] == NULL) 
+            return i;
+    }
+
+    return -1;
+}
+
+PLAYER_API unsigned int get_curr_playtime(void *pPlayerHandle)
+{
+    unsigned int time = 0;
+    IHXPlayer *pPlayer = (IHXPlayer *)pPlayerHandle;
+    if (pPlayer)
+        time = pPlayer->GetCurrentPlayTime();
+    return time;
+}
+
+PLAYER_API int get_player(void **ppPlayerHandle, on_buffering_cb_t on_buffering_cb, on_pos_length_cb_t on_pos_length_cb, on_state_change_cb_t on_state_change_cb, on_new_frame_cb_t on_new_frame_cb, void *context)
+{
+    int index = get_index();
+    IHXPlayer **ppPlayer = (IHXPlayer **)ppPlayerHandle;
+    ExampleClientContext*  pExContext       = NULL;
+    pExContext = new ExampleClientContext(index);
+    if (!pExContext)
+    {
+        return HXR_UNEXPECTED;
+    }
+    pExContext->AddRef();
+
+    ppPlayer[0] = NULL;
+    IHXClientEngine* pEngine = GetGlobal()->pEngine;
+    if (HXR_OK != pEngine->CreatePlayer(*ppPlayer))
+    {
+        HX_RELEASE(pExContext);
+        return HXR_FAILED;
+    }
+#if 1
+    char*                   pszGUIDList             = NULL;
+    //initialize the example context
+    pszGUIDList = GetGlobal()->g_pszGUIDList;
+    {
+        char pszGUID[GUID_LEN + 1]; /* Flawfinder: ignore */ // add 1 for terminator
+        char* token = NULL;
+        IHXPreferences* pPreferences = NULL;
+
+        pszGUID[0] = '\0';
+
+        if (pszGUIDList)
+        {
+            // Get next GUID from the GUID list
+            {
+                token = strtok(pszGUIDList, "\n\0");
+            }
+            if (token)
+            {
+                strncpy(pszGUID, token, GUID_LEN); /* Flawfinder: ignore */
+                pszGUID[GUID_LEN] = '\0';
+            }
+        }
+
+        ppPlayer[0]->QueryInterface(IID_IHXPreferences,
+                                     (void**) &pPreferences);
+        
+        pExContext->Init(ppPlayer[0], pPreferences, pszGUID, on_buffering_cb, on_pos_length_cb, on_state_change_cb, on_new_frame_cb, context);
+
+        ppPlayer[0]->SetClientContext(pExContext);
+
+        HX_RELEASE(pPreferences);
+
+        IHXErrorSinkControl*    pErrorSinkControl       = NULL;
+        ppPlayer[0]->QueryInterface(IID_IHXErrorSinkControl,
+                                     (void**) &pErrorSinkControl);
+    
+        if (pErrorSinkControl)
+        {
+            IHXErrorSink*           pErrorSink              = NULL;
+            pExContext->QueryInterface(IID_IHXErrorSink,
+                    (void**) &pErrorSink);
+            if (pErrorSink)
+            {
+                pErrorSinkControl->AddErrorSink(pErrorSink, HXLOG_EMERG, HXLOG_INFO);
+            }
+            HX_RELEASE(pErrorSink);
+        }
+        HX_RELEASE(pErrorSinkControl);
+	GetGlobal()->g_prefList.SetPreferences(ppPlayer[0]);
+
+    }
+#endif
+    HX_ASSERT(GetGlobal()->g_nPlayers < MAX_NUM_PLAYERS);
+    GetGlobal()->g_Players[index] = ppPlayer[0];
+    GetGlobal()->g_pClientContexts[index] = pExContext;
+    GetGlobal()->g_nPlayers++;
+
+    return HXR_OK;
+}
+
+static int get_index_by_player( IHXPlayer *pPlayer)
+{
+    int i;
+    /* an simple implementation */
+    for (i = 0; i < MAX_NUM_PLAYERS; i++)
+    {
+       if (GetGlobal()->g_Players[i] && GetGlobal()->g_Players[i] == pPlayer)
+           return i;
+    }
+
+    return -1;
+}
+
+PLAYER_API int player_openurl( void *pPlayerHandle, char *pszRawURL)
+{
+    HX_RESULT ret;
+    IHXPlayer *pPlayer = (IHXPlayer *)pPlayerHandle;
+    int index = get_index_by_player(pPlayer);
+    if (index < 0)
+        return HXR_FAIL;
+    
+    char *pszURLOrig = RemoveWrappingQuotes(pszRawURL);
+
+    //if no "://" was found lets add file:// by default so that you
+    //can refer to local content as just ./splay ~/Content/startrek.rm,
+    //for example, and not ./splay file:///home/gregory/Content/startrek.rm
+    char* pszAddOn = NULL;
+    if( strstr( pszURLOrig, "://") )
+        pszAddOn = (char *)"";
+    else
+        pszAddOn = (char *)"file://";
+
+    char *pszURL = new char[strlen(pszURLOrig)+strlen(pszAddOn)+1];
+    sprintf( pszURL, "%s%s", pszAddOn, pszURLOrig ); /* Flawfinder: ignore */
+    // Increment the number of URLs we have found
+    STDERR("opening %s on player\n", pszURL);
+
+    GetGlobal()->g_pszURLs[index] = pszURL;
+    ret = pPlayer->OpenURL(pszURL);
+ 
+    UINT32 sleepTime = 0;
+
+    IHXMediaPlatformKicker* pKicker = GetGlobal()->g_pIHXKicker;
+    if( pKicker )
+    {
+        pKicker->Kick(HXGetCurrentThreadID(), &sleepTime);
+    }
+
+    return ret;
+}
+
+PLAYER_API int put_player( void *pPlayerHandle)
+{
+    IHXPlayer *pPlayer = (IHXPlayer *)pPlayerHandle;
+    int index;
+    index = get_index_by_player(pPlayer);
+    if (index < 0)
+        return HXR_FAIL;
+
+    ExampleClientContext *pClientContext = GetGlobal()->g_pClientContexts[index];
+    if (pClientContext) {
+        pClientContext->Release();
+        pClientContext = NULL;
+    }
+
+    GetGlobal()->g_pClientContexts[index] = NULL;
+    if (pPlayer) {
+        if (GetGlobal()->pEngine) {
+            GetGlobal()->pEngine->ClosePlayer(pPlayer);
+        }
+        pPlayer->Release();
+        pPlayer = NULL;
+    }
+    GetGlobal()->g_Players[index] = NULL;
+    GetGlobal()->g_nPlayers--;
+    delete [] GetGlobal()->g_pszURLs[index];
+    GetGlobal()->g_pszURLs[index] = NULL;
+
+    return HXR_OK;
+}
+
+PLAYER_API int player_geturl( void *pPlayerHandle, char **pszURL)
+{
+    IHXPlayer *pPlayer = (IHXPlayer *)pPlayerHandle;
+    int index = get_index_by_player(pPlayer);
+    if (index >= 0) {
+        *pszURL = GetGlobal()->g_pszURLs[index];
+        return HXR_OK;
+    }
+
+    return  HXR_FAIL;
+}
+
+PLAYER_API int player_begin( void *pPlayerHandle )
+{
+    IHXPlayer *pPlayer = (IHXPlayer *)pPlayerHandle;
+    UINT32 sleepTime = 0;
+    pPlayer->Begin();
+
+#if 0
+    IHXMediaPlatformKicker* pKicker = GetGlobal()->g_pIHXKicker;
+	    if( pKicker )
+	    {
+		    pKicker->Kick(HXGetCurrentThreadID(), &sleepTime);
+	    }
+#endif
+    return HXR_OK;
+}
+
+PLAYER_API int player_pause( void *pPlayerHandle )
+{
+    IHXPlayer *pPlayer = (IHXPlayer *)pPlayerHandle;
+    UINT32 sleepTime = 0;
+    pPlayer->Pause();
+
+#if 0
+    IHXMediaPlatformKicker* pKicker = GetGlobal()->g_pIHXKicker;
+	    if( pKicker )
+	    {
+		    pKicker->Kick(HXGetCurrentThreadID(), &sleepTime);
+	    }
+#endif
+    return HXR_OK;
+}
+
+PLAYER_API int player_stop( void *pPlayerHandle )
+{
+    IHXPlayer *pPlayer = (IHXPlayer *)pPlayerHandle;
+    pPlayer->Stop();
+    return HXR_OK;
+}
+
+#if 0
+int main(int argc, char *argv[])
+{
+    IHXPlayer *pPlayer;
+    init_main();
+    while(1) {
+        get_player(&pPlayer);
+        player_openurl(pPlayer, argv[1]);
+        player_begin(pPlayer);
+     //   sleep(2);
+        player_stop(pPlayer);
+        put_player(pPlayer);
+    }
+    deinit_main();
+    return 0;
+}
+#endif
+
+PLAYER_API int player_seek(void *pPlayerHandle, int pos)
+{
+    IHXPlayer *pPlayer = (IHXPlayer *)pPlayerHandle;
+    if (pPlayer == NULL)
+        return HXR_FAIL;
+
+    return pPlayer->Seek(pos);
+}
+PLAYER_API int player_getvolume(void *pPlayerHandle)
+{
+    IHXPlayer *pPlayer = (IHXPlayer *)pPlayerHandle;
+    if (pPlayer == NULL)
+        return HXR_FAIL;
+
+    int volume = 0;
+
+    IHXAudioPlayer* pAudioPlayer = NULL;
+    pPlayer->QueryInterface(IID_IHXAudioPlayer, (void**) &pAudioPlayer);
+    if (pAudioPlayer)
+    {
+        // Get the IHXVolume
+        IHXVolume* pVolume = pAudioPlayer->GetAudioVolume();
+        if (pVolume)
+        {
+            volume = pVolume->GetVolume();
+        }
+        HX_RELEASE(pVolume);
+    }
+    HX_RELEASE(pAudioPlayer);
+
+    return volume;
+}
+
+
+PLAYER_API int player_setvolume(void *pPlayerHandle, unsigned short volume)
+{
+    IHXPlayer *pPlayer = (IHXPlayer *)pPlayerHandle;
+    if (pPlayer == NULL)
+        return HXR_FAIL;
+
+    IHXAudioPlayer* pAudioPlayer = NULL;
+    pPlayer->QueryInterface(IID_IHXAudioPlayer, (void**) &pAudioPlayer);
+    if (pAudioPlayer)
+    {
+        // Get the IHXVolume
+        IHXVolume* pVolume = pAudioPlayer->GetAudioVolume();
+        if (pVolume)
+        {
+            pVolume->SetVolume(volume);
+        }
+        HX_RELEASE(pVolume);
+    }
+    HX_RELEASE(pAudioPlayer);
+}
+
+PLAYER_API int deinit_main()
+{
+ 
+    pthread_cancel(GetGlobal()->g_pThreadKickmanId);
+    int ret ;
+    ret = pthread_join(GetGlobal()->g_pThreadKickmanId, NULL);
+    if (ret < 0) {
+	    perror("pthread_join error\n");
+    }
+#if defined(HELIX_FEATURE_PLAYBACK_VELOCITY)
+    if (GetGlobal()->g_pVelocityCaps)
+    {
+        IHXPlaybackVelocityCaps* pCaps = GetGlobal()->g_pVelocityCaps;
+        pCaps->Release();
+        GetGlobal()->g_pVelocityCaps = NULL;
+    }
+#endif /* #if defined(HELIX_FEATURE_PLAYBACK_VELOCITY) */
+
+#ifdef __TCS__
+    g_nPlayers = 0;
+#endif
+
+    
+    {
+        IHXClientEngine* pEngine = GetGlobal()->pEngine;
+
+        if (pEngine)
+        {
+            IHXClientEngine2* pEngine2 = NULL;
+            if (HXR_OK == pEngine->QueryInterface(IID_IHXClientEngine2, 
+                                                  (void**)&pEngine2))
+            {
+                pEngine2->Close();
+            }
+            HX_RELEASE(pEngine2);
+        }
+        HX_RELEASE(GetGlobal()->pEngine);
+        HX_RELEASE(GetGlobal()->g_pIHXKicker);
+        
+        if (GetGlobal()->pMediaPlatform)
+        {
+            // Reset() not only close the platform but also remove all
+            // persistent information(i.e. preferences) maintained by the
+            // platform
+            // GetGlobal()->pMediaPlatform->Reset(NULL);
+            GetGlobal()->pMediaPlatform->Close();
+            HX_RELEASE(GetGlobal()->pMediaPlatform);
+        }
+
+        if (GetGlobal()->m_fpHXMediaPlatformClose)
+        {
+            GetGlobal()->m_fpHXMediaPlatformClose();
+        }
+    }
+
+
+    if (GetGlobal()->bEnableVerboseMode)
+    {
+        STDOUT("\nDone.\n");
+    }
+
+    if (GetGlobal()->g_pszUsername)
+    {
+        delete [] GetGlobal()->g_pszUsername;
+        GetGlobal()->g_pszUsername = NULL;
+    }
+    if (GetGlobal()->g_pszPassword)
+    {
+        delete [] GetGlobal()->g_pszPassword;
+        GetGlobal()->g_pszPassword = NULL;
+    }
+    if (GetGlobal()->g_pszGUIDFile)
+    {
+        delete [] GetGlobal()->g_pszGUIDFile;
+        GetGlobal()->g_pszGUIDFile = NULL;
+    }
+    if (GetGlobal()->g_pszGUIDList)
+    {
+        delete [] GetGlobal()->g_pszGUIDList;
+        GetGlobal()->g_pszGUIDList = NULL;
+    }
+    // If an error occurred during playback, return that
+    
+    if (GetGlobal()->g_Error != HXR_OK)
+    {
+        return GetGlobal()->g_Error;
+    }
+    // or HXR_OK (if there was more than one player)
+    else
+    {
+        return HXR_OK;
+    }
+}
+char* GetAppName(char* pszArgv0)
+{
+    char* pszAppName;
+
+    pszAppName = strrchr(pszArgv0, '\\');
+
+    if (NULL == pszAppName)
+    {
+        return pszArgv0;
+    }
+    else
+    {
+        return pszAppName + 1;
+    }
+}
+
+void PrintUsage(const char* pszAppName)
+{
+}
+
+
+
+HXBOOL ReadGUIDFile()
+{
+    HXBOOL  bSuccess = FALSE;
+    FILE* pFile    = NULL;
+    int   nNumRead = 0;
+    int   readSize = 10000;
+    char*  pszBuffer = new char[readSize];
+
+    if (GetGlobal()->g_pszGUIDFile)
+    {
+        if((pFile = fopen(GetGlobal()->g_pszGUIDFile, "r")) != NULL)
+        {
+            // Read in the entire file
+            nNumRead = fread(pszBuffer, sizeof(char), readSize, pFile);
+            pszBuffer[nNumRead] = '\0';
+
+            // Store it for later parsing
+            GetGlobal()->g_pszGUIDList = new char[nNumRead + 1];
+            strcpy(GetGlobal()->g_pszGUIDList, pszBuffer); /* Flawfinder: ignore */
+
+            fclose(pFile);
+            pFile = NULL;
+
+            if (nNumRead > 0)
+            {
+                bSuccess = TRUE;
+            }
+        }
+    }
+
+    delete [] pszBuffer;
+
+    return bSuccess;
+}
+
+static int are_all_src_seekable(IHXPlayer *pPlayer)
+{
+    UINT16 nSrcCnt;
+    nSrcCnt = pPlayer->GetSourceCount();
+    HXSource *pSource = NULL;    /* This is brute-force */
+    for (UINT16 i = 0; i < nSrcCnt; i++) 
+    {
+        if (pPlayer->GetSource(i, (IUnknown *&)pSource) == HXR_OK)
+        {
+            if (!pSource->IsSeekable())
+                return FALSE;
+
+
+        }
+    }
+
+}
+
+PLAYER_API int player_canseek(void *pPlayerHandle)
+{
+    if (!pPlayerHandle)
+        return FALSE;
+
+    IHXPlayer *pPlayer = (IHXPlayer *)pPlayerHandle;
+    ExampleClientContext*  pExContext=NULL;
+    if (pPlayer->GetClientContext((IUnknown*&)pExContext) != HXR_OK)
+        return FALSE;
+
+    if (!pExContext)
+        return FALSE;
+
+    EHXClientState State = pExContext->GetState();
+
+    int all_src_seekable =  are_all_src_seekable(pPlayer);
+
+    HX_RELEASE(pExContext);
+
+    if (State < HX_CLIENT_STATE_CONNECTED)
+        return TRUE;
+
+    if (all_src_seekable && (!pPlayer->IsLive() || State == HX_CLIENT_STATE_PAUSED))
+        return TRUE;
+
+    return FALSE;
+}
+
+
Index: helix-libs/clientapps/clutter/player.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/player.h	2008-10-13 06:54:45.000000000 -0700
@@ -0,0 +1,60 @@
+#ifndef _PLAYER_H_
+#define _PLAYER_H_
+
+#ifdef __cplusplus
+#define PLAYER_API    extern "C"
+#else
+#define PLAYER_API
+#endif
+
+/* Duplicate of  EHXClientState */
+typedef enum _EPlayerStateState
+{
+    PLAYER_STATE_READY = 0,  // uninitialized
+    PLAYER_STATE_CONNECTING, // attempting to connect to sources
+    PLAYER_STATE_CONNECTED,  // connected to sources (realized)
+    PLAYER_STATE_OPENING,    // opening sources
+    PLAYER_STATE_OPENED,     // opened sources
+    PLAYER_STATE_PREFETCHING,// obtaining resources, buffering, etc.
+    PLAYER_STATE_PREFETCHED, // ready for playback at time zero
+    PLAYER_STATE_PLAYING,    // currently playing
+    PLAYER_STATE_PAUSED,     // paused
+    PLAYER_STATE_SEEKING     // seeking
+} EHXPlayerState;
+
+typedef struct {
+    int left;
+    int top;
+    int right;
+    int bottom;
+} PlayerRect;
+
+typedef struct {
+    PlayerRect Rect;
+    unsigned int  cx;
+    unsigned int cy;
+} PlayerImgInfo;
+
+typedef void (*on_pos_length_cb_t)(unsigned int, unsigned int, void *);
+typedef void (*on_buffering_cb_t)(unsigned int, unsigned short, void *);
+typedef void (*on_state_change_cb_t)(unsigned short, unsigned short, void *);
+typedef void (*on_new_frame_cb_t)(unsigned char *p, unsigned int size, PlayerImgInfo *rect, void *context);
+
+PLAYER_API int init_main();
+PLAYER_API int deinit_main();
+PLAYER_API int get_player(void **ppPlayerHandle, on_buffering_cb_t on_buffering_cb, on_pos_length_cb_t on_pos_length_cb, on_state_change_cb_t on_state_change_cb, on_new_frame_cb_t on_new_frame_cb, void *context);
+PLAYER_API int player_openurl( void *pPlayerHandle, char *pszRawURL);
+PLAYER_API int put_player( void *pPlayerHandle);
+PLAYER_API int player_geturl( void *pPlayerHandle, char **pszURL);
+PLAYER_API int player_begin( void *pPlayerHandle );
+PLAYER_API int player_stop( void *pPlayerHandle );
+PLAYER_API int player_pause( void *pPlayerHandle );
+PLAYER_API unsigned int get_curr_playtime(void *pPlayerHandle);
+PLAYER_API int player_seek(void *pPlayerHandle, int pos);
+PLAYER_API int player_getvolume(void *pPlayerHandle);
+PLAYER_API int player_setvolume(void *pPlayerHandle, unsigned short volumn);
+PLAYER_API int player_canseek(void *pPlayerHandle);
+
+
+#endif
+
Index: helix-libs/clientapps/clutter/preflist.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/preflist.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,142 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Source last modified: $Id: preflist.cpp,v 1.2 2007/07/06 20:32:36 jfinnecy Exp $
+ * 
+ * Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.
+ * 
+ * The contents of this file, and the files included with this file,
+ * are subject to the current version of the RealNetworks Public
+ * Source License (the "RPSL") available at
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed
+ * the file under the current version of the RealNetworks Community
+ * Source License (the "RCSL") available at
+ * http://www.helixcommunity.org/content/rcsl, in which case the RCSL
+ * will apply. You may also obtain the license terms directly from
+ * RealNetworks.  You may not use this file except in compliance with
+ * the RPSL or, if you have a valid RCSL with RealNetworks applicable
+ * to this file, the RCSL.  Please see the applicable RPSL or RCSL for
+ * the rights, obligations and limitations governing use of the
+ * contents of the file.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 (the
+ * "GPL") in which case the provisions of the GPL are applicable
+ * instead of those above. If you wish to allow use of your version of
+ * this file only under the terms of the GPL, and not to allow others
+ * to use your version of this file under the terms of either the RPSL
+ * or RCSL, indicate your decision by deleting the provisions above
+ * and replace them with the notice and other provisions required by
+ * the GPL. If you do not delete the provisions above, a recipient may
+ * use your version of this file under the terms of any one of the
+ * RPSL, the RCSL or the GPL.
+ * 
+ * This file is part of the Helix DNA Technology. RealNetworks is the
+ * developer of the Original Code and owns the copyrights in the
+ * portions it created.
+ * 
+ * This file, and the files included with this file, is distributed
+ * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY
+ * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS
+ * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET
+ * ENJOYMENT OR NON-INFRINGEMENT.
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location:
+ *    http://www.helixcommunity.org/content/tck
+ * 
+ * Contributor(s):
+ * 
+ * ***** END LICENSE BLOCK ***** */
+#include "preflist.h"
+
+#include "hxstring.h"
+#include "hxccf.h"
+#include "hxprefs.h"
+#include "ihxpckts.h"
+
+class CHXPrefInfo
+{
+public:
+    CHXPrefInfo(const char* pKey, const char* pValue);
+    ~CHXPrefInfo();
+    
+    const char* Key() const { return m_key;}
+    const char* Value() const { return m_value;}
+
+private:
+    CHXString m_key;
+    CHXString m_value;
+};
+
+CHXPrefInfo::CHXPrefInfo(const char* pKey, const char* pValue) :
+    m_key(pKey),
+    m_value(pValue)
+{}
+
+CHXPrefInfo::~CHXPrefInfo()
+{}
+
+CHXPrefList::CHXPrefList()
+{}
+
+CHXPrefList::~CHXPrefList()
+{
+    Clear();
+}
+
+void CHXPrefList::Add(const char* pKey, const char* pValue)
+{
+    CHXPrefInfo* pInfo = new CHXPrefInfo(pKey, pValue);
+
+    if (pInfo)
+    {
+        if (!m_prefInfo.AddTail(pInfo))
+        {
+            // We failed to insert the preference.
+            HX_DELETE(pInfo);
+        }
+    }
+}
+
+void CHXPrefList::Clear()
+{
+    while(!m_prefInfo.IsEmpty())
+    {
+        CHXPrefInfo* pInfo = (CHXPrefInfo*)m_prefInfo.RemoveHead();
+        HX_DELETE(pInfo);
+    }
+}
+
+void CHXPrefList::SetPreferences(IUnknown* pContext)
+{
+    IHXPreferences* pPrefs = NULL;
+    IHXCommonClassFactory* pCCF = NULL;
+
+    if (pContext &&
+        (HXR_OK == pContext->QueryInterface(IID_IHXPreferences,
+                                            (void**)&pPrefs)) &&
+        (HXR_OK == pContext->QueryInterface(IID_IHXCommonClassFactory,
+                                            (void**)&pCCF)))
+    {
+        CHXSimpleList::Iterator itr = m_prefInfo.Begin();
+        
+        for(; itr != m_prefInfo.End(); ++itr)
+        {
+            CHXPrefInfo* pInfo = (CHXPrefInfo*)(*itr);
+            
+            IHXBuffer* pBuf = NULL;
+            
+            if ((HXR_OK == pCCF->CreateInstance(CLSID_IHXBuffer,
+                                                (void**)&pBuf)) &&
+                (HXR_OK == pBuf->Set((const unsigned char*)pInfo->Value(),
+                                     strlen(pInfo->Value()))))
+            {
+                pPrefs->WritePref(pInfo->Key(), pBuf);
+            }
+
+            HX_RELEASE(pBuf);
+        }
+    }
+
+    HX_RELEASE(pPrefs);
+    HX_RELEASE(pCCF);
+}
Index: helix-libs/clientapps/clutter/preflist.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/preflist.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,69 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Source last modified: $Id: preflist.h,v 1.2 2007/07/06 20:32:36 jfinnecy Exp $
+ * 
+ * Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.
+ * 
+ * The contents of this file, and the files included with this file,
+ * are subject to the current version of the RealNetworks Public
+ * Source License (the "RPSL") available at
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed
+ * the file under the current version of the RealNetworks Community
+ * Source License (the "RCSL") available at
+ * http://www.helixcommunity.org/content/rcsl, in which case the RCSL
+ * will apply. You may also obtain the license terms directly from
+ * RealNetworks.  You may not use this file except in compliance with
+ * the RPSL or, if you have a valid RCSL with RealNetworks applicable
+ * to this file, the RCSL.  Please see the applicable RPSL or RCSL for
+ * the rights, obligations and limitations governing use of the
+ * contents of the file.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 (the
+ * "GPL") in which case the provisions of the GPL are applicable
+ * instead of those above. If you wish to allow use of your version of
+ * this file only under the terms of the GPL, and not to allow others
+ * to use your version of this file under the terms of either the RPSL
+ * or RCSL, indicate your decision by deleting the provisions above
+ * and replace them with the notice and other provisions required by
+ * the GPL. If you do not delete the provisions above, a recipient may
+ * use your version of this file under the terms of any one of the
+ * RPSL, the RCSL or the GPL.
+ * 
+ * This file is part of the Helix DNA Technology. RealNetworks is the
+ * developer of the Original Code and owns the copyrights in the
+ * portions it created.
+ * 
+ * This file, and the files included with this file, is distributed
+ * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY
+ * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS
+ * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET
+ * ENJOYMENT OR NON-INFRINGEMENT.
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location:
+ *    http://www.helixcommunity.org/content/tck
+ * 
+ * Contributor(s):
+ * 
+ * ***** END LICENSE BLOCK ***** */
+#ifndef PREFLIST_H
+#define PREFLIST_H
+
+#include "hxslist.h"
+
+class CHXPrefList
+{
+public:
+    CHXPrefList();
+    ~CHXPrefList();
+
+    void Add(const char* pKey, const char* pValue);
+    void Clear();
+
+    void SetPreferences(IUnknown* pContext);
+
+private:
+    CHXSimpleList m_prefInfo;
+};
+
+#endif /* PREFLIST_H */
Index: helix-libs/clientapps/clutter/print.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/print.cpp	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,80 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#include <stdarg.h>
+#include <stdio.h>
+#include "print.h"
+#ifdef WIN32_PLATFORM_PSPC
+#include "hlxosstr.h"
+#include <winbase.h>
+#endif
+
+int print2stdout(const char* pFmt, ...)
+{
+    va_list args;
+    
+    va_start(args, pFmt);
+
+#ifdef WIN32_PLATFORM_PSPC
+    char szMessage[512];
+    int ret = vsprintf(szMessage, pFmt, args);
+    OutputDebugString(OS_STRING(szMessage));
+#else
+    int ret = vfprintf(stdout, pFmt, args);
+#endif
+
+    va_end(args);
+
+    return ret;
+}
+
+int print2stderr(const char* pFmt, ...)
+{
+    va_list args;
+    
+    va_start(args, pFmt);
+
+#ifdef WIN32_PLATFORM_PSPC
+    char szMessage[512];
+    int ret = vsprintf(szMessage, pFmt, args);
+    OutputDebugString(OS_STRING(szMessage));
+#else
+    int ret = vfprintf(stderr, pFmt, args);
+#endif
+
+    va_end(args);
+
+    return ret;
+}
Index: helix-libs/clientapps/clutter/print.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/print.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,60 @@
+/* ***** BEGIN LICENSE BLOCK ***** 
+ * Version: RCSL 1.0/RPSL 1.0 
+ *  
+ * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+ *      
+ * The contents of this file, and the files included with this file, are 
+ * subject to the current version of the RealNetworks Public Source License 
+ * Version 1.0 (the "RPSL") available at 
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed 
+ * the file under the RealNetworks Community Source License Version 1.0 
+ * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+ * in which case the RCSL will apply. You may also obtain the license terms 
+ * directly from RealNetworks.  You may not use this file except in 
+ * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+ * applicable to this file, the RCSL.  Please see the applicable RPSL or 
+ * RCSL for the rights, obligations and limitations governing use of the 
+ * contents of the file.  
+ *  
+ * This file is part of the Helix DNA Technology. RealNetworks is the 
+ * developer of the Original Code and owns the copyrights in the portions 
+ * it created. 
+ *  
+ * This file, and the files included with this file, is distributed and made 
+ * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+ * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+ * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location: 
+ *    http://www.helixcommunity.org/content/tck 
+ * 
+ * Contributor(s): 
+ *  
+ * ***** END LICENSE BLOCK ***** */ 
+
+#ifndef PRINT_H
+#define PRINT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef _SYMBIAN
+#include "platform/symbian/symbian_print.h"
+
+#define STDOUT symbianPrint
+#define STDERR symbianPrint
+#else
+int print2stdout(const char* pFmt, ...);
+int print2stderr(const char* pFmt, ...);
+#define STDOUT print2stdout
+#define STDERR print2stderr
+#endif
+
+#ifdef __cplusplus
+};
+#endif
+
+
+#endif /* PRINT_H */
Index: helix-libs/clientapps/clutter/shmhelp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/shmhelp.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,88 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Source last modified: $Id: shmhelp.h,v 1.5 2007/07/06 20:54:01 jfinnecy Exp $
+ * 
+ * Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.
+ * 
+ * The contents of this file, and the files included with this file,
+ * are subject to the current version of the RealNetworks Public
+ * Source License (the "RPSL") available at
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed
+ * the file under the current version of the RealNetworks Community
+ * Source License (the "RCSL") available at
+ * http://www.helixcommunity.org/content/rcsl, in which case the RCSL
+ * will apply. You may also obtain the license terms directly from
+ * RealNetworks.  You may not use this file except in compliance with
+ * the RPSL or, if you have a valid RCSL with RealNetworks applicable
+ * to this file, the RCSL.  Please see the applicable RPSL or RCSL for
+ * the rights, obligations and limitations governing use of the
+ * contents of the file.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 (the
+ * "GPL") in which case the provisions of the GPL are applicable
+ * instead of those above. If you wish to allow use of your version of
+ * this file only under the terms of the GPL, and not to allow others
+ * to use your version of this file under the terms of either the RPSL
+ * or RCSL, indicate your decision by deleting the provisions above
+ * and replace them with the notice and other provisions required by
+ * the GPL. If you do not delete the provisions above, a recipient may
+ * use your version of this file under the terms of any one of the
+ * RPSL, the RCSL or the GPL.
+ * 
+ * This file is part of the Helix DNA Technology. RealNetworks is the
+ * developer of the Original Code and owns the copyrights in the
+ * portions it created.
+ * 
+ * This file, and the files included with this file, is distributed
+ * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY
+ * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS
+ * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET
+ * ENJOYMENT OR NON-INFRINGEMENT.
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location:
+ *    http://www.helixcommunity.org/content/tck
+ * 
+ * Contributor(s):
+ * 
+ * ***** END LICENSE BLOCK ***** */
+
+#if defined(USE_XWINDOWS)
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/XShm.h>
+#endif
+
+#include "hxcom.h"
+#include "hxtypes.h"
+
+
+class ShmHelp
+{
+  public:
+
+   //Helpers
+   static void Init(Display* pDisplay );
+   static HXBOOL ShmAvailable();
+   static HX_RESULT DetachSharedRegion(UCHAR**ppMem, XShmSegmentInfo* pInfo );
+   static HX_RESULT CreateSharedRegion( INT32 nSize,
+                                        UCHAR**ppMem,
+                                        int* pnShmID,
+                                        XShmSegmentInfo* pInfo );
+   
+
+  protected:
+   
+  private:
+   static HXBOOL zm_bUseShm;
+   
+   //The X11 Segment ID....
+   static int      zm_nSegment;
+   static Display* zm_pDisplay;
+
+   ShmHelp();
+   ShmHelp(Display*);
+   ~ShmHelp();
+   
+};
+
Index: helix-libs/clientapps/clutter/unix.pcf
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/unix.pcf	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,65 @@
+# 
+# ***** BEGIN LICENSE BLOCK ***** 
+# Version: RCSL 1.0/RPSL 1.0 
+#  
+# Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
+#      
+# The contents of this file, and the files included with this file, are 
+# subject to the current version of the RealNetworks Public Source License 
+# Version 1.0 (the "RPSL") available at 
+# http://www.helixcommunity.org/content/rpsl unless you have licensed 
+# the file under the RealNetworks Community Source License Version 1.0 
+# (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
+# in which case the RCSL will apply. You may also obtain the license terms 
+# directly from RealNetworks.  You may not use this file except in 
+# compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
+# applicable to this file, the RCSL.  Please see the applicable RPSL or 
+# RCSL for the rights, obligations and limitations governing use of the 
+# contents of the file.  
+#  
+# This file is part of the Helix DNA Technology. RealNetworks is the 
+# developer of the Original Code and owns the copyrights in the portions 
+# it created. 
+#  
+# This file, and the files included with this file, is distributed and made 
+# available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
+# EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+# INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
+# FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
+# 
+# Technology Compatibility Kit Test Suite(s) Location: 
+#    http://www.helixcommunity.org/content/tck 
+# 
+# Contributor(s): 
+#  
+# ***** END LICENSE BLOCK ***** 
+# 
+
+
+if( ('HELIX_FEATURE_MINI_SITE' not in project.defines) and
+    (platform.name in ('linux2', 'linux-i386')) and
+    ('HELIX_FEATURE_VIDEO' in project.defines) and
+    (project.BuildOption("nodll"))
+    ):
+              project.sys_libraries.append('Xv', 'Xext')
+
+
+
+
+if project.BuildOption("nodll"):
+	if project.IsDefined("HELIX_FEATURE_VIDEO_CODEC_RV20"):
+		if platform.name in ('linux2', 'linux-i386', 'win32') and sysinfo.arch == 'i386':
+			project.AddLibraries(GetSDKPath("rvg2dec_libs") + '[adecg2]')
+		else:
+			project.AddLibraries(GetSDKPath("rvg2dec_libs") + '[cdecg2]')
+                
+	if project.IsDefined("HELIX_FEATURE_VIDEO_CODEC_RV30") or \
+           project.IsDefined("HELIX_FEATURE_VIDEO_CODEC_RV40"):
+		if project.IsDefined("HELIX_FEATURE_ANSIC_RV89COMBO"):
+	 		project.AddLibraries(GetSDKPath("rv89combo_c_libs")+"[cdec]")
+	 	else:
+			if platform.name in ('linux2', 'linux-i386') and sysinfo.arch == 'i386':
+			        project.AddLibraries(GetSDKPath("rv89combo_libs")+"[adec40]")
+			else:
+			        project.AddLibraries(GetSDKPath("rv89combo_libs")+"[cdec40]")
+
Index: helix-libs/clientapps/clutter/unixcmap.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/unixcmap.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,51 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Source last modified: $Id: unixcmap.h,v 1.3 2007/07/06 20:54:01 jfinnecy Exp $
+ * 
+ * Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.
+ * 
+ * The contents of this file, and the files included with this file,
+ * are subject to the current version of the RealNetworks Public
+ * Source License (the "RPSL") available at
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed
+ * the file under the current version of the RealNetworks Community
+ * Source License (the "RCSL") available at
+ * http://www.helixcommunity.org/content/rcsl, in which case the RCSL
+ * will apply. You may also obtain the license terms directly from
+ * RealNetworks.  You may not use this file except in compliance with
+ * the RPSL or, if you have a valid RCSL with RealNetworks applicable
+ * to this file, the RCSL.  Please see the applicable RPSL or RCSL for
+ * the rights, obligations and limitations governing use of the
+ * contents of the file.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 (the
+ * "GPL") in which case the provisions of the GPL are applicable
+ * instead of those above. If you wish to allow use of your version of
+ * this file only under the terms of the GPL, and not to allow others
+ * to use your version of this file under the terms of either the RPSL
+ * or RCSL, indicate your decision by deleting the provisions above
+ * and replace them with the notice and other provisions required by
+ * the GPL. If you do not delete the provisions above, a recipient may
+ * use your version of this file under the terms of any one of the
+ * RPSL, the RCSL or the GPL.
+ * 
+ * This file is part of the Helix DNA Technology. RealNetworks is the
+ * developer of the Original Code and owns the copyrights in the
+ * portions it created.
+ * 
+ * This file, and the files included with this file, is distributed
+ * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY
+ * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS
+ * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET
+ * ENJOYMENT OR NON-INFRINGEMENT.
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location:
+ *    http://www.helixcommunity.org/content/tck
+ * 
+ * Contributor(s):
+ * 
+ * ***** END LICENSE BLOCK ***** */
+
+EXTERN_C Colormap HXGetXColormap(Display* pDisplay, Window window);
+EXTERN_C void HXFindBestXColor(Display* pDisplay, Colormap cmap, XColor* desired);
Index: helix-libs/clientapps/clutter/visuals.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ helix-libs/clientapps/clutter/visuals.h	2008-10-13 06:05:49.000000000 -0700
@@ -0,0 +1,74 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Source last modified: $Id: visuals.h,v 1.4 2007/07/06 20:54:01 jfinnecy Exp $
+ * 
+ * Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.
+ * 
+ * The contents of this file, and the files included with this file,
+ * are subject to the current version of the RealNetworks Public
+ * Source License (the "RPSL") available at
+ * http://www.helixcommunity.org/content/rpsl unless you have licensed
+ * the file under the current version of the RealNetworks Community
+ * Source License (the "RCSL") available at
+ * http://www.helixcommunity.org/content/rcsl, in which case the RCSL
+ * will apply. You may also obtain the license terms directly from
+ * RealNetworks.  You may not use this file except in compliance with
+ * the RPSL or, if you have a valid RCSL with RealNetworks applicable
+ * to this file, the RCSL.  Please see the applicable RPSL or RCSL for
+ * the rights, obligations and limitations governing use of the
+ * contents of the file.
+ * 
+ * Alternatively, the contents of this file may be used under the
+ * terms of the GNU General Public License Version 2 (the
+ * "GPL") in which case the provisions of the GPL are applicable
+ * instead of those above. If you wish to allow use of your version of
+ * this file only under the terms of the GPL, and not to allow others
+ * to use your version of this file under the terms of either the RPSL
+ * or RCSL, indicate your decision by deleting the provisions above
+ * and replace them with the notice and other provisions required by
+ * the GPL. If you do not delete the provisions above, a recipient may
+ * use your version of this file under the terms of any one of the
+ * RPSL, the RCSL or the GPL.
+ * 
+ * This file is part of the Helix DNA Technology. RealNetworks is the
+ * developer of the Original Code and owns the copyrights in the
+ * portions it created.
+ * 
+ * This file, and the files included with this file, is distributed
+ * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY
+ * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS
+ * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET
+ * ENJOYMENT OR NON-INFRINGEMENT.
+ * 
+ * Technology Compatibility Kit Test Suite(s) Location:
+ *    http://www.helixcommunity.org/content/tck
+ * 
+ * Contributor(s):
+ * 
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef _UNIX
+#error This is the UNIX platform specific implementation.
+#endif
+
+#ifndef _VISUALS_H_
+#define _VISUALS_H_
+
+#if defined(USE_XWINDOWS)
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Xos.h>
+#endif
+
+//
+// These functions are loaded with dlsym() so turn off name mangling
+// with extern "C". 
+//
+extern "C" {
+
+Visual* GetBestVisual(Display* display);
+Visual* GetVisual(Display* display, long mask, XVisualInfo* templ);
+
+}
+
+#endif	// _VISUALS_H_
