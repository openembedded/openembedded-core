#!/usr/bin/env python3

# Test every patch from files folder and output error on failure
#
# Copyright (C) 2016 Intel Corporation
#
# SPDX-License-Identifier: GPL-2.0-only

import os
import subprocess
import sys

currentdir = os.path.dirname(os.path.abspath(__file__))
patchesdir = os.path.join(currentdir, 'files')
topdir     = os.path.dirname(currentdir)
parentdir  = os.path.dirname(topdir)

# path to the repo root
repodir = os.path.dirname(os.path.dirname(parentdir))

def print_results(counts):
    total = sum(counts.values())
    print("============================================================================")
    print("Testsuite summary for %s" % os.path.basename(topdir))
    print("============================================================================")
    print("# TOTAL: " + str(total))
    print("# XPASS: " + str(counts["xpass"]))
    print("# XFAIL: " + str(counts["xfail"]))
    print("# XSKIP: " + str(counts["xskip"]))
    print("# PASS: " + str(counts["pass"]))
    print("# FAIL: " + str(counts["fail"]))
    print("# SKIP: " + str(counts["skip"]))
    print("# ERROR: " + str(counts["error"]))
    print("============================================================================")

# Once the tests are in oe-core, we can remove the testdir param and use os.path.dirname to get relative paths
def test(root, patch):
    res = True
    patchpath = os.path.abspath(os.path.join(root, patch))
    
    cmd     = 'patchtest --base-commit HEAD --repodir %s --testdir %s/tests --patch %s' % (repodir, topdir, patchpath)
    results = subprocess.check_output(cmd, stderr=subprocess.STDOUT, universal_newlines=True, shell=True)

    return results

if __name__ == '__main__':
    counts = {
        "pass": 0,
        "fail": 0,
        "skip": 0,
        "xpass": 0,
        "xfail": 0,
        "xskip": 0,
        "error": 0,
    }

    results = None
        
    for root, dirs, patches in os.walk(patchesdir):
        for patch in patches:
            results = test(root, patch)

            a = patch.split('.')
            klass, testname = a[0], a[1]
            expected_result = a[-1]
            testid          = ".%s.%s" % (klass,testname)

            for resultline in results.splitlines():
                if testid in resultline:
                    result, _ = resultline.split(':', 1)

                    if expected_result.upper() == "FAIL" and result.upper() == "FAIL":
                        counts["xfail"] = counts["xfail"] + 1
                        print("XFAIL: %s (file: %s)" % (testid.strip("."), os.path.basename(patch)))
                    elif expected_result.upper() == "PASS" and result.upper() == "PASS":
                        counts["xpass"] = counts["xpass"] + 1
                        print("XPASS: %s (file: %s)" % (testid.strip("."), os.path.basename(patch)))
                    elif expected_result.upper() == "SKIP" and result.upper() == "SKIP":
                        counts["xskip"] = counts["xskip"] + 1
                        print("XSKIP: %s (file: %s)" % (testid.strip("."), os.path.basename(patch)))
                    else:
                        print("%s: %s (%s)" % (result.upper(), testid.strip("."), os.path.basename(patch)))
                        if result.upper() == "PASS":
                            counts["pass"] = counts["pass"] + 1
                        elif result.upper() == "FAIL":
                            counts["fail"] = counts["fail"] + 1
                        elif result.upper() == "SKIP":
                            counts["skip"] = counts["skip"] + 1
                        else:
                            print("Bad result on test %s against %s" % (testid.strip("."), os.path.basename(patch)))
                            counts["error"] = counts["error"] + 1
                    break
            else:
                print ("No test for=%s" % patch)

    print_results(counts)
