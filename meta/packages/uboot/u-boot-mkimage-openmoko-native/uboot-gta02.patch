Add support for new GTA02 version of Neo1973

Index: u-boot/Makefile
===================================================================
--- u-boot.orig/Makefile
+++ u-boot/Makefile
@@ -2038,6 +2038,10 @@
 sbc2410x_config: unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm920t sbc2410x NULL s3c24x0
 
+gta02_config \
+gta02v1_config :	unconfig
+	@sh board/neo1973/gta02/split_by_variant.sh $@
+
 gta01_config \
 gta01v3_config \
 gta01bv2_config \
Index: u-boot/board/neo1973/gta02/Makefile
===================================================================
--- /dev/null
+++ u-boot/board/neo1973/gta02/Makefile
@@ -0,0 +1,64 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= gta02.o pcf50633.o ../common/cmd_neo1973.o ../common/jbt6k74.o ../common/udc.o ../common/bootmenu.o
+SOBJS	:= ../common/lowlevel_init.o
+
+.PHONY:	all
+
+all:	$(LIB) lowevel_foo.bin
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+lowlevel_foo.o:	../common/lowlevel_foo.S
+	$(CC) -c -DTEXT_BASE=0x33F80000 -march=armv4 \
+	  -o lowlevel_foo.o ../common/lowlevel_foo.S
+
+lowlevel_foo:	lowlevel_foo.o ../common/lowlevel_init.o ../common/lowlevel_foo.lds
+	$(LD) -T ../common/lowlevel_foo.lds -Ttext 0x33f80000 -Bstatic \
+	  ../common/lowlevel_init.o lowlevel_foo.o -o lowlevel_foo
+
+lowevel_foo.bin:	lowlevel_foo
+	$(CROSS_COMPILE)objcopy --gap-fill=0xff -O binary \
+	  lowlevel_foo lowlevel_foo.bin
+
+
+clean:
+	rm -f $(SOBJS) $(OBJS) lowlevel_foo lowlevel_foo.o
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend lowlevel_foo.bin
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
Index: u-boot/board/neo1973/gta02/gta02.c
===================================================================
--- /dev/null
+++ u-boot/board/neo1973/gta02/gta02.c
@@ -0,0 +1,313 @@
+/*
+ * (C) 2006-2007 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * based on existing S3C2410 startup code in u-boot:
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <s3c2440.h>
+#include <i2c.h>
+
+#include "../common/neo1973.h"
+#include "../common/jbt6k74.h"
+
+#include "pcf50633.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* That many seconds the power key needs to be pressed to power up */
+#define POWER_KEY_SECONDS	2
+
+#define M_MDIV	0x7f		/* Fout = 405.00MHz */
+#define M_PDIV	0x2
+#define M_SDIV	0x1
+
+#define U_M_MDIV	0x38
+#define U_M_PDIV	0x2
+#define U_M_SDIV	0x2
+
+unsigned int neo1973_wakeup_cause;
+extern int nobootdelay;
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+	  "subs %0, %1, #1\n"
+	  "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+	/* to reduce PLL lock time, adjust the LOCKTIME register */
+	clk_power->LOCKTIME = 0xFFFFFF;
+
+	/* configure MPLL */
+	clk_power->MPLLCON = ((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (4000);
+
+	/* configure UPLL */
+	clk_power->UPLLCON = ((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (8000);
+
+	/* set up the I/O ports */
+#if defined(CONFIG_ARCH_GTA02_v1)
+	gpio->GPACON = 0x007E1FFF;
+	gpio->GPADAT |= (1 << 16);      /* Set GPA16 to high (nNAND_WP) */
+
+	gpio->GPBCON = 0x00155555;
+	gpio->GPBUP = 0x000007FF;
+
+	gpio->GPCCON = 0x55551155;
+	gpio->GPCUP = 0x0000FFFF;
+
+	gpio->GPDCON = 0x55555555;
+	gpio->GPDUP = 0x0000FFFF;
+
+	gpio->GPECON = 0xAAAAAAAA;
+	gpio->GPEUP = 0x0000FFFF;
+
+	gpio->GPFCON = 0x0000AAAA;
+	gpio->GPFUP = 0x000000FF;
+
+	gpio->GPGCON = 0x013DFDFA;
+	gpio->GPGUP = 0x0000FFFF;
+
+	gpio->GPHCON = 0x0028AAAA;
+	gpio->GPHUP = 0x000007FF;
+
+	gpio->GPJCON = 0x1545541;
+#else
+#error Please define GTA02 version
+#endif
+
+	/* arch number of SMDK2410-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_NEO1973_GTA02;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	extern unsigned char booted_from_nand;
+	unsigned char tmp;
+	char buf[32];
+	int menu_vote = 0; /* <= 0: no, > 0: yes */
+	int seconds = 0;
+
+	/* Initialize the Power Management Unit with a safe register set */
+	pcf50633_init();
+#if 0
+	/* if there's no other reason, must be regular reset */
+	neo1973_wakeup_cause = NEO1973_WAKEUP_RESET;
+
+	if (!booted_from_nand)
+		goto woken_by_reset;
+
+	/* obtain wake-up reason, save INT1 in environment */
+	tmp = pcf50606_reg_read(PCF50606_REG_INT1);
+	sprintf(buf, "0x%02x", tmp);
+	setenv("pcf50606_int1", buf);
+
+	if (tmp & PCF50606_INT1_ALARM) {
+		/* we've been woken up by RTC alarm, boot */
+		neo1973_wakeup_cause = NEO1973_WAKEUP_ALARM;
+		goto continue_boot;
+	}
+	if (tmp & PCF50606_INT1_EXTONR) {
+		/* we've been woken up by charger insert */
+		neo1973_wakeup_cause = NEO1973_WAKEUP_CHARGER;
+	}
+
+	if (tmp & PCF50606_INT1_ONKEYF) {
+		/* we've been woken up by a falling edge of the onkey */
+		neo1973_wakeup_cause = NEO1973_WAKEUP_POWER_KEY;
+	}
+
+	if (neo1973_wakeup_cause == NEO1973_WAKEUP_CHARGER) {
+		/* if we still think it was only a charger insert, boot */
+		goto continue_boot;
+	}
+
+woken_by_reset:
+
+	while (neo1973_wakeup_cause == NEO1973_WAKEUP_RESET ||
+	    neo1973_on_key_pressed()) {
+		if (neo1973_aux_key_pressed())
+			menu_vote++;
+		else
+			menu_vote--;
+
+		if (neo1973_new_second())
+			seconds++;
+		if (seconds >= POWER_KEY_SECONDS)
+			goto continue_boot;
+	}
+	/* Power off if minimum number of seconds not reached */
+	neo1973_poweroff();
+
+continue_boot:
+	jbt6k74_init();
+	jbt6k74_enter_state(JBT_STATE_NORMAL);
+	jbt6k74_display_onoff(1);
+#endif
+
+	/* issue a short pulse with the vibrator */
+	neo1973_vibrator(1);
+	udelay(50000);
+	neo1973_vibrator(0);
+
+	/* switch on the backlight */
+	neo1973_backlight(1);
+
+#if 0
+	{
+		/* check if sd card is inserted, and power-up if it is */
+		S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+		if (!(gpio->GPFDAT & (1 << 5)))
+			gpio->GPBDAT &= ~(1 << 2);
+	}
+
+	if (menu_vote > 0) {
+		bootmenu();
+		nobootdelay = 1;
+	}
+#endif
+
+	return 0;
+}
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
+
+u_int32_t get_board_rev(void)
+{
+#if defined(CONFIG_ARCH_GTA02_v1)
+	return 0x00000310;
+#endif
+}
+
+void neo1973_poweroff(void)
+{
+	printf("poweroff\n");
+	udc_disconnect();
+	pcf50633_reg_write(PCF50633_REG_OOCSHDWN, 0x01);
+	/* don't return to caller */
+	while (1) ;
+}
+
+void neo1973_backlight(int on)
+{
+	/* FIXME: PMU based implementation */
+}
+
+/* FIXME: shared */
+void neo1973_vibrator(int on)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+	if (on)
+#if defined(CONFIG_ARCH_GTA01_v3) || defined(CONFIG_ARCH_GTA01_v4)
+		gpio->GPGDAT |= (1 << 11);	/* GPG11 */
+#elif defined(CONFIG_ARCH_GTA01B_v2) || defined(CONFIG_ARCH_GTA01B_v3)
+		gpio->GPBDAT |= (1 << 10);	/* GPB10 */
+#elif defined(CONFIG_ARCH_GTA01B_v4) || defined(CONFIG_ARCH_GTA02_v1)
+		gpio->GPBDAT |= (1 << 3);	/* GPB3 */
+#endif
+	else
+#if defined(CONFIG_ARCH_GTA01_v3) || defined(CONFIG_ARCH_GTA01_v4)
+		gpio->GPGDAT &= ~(1 << 11);	/* GPG11 */
+#elif defined(CONFIG_ARCH_GTA01B_v2) || defined(CONFIG_ARCH_GTA01B_v3)
+		gpio->GPBDAT &= ~(1 << 10);	/* GPB10 */
+#elif defined(CONFIG_ARCH_GTA01B_v4) || defined(CONFIG_ARCH_GTA02_v1)
+		gpio->GPBDAT &= ~(1 << 3);	/* GPB3 */
+#endif
+}
+
+int neo1973_new_second(void)
+{
+	return pcf50633_reg_read(PCF50633_REG_INT1) & PCF50633_INT1_SECOND;
+}
+
+int neo1973_on_key_pressed(void)
+{
+	return !(pcf50633_reg_read(PCF50633_REG_OOCSTAT)
+						& PCF50633_OOCSTAT_ONKEY);
+}
+
+/* FIXME: shared */
+int neo1973_aux_key_pressed(void)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+	if (gpio->GPFDAT & (1 << 6))
+		return 0;
+	return 1;
+}
+
+/* The sum of all part_size[]s must equal to the NAND size, i.e., 0x4000000.
+   "initrd" is sized such that it can hold two uncompressed 16 bit 640*480
+   images: 640*480*2*2 = 1228800 < 1245184. */
+
+unsigned int dynpart_size[] = {
+    CFG_UBOOT_SIZE, CFG_ENV_SIZE, 0x200000, 0xa0000, 0x1fce0000, 0 };
+char *dynpart_names[] = {
+    "u-boot", "u-boot_env", "kernel", "splash", "rootfs", NULL };
+
+
+const char *neo1973_get_charge_status(void)
+{
+	/* FIXME */
+	return "unknown";
+}
+
+int neo1973_set_charge_mode(enum neo1973_charger_cmd cmd)
+{
+	/* FIXME */
+	return 0;
+}
Index: u-boot/board/neo1973/gta02/u-boot.lds
===================================================================
--- /dev/null
+++ u-boot/board/neo1973/gta02/u-boot.lds
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm920t/start.o	(.text)
+	  cpu/arm920t/s3c24x0/nand_read.o (.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
Index: u-boot/include/configs/neo1973_gta02.h
===================================================================
--- /dev/null
+++ u-boot/include/configs/neo1973_gta02.h
@@ -0,0 +1,276 @@
+/*
+ * (C) Copyright 2007 OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * Configuation settings for the FIC Neo1973 GTA02 Linux GSM phone
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* we want to be able to start u-boot directly from within NAND flash */
+#define CONFIG_LL_INIT_NAND_ONLY
+#define CONFIG_S3C2410_NAND_BOOT	1
+#define CONFIG_S3C2410_NAND_SKIP_BAD	1
+
+#define CFG_UBOOT_SIZE		0x40000 /* size of u-boot, for NAND loading */
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T		1	/* This is an ARM920T Core	*/
+#define	CONFIG_S3C2440		1	/* in a SAMSUNG S3C2410 SoC     */
+#define CONFIG_SMDK2440		1	/* on a SAMSUNG SMDK2410 Board  */
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000/* the GTA02 has this input clock */
+
+
+#define USE_920T_MMU		1
+#define CONFIG_USE_IRQ		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + 400*1024)
+					/* >> CFG_VIDEO_LOGO_MAX_SIZE */
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL3          1	/* we use SERIAL 1 on GTA01 */
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define	CONFIG_RTC_S3C24X0	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#define CONFIG_COMMANDS (\
+			CFG_CMD_BDI	 | \
+			CFG_CMD_LOADS	 | \
+			CFG_CMD_LAODB	 | \
+			CFG_CMD_IMI	 | \
+			CFG_CMD_CACHE	 | \
+			CFG_CMD_MEMORY	 | \
+			CFG_CMD_ENV	 | \
+			/* CFG_CMD_IRQ	 | */  \
+			CFG_CMD_BOOTD	 | \
+			CFG_CMD_CONSOLE	 | \
+			/* CFG_CMD_BMP	 | */ \
+			CFG_CMD_ASKENV	 | \
+			CFG_CMD_RUN	 | \
+			CFG_CMD_ECHO	 | \
+			CFG_CMD_I2C	 | \
+			CFG_CMD_REGINFO	 | \
+			CFG_CMD_IMMAP	 | \
+			CFG_CMD_DATE	 | \
+			CFG_CMD_AUTOSCRIPT | \
+			CFG_CMD_BSP	 | \
+			CFG_CMD_ELF	 | \
+			CFG_CMD_MISC	 | \
+			/* CFG_CMD_USB	 | */ \
+			CFG_CMD_JFFS2	 | \
+			CFG_CMD_DIAG	 | \
+			/* CFG_CMD_HWFLOW	 | */ \
+			CFG_CMD_SAVES	 | \
+			CFG_CMD_NAND	 | \
+			CFG_CMD_PORTIO	 | \
+			CFG_CMD_MMC	 | \
+			CFG_CMD_FAT	 | \
+			CFG_CMD_EXT2	 | \
+			0)
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTARGS    	""
+#define CONFIG_BOOTCOMMAND	"setenv bootargs ${bootargs_base} ${mtdparts}; nand read.e 0x32000000 kernel; bootm 0x32000000"
+
+#define CONFIG_DOS_PARTITION	1
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory		*/
+#if defined(CONFIG_ARCH_GTA02_v1)
+#define	CFG_PROMPT		"GTA02v1 # "	/* Monitor Command Prompt	*/
+#endif
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define	CFG_MAXARGS		64		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CFG_MEMTEST_START	0x30000000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x33F00000	/* 63 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x33000000	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 15625 for 10 ms, so we need */
+/* it to wrap 100 times (total 1562500) to get 1 sec. */
+#define	CFG_HZ			1562500
+
+/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CFG_BOOTMENU
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(8*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+#if 0
+#define CONFIG_USB_OHCI		1
+#endif
+
+#define CONFIG_USB_DEVICE	1
+#define CONFIG_USB_TTY		1
+#define CFG_CONSOLE_IS_IN_ENV	1
+#define CONFIG_USBD_VENDORID 		0x1457     /* Linux/NetChip */
+#define CONFIG_USBD_PRODUCTID_GSERIAL	0x5120    /* gserial */
+#define CONFIG_USBD_PRODUCTID_CDCACM 	0x5119    /* CDC ACM */
+#define CONFIG_USBD_MANUFACTURER	"OpenMoko, Inc"
+#define CONFIG_USBD_PRODUCT_NAME	"Neo1973 Bootloader " U_BOOT_VERSION
+#define CONFIG_USBD_DFU			1
+#define CONFIG_USBD_DFU_XFER_SIZE 	4096	/* 0x4000 */
+#define CONFIG_USBD_DFU_INTERFACE	2
+
+#define CONFIG_EXTRA_ENV_SETTINGS 					\
+	"usbtty=cdc_acm\0"						\
+	"bootargs_base=rootfstype=jffs2 root=/dev/mtdblock4 console=ttySAC0,115200 console=tty0 loglevel=8\0" \
+	""
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x08000000 /* 128 MB */
+#define PHYS_SDRAM_RES_SIZE	0x00200000 /* 2 MB for frame buffer */
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+/* No NOR flash in this device */
+#define CFG_NO_FLASH		1
+
+#define	CFG_ENV_IS_IN_NAND	1
+#define CFG_ENV_SIZE		0x40000	/* 128k Total Size of Environment Sector */
+#define CFG_ENV_OFFSET_OOB	1	/* Location of ENV stored in block 0 OOB */
+#define	CFG_PREBOOT_OVERRIDE	1	/* allow preboot from memory */
+
+#define NAND_MAX_CHIPS		1
+#define CFG_NAND_BASE		0x4e000000
+#define CFG_MAX_NAND_DEVICE	1
+
+#define CONFIG_MMC		1
+#define CFG_MMC_BASE		0xff000000
+
+/* EXT2 driver */
+#define CONFIG_EXT2		1
+
+#define CONFIG_FAT		1
+#define CONFIG_SUPPORT_VFAT
+
+#if 1
+/* JFFS2 driver */
+#define CONFIG_JFFS2_CMDLINE	1
+#define CONFIG_JFFS2_NAND	1
+#define CONFIG_JFFS2_NAND_DEV	0
+//#define CONFIG_JFFS2_NAND_OFF	0x634000
+//#define CONFIG_JFFS2_NAND_SIZE	0x39cc000
+#endif
+
+/* ATAG configuration */
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_REVISION_TAG		1
+#if 0
+#define CONFIG_SERIAL_TAG		1
+#endif
+
+#define CONFIG_DRIVER_S3C24X0_I2C	1
+#define CONFIG_HARD_I2C			1
+#define CFG_I2C_SPEED			400000	/* 400kHz according to PCF50633 data sheet */
+#define CFG_I2C_SLAVE			0x7f
+
+/* we have a board_late_init() function */
+#define BOARD_LATE_INIT			1
+
+#if 0
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_S3C2410
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_SPLASH_SCREEN
+#define CFG_VIDEO_LOGO_MAX_SIZE	(640*480+1024+100) /* 100 = slack */
+#define CONFIG_VIDEO_BMP_GZIP
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_UNZIP
+
+#define VIDEO_KBD_INIT_FCT	0
+#define VIDEO_TSTC_FCT		serial_tstc
+#define VIDEO_GETC_FCT		serial_getc
+
+#define LCD_VIDEO_ADDR		0x33d00000
+#endif
+
+#define CONFIG_S3C2410_NAND_BBT                1
+//#define CONFIG_S3C2410_NAND_HWECC              1
+
+#define CONFIG_DRIVER_PCF50633		1
+
+#define MTDIDS_DEFAULT	"nand0=neo1973-nand"
+#define MTPARTS_DEFAULT	"neo1973-nand:256k(u-boot),128k(u-boot_env),2M(kernel),640k(splash),-(jffs2)"
+#define CFG_NAND_DYNPART_MTD_KERNEL_NAME "neo1973-nand"
+#define CONFIG_NAND_DYNPART
+
+#endif	/* __CONFIG_H */
Index: u-boot/board/neo1973/gta02/split_by_variant.sh
===================================================================
--- /dev/null
+++ u-boot/board/neo1973/gta02/split_by_variant.sh
@@ -0,0 +1,37 @@
+#!/bin/sh
+# ---------------------------------------------------------
+#  Set the core module defines according to Core Module
+# ---------------------------------------------------------
+# ---------------------------------------------------------
+# Set up the GTA01 type define
+# ---------------------------------------------------------
+
+CFGINC=${obj}include/config.h
+CFGTMP=${obj}board/neo1973/gta02/config.tmp
+
+mkdir -p ${obj}include
+if [ "$1" == "" ]
+then
+	echo "$0:: No parameters - using GTA02Bv1 config"
+	echo "#define CONFIG_ARCH_GTA02_v1" > $CFGINC
+	echo "CONFIG_USB_DFU_REVISION=0x0310" > $CFGTMP
+else
+	case "$1" in
+	gta02v1_config)
+	echo "#define CONFIG_ARCH_GTA02_v1" > $CFGINC
+	echo "CONFIG_USB_DFU_REVISION=0x0310" > $CFGTMP
+	;;
+
+	*)
+	echo "$0:: Unrecognised config - using GTA02v1 config"
+	echo "#define CONFIG_ARCH_GTA02_v1" > $CFGINC
+	echo "CONFIG_USB_DFU_REVISION=0x0310" > $CFGTMP
+	;;
+
+	esac
+
+fi
+# ---------------------------------------------------------
+# Complete the configuration
+# ---------------------------------------------------------
+$MKCONFIG -a neo1973_gta02 arm arm920t gta02 neo1973 s3c24x0
Index: u-boot/include/pcf50633.h
===================================================================
--- /dev/null
+++ u-boot/include/pcf50633.h
@@ -0,0 +1,235 @@
+#ifndef _PCF50633_H
+#define _PCF50633_H
+
+/* Philips PCF50633 Power Managemnt Unit (PMU) driver
+ * (C) 2006-2007 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ */
+
+enum pfc50633_regs {
+	PCF50633_REG_VERSION	= 0x00,
+	PCF50633_REG_VARIANT	= 0x01,
+	PCF50633_REG_INT1	= 0x02,	/* Interrupt Status */
+	PCF50633_REG_INT2	= 0x03,	/* Interrupt Status */
+	PCF50633_REG_INT3	= 0x04,	/* Interrupt Status */
+	PCF50633_REG_INT4	= 0x05,	/* Interrupt Status */
+	PCF50633_REG_INT5	= 0x06,	/* Interrupt Status */
+	PCF50633_REG_INT1M	= 0x07,	/* Interrupt Mask */
+	PCF50633_REG_INT2M	= 0x08,	/* Interrupt Mask */
+	PCF50633_REG_INT3M	= 0x09,	/* Interrupt Mask */
+	PCF50633_REG_INT4M	= 0x0a,	/* Interrupt Mask */
+	PCF50633_REG_INT5M	= 0x0b,	/* Interrupt Mask */
+	PCF50633_REG_OOCSHDWN	= 0x0c,
+	PCF50633_REG_OOCWAKE	= 0x0d,
+	PCF50633_REG_OOCTIM1	= 0x0e,
+	PCF50633_REG_OOCTIM2	= 0x0f,
+	PCF50633_REG_OOCMODE	= 0x10,
+	PCF50633_REG_OOCCTL	= 0x11,
+	PCF50633_REG_OOCSTAT	= 0x12,
+	PCF50633_REG_GPIOCTL	= 0x13,
+	PCF50633_REG_GPIO1CFG	= 0x14,
+	PCF50633_REG_GPIO2CFG	= 0x15,
+	PCF50633_REG_GPIO3CFG	= 0x16,
+	PCF50633_REG_GPOCFG	= 0x17,
+	PCF50633_REG_BVMCTL	= 0x18,
+	PCF50633_REG_SVMCTL	= 0x19,
+	PCF50633_REG_AUTOOUT	= 0x1a,
+	PCF50633_REG_AUTOENA	= 0x1b,
+	PCF50633_REG_AUTOCTL	= 0x1c,
+	PCF50633_REG_AUTOMXC	= 0x1d,
+	PCF50633_REG_DOWN1OUT	= 0x1e,
+	PCF50633_REG_DOWN1ENA	= 0x1f,
+	PCF50633_REG_DOWN1CTL	= 0x20,
+	PCF50633_REG_DOWN1MXC	= 0x21,
+	PCF50633_REG_DOWN2OUT	= 0x22,
+	PCF50633_REG_DOWN2ENA	= 0x23,
+	PCF50633_REG_DOWN2CTL	= 0x24,
+	PCF50633_REG_DOWN2MXC	= 0x25,
+	PCF50633_REG_MEMLDOOUT	= 0x26,
+	PCF50633_REG_MEMLDOENA	= 0x27,
+	PCF50633_REG_LEDOUT	= 0x28,
+	PCF50633_REG_LEDENA	= 0x29,
+	PCF50633_REG_LEDCTL	= 0x2a,
+	PCF50633_REG_LEDDIM	= 0x2b,
+	/* reserved */
+	PCF50633_REG_LDO1OUT	= 0x2d,
+	PCF50633_REG_LDO1ENA	= 0x2e,
+	PCF50633_REG_LDO2OUT	= 0x2f,
+	PCF50633_REG_LDO2ENA	= 0x30,
+	PCF50633_REG_LDO3OUT	= 0x31,
+	PCF50633_REG_LDO3ENA	= 0x32,
+	PCF50633_REG_LDO4OUT	= 0x33,
+	PCF50633_REG_LDO4ENA	= 0x34,
+	PCF50633_REG_LDO5OUT	= 0x35,
+	PCF50633_REG_LDO5ENA	= 0x36,
+	PCF50633_REG_LDO6OUT	= 0x37,
+	PCF50633_REG_LDO6ENA	= 0x38,
+	PCF50633_REG_HCLDOOUT	= 0x39,
+	PCF50633_REG_HCLDOENA	= 0x3a,
+	PCF50633_REG_STBYCTL1	= 0x3b,
+	PCF50633_REG_STBYCTL2	= 0x3c,
+	PCF50633_REG_DEBPF1	= 0x3d,
+	PCF50633_REG_DEBPF2	= 0x3e,
+	PCF50633_REG_DEBPF3	= 0x3f,
+	PCF50633_REG_HCLDOOVL	= 0x40,
+	PCF50633_REG_DCDCSTAT	= 0x41,
+	PCF50633_REG_LDOSTAT	= 0x42,
+	PCF50633_REG_MBCC1	= 0x43,
+	PCF50633_REG_MBCC2	= 0x44,
+	PCF50633_REG_MBCC3	= 0x45,
+	PCF50633_REG_MBCC4	= 0x46,
+	PCF50633_REG_MBCC5	= 0x47,
+	PCF50633_REG_MBCC6	= 0x48,
+	PCF50633_REG_MBCC7	= 0x49,
+	PCF50633_REG_MBCC8	= 0x4a,
+	PCF50633_REG_MBCS1	= 0x4b,
+	PCF50633_REG_MBCS2	= 0x4c,
+	PCF50633_REG_MBCS3	= 0x4d,
+	PCF50633_REG_BBCCTL	= 0x4e,
+	PCF50633_REG_ALMGAIN	= 0x4f,
+	PCF50633_REG_ALMDATA	= 0x50,
+	/* reserved */
+	PCF50633_REG_ADCC3	= 0x52,
+	PCF50633_REG_ADCC2	= 0x53,
+	PCF50633_REG_ADCC1	= 0x54,
+	PCF50633_REG_ADCS1	= 0x55,
+	PCF50633_REG_ADCS2	= 0x56,
+	PCF50633_REG_ADCS3	= 0x57,
+	/* reserved */
+	PCF50633_REG_RTCSC	= 0x59,	/* Second */
+	PCF50633_REG_RTCMN	= 0x5a,	/* Minute */
+	PCF50633_REG_RTCHR	= 0x5b,	/* Hour */
+	PCF50633_REG_RTCWD	= 0x5c,	/* Weekday */
+	PCF50633_REG_RTCDT	= 0x5d,	/* Day */
+	PCF50633_REG_RTCMT	= 0x5e,	/* Month */
+	PCF50633_REG_RTCYR	= 0x5f,	/* Year */
+	PCF50633_REG_RTCSCA	= 0x60, /* Alarm Second */
+	PCF50633_REG_RTCMNA	= 0x61, /* Alarm Minute */
+	PCF50633_REG_RTCHRA	= 0x62, /* Alarm Hour */
+	PCF50633_REG_RTCWDA	= 0x63, /* Alarm Weekday */
+	PCF50633_REG_RTCDTA	= 0x64, /* Alarm Day */
+	PCF50633_REG_RTCMTA	= 0x65, /* Alarm Month */
+	PCF50633_REG_RTCYRA	= 0x66, /* Alarm Year */
+
+	PCF50633_REG_MEMBYTE0	= 0x67,
+	PCF50633_REG_MEMBYTE1	= 0x68,
+	PCF50633_REG_MEMBYTE2	= 0x69,
+	PCF50633_REG_MEMBYTE3	= 0x6a,
+	PCF50633_REG_MEMBYTE4	= 0x6b,
+	PCF50633_REG_MEMBYTE5	= 0x6c,
+	PCF50633_REG_MEMBYTE6	= 0x6d,
+	PCF50633_REG_MEMBYTE7	= 0x6e,
+	/* reserved */
+	PCF50633_REG_DCDCPFM	= 0x84,
+	__NUM_PCF50633_REGS
+};
+
+enum pcf50633_reg_int1 {
+	PCF50633_INT1_ADPINS	= 0x01,	/* Adapter inserted */
+	PCF50633_INT1_ADPREM	= 0x02,	/* Adapter removed */
+	PCF50633_INT1_USBINS	= 0x04,	/* USB inserted */
+	PCF50633_INT1_USBREM	= 0x08,	/* USB removed */
+	/* reserved */
+	PCF50633_INT1_ALARM	= 0x40, /* RTC alarm time is reached */
+	PCF50633_INT1_SECOND	= 0x80,	/* RTC periodic second interrupt */
+};
+
+enum pcf50633_reg_int2 {
+	PCF50633_INT2_ONKEYR	= 0x01, /* ONKEY rising edge */
+	PCF50633_INT2_ONKEYF	= 0x02, /* ONKEY falling edge */
+	PCF50633_INT2_EXTON1R	= 0x04, /* EXTON1 rising edge */
+	PCF50633_INT2_EXTON1F	= 0x08, /* EXTON1 falling edge */
+	PCF50633_INT2_EXTON2R	= 0x10, /* EXTON2 rising edge */
+	PCF50633_INT2_EXTON2F	= 0x20, /* EXTON2 falling edge */
+	PCF50633_INT2_EXTON3R	= 0x40, /* EXTON3 rising edge */
+	PCF50633_INT2_EXTON3F	= 0x80, /* EXTON3 falling edge */
+};
+
+enum pcf50633_reg_int3 {
+	PCF50633_INT3_BATFULL	= 0x01, /* Battery full */
+	PCF50633_INT3_CHGHALT	= 0x02,	/* Charger halt */
+	PCF50633_INT3_THLIMON	= 0x04,
+	PCF50633_INT3_THLIMOFF	= 0x08,
+	PCF50633_INT3_USBLIMON	= 0x10,
+	PCF50633_INT3_USBLIMOFF	= 0x20,
+	PCF50633_INT3_ADCRDY	= 0x40,	/* ADC conversion finished */
+	PCF50633_INT3_ONKEY1S	= 0x80,	/* ONKEY pressed 1 second */
+};
+
+enum pcf50633_reg_int4 {
+	PCF50633_INT4_LOWSYS		= 0x01,
+	PCF50633_INT4_LOWBAT		= 0x02,
+	PCF50633_INT4_HIGHTMP		= 0x04,
+	PCF50633_INT4_AUTOPWRFAIL	= 0x08,
+	PCF50633_INT4_DWN1PWRFAIL	= 0x10,
+	PCF50633_INT4_DWN2PWRFAIL	= 0x20,
+	PCF50633_INT4_LEDPWRFAIL	= 0x40,
+	PCF50633_INT4_LEDOVP		= 0x80,
+};
+
+enum pcf50633_reg_int5 {
+	PCF50633_INT4_LDO1PWRFAIL	= 0x01,
+	PCF50633_INT4_LDO2PWRFAIL	= 0x02,
+	PCF50633_INT4_LDO3PWRFAIL	= 0x04,
+	PCF50633_INT4_LDO4PWRFAIL	= 0x08,
+	PCF50633_INT4_LDO5PWRFAIL	= 0x10,
+	PCF50633_INT4_LDO6PWRFAIL	= 0x20,
+	PCF50633_INT4_HCLDOPWRFAIL	= 0x40,
+	PCF50633_INT4_HCLDOOVL		= 0x80,
+};
+
+enum pcf50633_reg_oocwake {
+	PCF50633_OOCWAKE_ONKEY		= 0x01,
+	PCF50633_OOCWAKE_EXTON1		= 0x02,
+	PCF50633_OOCWAKE_EXTON2		= 0x04,
+	PCF50633_OOCWAKE_EXTON3		= 0x08,
+	PCF50633_OOCWAKE_RTC		= 0x10,
+	/* reserved */
+	PCF50633_OOCWAKE_USB		= 0x40,
+	PCF50633_OOCWAKE_ADP		= 0x80,
+};
+
+enum pcf50633_reg_mbcc1 {
+	PCF50633_MBCC1_CHGENA		= 0x01,	/* Charger enable */
+	PCF50633_MBCC1_AUTOSTOP		= 0x02,
+	PCF50633_MBCC1_AUTORES		= 0x04, /* automatic resume */
+	PCF50633_MBCC1_RESUME		= 0x08, /* explicit resume cmd */
+	PCF50633_MBCC1_RESTART		= 0x10, /* restart charging */
+	PCF50633_MBCC1_PREWDTIME_60M	= 0x20,	/* max. precharging time */
+	PCF50633_MBCC1_WDTIME_1H	= 0x00,
+	PCF50633_MBCC1_WDTIME_2H	= 0x40,
+	PCF50633_MBCC1_WDTIME_4H	= 0x80,
+	PCF50633_MBCC1_WDTIME_6H	= 0xc0,
+};
+#define PCF50633_MBCC1_WDTIME_MASK	  0xc0
+
+enum pcf50633_reg_mbcc2 {
+	PCF50633_MBCC2_VBATCOND_2V7	= 0x00,
+	PCF50633_MBCC2_VBATCOND_2V85	= 0x01,
+	PCF50633_MBCC2_VBATCOND_3V	= 0x02,
+	PCF50633_MBCC2_VBATCOND_3V15	= 0x03,
+	PCF50633_MBCC2_VMAX_4V		= 0x00,
+	PCF50633_MBCC2_VMAX_4V20	= 0x28,
+	PCF50633_MBCC2_VRESDEBTIME_64S	= 0x80,	/* debounce time (32/64sec) */
+};
+#define	PCF50633_MBCC2_VBATCOND_MASK	  0x03
+#define PCF50633_MBCC2_VMAX_MASK	  0x3c
+
+#define PCF50633_OOCSTAT_ONKEY		0x01
+
+/* this is to be provided by the board implementation */
+extern const u_int8_t pcf50633_initial_regs[__NUM_PCF50633_REGS];
+
+void pcf50633_reg_write(u_int8_t reg, u_int8_t val);
+
+u_int8_t pcf50633_reg_read(u_int8_t reg);
+
+void pcf50633_reg_set_bit_mask(u_int8_t reg, u_int8_t mask, u_int8_t val);
+void pcf50633_reg_clear_bits(u_int8_t reg, u_int8_t bits);
+
+void pcf50633_init(void);
+void pcf50633_usb_maxcurrent(unsigned int ma);
+
+#endif /* _PCF50633_H */
+
Index: u-boot/drivers/pcf50633.c
===================================================================
--- /dev/null
+++ u-boot/drivers/pcf50633.c
@@ -0,0 +1,142 @@
+#include <common.h>
+
+#ifdef CONFIG_DRIVER_PCF50633
+
+#include <i2c.h>
+#include <pcf50633.h>
+#include <asm/atomic.h>
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define PCF50633_I2C_ADDR		0x73
+
+void __pcf50633_reg_write(u_int8_t reg, u_int8_t val)
+{
+	i2c_write(PCF50633_I2C_ADDR, reg, 1, &val, 1);
+}
+
+u_int8_t __pcf50633_reg_read(u_int8_t reg)
+{
+	u_int8_t tmp;
+	i2c_read(PCF50633_I2C_ADDR, reg, 1, &tmp, 1);
+	return tmp;
+}
+
+void pcf50633_reg_write(u_int8_t reg, u_int8_t val)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	__pcf50633_reg_write(reg, val);
+	local_irq_restore(flags);
+}
+
+u_int8_t pcf50633_reg_read(u_int8_t reg)
+{
+	unsigned long flags;
+	u_int8_t tmp;
+
+	local_irq_save(flags);
+	tmp = __pcf50633_reg_read(reg);
+	local_irq_restore(flags);
+
+	return tmp;
+}
+
+void pcf50633_reg_set_bit_mask(u_int8_t reg, u_int8_t mask, u_int8_t val)
+{
+	unsigned long flags;
+	u_int8_t tmp;
+
+	local_irq_save(flags);
+	tmp = __pcf50633_reg_read(reg);
+	__pcf50633_reg_write(reg, (val & mask) | (tmp & ~mask));
+	local_irq_restore(flags);
+}
+
+void pcf50633_reg_clear_bits(u_int8_t reg, u_int8_t bits)
+{
+	unsigned long flags;
+	u_int8_t tmp;
+
+	local_irq_save(flags);
+	tmp = pcf50633_reg_read(reg);
+	pcf50633_reg_write(reg, (tmp & ~bits));
+	local_irq_restore(flags);
+}
+
+static const u_int8_t regs_invalid[] = {
+	PCF50633_REG_VERSION,
+	PCF50633_REG_VARIANT,
+	PCF50633_REG_OOCSHDWN,
+	PCF50633_REG_INT1,
+	PCF50633_REG_INT2,
+	PCF50633_REG_INT3,
+	PCF50633_REG_INT4,
+	PCF50633_REG_INT5,
+	PCF50633_REG_OOCSTAT,
+	0x2c,
+	PCF50633_REG_DCDCSTAT,
+	PCF50633_REG_LDOSTAT,
+	PCF50633_REG_MBCS1,
+	PCF50633_REG_MBCS2,
+	PCF50633_REG_MBCS3,
+	PCF50633_REG_ALMDATA,
+	0x51,
+	/* 0x55 ... 0x6e: don't write */
+	/* 0x6f ... 0x83: reserved */
+};
+#define PCF50633_LAST_REG	0x55
+
+static int reg_is_invalid(u_int8_t reg)
+{
+	int i;
+
+	/* all registers above 0x55 (ADCS1) except 0x84 */
+	if (reg == PCF50633_REG_DCDCPFM)
+		return 0;
+	if (reg >= 0x55)
+		return 1;
+
+	for (i = 0; i < ARRAY_SIZE(regs_invalid); i++) {
+		if (regs_invalid[i] > reg)
+			return 0;
+		if (regs_invalid[i] == reg)
+			return 1;
+	}
+
+	return 0;
+}
+
+
+/* initialize PCF50633 register set */
+void pcf50633_init(void)
+{
+	unsigned long flags;
+	u_int8_t i;
+
+	local_irq_save(flags);
+	for (i = 0; i < PCF50633_LAST_REG; i++) {
+		if (reg_is_invalid(i))
+			continue;
+		__pcf50633_reg_write(i, pcf50633_initial_regs[i]);
+	}
+	local_irq_restore(flags);
+}
+
+void pcf50633_usb_maxcurrent(unsigned int ma)
+{
+	u_int8_t val;
+
+	if (ma < 100)
+		val = 0x03;
+	else if (ma < 500)
+		val = 0x00;
+	else if (ma < 1000)
+		val = 0x01;
+	else
+		val = 0x02;
+
+	return pcf50633_reg_set_bit_mask(PCF50633_REG_MBCC7, 0x03, val);
+}
+
+#endif /* CONFIG DRIVER_PCF50633 */
Index: u-boot/board/neo1973/common/lowlevel_init.S
===================================================================
--- u-boot.orig/board/neo1973/common/lowlevel_init.S
+++ u-boot/board/neo1973/common/lowlevel_init.S
@@ -49,7 +49,7 @@
 #define WAIT		 	(0x1<<2)
 #define UBLB		 	(0x1<<3)
 
-#define B1_BWSCON	  	(DW32)
+#define B1_BWSCON	  	(DW16 + WAIT + UBLB)
 #define B2_BWSCON	  	(DW16)
 #define B3_BWSCON	  	(DW16 + WAIT + UBLB)
 #define B4_BWSCON	  	(DW16)
@@ -68,9 +68,9 @@
 
 /* BANK1CON */
 #define B1_Tacs		 	0x0	/*  0clk */
-#define B1_Tcos		 	0x0	/*  0clk */
-#define B1_Tacc		 	0x7	/* 14clk */
-#define B1_Tcoh		 	0x0	/*  0clk */
+#define B1_Tcos		 	0x1	/*  1clk */
+#define B1_Tacc		 	0x4	/*  4clk */
+#define B1_Tcoh		 	0x1	/*  1clk */
 #define B1_Tah		 	0x0	/*  0clk */
 #define B1_Tacp		 	0x0
 #define B1_PMC		 	0x0
@@ -112,7 +112,7 @@
 #if defined (CONFIG_ARCH_GTA01_v3) || defined(CONFIG_ARCH_GTA01_v4)
 #define B6_SCAN		 	0x1	/* 9bit */
 #elif defined(CONFIG_ARCH_GTA01B_v2) || defined(CONFIG_ARCH_GTA01B_v3) || \
-      defined(CONFIG_ARCH_GTA01B_v4)
+      defined(CONFIG_ARCH_GTA01B_v4) || defined(CONFIG_ARCH_GTA02_v1)
 #define B6_SCAN		 	0x2	/* 10bit */
 #endif
 
@@ -165,6 +165,18 @@
 	str	r1, [r0]
 #endif
 
+#if defined(CONFIG_ARCH_GTA02_v1)
+	/* enable KEEPACT to make sure PMU keeps us alive */
+	ldr	r0, =0x56000000	/* GPJ base */
+	ldr	r1, [r0, #0xd0]	/* GPJCON */
+	orr	r1, r1, #(1 << 6)
+	str	r1, [r0, #0xd0]
+
+	ldr	r1, [r0, #0xd4]	/* GPJDAT */
+	orr	r1, r1, #(1 << 3)
+	str	r1, [r0, #0xd4]
+#endif
+
 	/* everything is fine now */
 	mov	pc, lr
 
Index: u-boot/board/neo1973/gta02/pcf50633.c
===================================================================
--- /dev/null
+++ u-boot/board/neo1973/gta02/pcf50633.c
@@ -0,0 +1,91 @@
+
+#include <common.h>
+#include <pcf50633.h>
+
+/* initial register set for PCF50633 in Neo1973 GTA02 devices */
+const u_int8_t pcf50633_initial_regs[__NUM_PCF50633_REGS] = {
+	/* gap */
+	[PCF50633_REG_INT1M]	= PCF50633_INT1_SECOND,
+	[PCF50633_REG_INT2M]	= PCF50633_INT2_EXTON3F |
+				  PCF50633_INT2_EXTON3R |
+				  PCF50633_INT2_EXTON2F |
+				  PCF50633_INT2_EXTON2R |
+				  PCF50633_INT2_EXTON1R |
+				  PCF50633_INT2_EXTON1F,
+	[PCF50633_REG_INT3M]	= PCF50633_INT3_ADCRDY,
+	[PCF50633_REG_INT4M]	= 0x00,
+	[PCF50633_REG_INT5M]	= 0x00,
+
+	[PCF50633_REG_OOCWAKE]	= 0xd3, /* wake from ONKEY,EXTON!,RTC,USB,ADP */
+	[PCF50633_REG_OOCTIM1]	= 0xaa,	/* debounce 14ms everything */
+	[PCF50633_REG_OOCTIM2]	= 0x4a,
+	[PCF50633_REG_OOCMODE]	= 0x55,
+	[PCF50633_REG_OOCCTL]	= 0x44,
+
+	[PCF50633_REG_GPIOCTL]	= 0x01,	/* only GPIO1 is input */
+	[PCF50633_REG_GPIO2CFG]	= 0x00,
+	[PCF50633_REG_GPIO3CFG]	= 0x00,
+	[PCF50633_REG_GPOCFG]	= 0x00,
+
+	[PCF50633_REG_SVMCTL]	= 0x08,	/* 3.10V SYS voltage thresh. */
+	[PCF50633_REG_BVMCTL]	= 0x02,	/* 2.80V BAT voltage thresh. */
+
+	[PCF50633_REG_STBYCTL1]	= 0x00,
+	[PCF50633_REG_STBYCTL2]	= 0x00,
+
+	[PCF50633_REG_DEBPF1]	= 0xff,
+	[PCF50633_REG_DEBPF2]	= 0xff,
+	[PCF50633_REG_DEBPF2]	= 0x3f,
+
+	[PCF50633_REG_AUTOOUT]	= 0x6b,	/* 3.300V */
+	[PCF50633_REG_AUTOENA]	= 0x01,	/* always on */
+	[PCF50633_REG_AUTOCTL]	= 0x00, /* automatic up/down operation */
+	[PCF50633_REG_AUTOMXC]	= 0x0a,	/* 400mA at startup FIXME */
+
+	[PCF50633_REG_DOWN1OUT]	= 0x1b, /* 1.3V (0x1b * .025V + 0.625V) */
+	[PCF50633_REG_DOWN1ENA] = 0x02, /* enabled if GPIO1 = HIGH */
+	[PCF50633_REG_DOWN1CTL]	= 0x00, /* no DVM */
+	[PCF50633_REG_DOWN1MXC]	= 0x22,	/* limit to 510mA at startup */
+
+	[PCF50633_REG_DOWN2OUT]	= 0x2f, /* 1.8V (0x2f * .025V + 0.625V) */
+	[PCF50633_REG_DOWN2ENA]	= 0x02, /* enabled if GPIO1 = HIGH */
+	[PCF50633_REG_DOWN2CTL]	= 0x00,	/* no DVM */
+	[PCF50633_REG_DOWN2MXC]	= 0x22, /* limit to 510mA at startup */
+
+	[PCF50633_REG_MEMLDOOUT] = 0x00,
+	[PCF50633_REG_MEMLDOENA] = 0x00,
+
+	[PCF50633_REG_LEDOUT]	= 0x2f,	/* full backlight power */
+	[PCF50633_REG_LEDENA]	= 0x02,	/* enabled if GPIO1 = HIGH */
+	[PCF50633_REG_LEDCTL]	= 0x05, /* ovp enabled, ocp 500mA */
+	[PCF50633_REG_LEDDIM]	= 0x20,	/* dimming curve */
+
+	[PCF50633_REG_LDO1OUT]	= 0x04,	/* 1.3V (4 * 0.1V + 0.9V) */
+	[PCF50633_REG_LDO1ENA]	= 0x01,	/* always on */
+
+	[PCF50633_REG_LDO2OUT]	= 0x18,	/* 3.3V (24 * 0.1V + 0.9V) */
+	[PCF50633_REG_LDO2ENA]	= 0x02, /* enabled if GPIO1 = HIGH */
+
+	[PCF50633_REG_LDO3OUT]	= 0x15,	/* 3.0V (21 * 0.1V + 0.9V) */
+	[PCF50633_REG_LDO3ENA]	= 0x02, /* enabled if GPIO1 = HIGH */
+
+	[PCF50633_REG_LDO4ENA]	= 0x00,
+	[PCF50633_REG_LDO5ENA]	= 0x00,
+	[PCF50633_REG_LDO6ENA]	= 0x00,
+
+	[PCF50633_REG_HCLDOOUT]	= 0x18,	/* 3.3V (24 * 0.1V + 0.9V) */
+	[PCF50633_REG_HCLDOENA]	= 0x00, /* off by default*/
+
+	[PCF50633_REG_DCDCPFM]	= 0x00, /* off by default*/
+
+	[PCF50633_REG_MBCC1]	= 0xe6,
+	[PCF50633_REG_MBCC2]	= 0x28,	/* Vbatconid=2.7V, Vmax=4.20V */
+	[PCF50633_REG_MBCC3]	= 0x19,	/* 25/255 == 98mA pre-charge */
+	[PCF50633_REG_MBCC4]	= 0xff, /* 255/255 == 1A adapter fast */
+	[PCF50633_REG_MBCC5]	= 0x7f,	/* 127/255 == 500mA usb fast */
+	[PCF50633_REG_MBCC6]	= 0x00, /* cutoff current 1/32 * Ichg */
+	[PCF50633_REG_MBCC7]	= 0x00,	/* 1.6A max bat curr, USB 100mA */
+	[PCF50633_REG_MBCC8]	= 0x00,
+
+	[PCF50633_REG_BBCCTL]	= 0x19,	/* 3V, 200uA, on */
+};
Index: u-boot/board/neo1973/gta02/config.mk
===================================================================
--- /dev/null
+++ u-boot/board/neo1973/gta02/config.mk
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# FIC Neo1973 GTA01 board with S3C2410X (ARM920T) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+# GTA01v3 has 1 bank of 64 MB SDRAM
+# GTA01v4 has 1 bank of 64 MB SDRAM
+#
+# 	3000'0000 to 3400'0000
+# we load ourself to 33F8'0000
+#
+# GTA01Bv2 or later has 1 bank of 128 MB SDRAM
+#
+# 	3000'0000 to 3800'0000
+# we load ourself to 37F8'0000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# download area is 3200'0000 or 3300'0000
+
+CONFIG_USB_DFU_VENDOR=0x1457
+CONFIG_USB_DFU_PRODUCT=0x5119
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+TEXT_BASE = 0x33F80000
Index: u-boot/drivers/smedia3362.c
===================================================================
--- /dev/null
+++ u-boot/drivers/smedia3362.c
@@ -0,0 +1,125 @@
+/*
+ * (C) Copyright 2007 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_VIDEO_GLAMO3362)
+
+#include <video_fb.h>
+#include "videomodes.h"
+#include <s3c2410.h>
+#include "smedia3362.h"
+
+/*
+ * Export Graphic Device
+ */
+GraphicDevice smi;
+
+
+struct glamo_script {
+	u_int16_t reg;
+	u_int16_t val;
+} __attribute__((packed));
+
+/* from 'initial glamo 3365 script' */
+static struct glamo_script gl3362_init_script[] = {
+	/* clock */
+	{ GLAMO_REG_CLOCK_MEMORY, 	0x300a },
+	{ GLAMO_REG_CLOCK_LCD,		0x10aa },
+	{ GLAMO_REG_CLOCK_MMC,		0x100a },
+	{ GLAMO_REG_CLOCK_ISP,		0x32aa },
+	{ GLAMO_REG_CLOCK_JPEG,		0x100a },
+	{ GLAMO_REG_CLOCK_3D,		0x302a },
+	{ GLAMO_REG_CLOCK_2D,		0x302a },
+	//{ GLAMO_REG_CLOCK_RISC1,	0x1aaa },
+	//{ GLAMO_REG_CLOCK_RISC2,	0x002a },
+	{ GLAMO_REG_CLOCK_MPEG,		0x3aaa },
+	{ GLAMO_REG_CLOCK_MPROC,	0x12aa },
+		{ 0xfffe, 5 },
+	{ GLAMO_REG_CLOCK_HOST,		0x000d },
+	{ GLAMO_REG_CLOCK_MEMORY,	0x000a }I,
+	{ GLAMO_REG_CLOCK_LCD,		0x00ee },
+	{ GLAMO_REG_CLOCK_MMC,		0x000a },
+	{ GLAMO_REG_CLOCK_ISP,		0x02aa },
+	{ GLAMO_REG_CLOCK_JPEG,		0x000a },
+	{ GLAMO_REG_CLOCK_3D,		0x002a },
+	{ GLAMO_REG_CLOCK_2D,		0x002a },
+	//{ GLAMO_REG_CLOCK_RISC1,	0x0aaa },
+	//{ GLAMO_REG_CLOCK_RISC2,	0x002a },
+	{ GLAMO_REG_CLOCK_MPEG,		0x0aaa },
+	{ GLAMO_REG_CLOCK_MPROC,	0x02aa },
+		{ 0xfffe, 5 },
+	{ GLAMO_REG_PLL_GEN1,		0x061a }, /* PLL1=50MHz, OSCI=32kHz */
+	{ GLAMO_REG_PLL_GEN3,		0x09c3 }, /* PLL2=80MHz, OSCI=32kHz */
+		{ 0xfffe, 5 },
+	{ GLAMO_REG_CLOCK_GEN5_1,	0x18ff },
+	{ GLAMO_REG_CLOCK_GEN5_2,	0x051f },
+	{ GLAMO_REG_CLOCK_GEN6,		0x2000 },
+	{ GLAMO_REG_CLOCK_GEN7,		0x0105 },
+	{ GLAMO_REG_CLOCK_GEN8,		0x0100 },
+	{ GLAMO_REG_CLOCK_GEN10,	0x0017 },
+	{ GLAMO_REG_CLOCK_GEN11,	0x0017 },
+
+	/* hostbus interface */
+	{ GLAMO_REG_HOSTBUS(1),		0x0e00 },
+	{ GLAMO_REG_HOSTBUS(2),		0x07ff },
+	{ GLAMO_REG_HOSTBUS(4),		0x0080 },
+	{ GLAMO_REG_HOSTBUS(5),		0x0244 },
+	{ GLAMO_REG_HOSTBUS(6),		0x0600 },
+	{ GLAMO_REG_HOSTBUS(12),	0xf00e },
+
+	/* memory */
+	{ GLAMO_REG_MEM_TYPE,		0x0874 }, /* VRAM 8Mbyte */
+	{ GLAMO_REG_MEM_GEN,		0xafaf },
+	{ GLAMO_REG_MEM_TIMING(1),	0x0108 },
+	{ GLAMO_REG_MEM_TIMING(2),	0x0010 },
+	{ GLAMO_REG_MEM_TIMING(3),	0x0000 },
+	{ GLAMO_REG_MEM_TIMING(4),	0x0000 },
+	{ GLAMO_REG_MEM_TIMING(5),	0x0000 },
+	{ GLAMO_REG_MEM_TIMING(6),	0x0000 },
+	{ GLAMO_REG_MEM_TIMING(7),	0x0000 },
+	{ GLAMO_REG_MEM_TIMING(8),	0x1002 },
+	{ GLAMO_REG_MEM_TIMING(9),	0x6006 },
+	{ GLAMO_REG_MEM_TIMING(10),	0x00ff },
+	{ GLAMO_REG_MEM_TIMING(11),	0x0001 },
+	{ GLAMO_REG_MEM_POWER1,		0x0020 },
+	{ GLAMO_REG_MEM_POWRE2,		0x0000 },
+	{ GLAMO_REG_MEM_DRAM1,		0x0000 },
+		{ 0xfffe, 1 },
+	{ GLAMO_REG_MEM_DRAM1,		0xc100 },
+	{ GLAMO_REG_MEM_DRAM2,		0x01d6 },
+};
+
+static int glamo3362_init(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(gl3362_init_script); i++) {
+		struct glamo_reg *reg = gl3362_init_script[i];
+
+		if (reg->reg == 0xfffe)
+			delay(reg->val);
+		else
+			gl3362_reg_write(reg->reg, reg->val);
+	}
+	/* FIXME */
+}
+
+#endif /* CONFIG_VIDEO_GLAMO3362 */
Index: u-boot/drivers/Makefile
===================================================================
--- u-boot.orig/drivers/Makefile
+++ u-boot/drivers/Makefile
@@ -50,7 +50,7 @@
 	  usbdcore.o usbdfu.o usbdcore_ep0.o usbdcore_omap1510.o usbdcore_s3c2410.o usbtty.o \
 	  videomodes.o w83c553f.o \
 	  ks8695eth.o \
-	  pcf50606.o \
+	  pcf50606.o pcf50633.o \
 	  pxa_pcmcia.o mpc8xx_pcmcia.o tqm8xx_pcmcia.o	\
 	  rpx_pcmcia.o \
 	  fsl_i2c.o s3c2410_fb.o
Index: u-boot/common/cmd_nand.c
===================================================================
--- u-boot.orig/common/cmd_nand.c
+++ u-boot/common/cmd_nand.c
@@ -208,8 +208,10 @@
 		putc('\n');
 		for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
 			if (nand_info[i].name)
-				printf("Device %d: %s, sector size %lu KiB\n",
+				printf("Device %d: %s, page size %lu, "
+					"sector size %lu KiB\n",
 					i, nand_info[i].name,
+					nand_info[i].oobblock,
 					nand_info[i].erasesize >> 10);
 		}
 		return 0;
Index: u-boot/drivers/nand/nand_ids.c
===================================================================
--- u-boot.orig/drivers/nand/nand_ids.c
+++ u-boot/drivers/nand/nand_ids.c
@@ -67,7 +67,7 @@
 
 	{"NAND 256MiB 3,3V 8-bit", 	0x71, 512, 256, 0x4000, 0},
 
-	{"NAND 512MiB 3,3V 8-bit", 	0xDC, 512, 512, 0x4000, 0},
+	//{"NAND 512MiB 3,3V 8-bit", 	0xDC, 512, 512, 0x4000, 0},
 
 	/* These are the new chips with large page size. The pagesize
 	* and the erasesize is determined from the extended id bytes
Index: u-boot/board/neo1973/common/udc.c
===================================================================
--- u-boot.orig/board/neo1973/common/udc.c
+++ u-boot/board/neo1973/common/udc.c
@@ -3,6 +3,7 @@
 #include <usbdcore.h>
 #include <s3c2410.h>
 #include <pcf50606.h>
+#include <pcf50633.h>
 
 void udc_ctrl(enum usbd_event event, int param)
 {
@@ -23,6 +24,11 @@
     defined(CONFIG_ARCH_GTA01B_v2) || defined(CONFIG_ARCH_GTA01B_v3) || \
     defined(CONFIG_ARCH_GTA01B_v4)
 		pcf50606_charge_autofast(param);
+#elif defined(CONFIG_ARCH_GTA02_v1)
+		if (param)
+			pcf50633_usb_maxcurrent(500);
+		else
+			pcf50633_usb_maxcurrent(0);
 #endif
 		break;
 	default:
