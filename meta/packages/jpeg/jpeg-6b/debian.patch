
#
# Made by http://www.mn-logistik.de/unsupported/pxa250/patcher
#

--- jpeg-6b/jpegtran.1~libjpeg6bb-5
+++ jpeg-6b/jpegtran.1
@@ -131,6 +131,24 @@
 .B \-rot 180 -trim
 trims both edges.
 .PP
+We also offer a lossless-crop option, which discards data outside a given
+image region but losslessly preserves what is inside.  Like the rotate and
+flip transforms, lossless crop is restricted by the JPEG format: the upper
+left corner of the selected region must fall on an iMCU boundary.  If this
+does not hold for the given crop parameters, we silently move the upper left
+corner up and/or left to make it so, simultaneously increasing the region
+dimensions to keep the lower right crop corner unchanged.  (Thus, the
+output image covers at least the requested region, but may cover more.)
+
+Note: lossless-crop is an enhancement from http://sylvana.net/jpegcrop/ 
+that may not be available on non-Debian systems.
+
+The image can be losslessly cropped by giving the switch:
+.TP
+.B \-crop WxH+X+Y
+Crop to a rectangular subarea of width W, height H starting at point X,Y.
+.PP
+.PP
 Another not-strictly-lossless transformation switch is:
 .TP
 .B \-grayscale
--- jpeg-6b/configure~libjpeg6bb-5
+++ jpeg-6b/configure
@@ -52,7 +52,7 @@
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 infodir='${prefix}/info'
-mandir='${prefix}/man'
+mandir='${prefix}/share/man'
 
 # Initialize some other variables.
 subdirs=
--- jpeg-6b/makefile.cfg~libjpeg6bb-5
+++ jpeg-6b/makefile.cfg
@@ -17,7 +17,7 @@
 binprefix =
 manprefix =
 manext = 1
-mandir = $(prefix)/man/man$(manext)
+mandir = $(prefix)/share/man/man$(manext)
 
 # The name of your C compiler:
 CC= @CC@
@@ -210,6 +210,11 @@
 	$(INSTALL_DATA) $(srcdir)/jpeglib.h $(includedir)/jpeglib.h
 	$(INSTALL_DATA) $(srcdir)/jmorecfg.h $(includedir)/jmorecfg.h
 	$(INSTALL_DATA) $(srcdir)/jerror.h $(includedir)/jerror.h
+#<ballombe@debian.org>:mjpegtools require this file to build and header say:
+# * These declarations are considered internal to the JPEG library; most
+# * applications using the library shouldn't need to include this file.
+# So it is not forbidden to use it, therefore it must be installed.
+	$(INSTALL_DATA) $(srcdir)/jpegint.h $(includedir)/jpegint.h
 
 clean:
 	$(RM) *.o *.lo libjpeg.a libjpeg.la
--- jpeg-6b/jpegtran.c~libjpeg6bb-5
+++ jpeg-6b/jpegtran.c
@@ -1,7 +1,7 @@
 /*
  * jpegtran.c
  *
- * Copyright (C) 1995-1997, Thomas G. Lane.
+ * Copyright (C) 1995-2001, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -64,6 +64,7 @@
 #endif
 #if TRANSFORMS_SUPPORTED
   fprintf(stderr, "Switches for modifying the image:\n");
+  fprintf(stderr, "  -crop WxH+X+Y  Crop to a rectangular subarea\n");
   fprintf(stderr, "  -grayscale     Reduce to grayscale (omit color data)\n");
   fprintf(stderr, "  -flip [horizontal|vertical]  Mirror image (left-right or top-bottom)\n");
   fprintf(stderr, "  -rotate [90|180|270]         Rotate image (degrees clockwise)\n");
@@ -134,6 +135,7 @@
   transformoption.transform = JXFORM_NONE;
   transformoption.trim = FALSE;
   transformoption.force_grayscale = FALSE;
+  transformoption.crop = FALSE;
   cinfo->err->trace_level = 0;
 
   /* Scan command line options, adjust parameters */
@@ -160,7 +162,7 @@
       exit(EXIT_FAILURE);
 #endif
 
-    } else if (keymatch(arg, "copy", 1)) {
+    } else if (keymatch(arg, "copy", 2)) {
       /* Select which extra markers to copy. */
       if (++argn >= argc)	/* advance to next argument */
 	usage();
@@ -173,6 +175,20 @@
       } else
 	usage();
 
+    } else if (keymatch(arg, "crop", 2)) {
+      /* Perform lossless cropping. */
+#if TRANSFORMS_SUPPORTED
+      if (++argn >= argc)	/* advance to next argument */
+	usage();
+      if (! jtransform_parse_crop_spec(&transformoption, argv[argn])) {
+	fprintf(stderr, "%s: bogus -crop argument '%s'\n",
+		progname, argv[argn]);
+	exit(EXIT_FAILURE);
+      }
+#else
+      select_transform(JXFORM_NONE);	/* force an error */
+#endif
+
     } else if (keymatch(arg, "debug", 1) || keymatch(arg, "verbose", 1)) {
       /* Enable debug printouts. */
       /* On first -d, print version identification */
@@ -342,8 +358,10 @@
   jvirt_barray_ptr * src_coef_arrays;
   jvirt_barray_ptr * dst_coef_arrays;
   int file_index;
-  FILE * input_file;
-  FILE * output_file;
+  /* We assume all-in-memory processing and can therefore use only a
+   * single file pointer for sequential input and output operation. 
+   */
+  FILE * fp;
 
   /* On Mac, fetch a command line. */
 #ifdef USE_CCOMMAND
@@ -406,24 +424,13 @@
 
   /* Open the input file. */
   if (file_index < argc) {
-    if ((input_file = fopen(argv[file_index], READ_BINARY)) == NULL) {
+    if ((fp = fopen(argv[file_index], READ_BINARY)) == NULL) {
       fprintf(stderr, "%s: can't open %s\n", progname, argv[file_index]);
       exit(EXIT_FAILURE);
     }
   } else {
     /* default input file is stdin */
-    input_file = read_stdin();
-  }
-
-  /* Open the output file. */
-  if (outfilename != NULL) {
-    if ((output_file = fopen(outfilename, WRITE_BINARY)) == NULL) {
-      fprintf(stderr, "%s: can't open %s\n", progname, outfilename);
-      exit(EXIT_FAILURE);
-    }
-  } else {
-    /* default output file is stdout */
-    output_file = write_stdout();
+    fp = read_stdin();
   }
 
 #ifdef PROGRESS_REPORT
@@ -431,7 +438,7 @@
 #endif
 
   /* Specify data source for decompression */
-  jpeg_stdio_src(&srcinfo, input_file);
+  jpeg_stdio_src(&srcinfo, fp);
 
   /* Enable saving of extra markers that we want to copy */
   jcopy_markers_setup(&srcinfo, copyoption);
@@ -463,11 +470,32 @@
   dst_coef_arrays = src_coef_arrays;
 #endif
 
+  /* Close input file, if we opened it.
+   * Note: we assume that jpeg_read_coefficients consumed all input
+   * until JPEG_REACHED_EOI, and that jpeg_finish_decompress will
+   * only consume more while (! cinfo->inputctl->eoi_reached).
+   * We cannot call jpeg_finish_decompress here since we still need the
+   * virtual arrays allocated from the source object for processing.
+   */
+  if (fp != stdin)
+    fclose(fp);
+
+  /* Open the output file. */
+  if (outfilename != NULL) {
+    if ((fp = fopen(outfilename, WRITE_BINARY)) == NULL) {
+      fprintf(stderr, "%s: can't open %s\n", progname, outfilename);
+      exit(EXIT_FAILURE);
+    }
+  } else {
+    /* default output file is stdout */
+    fp = write_stdout();
+  }
+
   /* Adjust default compression parameters by re-parsing the options */
   file_index = parse_switches(&dstinfo, argc, argv, 0, TRUE);
 
   /* Specify data destination for compression */
-  jpeg_stdio_dest(&dstinfo, output_file);
+  jpeg_stdio_dest(&dstinfo, fp);
 
   /* Start compressor (note no image data is actually written here) */
   jpeg_write_coefficients(&dstinfo, dst_coef_arrays);
@@ -488,11 +516,9 @@
   (void) jpeg_finish_decompress(&srcinfo);
   jpeg_destroy_decompress(&srcinfo);
 
-  /* Close files, if we opened them */
-  if (input_file != stdin)
-    fclose(input_file);
-  if (output_file != stdout)
-    fclose(output_file);
+  /* Close output file, if we opened it */
+  if (fp != stdout)
+    fclose(fp);
 
 #ifdef PROGRESS_REPORT
   end_progress_monitor((j_common_ptr) &dstinfo);
--- jpeg-6b/rdjpgcom.c~libjpeg6bb-5
+++ jpeg-6b/rdjpgcom.c
@@ -14,6 +14,7 @@
 #define JPEG_CJPEG_DJPEG	/* to get the command-line config symbols */
 #include "jinclude.h"		/* get auto-config symbols, <stdio.h> */
 
+#include <locale.h>             /*ballombe@debian.org: use locale for isprint*/
 #include <ctype.h>		/* to declare isupper(), tolower() */
 #ifdef USE_SETMODE
 #include <fcntl.h>		/* to declare setmode()'s parameter macros */
@@ -223,7 +224,10 @@
   unsigned int length;
   int ch;
   int lastch = 0;
-
+/* ballombe@debian.org Thu, 15 Nov 2001 20:04:47 +0100*/
+/* Set locale properly for isprint*/
+  setlocale(LC_CTYPE,"");
+    
   /* Get the marker parameter length count */
   length = read_2_bytes();
   /* Length includes itself, so must be at least 2 */
@@ -254,6 +258,8 @@
     length--;
   }
   printf("\n");
+/*ballombe@debian.org: revert to C locale*/
+  setlocale(LC_CTYPE,"C");
 }
 
 
--- jpeg-6b/transupp.c~libjpeg6bb-5
+++ jpeg-6b/transupp.c
@@ -1,7 +1,7 @@
 /*
  * transupp.c
  *
- * Copyright (C) 1997, Thomas G. Lane.
+ * Copyright (C) 1997-2001, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -20,6 +20,7 @@
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "transupp.h"		/* My own external interface */
+#include <ctype.h>		/* to declare isdigit() */
 
 
 #if TRANSFORMS_SUPPORTED
@@ -28,7 +29,8 @@
  * Lossless image transformation routines.  These routines work on DCT
  * coefficient arrays and thus do not require any lossy decompression
  * or recompression of the image.
- * Thanks to Guido Vollbeding for the initial design and code of this feature.
+ * Thanks to Guido Vollbeding for the initial design and code of this feature,
+ * and to Ben Jackson for introducing the cropping feature.
  *
  * Horizontal flipping is done in-place, using a single top-to-bottom
  * pass through the virtual source array.  It will thus be much the
@@ -42,6 +44,13 @@
  * arrays for most of the transforms.  That could result in much thrashing
  * if the image is larger than main memory.
  *
+ * If cropping or trimming is involved, the destination arrays may be smaller
+ * than the source arrays.  Note it is not possible to do horizontal flip
+ * in-place when a nonzero Y crop offset is specified, since we'd have to move
+ * data from one block row to another but the virtual array manager doesn't
+ * guarantee we can touch more than one row at a time.  So in that case,
+ * we have to use a separate destination array.
+ *
  * Some notes about the operating environment of the individual transform
  * routines:
  * 1. Both the source and destination virtual arrays are allocated from the
@@ -54,20 +63,65 @@
  *    and we may as well take that as the effective iMCU size.
  * 4. When "trim" is in effect, the destination's dimensions will be the
  *    trimmed values but the source's will be untrimmed.
- * 5. All the routines assume that the source and destination buffers are
+ * 5. When "crop" is in effect, the destination's dimensions will be the
+ *    cropped values but the source's will be uncropped.  Each transform
+ *    routine is responsible for picking up source data starting at the
+ *    correct X and Y offset for the crop region.  (The X and Y offsets
+ *    passed to the transform routines are measured in iMCU blocks of the
+ *    destination.)
+ * 6. All the routines assume that the source and destination buffers are
  *    padded out to a full iMCU boundary.  This is true, although for the
  *    source buffer it is an undocumented property of jdcoefct.c.
- * Notes 2,3,4 boil down to this: generally we should use the destination's
- * dimensions and ignore the source's.
  */
 
 
 LOCAL(void)
-do_flip_h (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	   jvirt_barray_ptr *src_coef_arrays)
-/* Horizontal flip; done in-place, so no separate dest array is required */
+do_crop (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	 JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	 jvirt_barray_ptr *src_coef_arrays,
+	 jvirt_barray_ptr *dst_coef_arrays)
+/* Crop.  This is only used when no rotate/flip is requested with the crop. */
 {
-  JDIMENSION MCU_cols, comp_width, blk_x, blk_y;
+  JDIMENSION dst_blk_y, x_crop_blocks, y_crop_blocks;
+  int ci, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  jpeg_component_info *compptr;
+
+  /* We simply have to copy the right amount of data (the destination's
+   * image size) starting at the given X and Y offsets in the source.
+   */
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      src_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	 dst_blk_y + y_crop_blocks,
+	 (JDIMENSION) compptr->v_samp_factor, FALSE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,
+			dst_buffer[offset_y],
+			compptr->width_in_blocks);
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_flip_h_no_crop (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+		   JDIMENSION x_crop_offset,
+		   jvirt_barray_ptr *src_coef_arrays)
+/* Horizontal flip; done in-place, so no separate dest array is required.
+ * NB: this only works when y_crop_offset is zero.
+ */
+{
+  JDIMENSION MCU_cols, comp_width, blk_x, blk_y, x_crop_blocks;
   int ci, k, offset_y;
   JBLOCKARRAY buffer;
   JCOEFPTR ptr1, ptr2;
@@ -79,17 +133,19 @@
    * mirroring by changing the signs of odd-numbered columns.
    * Partial iMCUs at the right edge are left untouched.
    */
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+  MCU_cols = srcinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_width = MCU_cols * compptr->h_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
     for (blk_y = 0; blk_y < compptr->height_in_blocks;
 	 blk_y += compptr->v_samp_factor) {
       buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, src_coef_arrays[ci], blk_y,
 	 (JDIMENSION) compptr->v_samp_factor, TRUE);
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	/* Do the mirroring */
 	for (blk_x = 0; blk_x * 2 < comp_width; blk_x++) {
 	  ptr1 = buffer[offset_y][blk_x];
 	  ptr2 = buffer[offset_y][comp_width - blk_x - 1];
@@ -105,6 +161,79 @@
 	    *ptr2++ = -temp1;
 	  }
 	}
+	if (x_crop_blocks > 0) {
+	  /* Now left-justify the portion of the data to be kept.
+	   * We can't use a single jcopy_block_row() call because that routine
+	   * depends on memcpy(), whose behavior is unspecified for overlapping
+	   * source and destination areas.  Sigh.
+	   */
+	  for (blk_x = 0; blk_x < compptr->width_in_blocks; blk_x++) {
+	    jcopy_block_row(buffer[offset_y] + blk_x + x_crop_blocks,
+			    buffer[offset_y] + blk_x,
+			    (JDIMENSION) 1);
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_flip_h (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	   jvirt_barray_ptr *src_coef_arrays,
+	   jvirt_barray_ptr *dst_coef_arrays)
+/* Horizontal flip in general cropping case */
+{
+  JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
+  int ci, k, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JBLOCKROW src_row_ptr, dst_row_ptr;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  /* Here we must output into a separate array because we can't touch
+   * different rows of a single virtual array simultaneously.  Otherwise,
+   * this is essentially the same as the routine above.
+   */
+  MCU_cols = srcinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_width = MCU_cols * compptr->h_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      src_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	 dst_blk_y + y_crop_blocks,
+	 (JDIMENSION) compptr->v_samp_factor, FALSE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	dst_row_ptr = dst_buffer[offset_y];
+	src_row_ptr = src_buffer[offset_y];
+	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+	  if (x_crop_blocks + dst_blk_x < comp_width) {
+	    /* Do the mirrorable blocks */
+	    dst_ptr = dst_row_ptr[dst_blk_x];
+	    src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
+	    /* this unrolled loop doesn't need to know which row it's on... */
+	    for (k = 0; k < DCTSIZE2; k += 2) {
+	      *dst_ptr++ = *src_ptr++;	 /* copy even column */
+	      *dst_ptr++ = - *src_ptr++; /* copy odd column with sign change */
+	    }
+	  } else {
+	    /* Copy last partial block(s) verbatim */
+	    jcopy_block_row(src_row_ptr + dst_blk_x + x_crop_blocks,
+			    dst_row_ptr + dst_blk_x,
+			    (JDIMENSION) 1);
+	  }
+	}
       }
     }
   }
@@ -113,11 +242,13 @@
 
 LOCAL(void)
 do_flip_v (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	   jvirt_barray_ptr *src_coef_arrays,
 	   jvirt_barray_ptr *dst_coef_arrays)
 /* Vertical flip */
 {
   JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JBLOCKROW src_row_ptr, dst_row_ptr;
@@ -131,33 +262,38 @@
    * of odd-numbered rows.
    * Partial iMCUs at the bottom edge are copied verbatim.
    */
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+  MCU_rows = srcinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
 	 (JDIMENSION) compptr->v_samp_factor, TRUE);
-      if (dst_blk_y < comp_height) {
+      if (y_crop_blocks + dst_blk_y < comp_height) {
 	/* Row is within the mirrorable area. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
 	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
-	   comp_height - dst_blk_y - (JDIMENSION) compptr->v_samp_factor,
+	   comp_height - y_crop_blocks - dst_blk_y -
+	   (JDIMENSION) compptr->v_samp_factor,
 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
       } else {
 	/* Bottom-edge blocks will be copied verbatim. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
-	  ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_y,
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	   dst_blk_y + y_crop_blocks,
 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
       }
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
-	if (dst_blk_y < comp_height) {
+	if (y_crop_blocks + dst_blk_y < comp_height) {
 	  /* Row is within the mirrorable area. */
 	  dst_row_ptr = dst_buffer[offset_y];
 	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
+	  src_row_ptr += x_crop_blocks;
 	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	       dst_blk_x++) {
 	    dst_ptr = dst_row_ptr[dst_blk_x];
@@ -173,7 +309,8 @@
 	  }
 	} else {
 	  /* Just copy row verbatim. */
-	  jcopy_block_row(src_buffer[offset_y], dst_buffer[offset_y],
+	  jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,
+			  dst_buffer[offset_y],
 			  compptr->width_in_blocks);
 	}
       }
@@ -184,11 +321,12 @@
 
 LOCAL(void)
 do_transpose (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	      JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	      jvirt_barray_ptr *src_coef_arrays,
 	      jvirt_barray_ptr *dst_coef_arrays)
 /* Transpose source into destination */
 {
-  JDIMENSION dst_blk_x, dst_blk_y;
+  JDIMENSION dst_blk_x, dst_blk_y, x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_x, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JCOEFPTR src_ptr, dst_ptr;
@@ -201,6 +339,8 @@
    */
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
@@ -210,11 +350,12 @@
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
 	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
+	    ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	     dst_blk_x + x_crop_blocks,
 	     (JDIMENSION) compptr->h_samp_factor, FALSE);
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
-	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
 	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y + y_crop_blocks];
 	    for (i = 0; i < DCTSIZE; i++)
 	      for (j = 0; j < DCTSIZE; j++)
 		dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -228,6 +369,7 @@
 
 LOCAL(void)
 do_rot_90 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	   jvirt_barray_ptr *src_coef_arrays,
 	   jvirt_barray_ptr *dst_coef_arrays)
 /* 90 degree rotation is equivalent to
@@ -237,6 +379,7 @@
  */
 {
   JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_x, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JCOEFPTR src_ptr, dst_ptr;
@@ -246,11 +389,13 @@
    * at the (output) right edge properly.  They just get transposed and
    * not mirrored.
    */
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+  MCU_cols = srcinfo->image_height / (dstinfo->max_h_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_width = MCU_cols * compptr->h_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
@@ -259,15 +404,26 @@
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
-	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
-	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  if (x_crop_blocks + dst_blk_x < comp_width) {
+	    /* Block is within the mirrorable area. */
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       comp_width - x_crop_blocks - dst_blk_x -
+	       (JDIMENSION) compptr->h_samp_factor,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  } else {
+	    /* Edge blocks are transposed but not mirrored. */
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       dst_blk_x + x_crop_blocks,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  }
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
-	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
-	    if (dst_blk_x < comp_width) {
+	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    if (x_crop_blocks + dst_blk_x < comp_width) {
 	      /* Block is within the mirrorable area. */
-	      dst_ptr = dst_buffer[offset_y]
-		[comp_width - dst_blk_x - offset_x - 1];
+	      src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
+		[dst_blk_y + offset_y + y_crop_blocks];
 	      for (i = 0; i < DCTSIZE; i++) {
 		for (j = 0; j < DCTSIZE; j++)
 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -277,7 +433,8 @@
 	      }
 	    } else {
 	      /* Edge blocks are transposed but not mirrored. */
-	      dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	      src_ptr = src_buffer[offset_x]
+		[dst_blk_y + offset_y + y_crop_blocks];
 	      for (i = 0; i < DCTSIZE; i++)
 		for (j = 0; j < DCTSIZE; j++)
 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -292,6 +449,7 @@
 
 LOCAL(void)
 do_rot_270 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	    JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	    jvirt_barray_ptr *src_coef_arrays,
 	    jvirt_barray_ptr *dst_coef_arrays)
 /* 270 degree rotation is equivalent to
@@ -301,6 +459,7 @@
  */
 {
   JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_x, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JCOEFPTR src_ptr, dst_ptr;
@@ -310,11 +469,13 @@
    * at the (output) bottom edge properly.  They just get transposed and
    * not mirrored.
    */
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+  MCU_rows = srcinfo->image_width / (dstinfo->max_v_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
@@ -324,14 +485,15 @@
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
 	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
+	    ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	     dst_blk_x + x_crop_blocks,
 	     (JDIMENSION) compptr->h_samp_factor, FALSE);
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
 	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
-	    if (dst_blk_y < comp_height) {
+	    if (y_crop_blocks + dst_blk_y < comp_height) {
 	      /* Block is within the mirrorable area. */
 	      src_ptr = src_buffer[offset_x]
-		[comp_height - dst_blk_y - offset_y - 1];
+		[comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
 	      for (i = 0; i < DCTSIZE; i++) {
 		for (j = 0; j < DCTSIZE; j++) {
 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -341,7 +503,8 @@
 	      }
 	    } else {
 	      /* Edge blocks are transposed but not mirrored. */
-	      src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
+	      src_ptr = src_buffer[offset_x]
+		[dst_blk_y + offset_y + y_crop_blocks];
 	      for (i = 0; i < DCTSIZE; i++)
 		for (j = 0; j < DCTSIZE; j++)
 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -356,6 +519,7 @@
 
 LOCAL(void)
 do_rot_180 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	    JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	    jvirt_barray_ptr *src_coef_arrays,
 	    jvirt_barray_ptr *dst_coef_arrays)
 /* 180 degree rotation is equivalent to
@@ -365,89 +529,93 @@
  */
 {
   JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JBLOCKROW src_row_ptr, dst_row_ptr;
   JCOEFPTR src_ptr, dst_ptr;
   jpeg_component_info *compptr;
 
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+  MCU_cols = srcinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+  MCU_rows = srcinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_width = MCU_cols * compptr->h_samp_factor;
     comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
 	 (JDIMENSION) compptr->v_samp_factor, TRUE);
-      if (dst_blk_y < comp_height) {
+      if (y_crop_blocks + dst_blk_y < comp_height) {
 	/* Row is within the vertically mirrorable area. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
 	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
-	   comp_height - dst_blk_y - (JDIMENSION) compptr->v_samp_factor,
+	   comp_height - y_crop_blocks - dst_blk_y -
+	   (JDIMENSION) compptr->v_samp_factor,
 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
       } else {
 	/* Bottom-edge rows are only mirrored horizontally. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
-	  ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_y,
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	   dst_blk_y + y_crop_blocks,
 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
       }
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
-	if (dst_blk_y < comp_height) {
+	dst_row_ptr = dst_buffer[offset_y];
+	if (y_crop_blocks + dst_blk_y < comp_height) {
 	  /* Row is within the mirrorable area. */
-	  dst_row_ptr = dst_buffer[offset_y];
 	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
-	  /* Process the blocks that can be mirrored both ways. */
-	  for (dst_blk_x = 0; dst_blk_x < comp_width; dst_blk_x++) {
+	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
 	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[comp_width - dst_blk_x - 1];
-	    for (i = 0; i < DCTSIZE; i += 2) {
-	      /* For even row, negate every odd column. */
-	      for (j = 0; j < DCTSIZE; j += 2) {
-		*dst_ptr++ = *src_ptr++;
-		*dst_ptr++ = - *src_ptr++;
+	    if (x_crop_blocks + dst_blk_x < comp_width) {
+	      /* Process the blocks that can be mirrored both ways. */
+	      src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
+	      for (i = 0; i < DCTSIZE; i += 2) {
+		/* For even row, negate every odd column. */
+		for (j = 0; j < DCTSIZE; j += 2) {
+		  *dst_ptr++ = *src_ptr++;
+		  *dst_ptr++ = - *src_ptr++;
+		}
+		/* For odd row, negate every even column. */
+		for (j = 0; j < DCTSIZE; j += 2) {
+		  *dst_ptr++ = - *src_ptr++;
+		  *dst_ptr++ = *src_ptr++;
+		}
 	      }
-	      /* For odd row, negate every even column. */
-	      for (j = 0; j < DCTSIZE; j += 2) {
-		*dst_ptr++ = - *src_ptr++;
-		*dst_ptr++ = *src_ptr++;
+	    } else {
+	      /* Any remaining right-edge blocks are only mirrored vertically. */
+	      src_ptr = src_row_ptr[x_crop_blocks + dst_blk_x];
+	      for (i = 0; i < DCTSIZE; i += 2) {
+		for (j = 0; j < DCTSIZE; j++)
+		  *dst_ptr++ = *src_ptr++;
+		for (j = 0; j < DCTSIZE; j++)
+		  *dst_ptr++ = - *src_ptr++;
 	      }
 	    }
 	  }
-	  /* Any remaining right-edge blocks are only mirrored vertically. */
-	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
-	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[dst_blk_x];
-	    for (i = 0; i < DCTSIZE; i += 2) {
-	      for (j = 0; j < DCTSIZE; j++)
-		*dst_ptr++ = *src_ptr++;
-	      for (j = 0; j < DCTSIZE; j++)
-		*dst_ptr++ = - *src_ptr++;
-	    }
-	  }
 	} else {
 	  /* Remaining rows are just mirrored horizontally. */
-	  dst_row_ptr = dst_buffer[offset_y];
 	  src_row_ptr = src_buffer[offset_y];
-	  /* Process the blocks that can be mirrored. */
-	  for (dst_blk_x = 0; dst_blk_x < comp_width; dst_blk_x++) {
-	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[comp_width - dst_blk_x - 1];
-	    for (i = 0; i < DCTSIZE2; i += 2) {
-	      *dst_ptr++ = *src_ptr++;
-	      *dst_ptr++ = - *src_ptr++;
+	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+	    if (x_crop_blocks + dst_blk_x < comp_width) {
+	      /* Process the blocks that can be mirrored. */
+	      dst_ptr = dst_row_ptr[dst_blk_x];
+	      src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
+	      for (i = 0; i < DCTSIZE2; i += 2) {
+		*dst_ptr++ = *src_ptr++;
+		*dst_ptr++ = - *src_ptr++;
+	      }
+	    } else {
+	      /* Any remaining right-edge blocks are only copied. */
+	      jcopy_block_row(src_row_ptr + dst_blk_x + x_crop_blocks,
+			      dst_row_ptr + dst_blk_x,
+			      (JDIMENSION) 1);
 	    }
 	  }
-	  /* Any remaining right-edge blocks are only copied. */
-	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
-	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[dst_blk_x];
-	    for (i = 0; i < DCTSIZE2; i++)
-	      *dst_ptr++ = *src_ptr++;
-	  }
 	}
       }
     }
@@ -457,6 +625,7 @@
 
 LOCAL(void)
 do_transverse (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	       JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	       jvirt_barray_ptr *src_coef_arrays,
 	       jvirt_barray_ptr *dst_coef_arrays)
 /* Transverse transpose is equivalent to
@@ -470,18 +639,21 @@
  */
 {
   JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_x, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JCOEFPTR src_ptr, dst_ptr;
   jpeg_component_info *compptr;
 
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+  MCU_cols = srcinfo->image_height / (dstinfo->max_h_samp_factor * DCTSIZE);
+  MCU_rows = srcinfo->image_width / (dstinfo->max_v_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_width = MCU_cols * compptr->h_samp_factor;
     comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
@@ -490,17 +662,26 @@
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
-	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
-	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  if (x_crop_blocks + dst_blk_x < comp_width) {
+	    /* Block is within the mirrorable area. */
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       comp_width - x_crop_blocks - dst_blk_x -
+	       (JDIMENSION) compptr->h_samp_factor,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  } else {
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       dst_blk_x + x_crop_blocks,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  }
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
-	    if (dst_blk_y < comp_height) {
-	      src_ptr = src_buffer[offset_x]
-		[comp_height - dst_blk_y - offset_y - 1];
-	      if (dst_blk_x < comp_width) {
+	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    if (y_crop_blocks + dst_blk_y < comp_height) {
+	      if (x_crop_blocks + dst_blk_x < comp_width) {
 		/* Block is within the mirrorable area. */
-		dst_ptr = dst_buffer[offset_y]
-		  [comp_width - dst_blk_x - offset_x - 1];
+		src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
+		  [comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
 		for (i = 0; i < DCTSIZE; i++) {
 		  for (j = 0; j < DCTSIZE; j++) {
 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -516,7 +697,8 @@
 		}
 	      } else {
 		/* Right-edge blocks are mirrored in y only */
-		dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+		src_ptr = src_buffer[offset_x]
+		  [comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
 		for (i = 0; i < DCTSIZE; i++) {
 		  for (j = 0; j < DCTSIZE; j++) {
 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -526,11 +708,10 @@
 		}
 	      }
 	    } else {
-	      src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
-	      if (dst_blk_x < comp_width) {
+	      if (x_crop_blocks + dst_blk_x < comp_width) {
 		/* Bottom-edge blocks are mirrored in x only */
-		dst_ptr = dst_buffer[offset_y]
-		  [comp_width - dst_blk_x - offset_x - 1];
+		src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
+		  [dst_blk_y + offset_y + y_crop_blocks];
 		for (i = 0; i < DCTSIZE; i++) {
 		  for (j = 0; j < DCTSIZE; j++)
 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -540,7 +721,8 @@
 		}
 	      } else {
 		/* At lower right corner, just transpose, no mirroring */
-		dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+		src_ptr = src_buffer[offset_x]
+		  [dst_blk_y + offset_y + y_crop_blocks];
 		for (i = 0; i < DCTSIZE; i++)
 		  for (j = 0; j < DCTSIZE; j++)
 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -554,8 +736,116 @@
 }
 
 
+/* Parse an unsigned integer: subroutine for jtransform_parse_crop_spec.
+ * Returns TRUE if valid integer found, FALSE if not.
+ * *strptr is advanced over the digit string, and *result is set to its value.
+ */
+
+LOCAL(boolean)
+jt_read_integer (const char ** strptr, JDIMENSION * result)
+{
+  const char * ptr = *strptr;
+  JDIMENSION val = 0;
+
+  for (; isdigit(*ptr); ptr++) {
+    val = val * 10 + (JDIMENSION) (*ptr - '0');
+  }
+  *result = val;
+  if (ptr == *strptr)
+    return FALSE;		/* oops, no digits */
+  *strptr = ptr;
+  return TRUE;
+}
+
+
+/* Parse a crop specification (written in X11 geometry style).
+ * The routine returns TRUE if the spec string is valid, FALSE if not.
+ *
+ * The crop spec string should have the format
+ *	<width>x<height>{+-}<xoffset>{+-}<yoffset>
+ * where width, height, xoffset, and yoffset are unsigned integers.
+ * Each of the elements can be omitted to indicate a default value.
+ * (A weakness of this style is that it is not possible to omit xoffset
+ * while specifying yoffset, since they look alike.)
+ *
+ * This code is loosely based on XParseGeometry from the X11 distribution.
+ */
+
+GLOBAL(boolean)
+jtransform_parse_crop_spec (jpeg_transform_info *info, const char *spec)
+{
+  info->crop = FALSE;
+  info->crop_width_set = JCROP_UNSET;
+  info->crop_height_set = JCROP_UNSET;
+  info->crop_xoffset_set = JCROP_UNSET;
+  info->crop_yoffset_set = JCROP_UNSET;
+
+  if (isdigit(*spec)) {
+    /* fetch width */
+    if (! jt_read_integer(&spec, &info->crop_width))
+      return FALSE;
+    info->crop_width_set = JCROP_POS;
+  }
+  if (*spec == 'x' || *spec == 'X') {	
+    /* fetch height */
+    spec++;
+    if (! jt_read_integer(&spec, &info->crop_height))
+      return FALSE;
+    info->crop_height_set = JCROP_POS;
+  }
+  if (*spec == '+' || *spec == '-') {
+    /* fetch xoffset */
+    info->crop_xoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;
+    spec++;
+    if (! jt_read_integer(&spec, &info->crop_xoffset))
+      return FALSE;
+  }
+  if (*spec == '+' || *spec == '-') {
+    /* fetch yoffset */
+    info->crop_yoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;
+    spec++;
+    if (! jt_read_integer(&spec, &info->crop_yoffset))
+      return FALSE;
+  }
+  /* We had better have gotten to the end of the string. */
+  if (*spec != '\0')
+    return FALSE;
+  info->crop = TRUE;
+  return TRUE;
+}
+
+
+/* Trim off any partial iMCUs on the indicated destination edge */
+
+LOCAL(void)
+trim_right_edge (jpeg_transform_info *info, JDIMENSION full_width)
+{
+  JDIMENSION MCU_cols;
+
+  MCU_cols = info->output_width / (info->max_h_samp_factor * DCTSIZE);
+  if (MCU_cols > 0 && info->x_crop_offset + MCU_cols ==
+      full_width / (info->max_h_samp_factor * DCTSIZE))
+    info->output_width = MCU_cols * (info->max_h_samp_factor * DCTSIZE);
+}
+
+LOCAL(void)
+trim_bottom_edge (jpeg_transform_info *info, JDIMENSION full_height)
+{
+  JDIMENSION MCU_rows;
+
+  MCU_rows = info->output_height / (info->max_v_samp_factor * DCTSIZE);
+  if (MCU_rows > 0 && info->y_crop_offset + MCU_rows ==
+      full_height / (info->max_v_samp_factor * DCTSIZE))
+    info->output_height = MCU_rows * (info->max_v_samp_factor * DCTSIZE);
+}
+
+
 /* Request any required workspace.
  *
+ * This routine figures out the size that the output image will be
+ * (which implies that all the transform parameters must be set before
+ * it is called).
+ *
  * We allocate the workspace virtual arrays from the source decompression
  * object, so that all the arrays (both the original data and the workspace)
  * will be taken into account while making memory management decisions.
@@ -569,9 +859,13 @@
 			      jpeg_transform_info *info)
 {
   jvirt_barray_ptr *coef_arrays = NULL;
+  boolean need_workspace, transpose_it;
   jpeg_component_info *compptr;
-  int ci;
+  JDIMENSION xoffset, yoffset, width_in_iMCUs, height_in_iMCUs;
+  JDIMENSION width_in_blocks, height_in_blocks;
+  int ci, h_samp_factor, v_samp_factor;
 
+  /* Determine number of components in output image */
   if (info->force_grayscale &&
       srcinfo->jpeg_color_space == JCS_YCbCr &&
       srcinfo->num_components == 3) {
@@ -581,55 +875,181 @@
     /* Process all the components */
     info->num_components = srcinfo->num_components;
   }
+  /* If there is only one output component, force the iMCU size to be 1;
+   * else use the source iMCU size.  (This allows us to do the right thing
+   * when reducing color to grayscale, and also provides a handy way of
+   * cleaning up "funny" grayscale images whose sampling factors are not 1x1.)
+   */
+
+  switch (info->transform) {
+  case JXFORM_TRANSPOSE:
+  case JXFORM_TRANSVERSE:
+  case JXFORM_ROT_90:
+  case JXFORM_ROT_270:
+    info->output_width = srcinfo->image_height;
+    info->output_height = srcinfo->image_width;
+    if (info->num_components == 1) {
+      info->max_h_samp_factor = 1;
+      info->max_v_samp_factor = 1;
+    } else {
+      info->max_h_samp_factor = srcinfo->max_v_samp_factor;
+      info->max_v_samp_factor = srcinfo->max_h_samp_factor;
+    }
+    break;
+  default:
+    info->output_width = srcinfo->image_width;
+    info->output_height = srcinfo->image_height;
+    if (info->num_components == 1) {
+      info->max_h_samp_factor = 1;
+      info->max_v_samp_factor = 1;
+    } else {
+      info->max_h_samp_factor = srcinfo->max_h_samp_factor;
+      info->max_v_samp_factor = srcinfo->max_v_samp_factor;
+    }
+    break;
+  }
+
+  /* If cropping has been requested, compute the crop area's position and
+   * dimensions, ensuring that its upper left corner falls at an iMCU boundary.
+   */
+  if (info->crop) {
+    /* Insert default values for unset crop parameters */
+    if (info->crop_xoffset_set == JCROP_UNSET)
+      info->crop_xoffset = 0;	/* default to +0 */
+    if (info->crop_yoffset_set == JCROP_UNSET)
+      info->crop_yoffset = 0;	/* default to +0 */
+    if (info->crop_xoffset >= info->output_width ||
+	info->crop_yoffset >= info->output_height)
+      ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);
+    if (info->crop_width_set == JCROP_UNSET)
+      info->crop_width = info->output_width - info->crop_xoffset;
+    if (info->crop_height_set == JCROP_UNSET)
+      info->crop_height = info->output_height - info->crop_yoffset;
+    /* Ensure parameters are valid */
+    if (info->crop_width <= 0 || info->crop_width > info->output_width ||
+	info->crop_height <= 0 || info->crop_height > info->output_height ||
+	info->crop_xoffset > info->output_width - info->crop_width ||
+	info->crop_yoffset > info->output_height - info->crop_height)
+      ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);
+    /* Convert negative crop offsets into regular offsets */
+    if (info->crop_xoffset_set == JCROP_NEG)
+      xoffset = info->output_width - info->crop_width - info->crop_xoffset;
+    else
+      xoffset = info->crop_xoffset;
+    if (info->crop_yoffset_set == JCROP_NEG)
+      yoffset = info->output_height - info->crop_height - info->crop_yoffset;
+    else
+      yoffset = info->crop_yoffset;
+    /* Now adjust so that upper left corner falls at an iMCU boundary */
+    info->output_width =
+      info->crop_width + (xoffset % (info->max_h_samp_factor * DCTSIZE));
+    info->output_height =
+      info->crop_height + (yoffset % (info->max_v_samp_factor * DCTSIZE));
+    /* Save x/y offsets measured in iMCUs */
+    info->x_crop_offset = xoffset / (info->max_h_samp_factor * DCTSIZE);
+    info->y_crop_offset = yoffset / (info->max_v_samp_factor * DCTSIZE);
+  } else {
+    info->x_crop_offset = 0;
+    info->y_crop_offset = 0;
+  }
 
+  /* Figure out whether we need workspace arrays,
+   * and if so whether they are transposed relative to the source.
+   */
+  need_workspace = FALSE;
+  transpose_it = FALSE;
   switch (info->transform) {
   case JXFORM_NONE:
+    if (info->x_crop_offset != 0 || info->y_crop_offset != 0)
+      need_workspace = TRUE;
+    /* No workspace needed if neither cropping nor transforming */
+    break;
   case JXFORM_FLIP_H:
-    /* Don't need a workspace array */
+    if (info->trim)
+      trim_right_edge(info, srcinfo->image_width);
+    if (info->y_crop_offset != 0)
+      need_workspace = TRUE;
+    /* do_flip_h_no_crop doesn't need a workspace array */
     break;
   case JXFORM_FLIP_V:
-  case JXFORM_ROT_180:
-    /* Need workspace arrays having same dimensions as source image.
-     * Note that we allocate arrays padded out to the next iMCU boundary,
-     * so that transform routines need not worry about missing edge blocks.
-     */
-    coef_arrays = (jvirt_barray_ptr *)
-      (*srcinfo->mem->alloc_small) ((j_common_ptr) srcinfo, JPOOL_IMAGE,
-	SIZEOF(jvirt_barray_ptr) * info->num_components);
-    for (ci = 0; ci < info->num_components; ci++) {
-      compptr = srcinfo->comp_info + ci;
-      coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
-	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
-	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
-				(long) compptr->h_samp_factor),
-	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
-				(long) compptr->v_samp_factor),
-	 (JDIMENSION) compptr->v_samp_factor);
-    }
+    if (info->trim)
+      trim_bottom_edge(info, srcinfo->image_height);
+    /* Need workspace arrays having same dimensions as source image. */
+    need_workspace = TRUE;
     break;
   case JXFORM_TRANSPOSE:
+    /* transpose does NOT have to trim anything */
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
   case JXFORM_TRANSVERSE:
+    if (info->trim) {
+      trim_right_edge(info, srcinfo->image_height);
+      trim_bottom_edge(info, srcinfo->image_width);
+    }
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
   case JXFORM_ROT_90:
+    if (info->trim)
+      trim_right_edge(info, srcinfo->image_height);
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
+  case JXFORM_ROT_180:
+    if (info->trim) {
+      trim_right_edge(info, srcinfo->image_width);
+      trim_bottom_edge(info, srcinfo->image_height);
+    }
+    /* Need workspace arrays having same dimensions as source image. */
+    need_workspace = TRUE;
+    break;
   case JXFORM_ROT_270:
-    /* Need workspace arrays having transposed dimensions.
-     * Note that we allocate arrays padded out to the next iMCU boundary,
-     * so that transform routines need not worry about missing edge blocks.
-     */
+    if (info->trim)
+      trim_bottom_edge(info, srcinfo->image_width);
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
+  }
+
+  /* Allocate workspace if needed.
+   * Note that we allocate arrays padded out to the next iMCU boundary,
+   * so that transform routines need not worry about missing edge blocks.
+   */
+  if (need_workspace) {
     coef_arrays = (jvirt_barray_ptr *)
       (*srcinfo->mem->alloc_small) ((j_common_ptr) srcinfo, JPOOL_IMAGE,
-	SIZEOF(jvirt_barray_ptr) * info->num_components);
+		SIZEOF(jvirt_barray_ptr) * info->num_components);
+    width_in_iMCUs = (JDIMENSION)
+      jdiv_round_up((long) info->output_width,
+		    (long) (info->max_h_samp_factor * DCTSIZE));
+    height_in_iMCUs = (JDIMENSION)
+      jdiv_round_up((long) info->output_height,
+		    (long) (info->max_v_samp_factor * DCTSIZE));
     for (ci = 0; ci < info->num_components; ci++) {
       compptr = srcinfo->comp_info + ci;
+      if (info->num_components == 1) {
+	/* we're going to force samp factors to 1x1 in this case */
+	h_samp_factor = v_samp_factor = 1;
+      } else if (transpose_it) {
+	h_samp_factor = compptr->v_samp_factor;
+	v_samp_factor = compptr->h_samp_factor;
+      } else {
+	h_samp_factor = compptr->h_samp_factor;
+	v_samp_factor = compptr->v_samp_factor;
+      }
+      width_in_blocks = width_in_iMCUs * h_samp_factor;
+      height_in_blocks = height_in_iMCUs * v_samp_factor;
       coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
 	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
-	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
-				(long) compptr->v_samp_factor),
-	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
-				(long) compptr->h_samp_factor),
-	 (JDIMENSION) compptr->h_samp_factor);
+	 width_in_blocks, height_in_blocks, (JDIMENSION) v_samp_factor);
     }
-    break;
   }
+
   info->workspace_coef_arrays = coef_arrays;
 }
 
@@ -642,14 +1062,8 @@
   int tblno, i, j, ci, itemp;
   jpeg_component_info *compptr;
   JQUANT_TBL *qtblptr;
-  JDIMENSION dtemp;
   UINT16 qtemp;
 
-  /* Transpose basic image dimensions */
-  dtemp = dstinfo->image_width;
-  dstinfo->image_width = dstinfo->image_height;
-  dstinfo->image_height = dtemp;
-
   /* Transpose sampling factors */
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
@@ -674,46 +1088,159 @@
 }
 
 
-/* Trim off any partial iMCUs on the indicated destination edge */
+/* Adjust Exif image parameters.
+ *
+ * We try to adjust the Tags ExifImageWidth and ExifImageHeight if possible.
+ */
 
 LOCAL(void)
-trim_right_edge (j_compress_ptr dstinfo)
+adjust_exif_parameters (JOCTET FAR * data, unsigned int length,
+			JDIMENSION new_width, JDIMENSION new_height)
 {
-  int ci, max_h_samp_factor;
-  JDIMENSION MCU_cols;
+  boolean is_motorola; /* Flag for byte order */
+  unsigned int number_of_tags, tagnum;
+  unsigned int firstoffset, offset;
+  JDIMENSION new_value;
 
-  /* We have to compute max_h_samp_factor ourselves,
-   * because it hasn't been set yet in the destination
-   * (and we don't want to use the source's value).
-   */
-  max_h_samp_factor = 1;
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    int h_samp_factor = dstinfo->comp_info[ci].h_samp_factor;
-    max_h_samp_factor = MAX(max_h_samp_factor, h_samp_factor);
+  if (length < 12) return; /* Length of an IFD entry */
+
+  /* Discover byte order */
+  if (GETJOCTET(data[0]) == 0x49 && GETJOCTET(data[1]) == 0x49)
+    is_motorola = FALSE;
+  else if (GETJOCTET(data[0]) == 0x4D && GETJOCTET(data[1]) == 0x4D)
+    is_motorola = TRUE;
+  else
+    return;
+
+  /* Check Tag Mark */
+  if (is_motorola) {
+    if (GETJOCTET(data[2]) != 0) return;
+    if (GETJOCTET(data[3]) != 0x2A) return;
+  } else {
+    if (GETJOCTET(data[3]) != 0) return;
+    if (GETJOCTET(data[2]) != 0x2A) return;
   }
-  MCU_cols = dstinfo->image_width / (max_h_samp_factor * DCTSIZE);
-  if (MCU_cols > 0)		/* can't trim to 0 pixels */
-    dstinfo->image_width = MCU_cols * (max_h_samp_factor * DCTSIZE);
-}
 
-LOCAL(void)
-trim_bottom_edge (j_compress_ptr dstinfo)
-{
-  int ci, max_v_samp_factor;
-  JDIMENSION MCU_rows;
+  /* Get first IFD offset (offset to IFD0) */
+  if (is_motorola) {
+    if (GETJOCTET(data[4]) != 0) return;
+    if (GETJOCTET(data[5]) != 0) return;
+    firstoffset = GETJOCTET(data[6]);
+    firstoffset <<= 8;
+    firstoffset += GETJOCTET(data[7]);
+  } else {
+    if (GETJOCTET(data[7]) != 0) return;
+    if (GETJOCTET(data[6]) != 0) return;
+    firstoffset = GETJOCTET(data[5]);
+    firstoffset <<= 8;
+    firstoffset += GETJOCTET(data[4]);
+  }
+  if (firstoffset > length - 2) return; /* check end of data segment */
 
-  /* We have to compute max_v_samp_factor ourselves,
-   * because it hasn't been set yet in the destination
-   * (and we don't want to use the source's value).
-   */
-  max_v_samp_factor = 1;
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    int v_samp_factor = dstinfo->comp_info[ci].v_samp_factor;
-    max_v_samp_factor = MAX(max_v_samp_factor, v_samp_factor);
+  /* Get the number of directory entries contained in this IFD */
+  if (is_motorola) {
+    number_of_tags = GETJOCTET(data[firstoffset]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[firstoffset+1]);
+  } else {
+    number_of_tags = GETJOCTET(data[firstoffset+1]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[firstoffset]);
   }
-  MCU_rows = dstinfo->image_height / (max_v_samp_factor * DCTSIZE);
-  if (MCU_rows > 0)		/* can't trim to 0 pixels */
-    dstinfo->image_height = MCU_rows * (max_v_samp_factor * DCTSIZE);
+  if (number_of_tags == 0) return;
+  firstoffset += 2;
+
+  /* Search for ExifSubIFD offset Tag in IFD0 */
+  for (;;) {
+    if (firstoffset > length - 12) return; /* check end of data segment */
+    /* Get Tag number */
+    if (is_motorola) {
+      tagnum = GETJOCTET(data[firstoffset]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[firstoffset+1]);
+    } else {
+      tagnum = GETJOCTET(data[firstoffset+1]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[firstoffset]);
+    }
+    if (tagnum == 0x8769) break; /* found ExifSubIFD offset Tag */
+    if (--number_of_tags == 0) return;
+    firstoffset += 12;
+  }
+
+  /* Get the ExifSubIFD offset */
+  if (is_motorola) {
+    if (GETJOCTET(data[firstoffset+8]) != 0) return;
+    if (GETJOCTET(data[firstoffset+9]) != 0) return;
+    offset = GETJOCTET(data[firstoffset+10]);
+    offset <<= 8;
+    offset += GETJOCTET(data[firstoffset+11]);
+  } else {
+    if (GETJOCTET(data[firstoffset+11]) != 0) return;
+    if (GETJOCTET(data[firstoffset+10]) != 0) return;
+    offset = GETJOCTET(data[firstoffset+9]);
+    offset <<= 8;
+    offset += GETJOCTET(data[firstoffset+8]);
+  }
+  if (offset > length - 2) return; /* check end of data segment */
+
+  /* Get the number of directory entries contained in this SubIFD */
+  if (is_motorola) {
+    number_of_tags = GETJOCTET(data[offset]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[offset+1]);
+  } else {
+    number_of_tags = GETJOCTET(data[offset+1]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[offset]);
+  }
+  if (number_of_tags < 2) return;
+  offset += 2;
+
+  /* Search for ExifImageWidth and ExifImageHeight Tags in this SubIFD */
+  do {
+    if (offset > length - 12) return; /* check end of data segment */
+    /* Get Tag number */
+    if (is_motorola) {
+      tagnum = GETJOCTET(data[offset]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[offset+1]);
+    } else {
+      tagnum = GETJOCTET(data[offset+1]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[offset]);
+    }
+    if (tagnum == 0xA002 || tagnum == 0xA003) {
+      if (tagnum == 0xA002)
+	new_value = new_width; /* ExifImageWidth Tag */
+      else
+	new_value = new_height; /* ExifImageHeight Tag */
+      if (is_motorola) {
+	data[offset+2] = 0; /* Format = unsigned long (4 octets) */
+	data[offset+3] = 4;
+	data[offset+4] = 0; /* Number Of Components = 1 */
+	data[offset+5] = 0;
+	data[offset+6] = 0;
+	data[offset+7] = 1;
+	data[offset+8] = 0;
+	data[offset+9] = 0;
+	data[offset+10] = (JOCTET)((new_value >> 8) & 0xFF);
+	data[offset+11] = (JOCTET)(new_value & 0xFF);
+      } else {
+	data[offset+2] = 4; /* Format = unsigned long (4 octets) */
+	data[offset+3] = 0;
+	data[offset+4] = 1; /* Number Of Components = 1 */
+	data[offset+5] = 0;
+	data[offset+6] = 0;
+	data[offset+7] = 0;
+	data[offset+8] = (JOCTET)(new_value & 0xFF);
+	data[offset+9] = (JOCTET)((new_value >> 8) & 0xFF);
+	data[offset+10] = 0;
+	data[offset+11] = 0;
+      }
+    }
+    offset += 12;
+  } while (--number_of_tags);
 }
 
 
@@ -736,18 +1263,22 @@
 {
   /* If force-to-grayscale is requested, adjust destination parameters */
   if (info->force_grayscale) {
-    /* We use jpeg_set_colorspace to make sure subsidiary settings get fixed
-     * properly.  Among other things, the target h_samp_factor & v_samp_factor
-     * will get set to 1, which typically won't match the source.
-     * In fact we do this even if the source is already grayscale; that
-     * provides an easy way of coercing a grayscale JPEG with funny sampling
-     * factors to the customary 1,1.  (Some decoders fail on other factors.)
+    /* First, ensure we have YCbCr or grayscale data, and that the source's
+     * Y channel is full resolution.  (No reasonable person would make Y
+     * be less than full resolution, so actually coping with that case
+     * isn't worth extra code space.  But we check it to avoid crashing.)
      */
-    if ((dstinfo->jpeg_color_space == JCS_YCbCr &&
-	 dstinfo->num_components == 3) ||
-	(dstinfo->jpeg_color_space == JCS_GRAYSCALE &&
-	 dstinfo->num_components == 1)) {
-      /* We have to preserve the source's quantization table number. */
+    if (((dstinfo->jpeg_color_space == JCS_YCbCr &&
+	  dstinfo->num_components == 3) ||
+	 (dstinfo->jpeg_color_space == JCS_GRAYSCALE &&
+	  dstinfo->num_components == 1)) &&
+	srcinfo->comp_info[0].h_samp_factor == srcinfo->max_h_samp_factor &&
+	srcinfo->comp_info[0].v_samp_factor == srcinfo->max_v_samp_factor) {
+      /* We use jpeg_set_colorspace to make sure subsidiary settings get fixed
+       * properly.  Among other things, it sets the target h_samp_factor &
+       * v_samp_factor to 1, which typically won't match the source.
+       * We have to preserve the source's quantization table number, however.
+       */
       int sv_quant_tbl_no = dstinfo->comp_info[0].quant_tbl_no;
       jpeg_set_colorspace(dstinfo, JCS_GRAYSCALE);
       dstinfo->comp_info[0].quant_tbl_no = sv_quant_tbl_no;
@@ -755,50 +1286,52 @@
       /* Sorry, can't do it */
       ERREXIT(dstinfo, JERR_CONVERSION_NOTIMPL);
     }
+  } else if (info->num_components == 1) {
+    /* For a single-component source, we force the destination sampling factors
+     * to 1x1, with or without force_grayscale.  This is useful because some
+     * decoders choke on grayscale images with other sampling factors.
+     */
+    dstinfo->comp_info[0].h_samp_factor = 1;
+    dstinfo->comp_info[0].v_samp_factor = 1;
   }
 
-  /* Correct the destination's image dimensions etc if necessary */
+  /* Correct the destination's image dimensions as necessary
+   * for crop and rotate/flip operations.
+   */
+  dstinfo->image_width = info->output_width;
+  dstinfo->image_height = info->output_height;
+
+  /* Transpose destination image parameters */
   switch (info->transform) {
-  case JXFORM_NONE:
-    /* Nothing to do */
-    break;
-  case JXFORM_FLIP_H:
-    if (info->trim)
-      trim_right_edge(dstinfo);
-    break;
-  case JXFORM_FLIP_V:
-    if (info->trim)
-      trim_bottom_edge(dstinfo);
-    break;
   case JXFORM_TRANSPOSE:
-    transpose_critical_parameters(dstinfo);
-    /* transpose does NOT have to trim anything */
-    break;
   case JXFORM_TRANSVERSE:
-    transpose_critical_parameters(dstinfo);
-    if (info->trim) {
-      trim_right_edge(dstinfo);
-      trim_bottom_edge(dstinfo);
-    }
-    break;
   case JXFORM_ROT_90:
-    transpose_critical_parameters(dstinfo);
-    if (info->trim)
-      trim_right_edge(dstinfo);
-    break;
-  case JXFORM_ROT_180:
-    if (info->trim) {
-      trim_right_edge(dstinfo);
-      trim_bottom_edge(dstinfo);
-    }
-    break;
   case JXFORM_ROT_270:
     transpose_critical_parameters(dstinfo);
-    if (info->trim)
-      trim_bottom_edge(dstinfo);
     break;
   }
 
+  /* Adjust Exif properties */
+  if (srcinfo->marker_list != NULL &&
+      srcinfo->marker_list->marker == JPEG_APP0+1 &&
+      srcinfo->marker_list->data_length >= 6 &&
+      GETJOCTET(srcinfo->marker_list->data[0]) == 0x45 &&
+      GETJOCTET(srcinfo->marker_list->data[1]) == 0x78 &&
+      GETJOCTET(srcinfo->marker_list->data[2]) == 0x69 &&
+      GETJOCTET(srcinfo->marker_list->data[3]) == 0x66 &&
+      GETJOCTET(srcinfo->marker_list->data[4]) == 0 &&
+      GETJOCTET(srcinfo->marker_list->data[5]) == 0) {
+    /* Suppress output of JFIF marker */
+    dstinfo->write_JFIF_header = FALSE;
+    /* Adjust Exif image parameters */
+    if (dstinfo->image_width != srcinfo->image_width ||
+	dstinfo->image_height != srcinfo->image_height)
+      /* Align data segment to start of TIFF structure for parsing */
+      adjust_exif_parameters(srcinfo->marker_list->data + 6,
+	srcinfo->marker_list->data_length - 6,
+	dstinfo->image_width, dstinfo->image_height);
+  }
+
   /* Return the appropriate output data set */
   if (info->workspace_coef_arrays != NULL)
     return info->workspace_coef_arrays;
@@ -816,36 +1349,53 @@
  */
 
 GLOBAL(void)
-jtransform_execute_transformation (j_decompress_ptr srcinfo,
-				   j_compress_ptr dstinfo,
-				   jvirt_barray_ptr *src_coef_arrays,
-				   jpeg_transform_info *info)
+jtransform_execute_transform (j_decompress_ptr srcinfo,
+			      j_compress_ptr dstinfo,
+			      jvirt_barray_ptr *src_coef_arrays,
+			      jpeg_transform_info *info)
 {
   jvirt_barray_ptr *dst_coef_arrays = info->workspace_coef_arrays;
 
+  /* Note: conditions tested here should match those in switch statement
+   * in jtransform_request_workspace()
+   */
   switch (info->transform) {
   case JXFORM_NONE:
+    if (info->x_crop_offset != 0 || info->y_crop_offset != 0)
+      do_crop(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	      src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_FLIP_H:
-    do_flip_h(srcinfo, dstinfo, src_coef_arrays);
+    if (info->y_crop_offset != 0)
+      do_flip_h(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+		src_coef_arrays, dst_coef_arrays);
+    else
+      do_flip_h_no_crop(srcinfo, dstinfo, info->x_crop_offset,
+			src_coef_arrays);
     break;
   case JXFORM_FLIP_V:
-    do_flip_v(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_flip_v(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	      src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_TRANSPOSE:
-    do_transpose(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_transpose(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+		 src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_TRANSVERSE:
-    do_transverse(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_transverse(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+		  src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_ROT_90:
-    do_rot_90(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_rot_90(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	      src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_ROT_180:
-    do_rot_180(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_rot_180(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	       src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_ROT_270:
-    do_rot_270(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_rot_270(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	       src_coef_arrays, dst_coef_arrays);
     break;
   }
 }
--- jpeg-6b/jerror.h~libjpeg6bb-5
+++ jpeg-6b/jerror.h
@@ -45,6 +45,7 @@
 JMESSAGE(JERR_BAD_ALLOC_CHUNK, "MAX_ALLOC_CHUNK is wrong, please fix")
 JMESSAGE(JERR_BAD_BUFFER_MODE, "Bogus buffer control mode")
 JMESSAGE(JERR_BAD_COMPONENT_ID, "Invalid component ID %d in SOS")
+JMESSAGE(JERR_BAD_CROP_SPEC, "Invalid crop request")
 JMESSAGE(JERR_BAD_DCT_COEF, "DCT coefficient out of range")
 JMESSAGE(JERR_BAD_DCTSIZE, "IDCT output block size %d not supported")
 JMESSAGE(JERR_BAD_HUFF_TABLE, "Bogus Huffman table definition")
--- jpeg-6b/transupp.h~libjpeg6bb-5
+++ jpeg-6b/transupp.h
@@ -1,7 +1,7 @@
 /*
  * transupp.h
  *
- * Copyright (C) 1997, Thomas G. Lane.
+ * Copyright (C) 1997-2001, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -22,32 +22,6 @@
 #define TRANSFORMS_SUPPORTED 1		/* 0 disables transform code */
 #endif
 
-/* Short forms of external names for systems with brain-damaged linkers. */
-
-#ifdef NEED_SHORT_EXTERNAL_NAMES
-#define jtransform_request_workspace		jTrRequest
-#define jtransform_adjust_parameters		jTrAdjust
-#define jtransform_execute_transformation	jTrExec
-#define jcopy_markers_setup			jCMrkSetup
-#define jcopy_markers_execute			jCMrkExec
-#endif /* NEED_SHORT_EXTERNAL_NAMES */
-
-
-/*
- * Codes for supported types of image transformations.
- */
-
-typedef enum {
-	JXFORM_NONE,		/* no transformation */
-	JXFORM_FLIP_H,		/* horizontal flip */
-	JXFORM_FLIP_V,		/* vertical flip */
-	JXFORM_TRANSPOSE,	/* transpose across UL-to-LR axis */
-	JXFORM_TRANSVERSE,	/* transpose across UR-to-LL axis */
-	JXFORM_ROT_90,		/* 90-degree clockwise rotation */
-	JXFORM_ROT_180,		/* 180-degree rotation */
-	JXFORM_ROT_270		/* 270-degree clockwise (or 90 ccw) */
-} JXFORM_CODE;
-
 /*
  * Although rotating and flipping data expressed as DCT coefficients is not
  * hard, there is an asymmetry in the JPEG format specification for images
@@ -75,6 +49,19 @@
  * (For example, -rot 270 -trim trims only the bottom edge, but -rot 90 -trim
  * followed by -rot 180 -trim trims both edges.)
  *
+ * We also offer a lossless-crop option, which discards data outside a given
+ * image region but losslessly preserves what is inside.  Like the rotate and
+ * flip transforms, lossless crop is restricted by the JPEG format: the upper
+ * left corner of the selected region must fall on an iMCU boundary.  If this
+ * does not hold for the given crop parameters, we silently move the upper left
+ * corner up and/or left to make it so, simultaneously increasing the region
+ * dimensions to keep the lower right crop corner unchanged.  (Thus, the
+ * output image covers at least the requested region, but may cover more.)
+ *
+ * If both crop and a rotate/flip transform are requested, the crop is applied
+ * last --- that is, the crop region is specified in terms of the destination
+ * image.
+ *
  * We also offer a "force to grayscale" option, which simply discards the
  * chrominance channels of a YCbCr image.  This is lossless in the sense that
  * the luminance channel is preserved exactly.  It's not the same kind of
@@ -83,20 +70,87 @@
  * be aware of the option to know how many components to work on.
  */
 
+
+/* Short forms of external names for systems with brain-damaged linkers. */
+
+#ifdef NEED_SHORT_EXTERNAL_NAMES
+#define jtransform_parse_crop_spec	jTrParCrop
+#define jtransform_request_workspace	jTrRequest
+#define jtransform_adjust_parameters	jTrAdjust
+#define jtransform_execute_transform	jTrExec
+#define jcopy_markers_setup		jCMrkSetup
+#define jcopy_markers_execute		jCMrkExec
+#endif /* NEED_SHORT_EXTERNAL_NAMES */
+
+
+/*
+ * Codes for supported types of image transformations.
+ */
+
+typedef enum {
+	JXFORM_NONE,		/* no transformation */
+	JXFORM_FLIP_H,		/* horizontal flip */
+	JXFORM_FLIP_V,		/* vertical flip */
+	JXFORM_TRANSPOSE,	/* transpose across UL-to-LR axis */
+	JXFORM_TRANSVERSE,	/* transpose across UR-to-LL axis */
+	JXFORM_ROT_90,		/* 90-degree clockwise rotation */
+	JXFORM_ROT_180,		/* 180-degree rotation */
+	JXFORM_ROT_270		/* 270-degree clockwise (or 90 ccw) */
+} JXFORM_CODE;
+
+/*
+ * Codes for crop parameters, which can individually be unspecified,
+ * positive, or negative.  (Negative width or height makes no sense, though.)
+ */
+
+typedef enum {
+	JCROP_UNSET,
+	JCROP_POS,
+	JCROP_NEG
+} JCROP_CODE;
+
+/*
+ * Transform parameters struct.
+ * NB: application must not change any elements of this struct after
+ * calling jtransform_request_workspace.
+ */
+
 typedef struct {
   /* Options: set by caller */
   JXFORM_CODE transform;	/* image transform operator */
   boolean trim;			/* if TRUE, trim partial MCUs as needed */
   boolean force_grayscale;	/* if TRUE, convert color image to grayscale */
+  boolean crop;			/* if TRUE, crop source image */
+
+  /* Crop parameters: application need not set these unless crop is TRUE.
+   * These can be filled in by jtransform_parse_crop_spec().
+   */
+  JDIMENSION crop_width;	/* Width of selected region */
+  JCROP_CODE crop_width_set;
+  JDIMENSION crop_height;	/* Height of selected region */
+  JCROP_CODE crop_height_set;
+  JDIMENSION crop_xoffset;	/* X offset of selected region */
+  JCROP_CODE crop_xoffset_set;	/* (negative measures from right edge) */
+  JDIMENSION crop_yoffset;	/* Y offset of selected region */
+  JCROP_CODE crop_yoffset_set;	/* (negative measures from bottom edge) */
 
   /* Internal workspace: caller should not touch these */
   int num_components;		/* # of components in workspace */
   jvirt_barray_ptr * workspace_coef_arrays; /* workspace for transformations */
+  JDIMENSION output_width;	/* cropped destination dimensions */
+  JDIMENSION output_height;
+  JDIMENSION x_crop_offset;	/* destination crop offsets measured in iMCUs */
+  JDIMENSION y_crop_offset;
+  int max_h_samp_factor;	/* destination iMCU size */
+  int max_v_samp_factor;
 } jpeg_transform_info;
 
 
 #if TRANSFORMS_SUPPORTED
 
+/* Parse a crop specification (written in X11 geometry style) */
+EXTERN(boolean) jtransform_parse_crop_spec
+	JPP((jpeg_transform_info *info, const char *spec));
 /* Request any required workspace */
 EXTERN(void) jtransform_request_workspace
 	JPP((j_decompress_ptr srcinfo, jpeg_transform_info *info));
@@ -106,11 +160,18 @@
 	     jvirt_barray_ptr *src_coef_arrays,
 	     jpeg_transform_info *info));
 /* Execute the actual transformation, if any */
-EXTERN(void) jtransform_execute_transformation
+EXTERN(void) jtransform_execute_transform
 	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
 	     jvirt_barray_ptr *src_coef_arrays,
 	     jpeg_transform_info *info));
 
+/* jtransform_execute_transform used to be called
+ * jtransform_execute_transformation, but some compilers complain about
+ * routine names that long.  This macro is here to avoid breaking any
+ * old source code that uses the original name...
+ */
+#define jtransform_execute_transformation	jtransform_execute_transform
+
 #endif /* TRANSFORMS_SUPPORTED */
 
 
--- /dev/null
+++ jpeg-6b/testimg.uu
@@ -0,0 +1,873 @@
+begin 664 testimg.gif
+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
+MKUD):-'R!8W_UBQ<2$XAP35K%I,C+5K@60-@S1H`:P"L<;?&'0``[@``````
+M````````````````````````````````<`?`'4``:]RM<0=@C;LU[M:X6^-N
+MC;LU[M:XV[5KUZY=NW9MVK5IUZ9=FW9MVA1BTZ80FT)LVF3)4KUHT:*=R)#!
+M1P8?NG31H4,'`0H1='3IRN`C@X\,&71ER)`A0X8,)S)$RQ`M0[0,T:)%BQ8M
+MVHEH)TZ4.5'&AZX[NNZPJT6/C(M7N&C1$@.L3Y]?:/9$6+-KS9HU`-:L<;<&
+MP)HU[M:X6^-NS1IW:]RM<>?.W:Y=-X[02O`*"9($"9!T0-(!"1)<_TAF<4&B
+M3ITZ)+AFT?+0HDF+-6O6`%CC;HV[-0#6`%@#````````````````````````
+M``````````````````#6``"PQMT:`.[6N%OC#@``=P``N%OC;I>[79MV;=JU
+M">"N7;LV[=JT:].N$)LVA0BQ*<2F398L6:H7[42&##Y09<C@0Y<N.G3HT*&C
+M2U<&'QE\9,B0(4.&#!E.9#AQXD2T$QF21(L6+5JT:-%.1#MQXD29,C[*^+AS
+MAUTM:Q+6N7'A9A8M)D?P`,N"!E^$76MV`7`'P)T[=VO<N5OC;HV[->[6N%NS
+M:XV[7>[<N=OU2XRI6:^0()F%Y%0'258ZJ/_KH.[4J5/JU*G#A6L6DS\M;K18
+MLV;-FC5KW*U9`V"-NS7N`*P!````````````````````````````````````
+M`````'<`UK@#X`Z`.P#N``!8XVZ-.P"[W.W:M6M7A%V[-NW:M,O=IEV;=FW:
+M%6+7IA";0FS:9,E2O7K13IPX`3"#CPP^?/C0I4N7"%VZ=&7(D"%#A@P93F3(
+MD"'#B0S1,D2+%BU:M`S1HD6+%BW:"64GRIPH4\8'*@)W:EFC)\&%FU.XN-"B
+M)>9(BSZ_\.W9LVN-NS4`W*UQYVZ-.W<`W*UQMV:7.W=KUJQQY\Z=NUTWCO"9
+MY<8-$B2G.A10I$C_D:("!4YU>'1*W:E3LT`P:7&CQ8TU:P"L6;-FS1IW[M:L
+M<;=FC;LU````````````````````````````````````````6`/`W1H`[@``
+M<`<```!W`-RM<;=FE[M=FW9MVK5IUZY=FW;QV+5KTZY=N_;LV15BTZ9-FRQ9
+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
+JVO-KSZ\]>_;LV;-G#[X!?RY<N/!GP"]\:_#ARS+@SQ%@`WZM6;,F(``[
+`
+end
